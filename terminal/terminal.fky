#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<namespace terminal_private>

<require ./keys>
<require ./events>

<using std>
<using terminal_private>

#
  Topic: Terminal

  The terminal library offers an interface for using text-terminals in a
  comfortable way.

  The base data type is the <std_types::screen>, a rectangular array of
  characters, associated text-styles (bold, italic, ...), draw and clear colors.

  Coordinates are always one-based.

  Each colour supports 256 shades of red, green and blue.

  To update the state of a <std_types::screen> or <std_types::terminal no
  I/O-acccess rights are necessary.

  There are methods to set draw and clear colors, to draw text, lines
  or more complex shapes, to clear the screen or parts of it, to scroll the
  screen or copy arbitrary rectangular areas between screens ("blitting").

  Horizontal and vertical lines are drawn using the appropriate unicode graphics
  characters.

  Screens and terminals also support Unicode Emojis.

  The terminal library is somewhat similar to the *curses* library. It tries to
  update the contents of a terminal in a smart way.

  To start using the functions of this library one must first create a
  <std_types::terminal> object (see <std::create_terminal>) supplying the
  terminal's width and height. The current terminal size can be retrieved via
  the I/O-function <std::get_terminal_size>.

  As an alternative one can use the high-level function
  <std::initialize_terminal>. When using this function one gets automatic
  cleanup "for free".

  <std_types::terminal> objects are an in-memory representation of the
  terminal's contents. To update the terminal's contents one must call the
  method <std_types::terminal/std::update> to create a character string
  representing the changes to the terminal's contents and then write this
  string to the terminal.

  Related topics: Input-Output, Colours

  Example:

    <require basic/stdlib>
    <require terminal/terminal>

    get_terminal_size! STDIN_FILENO $width $height
    create_terminal $terminal width height
    draw_text &terminal 10 5 "Hello, world!"
    update_terminal &terminal $output # create output character stream
    print! output # print the generated character stream

  Example:

    <require basic/stdlib>
    <require terminal/terminal>

    initialize_terminal!: (terminal)
      draw_text &terminal 10 5 "Hello, world!"
      update_terminal &terminal $output # create output character stream
      print! output # print the generated character stream

#
  Topic: Colours

  The <@Terminal> library uses <std_types::character>s for text and background
  colours.

  Each colour is a combination of red, green and blue. Each colour component
  supports 256 shades.

  Related topics: Terminal

# Methods

$std::resize ()
$std::set_cursor ()
$std::set_character_at ()
$std::get_character_at ()
$std::set_draw_colour_at ()
$std::get_draw_colour_at ()
$std::set_clear_colour_at ()
$std::get_clear_colour_at ()
$std::move ()
$std::draw_character ()
$std::draw_line ()
$std::draw_thick_line ()
$std::draw_border ()
$std::draw_thick_border ()
$std::plot ()
$std::plot_line ()
$std::fill_trapezoid ()
$std::scroll_left ()
$std::scroll_right ()
$std::scroll_up ()
$std::scroll_down ()
$std::create_text_screen ()
$std::switch_cursor_on ()
$std::switch_cursor_off ()
$std::has_a_visible_cursor ()
$std::set_mouse_reporting ()
$std::get_mouse_reporting ()

$std::get_rectangle_at ()
$std::get_rectangle_by_key ()
$std::get_next_rectangle ()
$std::get_previous_rectangle ()

$std::cursor_x_of ()
$std::cursor_y_of ()

# Mouse Reporting

$std::DISABLED .
$std::CLICKS .
$std::DRAG .
$std::MOVE .

# Attributes

$rows_of ()
$current_buffer_of ()
$terminal_private::rectangles_of ()
$cursor_is_visible_of ()
$cursor_colour_of ()

$terminal_private::RECTANGLE . # info x y width height
$terminal_private::HORIZONTAL . #  rectangle_list x y width height
$terminal_private::VERTICAL . # rectangle_list x y width height

$INVALID_COLOUR '@0xffffffff;'

$std_types::screen std_types::generic_terminal

$std::is_a_screen ()

$std_types::screen.is_a_screen true
$std_types::object.is_a_screen false

$std_types::screen.rectangles_of undefined

# Screen types

$std::TEXT .

$std_types::screen.type_of TEXT
$std_types::screen.plot_y_resolution_of 0.5
$std_types::screen.serialization_tag_of "screen"
$std_types::screen.serialization_fields_of
  list
    `rows_of
    `cursor_x_of
    `cursor_y_of
    `std::width_of
    `std::height_of
    `draw_colour_of
    `clear_colour_of
$std_types::screen.rows_of undefined
$std_types::screen.cursor_x_of undefined
$std_types::screen.cursor_y_of undefined
$std_types::screen.cursor_is_visible_of undefined
$std_types::screen.cursor_colour_of undefined

$std_types::terminal std_types::screen
$std_types::terminal.name_of "terminal"
$std_types::terminal.serialization_tag_of "terminal"
$std_types::terminal.serialization_fields_of
  list
    `rows_of
    `cursor_x_of
    `cursor_y_of
    `std::width_of
    `std::height_of
    `draw_colour_of
    `clear_colour_of
    `cursor_is_visible_of
    `current_buffer_of
$std_types::terminal.current_buffer_of undefined

$std::create_screen ()

$std_types::screen/create_screen:
  (
    screen
    width = undefined
    height = undefined
    options*
  )
  update_if width.is_undefined &width -> width_of(screen)
  update_if height.is_undefined &height -> height_of(screen)
  get_options options
    DRAW_COLOUR = draw_colour_of(screen) $draw_colour
    CLEAR_COLOUR = clear_colour_of(screen) $clear_colour
    TEXT_ATTRIBUTES = text_attributes_of(screen) $text_attributes
  $row dup(string(' ' draw_colour clear_colour) width)
  $rows dup(list(row) height)
  ->
    std_types::screen
      .width_of width
      .height_of height
      .draw_colour_of draw_colour
      .clear_colour_of clear_colour
      .text_attributes_of text_attributes
      .rows_of rows

$create_buffer:
  (
    width
    height
    options*
  )
  get_options options
    DRAW_COLOUR = BLACK $draw_colour
    CLEAR_COLOUR = WHITE $clear_colour
  $row dup(string(' ' draw_colour clear_colour) width)
  $rows dup(list(row) height)
  ->
    std_types::screen
      .cursor_is_visible_of undefined
      .cursor_x_of 1
      .cursor_y_of 1
      .width_of width
      .height_of height
      .draw_colour_of draw_colour
      .clear_colour_of clear_colour
      .rows_of rows

$std_types::screen/resize:
  (
    screen
    new_width
    new_height
  )
  resize_rows &screen
    new_width new_height
    draw_colour_of(screen) clear_colour_of(screen)
  -> screen

$resize_rows: (screen new_width new_height draw_colour clear_colour)
  $width width_of(screen)
  $height height_of(screen)
  $rows rows_of(screen)
  update_if new_height < height &rows -> range(rows 1 new_height)
  update_if new_width != width &rows:
    if
      new_width < width: map rows: (row) range row 1 3*new_width
      :
	$empty dup(string(' ' draw_colour clear_colour) new_width-width)
	map rows: (row) append row empty
  update_if new_height > height &rows:
    $empty dup(string(' ' draw_colour clear_colour) new_width)
    append rows dup(list(empty) new_height-height)
  ->
    screen
      .width_of new_width
      .height_of new_height
      .rows_of rows

$std::character_at:
  (
    screen
    x
    y
  )
  -> rows_of(screen)(y)(3*x-2)

$std::draw_colour_at:
  (
    screen
    x
    y
  )
  -> rows_of(screen)(y)(3*x-1)

$std::clear_colour_at:
  (
    screen
    x
    y
  )
  -> rows_of(screen)(y)(3*x)

$std_types::screen/scroll_up:
  (
    screen
    delta = 1
  )
  min &delta height_of(screen)
  $empty_line
    dup
      string
	' '
	draw_colour_of(screen)
	clear_colour_of(screen)
      width_of(screen)
  $empty_lines dup(list(empty_line) delta)
  ->
    screen
      .rows_of
	append
	  range(rows_of(screen) delta+1 -1)
	  empty_lines

$std_types::screen/scroll_down:
  (
    screen
    delta = 1
  )
  min &delta height_of(screen)
  $empty_line
    dup
      string
	' '
	draw_colour_of(screen)
	clear_colour_of(screen)
      width_of(screen)
  $empty_lines dup(list(empty_line) delta)
  ->
    screen
      .rows_of
	append
	  empty_lines
	  range(rows_of(screen) 1 -(delta+1))

$std_types::screen/scroll_left:
  (
    screen
    delta = 1
  )
  $pad
    dup
      string
	' '
	draw_colour_of(screen)
	clear_colour_of(screen)
      delta
  map &screen.rows_of: (row) append range(row 3*delta+1 -1) pad
  -> screen

$std_types::screen/scroll_right:
  (
    screen
    delta = 1
  )
  $pad
    dup
      string
	' '
	draw_colour_of(screen)
	clear_colour_of(screen)
      delta
  map &screen.rows_of: (row) append pad range(row 1 -(3*delta+1))
  -> screen

$std_types::screen/invert:
  (
    self
    x = 1
    y = 1
    width = undefined
    height = undefined
  )
  update_if width.is_undefined &width -> width_of(self)-x+1
  update_if height.is_undefined &height -> height_of(self)-y+1
  update_if x < 1 &x &width -> 1 width-1+x
  update_if y < 1 &y &height -> 1 height-1+y
  update_if width > width_of(self) &width -> width_of(self)-x+1
  update_if height > height_of(self) &height -> height_of(self)-y+1
  if
    width <= 0 || height <= 0
    -> self
    :
      map &self.rows_of: (cy row)
	if
	  cy < y || cy >= y+height
	  -> row
	  :
	    append
	      range(row 1 3*(x-1))
	      do
		:
		  $new_row ""
		  from_to x x+width-1
		    : (cx)
		      push &new_row row(3*cx-2)
		      push &new_row row(3*cx)
		      push &new_row row(3*cx-1)
		      next
		    -> new_row
	      range(row 3*(x+width)-2 -1)
      -> self

$std_types::screen/clear:
  (
    self
    x = 1
    y = 1
    width = undefined
    height = undefined
  )
  update_if width.is_undefined &width -> width_of(self)-x+1
  update_if height.is_undefined &height -> height_of(self)-y+1
  basic_private::clear self self x y width height

$std_types::screen/basic_private::clear:
  (
    self
    view
    x
    y
    width
    height
  )
  update_if x < x_of(view) &x &width -> x_of(view) width-(x_of(view)-x)
  update_if y < y_of(view) &y &height -> y_of(view) height-(y_of(view)-y)
  update_if x+width > x_of(view)+width_of(view) &width
    -> x_of(view)+width_of(view)-x
  update_if y+height > y_of(view)+height_of(view) &height
    -> y_of(view)+height_of(view)-y
  !height (2*height).to_integer
  if
    width < 1 || height < 1
    -> self
    :
      !y (2*(y-1)).to_integer+1
      $rows rows_of(self)
      $draw_colour draw_colour_of(view)
      $clear_colour clear_colour_of(view)
      $row_no (y+1) >> 1
      if
	y & 1 == 0: # draw upper half line
	  $row rows(row_no)
	  $buf ""
	  from_to x x+width-1
	    : (cx)
	      $original_clear_colour row(3*cx)
	      push &buf '▄'
	      push &buf clear_colour
	      push &buf original_clear_colour
	      next
	    :
	      !rows(row_no)
		append
		  fix_left(range(row 1 3*(x-1)))
		  buf
		  fix_right(range(row 3*(x+width)-2 -1))
	      inc &y
	      inc &row_no
	      dec &height
	      clear_lines
	clear_lines

      $clear_lines:
	$full_line_count height >> 1
	clear_rows !rows
	  x
	  row_no
	  width
	  full_line_count
	if
	  height & 1 == 1: # draw lower half line
	    plus &row_no full_line_count
	    $row rows(row_no)
	    $buf ""
	    from_to x x+width-1
	      : (cx)
		$original_draw_colour row(3*cx)
		push &buf '▄'
		push &buf original_draw_colour
		push &buf clear_colour
		next
	      :
		!rows(row_no)
		  append
		    fix_left(range(row 1 3*(x-1)))
		    buf
		    fix_right(range(row 3*(x+width)-2 -1))
		-> self(.rows_of rows)
	  -> self(.rows_of rows)

      $clear_rows: (cx cy cw ch)
	$insertion
	  dup
	    string
	      ' '
	      draw_colour
	      clear_colour
	    width
	map $updated_rows range(rows cy cy+ch-1): (row)
	  ->
	    append
	      fix_left(range(row 1 3*(cx-1)))
	      insertion
	      fix_right(range(row 3*(cx+cw)-2 -1))
	->
	  append
	    range(rows 1 cy-1)
	    updated_rows
	    range(rows cy+ch -1)

$fix_left: (buf)
  # replace emojis in the right most position with spaces
  if
    buf.is_empty
    -> buf
    :
      if
	width_of(buf(-3)) == 2
	-> buf(-3 ' ')
	-> buf

$fix_right: (buf)
  # replace emojis in the left most position with spaces
  if
    buf.is_empty
    -> buf
    :
      if
	buf(1) == INVALID_CHARACTER
	-> buf(1 ' ')
	-> buf

$std_types::screen/draw_shadow:
  #
    darken fore- and background colours
  (
    screen
    factor = 0.5
    x
    y
    width
    height
  )
  update_if x < 1 &x &width -> 1 width-1+x
  update_if y < 1 &y &height -> 1 height-1+y
  update_if width > width_of(screen) &width -> width_of(screen)-x+1
  update_if height > height_of(screen) &height -> height_of(screen)-y+1
  darken &screen.clear_colour_of
  if
    width <= 0 || height <= 0
    -> screen
    :
      $rows rows_of(screen)
      screen
	.rows_of
	  append
	    range(rows 1 y-1)
	    map
	      range(rows y y+height-1): (row)
		append
		  range(row 1 3*(x-1))
		  do
		    :
		      $shadow_row ""
		      from_to x x+width-1
			: (cx)
			  $chr row(3*cx-2)
			  $draw_colour row(3*cx-1)
			  $clear_colour row(3*cx)
			  push &shadow_row chr
			  push &shadow_row darken(draw_colour)
			  push &shadow_row darken(clear_colour)
			  next
			-> shadow_row
		  range(row 3*(x+width)-2 -1)
	    range(rows y+height -1)

  $darken: (colour)
    $text_attributes text_attributes_of(colour)
    $red red_component_of(colour)
    $green green_component_of(colour)
    $blue blue_component_of(colour)
    rgb_character
      text_attributes
      to_integer(red*factor)
      to_integer(green*factor)
      to_integer(blue*factor)

$std_types::screen/fill_rectangle:
  #
    fill a rectangular area with the specified colour and opacity
  (
    screen
    colour
    opacity = 1
    x
    y
    width
    height
  )
  update_if x < 1 &x &width -> 1 width-1+x
  update_if y < 1 &y &height -> 1 height-1+y
  update_if width > width_of(screen) &width -> width_of(screen)-x+1
  update_if height > height_of(screen) &height -> height_of(screen)-y+1
  if
    width <= 0 || height <= 0
    -> screen
    :
      $red red_component_of(colour)
      $green green_component_of(colour)
      $blue blue_component_of(colour)
      $rows rows_of(screen)
      screen
	.rows_of
	  append
	    range(rows 1 y-1)
	    map
	      range(rows y y+height-1): (row)
		append
		  range(row 1 3*(x-1))
		  do
		    :
		      $shadow_row ""
		      from_to x x+width-1
			: (cx)
			  $chr row(3*cx-2)
			  $draw_colour row(3*cx-1)
			  $clear_colour row(3*cx)
			  push &shadow_row chr
			  push &shadow_row mix(draw_colour)
			  push &shadow_row mix(clear_colour)
			  next
			-> shadow_row
		  range(row 3*(x+width)-2 -1)
	    range(rows y+height -1)

      $mix: (background_colour)
	if
	  opacity == 1
	  -> colour
	  :
	    $text_attributes text_attributes_of(background_colour)
	    $bg_red red_component_of(background_colour)
	    $bg_green green_component_of(background_colour)
	    $bg_blue blue_component_of(background_colour)
	    rgb_character
	      text_attributes
	      to_integer(red*opacity+bg_red*(1-opacity))
	      to_integer(green*opacity+bg_green*(1-opacity))
	      to_integer(blue*opacity+bg_blue*(1-opacity))

$std_types::screen/move:
  (
    screen
    x
    y
    sx
    sy
    width
    height
  )
  copy screen screen x y sx sy width height

$std_types::screen/copy:
  (
    destination
    source
    x = 1
    y = 1
    sx = 1
    sy = 1
    width = undefined
    height = undefined
  )
  if
    &&
      x == 1
      y == 1
      sx == 1
      sy == 1
      width_of(source) == width_of(destination)
      height_of(source) == height_of(destination)
    -> destination(.rows_of rows_of(source))
    :
      $source_width width_of(source)
      $source_height height_of(source)
      update_if width.is_undefined &width -> source_width
      update_if height.is_undefined &height -> source_height
      if
	||
	  sx < 1
	  width < 0
	  (sx+width-1) > source_width
	  sy < 1
	  height < 0
	  sy+height-1 > source_height
	:
	  error
	    "
	      INVALID ARGUMENTS FOR "std_types::screen/copy"@
	:
	  $destination_width width_of(destination)
	  $destination_height height_of(destination)
	  if
	    x < 1:
	      $dx 1-x
	      !x 1
	      plus &sx dx
	      minus &width dx
	      check_y
	    check_y

	  $check_y:
	    if
	      y < 1:
		$dy 1-y
		!y 1
		plus &sy dy
		minus height dy
		check_width
	      check_width

	  $check_width:
	    if
	      x+width-1 > destination_width:
		!width destination_width+1-x
		check_height
	      check_height

	  $check_height:
	    if
	      y+height-1 > destination_height:
		!height destination_height+1-y
		copy_rows
	      copy_rows

	  $copy_rows:
	    if
	      width <= 0 || height <= 0
	      -> destination
	      :
		$dx 3*(sx-x)
		$dy sy-y
		!x 3*x-2
		!width 3*width
		$rows rows_of(destination)
		$source_rows rows_of(source)
		->
		  destination
		    .rows_of
		      append
			append
			  range(rows 1 y-1)
			  map(range(rows y y+height-1) copy_row)
			range(rows y+height -1)

		$copy_row: (cy row)
		  append
		    append
		      range(row 1 x-1)
		      range(source_rows(y+cy+dy-1) x+dx x+dx+width-1)
		    range(row x+width -1)

$std::FILE_DESCRIPTOR .
$std::RECEIVE_CTRL_C_AND_CTRL_Z .
$std::RECEIVE_CTRL_Q_AND_CTRL_S .
$std::MAP_CR .
$std::RECEIVE_SIGWINCH .
$std::MOUSE_REPORTING .
$std::CURSOR_OFF .
$std::TITLE .

$terminal_private::backspace_character '@del;'

$std::initialize_terminal ()

$std_types::object/initialize_terminal:
  #
    Example:

      initialize_terminal!
	DRAW_COLOUR = RED
	CLEAR_COLOUR = BLACK
	TITLE = "My Terminal"
	: (terminal)
	  draw_text &terminal 10 5 "Hello, world!"
	  update_terminal &terminal $output # create output character stream
	  print! output # print the generated character stream
  (
    options* # the options to use
    body # the function to call
  )
  get_options options
    DRAW_COLOUR = BLACK $draw_colour
    CLEAR_COLOUR = WHITE $clear_colour
    FILE_DESCRIPTOR = STDIN_FILENO $fd
    RECEIVE_CTRL_C_AND_CTRL_Z = false $do_receive_ctrl_c_and_ctrl_z
    RECEIVE_CTRL_Q_AND_CTRL_S = false $do_receive_ctrl_q_and_ctrl_s
    MAP_CR = false $do_map_cr
    RECEIVE_SIGWINCH = false $_do_receive_sigwinch
    MOUSE_REPORTING = DISABLED $mouse_reporting
    CURSOR_OFF = false $do_switch_cursor_off
    TITLE = undefined $title

  get_terminal_attributes! fd $original_attributes
  $attributes original_attributes
  use_canonical_mode &attributes false #  no line-buffering ...
  echo_characters &attributes false # ... and no echoing of typed in characters
  update_if do_receive_ctrl_c_and_ctrl_z &attributes:
    generate_signals attributes false
  update_if do_receive_ctrl_q_and_ctrl_s &attributes:
    enable_xon_xoff_for_output attributes false
  update_if do_map_cr &attributes:
    map_cr_to_lf_on_input attributes false
  set_terminal_attributes! $success STDIN_FILENO attributes

  on success.is_an_error success

  !terminal_private::backspace_character backspace_character_of(attributes)

  print! "@esc;[?47h" # switch to alternate screen
  print! "@esc;[33s" # store cursor position
  on do_switch_cursor_off: cursor_off!
  on mouse_reporting == CLICKS:
    print! "@esc;[?9;1006;1015h" # enable mouse reporting
  on mouse_reporting == DRAG:
    print! "@esc;[?9;1002;1006;1015h" # enable mouse reporting
  on mouse_reporting == MOVE:
    print! "@esc;[?9;1003;1006;1015h" # enable mouse reporting
  on title.is_defined: print! "@esc;]0;@(title)@7;"

  get_terminal_size! fd $width $height
  create_terminal $terminal width height
    DRAW_COLOUR = draw_colour
    CLEAR_COLOUR = clear_colour
    CURSOR_OFF = do_switch_cursor_off
    MOUSE_REPORTING = mouse_reporting

  try $err: body! terminal
  set_terminal_attributes! $_success fd original_attributes
  print! "@esc;[u" # restore cursor position
  print! "@esc;[?47l" # switch to default screen
  print! "@esc;[0m" # set default colours
  print! "@esc;]112;@bel;" # restore default cursor colour
  cursor_on!
  on mouse_reporting == CLICKS:
    print! "@esc;[?9;1006;1015l" # disable mouse reporting
  on mouse_reporting == DRAG:
    print! "@esc;[?9;1002;1006;1015l" # disable mouse reporting
  on mouse_reporting == MOVE:
    print! "@esc;[?9;1003;1006;1015l" # disable mouse reporting
  on err.is_an_error err

$std_types::io/initialize_terminal:
  (
    io
    id
    options*
  )
  run io initialize_terminal_action id options

$initialize_terminal_action: (io id options)
  get_options options
    DRAW_COLOUR = BLACK $draw_colour
    CLEAR_COLOUR = WHITE $clear_colour
    FILE_DESCRIPTOR = STDIN_FILENO $fd
    RECEIVE_CTRL_C_AND_CTRL_Z = false $do_receive_ctrl_c_and_ctrl_z
    RECEIVE_CTRL_Q_AND_CTRL_S = false $do_receive_ctrl_q_and_ctrl_s
    MAP_CR = false $do_map_cr
    RECEIVE_SIGWINCH = false $_do_receive_sigwinch
    MOUSE_REPORTING = false $mouse_reporting
    CURSOR_OFF = false $do_switch_cursor_off
    TITLE = undefined $title
  get_terminal_attributes! fd $original_attributes
  $attributes original_attributes
  use_canonical_mode &attributes false #  no line-buffering ...
  echo_characters &attributes false # ... and no echoing of typed in characters
  update_if do_receive_ctrl_c_and_ctrl_z &attributes:
    generate_signals attributes false
  update_if do_receive_ctrl_q_and_ctrl_s &attributes:
    enable_xon_xoff_for_output attributes false
  update_if do_map_cr &attributes:
    map_cr_to_lf_on_input attributes false
  set_terminal_attributes! $err STDIN_FILENO attributes
  if
    err.is_an_error
    -> io tuple(JOB_FAILED id err)
    :
      $buf ""
      append &buf "@esc;[?47h" # switch to alternate screen
      append &buf "@esc;[33s" # store cursor position
      append &buf "@esc;]112;@bel;" # restore default cursor colour
      update_if do_switch_cursor_off &buf: append buf "@esc;[?25l"
      update_if mouse_reporting == CLICKS &buf:
	append buf "@esc;[?9;1006;1015h"
      update_if mouse_reporting == DRAG &buf:
	append buf "@esc;[?9;1002;1006;1015h"
      update_if mouse_reporting == MOVE &buf:
	append buf "@esc;[?9;1003;1006;1015h"
      update_if title.is_defined &buf: append buf "@esc;]0;@(title)@7;"
      write &io STDOUT_FILENO buf
      get_terminal_size! fd $width $height
      create_terminal $terminal
	width height
	DRAW_COLOUR = draw_colour
	CLEAR_COLOUR = clear_colour
	MOUSE_REPORTING = mouse_reporting
      !terminal
	.original_attributes_of original_attributes
	.fd_of fd
	.do_switch_cursor_on_of do_switch_cursor_off
      -> io tuple(JOB_COMPLETED id terminal)

$original_attributes_of ()
$fd_of ()
$do_switch_cursor_on_of ()
$mouse_reporting_of ()

$std_types::terminal.original_attributes_of undefined
$std_types::terminal.fd_of undefined
$std_types::terminal.do_switch_cursor_on_of undefined
$std_types::terminal.mouse_reporting_of DISABLED

$std_types::terminal/finalize:
  (
    self
    io
  )
  $buf ""
  append &buf "@esc;[u" # restore cursor position
  append &buf "@esc;[?47l" # switch to default screen
  append &buf "@esc;[0m" # set default colours
  append &buf "@esc;]112;@bel;" # restore default cursor colour
  append &buf "@esc;[?25h" # switch cursor on
  update_if mouse_reporting_of(self) == CLICKS &buf:
    append buf "@esc;[?9;1006;1015l"
  update_if mouse_reporting_of(self) == DRAG &buf:
    append buf "@esc;[?9;1002;1006;1015l"
  update_if mouse_reporting_of(self) == MOVE &buf:
    append buf "@esc;[?9;1003;1006;1015l"
  write &io STDOUT_FILENO buf
  run io reset_attributes self

$reset_attributes: (io terminal)
  set_terminal_attributes! $_success
    fd_of(terminal)
    original_attributes_of(terminal)
  -> io undefined

$std_types::terminal/update:
  (
    terminal
    do_log = false # log updates to <stderr>
  )
  $output ""
  $current_buffer current_buffer_of(terminal)
  $cursor_colour cursor_colour_of(terminal)
  $current_y cursor_y_of(current_buffer)
  $current_x cursor_x_of(current_buffer)
  $current_draw_colour draw_colour_of(current_buffer)
  $current_clear_colour clear_colour_of(current_buffer)
  $new_rows rows_of(terminal)
  $current_rows rows_of(current_buffer)
  $terminal_width width_of(terminal)
  $terminal_height height_of(terminal)
  from_to 1 terminal_height
    !output
    !current_y !current_x
    !current_clear_colour !current_draw_colour
    : (y)
      $new_row new_rows(y)
      $current_row current_rows(y)
      $last_column find_last_non_empty_column(new_row)
      from_to 1 terminal_width
	: (x)
	  $new_chr new_row(3*x-2)
	  if
	    new_chr == INVALID_CHARACTER
	    next
	    :
	      $new_draw_colour new_row(3*x-1)
	      $new_clear_colour new_row(3*x)
	      if
		||
		  new_chr != current_row(3*x-2)
		  new_draw_colour != current_row(3*x-1)
		  new_clear_colour != current_row(3*x)
		:
		  if
		    x > last_column:
		      move_to last_column+1 y:
			use_clear_colour new_row(-1):
			  append &output csi('K') # clear to the end of the line
			  break
		    :
		      move_to x y:
			use_draw_colour new_draw_colour:
			  use_clear_colour new_clear_colour:
			    emit_character new_chr:
			      next
		next
	next
    ->
      output
      current_y current_x
      current_clear_colour current_draw_colour

  if
    current_y.is_undefined:
      !current_y 1
      !current_x 1
      log! "move cursor to @(current_y), @(current_x)"
      append &output csi(current_y current_x 'H')
      finish
    finish

  $log:
    (
      args*
    )
    if
      do_log:
	debug::print push(create_string(args) '@nl;')
      pass

  $csi: (arguments* command)
    -> string("@esc;[" join(arguments ';') command)

  $osc: (arguments* command)
    -> string("@esc;]" join(arguments ';') command)

  $move_to: (x y cont)
    if
      y != current_y:
	if
	  x != current_x:
	    !current_y y
	    !current_x x
	    log "move cursor to @(y), @(x)"
	    append &output csi(y x 'H')
	    cont
	  :
	    if
	      y > current_y:
		$delta y-current_y
		!current_y y
		if
		  delta > 1:
		    log "move cursor down by " delta
		    append &output csi(delta 'B')
		    cont

		  :
		    log "move cursor down"
		    append &output csi('B')
		    cont
	      :
		$delta current_y-y
		!current_y y
		if
		  delta > 1:
		    log "move cursor up by " delta
		    append &output csi(delta 'A')
		    cont
		  :
		    log "move cursor up"
		    append &output csi('A')
		    cont
      :
	if
	  x != current_x:
	    if
	      x > current_x:
		$delta x-current_x
		!current_x x
		if
		  delta > 1:
		    log "move cursor right by " delta
		    append &output csi(delta 'C')
		    cont
		  :
		    log "move cursor right"
		    append &output csi('C')
		    cont
	      :
		$delta current_x-x
		!current_x x
		if
		  delta > 1:
		    log "move cursor left by " delta
		    append &output csi(delta 'D')
		    cont
		  :
		    log "move cursor left"
		    append &output csi('D')
		    cont
	  cont

  $use_draw_colour: (colour cont)
    if
      colour == current_draw_colour
      cont
      :
	if
	  current_draw_colour == INVALID_COLOUR:
	    !current_draw_colour colour
	    $colour_value colour.to_integer
	    $text_attributes colour_value >> 24
	    bit_and &colour_value 0xffffff
	    $red colour_value >> 16
	    $green (colour_value >> 8) & 0xff
	    $blue colour_value & 0xff
	    #log "set text colour to @(red), @(green), @(blue)"
	    append &output csi(38 2 red green blue 'm')
	    $bold text_attributes & BOLD
	    $italic text_attributes & ITALIC
	    $underline text_attributes & UNDERLINE
	    $strikethrough text_attributes & STRIKETHROUGH
	    update_if bold != 0 &output: append output csi(1 'm')
	    update_if italic != 0 &output: append output csi(3 'm')
	    update_if underline != 0 &output: append output csi(4 'm')
	    update_if strikethrough != 0 &output: append output csi(9 'm')
	    cont
	  :
	    $previous_text_attributes current_draw_colour.to_integer >> 24
	    $previous_colour_value current_draw_colour.to_integer & 0xffffff
	    !current_draw_colour colour
	    $colour_value colour.to_integer
	    $text_attributes colour_value >> 24
	    bit_and &colour_value 0xffffff
	    update_if
	      colour_value != previous_colour_value &output:
		$red colour_value >> 16
		$green (colour_value >> 8) & 0xff
		$blue colour_value & 0xff
		#log "set text colour to @(red), @(green), @(blue)"
		append output csi(38 2 red green blue 'm')
	    $bold text_attributes & BOLD
	    $previous_bold previous_text_attributes & BOLD
	    $italic text_attributes & ITALIC
	    $previous_italic previous_text_attributes & ITALIC
	    $underline text_attributes & UNDERLINE
	    $previous_underline previous_text_attributes & UNDERLINE
	    $strikethrough text_attributes & STRIKETHROUGH
	    $previous_strikethrough previous_text_attributes & STRIKETHROUGH
	    update_if bold != previous_bold &output:
	      if
		bold != 0:
		  append output csi(1 'm')
		:
		  append output csi(22 'm')
	    update_if italic != previous_italic &output:
	      if
		italic != 0:
		  append output csi(3 'm')
		:
		  append output csi(23 'm')
	    update_if underline != previous_underline &output:
	      if
		underline != 0:
		  append output csi(4 'm')
		:
		  append output csi(24 'm')
	    update_if strikethrough != previous_strikethrough &output:
	      if
		strikethrough != 0:
		  append output csi(9 'm')
		:
		  append output csi(29 'm')
	    cont

  $use_clear_colour: (colour cont)
    if
      colour != current_clear_colour:
	!current_clear_colour colour
	$colour_value colour.to_integer
	$red (colour_value >> 16) & 0xff
	$green (colour_value >> 8) & 0xff
	$blue colour_value & 0xff
	log "set background colour to @(red), @(green), @(blue)"
	append &output csi(48 2 red green blue 'm')
	cont
      cont

  # set cursor style

    CSI <value> SPC q

      value:
	0  -> blinking block.
	1  -> blinking block (default).
	2  -> steady block.
	3  -> blinking underline.
	4  -> steady underline.
	5  -> blinking bar (xterm).
	6  -> steady bar (xterm).

  # set cursor colour

    OSC 12 ; rgb:xxxx/xxxx/xxxx BEL

    or

    OSC 12 ; #xxxxxx BEL

  # get cursor colour

    OSC 12 ; ? BEL

    reply:

    12;rgb:xxxx/xxxx/xxxx

  $set_cursor_colour: (colour cont)
    if
      colour == cursor_colour
      cont
      :
	!cursor_colour colour
	$colour_value colour.to_integer
	$red hex((colour_value >> 16) & 0xff 2)
	$green hex((colour_value >> 8) & 0xff 2)
	$blue hex(colour_value & 0xff 2)
	log "set cursor colour to @(red), @(green), @(blue)"
	append &output osc(12 "#@(red)@(green)@(blue)" "@bel;")
	cont

  $auto_cursor_colour: (cont)
    if
      cursor_colour.is_undefined
      cont
      :
	!cursor_colour undefined
	append &output "@esc;]112;@bel;"
	cont

  $emit_character: (chr cont)
    log "print " debug::string(chr).trim
    $chr_width width_of(chr)
    if !chr !chr_width
      current_x == terminal_width && chr_width == 2
      -> ' ' 1
      -> chr chr_width
    push &output chr
    plus &current_x width_of(chr)
    if
      current_x > terminal_width:
	#
	  there seems to be *no* autowrap to the start of the next line!
	!current_x undefined
	!current_y undefined
	cont
      cont

  $finish:
    $cursor_is_visible cursor_is_visible_of(terminal)
    if
      cursor_is_visible:
	$cursor_x cursor_x_of(terminal)
	$cursor_y cursor_y_of(terminal)
	move_to cursor_x cursor_y:
	  $row new_rows(current_y)
	  if
	    row(3*current_x-2) == ' ':
	      set_cursor_colour row(3*current_x-1) switch_cursor_on_or_off
	    :
	      auto_cursor_colour switch_cursor_on_or_off
      switch_cursor_on_or_off

    $switch_cursor_on_or_off:
      if
	cursor_is_visible != cursor_is_visible_of(current_buffer):
	  if
	    cursor_is_visible:
	      log "switch cursor on"
	      append &output csi("?25h")
	      update_current_buffer
	    :
	      log "switch cursor off"
	      append &output csi("?25l")
	      update_current_buffer
	update_current_buffer

    $update_current_buffer:
      !current_buffer.cursor_is_visible_of cursor_is_visible
      !current_buffer.cursor_y_of current_y
      !current_buffer.cursor_x_of current_x
      !current_buffer.draw_colour_of current_draw_colour
      !current_buffer.clear_colour_of current_clear_colour
      !current_buffer.rows_of new_rows
      ->
	terminal
	  .current_buffer_of current_buffer
	  .cursor_colour_of cursor_colour
	output

$find_last_non_empty_column: (row)
  $i length_of(row)
  $clear_colour row(i)
  loop:
    if
      i > 0 && row(i-2) == ' ' && row(i) == clear_colour:
	!i i-3
	next
      -> i .div. 3

$std_types::screen/plot:
  (
    screen # the screen or terminal onto which to plot
    x # the x-cordinate of the *half block*
    y # the y-coordinate of the *half block*
  )
  basic_private::abs_x screen &x
  basic_private::abs_y screen &y
  $row_no (y+1) .div. 2
  if
    ||
      row_no < 1
      row_no > height_of(screen)
      x < 1
      x > width_of(screen)
    -> screen
    :
      $rows rows_of(screen)
      $row rows(row_no)
      $chr row(3*x-2)
      if !row
	chr == INVALID_CHARACTER
	-> row(3*x-5 ' ')
	-> row
      if !row
	width_of(chr) == 2
	-> row(3*x+1 ' ')
	-> row
      if
	y.is_odd:
	  # upper half block
	  case chr
	    '▀', '█' return
	    '▄':
	      !row(3*x-2) '█'
	      return
	    :
	      !row(3*x-2) '▀'
	      return
	:
	  # lower half block
	  case chr
	    '▀':
	      !row(3*x-2) '█'
	      return
	    '▄', '█' return
	    :
	      !row(3*x-2) '▄'
	      return

      $return:
	!row(3*x-1) draw_colour_of(screen)
	-> screen(.rows_of rows(row_no row))

$std_types::screen/plot_line:
  #
    draws a line from a point to another point

    Example:

      <require basic/stdlib>
      <require terminal/terminal>

      initialize_terminal! CURSOR_OFF: (terminal)
	draw_text &terminal 1 1 "12345678901"
	from_to 2 9
	  : (y)
	    draw_text &terminal 1 y y "__________"
	    next!
	  :
	    plot_line &terminal 3 3 11 9
	    update_terminal &terminal $output # create output character stream
	    print! output # print the generated character stream
	    get_key! $_key
	    pass

    Output:

      12345678901
      2__________
      3_▀▄_______
      4__▀▄______
      5____█_____
      6_____▀▄___
      7______▀▄__
      8________█_
      9_________▀
  (
    screen
    x1
    y1
    x2
    y2
  )
  !y1 (2*(y1-1)).to_integer+1
  !y2 (2*(y2-1)).to_integer+1
  basic_private::abs_x screen &x1
  basic_private::abs_y screen &y1
  basic_private::abs_x screen &x2
  basic_private::abs_y screen &y2
  $dx x2-x1
  $dy y2-y1
  if
    abs(dx) >= abs(dy):
      $iter bresenham(abs(dx)+1 y1 y2)
      if
	x2 >= x1:
	  from_to x1 x2
	    : (x)
	      next_value &iter $y
	      plot &screen x y
	      next
	    -> screen
	:
	  from_to_by x1 x2 -1
	    : (x)
	      next_value &iter $y
	      plot &screen x y
	      next
	    -> screen
    :
      $iter bresenham(abs(dy)+1 x1 x2)
      if
	y2 >= y1:
	  from_to y1 y2
	    : (y)
	      next_value &iter $x
	      plot &screen x y
	      next
	    -> screen
	:
	  from_to_by y1 y2 -1
	    : (y)
	      next_value &iter $x
	      plot &screen x y
	      next
	    -> screen

$std_types::screen/fill_trapezoid:
  #
    draws a filled trapezoid (without borders)

    The left and top edge are included in the filled area;
    the bottom and right edge are not included.

    Topic: Terminal
  (
    screen
    x1
    y1
    w1
    x2
    y2
    w2
  )
  basic_private::abs_x screen &x1
  basic_private::abs_y screen &y1
  basic_private::abs_x screen &x2
  basic_private::abs_y screen &y2
  if
    ||
      w1 < 0
      w2 < 0
      y1 >= y2
    -> screen
    :
      # use the Bresenham algorithm to compute the left and right edge
      $dy y2-y1
      $left_iter bresenham(dy x1 x2)
      $right_iter bresenham(dy x1+w1 x2+w2)
      from_to y1 y2-1
	: (y)
	  next_value &left_iter $lx
	  next_value &right_iter $rx
	  plot_line &screen lx y rx-1 y
	  next
	-> screen

$std_types::screen/set_draw_colour:
  (
    screen
    colour
  )
  -> screen(.draw_colour_of colour)

$std_types::screen/set_clear_colour:
  (
    screen
    colour
  )
  -> screen(.clear_colour_of colour)

$INVALID_CHARACTER '@0;'

$std_types::terminal/set_cursor:
  (
    self # the terminal for which to set the cursor
    x # in logical screen coordinates
    y # in logical screen coordinates (any coordinate within a row is accepted)
  )
  ->
    self
      .cursor_x_of x
      .cursor_y_of y

$std_types::view/set_cursor:
  (
    view
    terminal
    x
    y
  )
  $width width_of(view)
  $height height_of(view)
  max &x 1
  max &y 1
  min &x width
  min &y height
  set_cursor terminal x+x_of(view)-1 y+y_of(view)-1

$std_types::screen/set_character_at:
  (
    screen
    x
    y
    chr
  )
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x-2) chr
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::view/set_character_at:
  (
    view
    screen
    x
    y
    chr
  )
  plus &x x_of(view)-1
  plus &y y_of(view)-1
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x-2) chr
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::screen/get_character_at:
  (
    screen
    x
    y
  )
  $rows rows_of(screen)
  $row rows(y)
  -> row(3*x-2)

$std_types::view/get_character_at:
  (
    view
    screen
    x
    y
  )
  plus &x x_of(view)-1
  plus &y y_of(view)-1
  $rows rows_of(screen)
  $row rows(y)
  -> row(3*x-2)

$std_types::screen/set_draw_colour_at:
  (
    screen
    x
    y
    colour
  )
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x-1) colour
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::view/set_draw_colour_at:
  (
    view
    screen
    x
    y
    colour
  )
  plus &x x_of(view)-1
  plus &y y_of(view)-1
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x-1) colour
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::screen/get_draw_colour_at:
  (
    screen
    x
    y
  )
  $rows rows_of(screen)
  $row rows(y)
  -> row(3*x-1)

$std_types::view/get_draw_colour_at:
  (
    view
    screen
    x
    y
  )
  plus &x x_of(view)-1
  plus &y y_of(view)-1
  $rows rows_of(screen)
  $row rows(y)
  -> row(3*x-1)

$std_types::screen/set_clear_colour_at:
  (
    screen
    x
    y
    colour
  )
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x) colour
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::view/set_clear_colour_at:
  (
    view
    screen
    x
    y
    colour
  )
  plus &x x_of(view)-1
  plus &y y_of(view)-1
  $rows rows_of(screen)
  $row rows(y)
  !row(3*x) colour
  !rows(y) row
  -> screen(.rows_of rows)

$std_types::screen/get_clear_colour_at:
  (
    screen
    x
    y
  )
  $rows rows_of(screen)
  $row rows(y)
  -> row(3*x)

$std_types::view/get_clear_colour_at:
  (
    view
    screen
    x
    y
  )
  plus &x x_of(view)-1
  plus &y y_of(view)-1
  $rows rows_of(screen)
  $row rows(y)
  -> row(3*x)

$std_types::screen/draw_character:
  (
    screen
    x
    y
    chr
  )
  draw_text screen x y chr.to_string

$std_types::screen/draw_text:
  (
    self
    x
    y
    args*
  )
  basic_private::draw_text self self x y create_string(args)

$std_types::screen/basic_private::draw_text:
  (
    self
    view
    x
    y
    text
  )
  if
    text.is_empty
    -> self
    :
      $left_x x_of(view)
      $top_y y_of(view)
      $right_x x_of(view)+width_of(view)-1
      $bottom_y y_of(view)+height_of(view)-1
      $first_y y
      $draw_colour
	character
	  draw_colour_of(view).to_integer | (text_attributes_of(view) << 24)
      $emoji_draw_colour draw_colour_of(view)
      $clear_colour clear_colour_of(view)
      $colour
	if
	  clear_colour.is_defined
	  -> string(draw_colour clear_colour)
	  -> undefined
      without_suffix &text '@nl;'
      split text '@nl;' $lines
      if
	||
	  x > right_x
	  first_y > bottom_y
	  first_y+length_of(lines) <= top_y
	-> self # text is completely outside the "window"
	:
	  update_if first_y < top_y &lines &first_y
	    -> range(lines top_y+1-first_y -1) top_y
	  $line_count length_of(lines)
	  if !lines $last_y
	    first_y+line_count-1 > bottom_y
	    -> range(lines 1 bottom_y+1-first_y) bottom_y
	    -> lines first_y+line_count-1
	  $rows rows_of(self)
	  ->
	    self
	      .rows_of
		append
		  range(rows 1 first_y-1)
		  map(range(rows first_y last_y) update_row)
		  range(rows last_y+1 -1)

      $update_row: (no row)
	$line lines(no)
	if
	  line.is_empty
	  -> row
	  :
	    find_start $sx $i $insert_space
	    if
	      sx.is_undefined
	      -> row
	      :
		create_attributed_text $ex $attributed_text
		  sx range(line i -1) insert_space
		$left range(row 1 3*(sx-1))
		$right range(row 3*ex-2 -1)
		append left attributed_text right

	$find_start:
	  $i 1
	  $n length_of(line)
	  loop:
	    if
	      i > n
	      -> undefined undefined undefined
	      :
		if
		  x >= left_x:
		    if
		      i > 1 && x > left_x
		      -> x-1 i true
		      -> x i false
		  :
		    plus &x width_of(line(i))
		    inc &i
		    next

	$create_attributed_text: (ax atext insert_space)
	  #
	    ATTENTION!!!

	    There is a severe bug in the Gnome Terminal that prevents output
	    of emojis if the italic text attribute is set.

	    As a workaround all text attributes are suppressed for wide
	    characters.

	  if
	    colour.is_defined:
	      if $attributed_text !ax
		insert_space
		-> string(' ' colour) ax+1
		-> "" ax
	      for_each atext
		: (chr)
		  $cw width_of(chr)
		  if
		    ax+cw > right_x+1:
		      if
			ax == right_x:
			  push &attributed_text ' '
			  append &attributed_text colour
			  -> ax+1 attributed_text
			-> ax attributed_text
		    :
		      if
			cw == 1:
			  push &attributed_text chr
			  append &attributed_text colour
			  inc &ax
			  next
			:
			  push &attributed_text chr
			  push &attributed_text emoji_draw_colour
			  push &attributed_text clear_colour
			  push &attributed_text INVALID_CHARACTER
			  append &attributed_text colour
			  plus &ax cw
			  next
		-> ax attributed_text
	    :
	      if $attributed_text !ax
		insert_space
		-> string(' ' draw_colour row(3*ax)) ax+1
		-> "" ax
	      for_each atext
		: (chr)
		  $cw width_of(chr)
		  if
		    ax+cw > right_x+1:
		      if
			ax == right_x:
			  push &attributed_text ' '
			  push &attributed_text draw_colour
			  push &attributed_text row(3*ax)
			  -> ax+1 attributed_text
			-> ax attributed_text
		    :
		      if
			cw == 1:
			  push &attributed_text chr
			  push &attributed_text draw_colour
			  push &attributed_text row(3*ax)
			  inc &ax
			  next
			:
			  push &attributed_text chr
			  push &attributed_text draw_colour
			  push &attributed_text row(3*ax)
			  push &attributed_text INVALID_CHARACTER
			  push &attributed_text draw_colour
			  push &attributed_text row(3*(ax+1))
			  plus &ax cw
			  next
		-> ax attributed_text

$std_types::screen/draw_attributed_text:
  #
    the text must not contain any newline characters and is clipped on the
    borders of the current window.
  (
    self
    x
    y
    attributed_text
  )
  basic_private::draw_attributed_text self self x y attributed_text

$std_types::screen/basic_private::draw_attributed_text:
  (
    self
    view
    x
    y
    attributed_text
  )
  $n length_of(attributed_text) .div. 3
  $left_x x_of(view)
  $top_y y_of(view)
  $right_x x_of(view)+width_of(view)-1
  $bottom_y y_of(view)+height_of(view)-1
  if
    ||
      x+n-1 < left_x
      x > right_x
      y < top_y
      y > bottom_y
    -> self # text is completely outside the "window"
    :
      $rows rows_of(self)
      ->
	self
	  .rows_of
	    append
	      push(range(rows 1 y-1) update_row(rows(y)))
	      range(rows y+1 -1)

  $update_row: (row)
    $s max(left_x+1-x 1) # first attributed character to output
    $e min(right_x+1-x n)
    max &x left_x
    $left_text range(row 1 3*(x-1))
    range &attributed_text 3*s-2 3*e
    $right_text range(row 3*(x+e-s)+1 -1)
    update_if left_text.is_not_empty && width_of(left_text(-3)) > 1
      &left_text -> left_text(-3 ' ')
    update_if attributed_text(1) == INVALID_CHARACTER
      &attributed_text -> attributed_text(1 ' ')
    update_if width_of(attributed_text(-3)) > 1
      &attributed_text -> attributed_text(-3 ' ')
    update_if right_text.is_not_empty && right_text(1) == INVALID_CHARACTER
      &right_text -> right_text(1 ' ')
    append left_text attributed_text right_text

#
  000000xx right
  0000xx00 bottom
  00xx0000 left
  xx000000 top

  00 no line
  01 thin line
  10 thick line
  11 thick line

$box_lines
  list
    '╶' # 00 00 00 01
    '╺' # 00 00 00 10
    '╺' # 00 00 00 11
    '╷' # 00 00 01 00
    '┌' # 00 00 01 01
    '┍' # 00 00 01 10
    '┍' # 00 00 01 11
    '╻' # 00 00 10 00
    '┎' # 00 00 10 01
    '┏' # 00 00 10 10
    '┏' # 00 00 10 11
    '╻' # 00 00 11 00
    '┎' # 00 00 11 01
    '┏' # 00 00 11 10
    '┏' # 00 00 11 11
    '╴' # 00 01 00 00
    '─' # 00 01 00 01
    '╼' # 00 01 00 10
    '╼' # 00 01 00 11
    '┐' # 00 01 01 00
    '┬' # 00 01 01 01
    '┮' # 00 01 01 10
    '┮' # 00 01 01 11
    '┒' # 00 01 10 00
    '┰' # 00 01 10 01
    '┲' # 00 01 10 10
    '┲' # 00 01 10 11
    '┒' # 00 01 11 00
    '┰' # 00 01 11 01
    '┲' # 00 01 11 10
    '┲' # 00 01 11 11
    '╸' # 00 10 00 00
    '╾' # 00 10 00 01
    '━' # 00 10 00 10
    '━' # 00 10 00 11
    '┑' # 00 10 01 00
    '┭' # 00 10 01 01
    '┯' # 00 10 01 10
    '┯' # 00 10 01 11
    '┓' # 00 10 10 00
    '┱' # 00 10 10 01
    '┳' # 00 10 10 10
    '┳' # 00 10 10 11
    '┓' # 00 10 11 00
    '┱' # 00 10 11 01
    '┳' # 00 10 11 10
    '┳' # 00 10 11 11
    '╸' # 00 11 00 00
    '╾' # 00 11 00 01
    '━' # 00 11 00 10
    '━' # 00 11 00 11
    '┑' # 00 11 01 00
    '┭' # 00 11 01 01
    '┯' # 00 11 01 10
    '┯' # 00 11 01 11
    '┓' # 00 11 10 00
    '┱' # 00 11 10 01
    '┳' # 00 11 10 10
    '┳' # 00 11 10 11
    '┓' # 00 11 11 00
    '┱' # 00 11 11 01
    '┳' # 00 11 11 10
    '┳' # 00 11 11 11
    '╵' # 01 00 00 00
    '└' # 01 00 00 01
    '┕' # 01 00 00 10
    '┕' # 01 00 00 11
    '│' # 01 00 01 00
    '├' # 01 00 01 01
    '┝' # 01 00 01 10
    '┝' # 01 00 01 11
    '╽' # 01 00 10 00
    '┟' # 01 00 10 01
    '┢' # 01 00 10 10
    '┢' # 01 00 10 11
    '╽' # 01 00 11 00
    '┟' # 01 00 11 01
    '┢' # 01 00 11 10
    '┢' # 01 00 11 11
    '┘' # 01 01 00 00
    '┴' # 01 01 00 01
    '┶' # 01 01 00 10
    '┶' # 01 01 00 11
    '┤' # 01 01 01 00
    '┼' # 01 01 01 01
    '┾' # 01 01 01 10
    '┾' # 01 01 01 11
    '┧' # 01 01 10 00
    '╁' # 01 01 10 01
    '╆' # 01 01 10 10
    '╆' # 01 01 10 11
    '┧' # 01 01 11 00
    '╁' # 01 01 11 01
    '╆' # 01 01 11 10
    '╆' # 01 01 11 11
    '┙' # 01 10 00 00
    '┵' # 01 10 00 01
    '┷' # 01 10 00 10
    '┷' # 01 10 00 11
    '┥' # 01 10 01 00
    '┽' # 01 10 01 01
    '┿' # 01 10 01 10
    '┿' # 01 10 01 11
    '┪' # 01 10 10 00
    '╅' # 01 10 10 01
    '╈' # 01 10 10 10
    '╈' # 01 10 10 11
    '┪' # 01 10 11 00
    '╅' # 01 10 11 01
    '╈' # 01 10 11 10
    '╈' # 01 10 11 11
    '┙' # 01 11 00 00
    '┵' # 01 11 00 01
    '┷' # 01 11 00 10
    '┷' # 01 11 00 11
    '┥' # 01 11 01 00
    '┽' # 01 11 01 01
    '┿' # 01 11 01 10
    '┿' # 01 11 01 11
    '┪' # 01 11 10 00
    '╅' # 01 11 10 01
    '╈' # 01 11 10 10
    '╈' # 01 11 10 11
    '┪' # 01 11 11 00
    '╅' # 01 11 11 01
    '╈' # 01 11 11 10
    '╈' # 01 11 11 11
    '╹' # 10 00 00 00
    '┖' # 10 00 00 01
    '┗' # 10 00 00 10
    '┗' # 10 00 00 11
    '╿' # 10 00 01 00
    '┞' # 10 00 01 01
    '┡' # 10 00 01 10
    '┡' # 10 00 01 11
    '┃' # 10 00 10 00
    '┠' # 10 00 10 01
    '┣' # 10 00 10 10
    '┣' # 10 00 10 11
    '┃' # 10 00 11 00
    '┠' # 10 00 11 01
    '┣' # 10 00 11 10
    '┣' # 10 00 11 11
    '┚' # 10 01 00 00
    '┸' # 10 01 00 01
    '┺' # 10 01 00 10
    '┺' # 10 01 00 11
    '┦' # 10 01 01 00
    '╀' # 10 01 01 01
    '╄' # 10 01 01 10
    '╄' # 10 01 01 11
    '┨' # 10 01 10 00
    '╂' # 10 01 10 01
    '╊' # 10 01 10 10
    '╊' # 10 01 10 11
    '┨' # 10 01 11 00
    '╂' # 10 01 11 01
    '╊' # 10 01 11 10
    '╊' # 10 01 11 11
    '┛' # 10 10 00 00
    '┹' # 10 10 00 01
    '┻' # 10 10 00 10
    '┻' # 10 10 00 11
    '┩' # 10 10 01 00
    '╃' # 10 10 01 01
    '╇' # 10 10 01 10
    '╇' # 10 10 01 11
    '┫' # 10 10 10 00
    '╉' # 10 10 10 01
    '╋' # 10 10 10 10
    '╋' # 10 10 10 11
    '┫' # 10 10 11 00
    '╉' # 10 10 11 01
    '╋' # 10 10 11 10
    '╋' # 10 10 11 11
    '┛' # 10 11 00 00
    '┹' # 10 11 00 01
    '┻' # 10 11 00 10
    '┻' # 10 11 00 11
    '┩' # 10 11 01 00
    '╃' # 10 11 01 01
    '╇' # 10 11 01 10
    '╇' # 10 11 01 11
    '┫' # 10 11 10 00
    '╉' # 10 11 10 01
    '╋' # 10 11 10 10
    '╋' # 10 11 10 11
    '┫' # 10 11 11 00
    '╉' # 10 11 11 01
    '╋' # 10 11 11 10
    '╋' # 10 11 11 11
    '╹' # 11 00 00 00
    '┖' # 11 00 00 01
    '┗' # 11 00 00 10
    '┗' # 11 00 00 11
    '╿' # 11 00 01 00
    '┞' # 11 00 01 01
    '┡' # 11 00 01 10
    '┡' # 11 00 01 11
    '┃' # 11 00 10 00
    '┠' # 11 00 10 01
    '┣' # 11 00 10 10
    '┣' # 11 00 10 11
    '┃' # 11 00 11 00
    '┠' # 11 00 11 01
    '┣' # 11 00 11 10
    '┣' # 11 00 11 11
    '┚' # 11 01 00 00
    '┸' # 11 01 00 01
    '┺' # 11 01 00 10
    '┺' # 11 01 00 11
    '┦' # 11 01 01 00
    '╀' # 11 01 01 01
    '╄' # 11 01 01 10
    '╄' # 11 01 01 11
    '┨' # 11 01 10 00
    '╂' # 11 01 10 01
    '╊' # 11 01 10 10
    '╊' # 11 01 10 11
    '┨' # 11 01 11 00
    '╂' # 11 01 11 01
    '╊' # 11 01 11 10
    '╊' # 11 01 11 11
    '┛' # 11 10 00 00
    '┹' # 11 10 00 01
    '┻' # 11 10 00 10
    '┻' # 11 10 00 11
    '┩' # 11 10 01 00
    '╃' # 11 10 01 01
    '╇' # 11 10 01 10
    '╇' # 11 10 01 11
    '┫' # 11 10 10 00
    '╉' # 11 10 10 01
    '╋' # 11 10 10 10
    '╋' # 11 10 10 11
    '┫' # 11 10 11 00
    '╉' # 11 10 11 01
    '╋' # 11 10 11 10
    '╋' # 11 10 11 11
    '┛' # 11 11 00 00
    '┹' # 11 11 00 01
    '┻' # 11 11 00 10
    '┻' # 11 11 00 11
    '┩' # 11 11 01 00
    '╃' # 11 11 01 01
    '╇' # 11 11 01 10
    '╇' # 11 11 01 11
    '┫' # 11 11 10 00
    '╉' # 11 11 10 01
    '╋' # 11 11 10 10
    '╋' # 11 11 10 11
    '┫' # 11 11 11 00
    '╉' # 11 11 11 01
    '╋' # 11 11 11 10
    '╋' # 11 11 11 11

$box_line_to_int8 swap_key_and_value(box_lines)

$std_types::screen/draw_line:
  (
    screen
    x1
    y1
    x2
    y2
  )
  check_draw_line_arguments screen &x1 &y1 &x2 &y2
  if
    x1.is_an_error || x1.is_undefined
    -> screen
    :
      $rows rows_of(screen)
      $colours string(draw_colour_of(screen) clear_colour_of(screen))
      if
	y1 == y2:
	  # draw horizontal line
	  $row rows(y1)
	  $left range(row 1 3*(x1-1))
	  $right range(row 3*(x2+1)-2 -1)
	  append &left update_line_cell(0x01 row(3*x1-2) colours)
	  from_to x1+1 x2-1
	    : (cx)
	      append &left update_line_cell(0x11 row(3*cx-2) colours)
	      next
	    :
	      append &left update_line_cell(0x10 row(3*x2-2) colours)
	      !rows(y1) append(left right)
	      -> screen(.rows_of rows)
	:
	  # draw vertical line
	  $top range(rows 1 y1-1)
	  $bottom range(rows y2+1 -1)
	  $first_row rows(y1)
	  push &top
	    append
	      range(first_row 1 3*(x1-1))
	      update_line_cell(0x04 first_row(3*x1-2) colours)
	      range(first_row 3*(x1+1)-2 -1)
	  from_to y1+1 y2-1
	    : (cy)
	      $row rows(cy)
	      push &top
		append
		  range(row 1 3*(x1-1))
		  update_line_cell(0x44 row(3*x1-2) colours)
		  range(row 3*(x1+1)-2 -1)
	      next
	    :
	      $last_row rows(y2)
	      push &top
		append
		  range(last_row 1 3*(x1-1))
		  update_line_cell(0x40 last_row(3*x1-2) colours)
		  range(last_row 3*(x1+1)-2 -1)
	      -> screen(.rows_of append(top bottom))

$std_types::screen/draw_thick_line:
  (
    screen
    x1
    y1
    x2
    y2
  )
  check_draw_line_arguments screen &x1 &y1 &x2 &y2
  if
    x1.is_an_error || x1.is_undefined
    -> screen
    :
      $rows rows_of(screen)
      $colours string(draw_colour_of(screen) clear_colour_of(screen))
      if
	y1 == y2:
	  # draw horizontal line
	  $row rows(y1)
	  $left range(row 1 3*(x1-1))
	  $right range(row 3*(x2+1)-2 -1)
	  append &left update_line_cell(0x03 row(3*x1-2) colours)
	  from_to x1+1 x2-1
	    : (cx)
	      append &left update_line_cell(0x33 row(3*cx-2) colours)
	      next
	    :
	      append &left update_line_cell(0x30 row(3*x2-2) colours)
	      !rows(y1) append(left right)
	      -> screen(.rows_of rows)
	:
	  # draw vertical line
	  $top range(rows 1 y1-1)
	  $bottom range(rows y2+1 -1)
	  $first_row rows(y1)
	  push &top
	    append
	      range(first_row 1 3*(x1-1))
	      update_line_cell(0x0c first_row(3*x1-2) colours)
	      range(first_row 3*(x1+1)-2 -1)
	  from_to y1+1 y2-1
	    : (cy)
	      $row rows(cy)
	      push &top
		append
		  range(row 1 3*(x1-1))
		  update_line_cell(0xcc row(3*x1-2) colours)
		  range(row 3*(x1+1)-2 -1)
	      next
	    :
	      $last_row rows(y2)
	      push &top
		append
		  range(last_row 1 3*(x1-1))
		  update_line_cell(0xc0 last_row(3*x1-2) colours)
		  range(last_row 3*(x1+1)-2 -1)
	      -> screen(.rows_of append(top bottom))

$update_line_cell: (line_mask character colours)
  $current_line_mask default_value(box_line_to_int8(character) 0)
  $new_line_mask line_mask | current_line_mask
  $new_character box_lines(new_line_mask)
  put colours new_character

$check_draw_line_arguments: (screen x1 y1 x2 y2)
  # the line must be horizontal or vertical
  $width width_of(screen)
  $height height_of(screen)
  if
    x1 == x2:
      if
	y1 == y2
	invalid_arguments
	:
	  # swap if necessary
	  update_if y1 > y2 &y1 &y2 -> y2 y1
	  # clip
	  if
	    y1 > height || y2 < 1 || x1 < 1 || x1 > width
	    -> undefined undefined undefined undefined
	    :
	      update_if y1 < 1 &y1 -> 1
	      update_if y2 > height &y2 -> height
	      -> x1 y1 x2 y2
    :
      if
	y1 != y2
	invalid_arguments
	:
	  # swap if necessary
	  update_if x1 > x2 &x1 &x2 -> x2 x1
	  # clip
	  if
	    x1 > width || x2 < 1 || y1 < 1 || y1 > height
	    -> undefined undefined undefined undefined
	    :
	      update_if x1 < 1 &x1 -> 1
	      update_if x2 > width &x2 -> width
	      -> x1 y1 x2 y2

  $invalid_arguments:
    error "
      INVALID ARGUMENTS FOR "std_types::screen/draw_line"@

$std_types::screen/draw_border:
  (
    self
    x1
    y1
    x2
    y2
  )
  draw_line &self x1 y1 x1 y2
  draw_line &self x1 y2 x2 y2
  draw_line &self x2 y2 x2 y1
  draw_line self x2 y1 x1 y1

$std_types::screen/draw_thick_border:
  (
    self
    x1
    y1
    x2
    y2
  )
  draw_thick_line &self x1 y1 x1 y2
  draw_thick_line &self x1 y2 x2 y2
  draw_thick_line &self x2 y2 x2 y1
  draw_thick_line self x2 y1 x1 y1

$std::create_terminal:
  #
    Example:

      <require basic/stdlib>
      <require terminal/terminal>

      get_terminal_size! STDIN_FILENO $width $height
      create_terminal $terminal width height
	DRAW_COLOUR = WHITE
	CLEAR_COLOUR = BLUE
      draw_text &terminal
	10 # column
	5 # row
	"
	  This is a multi-line
	  text.
      update_terminal &terminal $output # create output character stream
      print! output # print the generated character stream
  (
    width
    height
    options*
  )
  get_options options
    DRAW_COLOUR = BLACK $draw_colour
    CLEAR_COLOUR = WHITE $clear_colour
    CURSOR_OFF = false $do_switch_cursor_off
    MOUSE_REPORTING = DISABLED $mouse_reporting
  $row dup(string(' ' draw_colour clear_colour) width)
  $rows dup(list(row) height)
  $terminal
    std_types::terminal
      .cursor_x_of 1
      .cursor_y_of 1
      .width_of width
      .height_of height
      .draw_colour_of draw_colour
      .clear_colour_of clear_colour
      .cursor_is_visible_of not(do_switch_cursor_off)
      .mouse_reporting_of mouse_reporting
      .rows_of rows
  $buffer
    create_buffer
      width height
      DRAW_COLOUR = INVALID_COLOUR
      CLEAR_COLOUR = INVALID_COLOUR
  ->
    terminal
      .current_buffer_of
	buffer
	  .cursor_x_of undefined # cursor column
	  .cursor_y_of undefined # cursor row

$std_types::terminal/resize:
  (
    self
    new_width
    new_height
  )
  resize_rows &self
    new_width new_height
    draw_colour_of(self) clear_colour_of(self)
  $buffer # invalidate buffer
    create_buffer
      new_width new_height
      DRAW_COLOUR = INVALID_COLOUR
      CLEAR_COLOUR = INVALID_COLOUR
  !buffer
    buffer
      .cursor_x_of undefined # cursor column
      .cursor_y_of undefined # cursor row
  -> self(.current_buffer_of buffer)

$std_types::terminal/switch_cursor_on:
  (
    self
  )
  -> self(.cursor_is_visible_of true)

$std_types::terminal/switch_cursor_off:
  (
    self
  )
  -> self(.cursor_is_visible_of false)

$std_types::terminal/has_a_visible_cursor:
  (
    self
  )
  -> cursor_is_visible_of(self)

$std_types::terminal/set_mouse_reporting:
  (
    self
    mouse_reporting
  )
  -> self(.mouse_reporting_of mouse_reporting)

$std_types::terminal/get_mouse_reporting:
  (
    self
  )
  -> mouse_reporting_of(self)

$std::cursor_off:
  print! "@esc;[?25l"

$std::cursor_on:
  print! "@esc;[?25h"

$std::cursor_home:
  print! "@esc;[1;1H"

$std::clear_screen:
  cursor_home!
  print! "@esc;[2J"

$std::rows_and_columns:
  (
    text
  )
  $rows 0
  $longest 0
  $length 0
  for_each text
    : (chr)
      if
	chr == '@nl;':
	  max &longest length
	  inc &rows
	  !length 0
	  next
	:
	  inc &length
	  next
    :
      if
	text(-1) != '@nl;':
	  max &longest length
	  -> rows+1 longest
	-> rows longest

$std::add_attributes:
  (
    text
    draw_colour
    clear_colour
  )
  $buf ""
  for_each text
    : (chr)
      push &buf chr
      push &buf draw_colour
      push &buf clear_colour
      if
	chr.is_a_wide_character:
	  push &buf INVALID_CHARACTER
	  push &buf draw_colour
	  push &buf clear_colour
	  next
	next
    -> buf

$std_types::screen/create_text_screen:
  (
    template
    text
    info = undefined
  )
  $draw_attributes
    character
      draw_colour_of(template).to_integer | (text_attributes_of(template) << 24)
  without_suffix &text '@nl;'
  $lines split(text '@nl;')
  $width map_reduce(lines width_of max 0)
  $height max(length_of(lines) 1)
  $rows
    if
      height == 1
      -> list(add_attributes(text draw_attributes clear_colour_of(template)))
      ->
	map_reduce
	  lines: (line)
	    list
	      add_attributes
		pad_right(line width)
		draw_attributes
		clear_colour_of(template)
  template
    .width_of width
    .height_of height
    .rows_of rows
    .rectangles_of
      if
	info.is_defined
	-> tuple(RECTANGLE info 1 1 width height)
	-> undefined

$std_types::screen/adjoin:
  (
    screens*
  )
  $non_empty_screens filter(screens: (screen) -> width_of(screen) > 0)
  case length_of(non_empty_screens)
    0 -> screens(-1)
    1 ->
      non_empty_screens(1)
	.clear_colour_of clear_colour_of(screens(-1))
	.draw_colour_of draw_colour_of(screens(-1))
    :
      adjoin_screens non_empty_screens(1) range(non_empty_screens 2 -1)

$adjoin_screens:
  (
    left
    screens
  )
  $width width_of(left)
  $height height_of(left)
  $rows rows_of(left)
  $rectangles rectangles_of(left)
  $dx 0
  $dy 0
  $clear_colour clear_colour_of(left)
  $draw_colour draw_colour_of(left)
  !rectangles
    if
      rectangles.is_defined:
	rectangles $kind $info $x $y
	if
	  kind == HORIZONTAL:
	    !dx x-1
	    !dy y-1
	    map info add_delta
	  -> list(rectangles)
      -> empty_list
  for_each screens
    : (screen)
      if
	height_of(screen) != height:
	  error RUNTIME_ERROR "INVALID ARGUMENTS" screen
	:
	  $more_rectangles rectangles_of(screen)
	  update_if more_rectangles.is_defined &rectangles:
	    more_rectangles $kind $info $x $y $w $h
	    if
	      kind == HORIZONTAL:
		!dx x-1+width
		!dy y-1
		append rectangles map(info add_delta)
	      :
		push rectangles tuple(kind info x+width y w h)
	  plus &width width_of(screen)
	  map &rows: (idx row) append row rows_of(screen)(idx)
	  !clear_colour clear_colour_of(screen)
	  !draw_colour draw_colour_of(screen)
	  next
    ->
      left
	.width_of width
	.rows_of rows
	.clear_colour_of clear_colour
	.draw_colour_of draw_colour
	.rectangles_of
	  if
	    rectangles.is_empty
	    -> undefined
	    :
	      if
		length_of(rectangles) == 1
		-> rectangles(1)
		-> tuple(HORIZONTAL rectangles 1 1 width height)

  $add_delta: (item)
    item $kind $info $x $y $w $h
    -> tuple(kind info x+dx y+dy w h)

$std_types::screen/append:
  (
    self
    screens*
  )
  $width width_of(self)
  $height height_of(self)
  $rows rows_of(self)
  $rectangles rectangles_of(self)
  $dx 0
  $dy 0
  !rectangles
    if
      rectangles.is_defined:
	rectangles $kind $info $x $y
	if
	  kind == VERTICAL:
	    !dx x-1
	    !dy y-1
	    map info add_delta
	  -> list(rectangles)
      -> empty_list
  for_each screens
    : (screen)
      if
	width_of(screen) != width:
	  error RUNTIME_ERROR "INVALID ARGUMENTS" screen
	:
	  $more_rectangles rectangles_of(screen)
	  update_if more_rectangles.is_defined &rectangles:
	    more_rectangles $kind $info $x $y $w $h
	    if
	      kind == VERTICAL:
		!dx x-1
		!dy y-1+height
		append rectangles map(info add_delta)
	      :
		push rectangles tuple(kind info x y+height w h)
	  plus &height height_of(screen)
	  append &rows rows_of(screen)
	  next
    ->
      self
	.height_of height
	.rows_of rows
	.rectangles_of
	  if
	    rectangles.is_empty
	    -> undefined
	    :
	      if
		length_of(rectangles) == 1
		-> rectangles(1)
		-> tuple(VERTICAL rectangles 1 1 width height)

  $add_delta: (item)
    item $kind $info $x $y $w $h
    -> tuple(kind info x+dx y+dy w h)

$std_types::screen/get_rectangle_at:
  (
    self
    x
    y
  )
  $rectangles rectangles_of(self)
  if
    rectangles.is_undefined
    -> undefined
    -> find_rectangle_at(rectangles x y 0 0)

$find_rectangle_at: (rectangle rx ry dx dy)
  rectangle $kind $info $x $y $w $h
  if
    rx >= x && rx < x+w && ry >= y && ry < y+h:
      if
	kind == RECTANGLE
	-> tuple(info x+dx y+dy w h)
	:
	  $ndx x-1
	  $ndy y-1
	  minus &rx ndx
	  minus &ry ndy
	  plus &dx ndx
	  plus &dy ndy
	  $s 1
	  $e length_of(info)
	  if
	    kind == HORIZONTAL:
	      loop:
		$i s+e .div. 2
		info(i) $_kind $_info $x_i $_y_i $w_i $_h_i
		if
		  rx < x_i:
		    if
		      i == s
		      -> undefined
		      :
			!e i-1
			next
		  :
		    if
		      rx < x_i+w_i
		      -> find_rectangle_at(info(i) rx ry x-1 y-1)
		      :
			if
			  i == e
			  -> undefined
			  :
			    !s i+1
			    next
	    :
	      loop:
		$i s+e .div. 2
		info(i) $_kind $_info $_x_i $y_i $_w_i $h_i
		if
		  ry < y_i:
		    if
		      i == s
		      -> undefined
		      :
			!e i-1
			next
		  :
		    if
		      ry < y_i+h_i
		      -> find_rectangle_at(info(i) rx ry x-1 y-1)
		      :
			if
			  i == e
			  -> undefined
			  :
			    !s i+1
			    next
    -> undefined

$std_types::screen/get_rectangle_by_key:
  (
    self
    key
  )
  $rectangles rectangles_of(self)
  if
    rectangles.is_undefined
    -> undefined
    :
      find_rectangle_by_key
	rectangles
	if
	  key.is_a_character
	  -> key.to_lower_case
	  -> key

$find_rectangle_by_key: (rectangle key)
  rectangle $kind $info
  case kind
    RECTANGLE:
      info $shortcut
      if
	shortcut == key
	-> rectangle
	-> undefined
    :
      for_each info
	: (item)
	  $result find_rectangle_by_key(item key)
	  if
	    result.is_defined
	    -> result
	    next
	-> undefined

$std_types::screen/get_next_rectangle:
  (
    self
    rectangle = undefined
  )
  if
    rectangle.is_undefined:
      $rectangles rectangles_of(self)
      if
	rectangles.is_defined
	-> find_first_rectangle(rectangles 0 0)
	-> undefined
    :
      rectangle $_info $x $y
      $rect find_next_rectangle(rectangles_of(self) x y 0 0)
      if
	RECTANGLE == rect
	-> undefined
	-> rect

$find_first_rectangle: (rectangle dx dy)
  rectangle $kind $info $x $y $w $h
  plus &x dx
  plus &y dy
  if
    kind == RECTANGLE
    -> tuple(info x y w h)
    -> find_first_rectangle(info(1) x-1 y-1)

$find_next_rectangle: (rectangle rx ry dx dy)
  rectangle $kind $info $x $y $w $h
  plus &x dx
  plus &y dy
  if
    rx >= x && rx < x+w && ry >= y && ry < y+h:
      $n length_of(info)
      case kind
	RECTANGLE -> RECTANGLE
	HORIZONTAL:
	  $s 1
	  $e n
	  loop:
	    $i s+e .div. 2
	    info(i) $_kind $_info $x_i $_y_i $w_i
	    if
	      rx < x_i:
		if
		  i == s
		  -> undefined
		  :
		    !e i-1
		    next
	      :
		if
		  rx < x_i+w_i
		  :
		    $rect find_next_rectangle(info(i) rx ry x-1 y-1)
		    if
		      RECTANGLE == rect: # found one match
			if
			  i < n
			  -> find_first_rectangle(info(i+1) x-1 y-1)
			  -> RECTANGLE
		      -> rect
		  :
		    if
		      i == e
		      -> undefined
		      :
			!s i+1
			next
	VERTICAL:
	  $s 1
	  $e length_of(info)
	  loop:
	    $i s+e .div. 2
	    info(i) $_kind $_info $_x_i $y_i $_w_i $h_i
	    if
	      ry < y_i:
		if
		  i == s
		  -> undefined
		  :
		    !e i-1
		    next
	      :
		if
		  ry < y_i+h_i:
		    $rect find_next_rectangle(info(i) rx ry x-1 y-1)
		    if
		      RECTANGLE == rect: # found one match
			if
			  i < n
			  -> find_first_rectangle(info(i+1) x-1 y-1)
			  -> RECTANGLE
		      -> rect
		  :
		    if
		      i == e
		      -> undefined
		      :
			!s i+1
			next
    -> undefined

$std_types::screen/get_previous_rectangle:
  (
    self
    rectangle = undefined
  )
  if
    rectangle.is_undefined:
      $rectangles rectangles_of(self)
      if
	rectangles.is_defined
	-> find_last_rectangle(rectangles 0 0)
	-> undefined
    :
      rectangle $_info $x $y
      $rect
	find_previous_rectangle(rectangles_of(self) x y 0 0)
      if
	RECTANGLE == rect
	-> undefined
	-> rect

$find_last_rectangle: (rectangle dx dy)
  rectangle $kind $info $x $y $w $h
  plus &x dx
  plus &y dy
  if
    kind == RECTANGLE
    -> tuple(info x y w h)
    -> find_last_rectangle(info(-1) x-1 y-1)

$find_previous_rectangle: (rectangle rx ry dx dy)
  rectangle $kind $info $x $y $w $h
  plus &x dx
  plus &y dy
  if
    rx >= x && rx < x+w && ry >= y && ry < y+h:
      $n length_of(info)
      case kind
	RECTANGLE -> RECTANGLE
	HORIZONTAL:
	  $s 1
	  $e n
	  loop:
	    $i s+e .div. 2
	    info(i) $_kind $_info $x_i $_y_i $w_i
	    if
	      rx < x_i:
		if
		  i == s
		  -> undefined
		  :
		    !e i-1
		    next
	      :
		if
		  rx < x_i+w_i:
		    $rect find_previous_rectangle(info(i) rx ry x-1 y-1)
		    if
		      RECTANGLE == rect: # found one match
			if
			  i > 1
			  -> find_last_rectangle(info(i-1) x-1 y-1)
			  -> RECTANGLE
		      -> rect
		  :
		    if
		      i == e
		      -> undefined
		      :
			!s i+1
			next
	VERTICAL:
	  $s 1
	  $e length_of(info)
	  loop:
	    $i s+e .div. 2
	    info(i) $_kind $_info $_x_i $y_i $_w_i $h_i
	    if
	      ry < y_i:
		if
		  i == s
		  -> undefined
		  :
		    !e i-1
		    next
	      :
		if
		  ry < y_i+h_i:
		    $rect find_previous_rectangle(info(i) rx ry x-1 y-1)
		    if
		      RECTANGLE == rect: # found one match
			if
			  i > 1
			  -> find_last_rectangle(info(i-1) x-1 y-1)
			  -> RECTANGLE
		      -> rect
		  :
		    if
		      i == e
		      -> undefined
		      :
			!s i+1
			next
    -> undefined

$std_types::screen/pad_left:
  (
    self
    width
    clear_colour = undefined
  )
  $delta width-width_of(self)
  if
    delta <= 0
    -> self
    :
      update_if clear_colour.is_undefined &clear_colour -> clear_colour_of(self)
      $pad
	dup
	  string
	    ' '
	    draw_colour_of(self)
	    clear_colour
	  delta
      map &self.rows_of: (row) append pad row
      update_if rectangles_of(self).is_defined &self.rectangles_of:
	rectangles_of(self) $kind $info $x $y $w $h
	tuple kind info x+delta y w h
      -> self(.width_of width)

$std_types::screen/pad_right:
  (
    self
    width
    clear_colour = undefined
  )
  if
    width <= width_of(self)
    -> self
    :
      update_if clear_colour.is_undefined &clear_colour:
	if
	  width_of(self) > 0
	  -> rows_of(self)(1)(-1) # the clear colour of the last column
	  -> clear_colour_of(self)
      $pad
	dup(string(' ' draw_colour_of(self) clear_colour) width-width_of(self))
      map &self.rows_of: (row) append row pad
      -> self(.width_of width)

$std_types::screen/pad_bottom:
  (
    self
    height
    clear_colour = undefined
  )
  if
    height <= height_of(self)
    -> self
    :
      update_if clear_colour.is_undefined &clear_colour:
	if
	  height_of(self) > 0
	  -> rows_of(self)(-1)(3) # the clear colour of the last row
	  -> clear_colour_of(self)
      $pad dup(string(' ' draw_colour_of(self) clear_colour) width_of(self))
      append &self.rows_of dup(list(pad) height-height_of(self))
      -> self(.height_of height)

$std_types::screen/truncate:
  (
    self
    width
    height = undefined
  )
  update_if height.is_undefined &height -> height_of(self)
  if
    width >= width_of(self) && height >= height_of(self)
    -> self
    :
      $rows
	map
	  range(rows_of(self) 1 height): (row)
	    -> range(row 1 3*width)
      ->
	self
	  .width_of width
	  .height_of height
	  .rows_of rows

$std_types::screen/range:
  (
    self
    x1
    y1
    x2
    y2
  )
  # check arguments
  if
    x1 < 1 || x2 > width_of(self) || y1 < 1 || y2 > height_of(self):
      error RUNTIME_ERROR "INVALID ARGUMENTS"
    :
      $width x2-x1+1
      $height y2-y1+1
      $rows map(range(rows_of(self) y1 y2): (row) range row 3*x1-2 3*x2)
      ->
	self
	  .width_of width
	  .height_of height
	  .rows_of rows
