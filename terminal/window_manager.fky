#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

#
  Topic: Window Manager

$std::draw_vertical_slider ()
$std::draw_horizontal_slider ()

# Terminal Methods

$std::create_window_manager ()

# Window Manager Event Types

$std::FOCUS_CHANGED .

# Window Manager Methods

$std::set_time ()
$std::create_window ()
$std::create_dialog ()
$std::set_menu ()
$std::set_status ()
$std::shrink ()
$std::enlarge ()
$std::move_left ()
$std::move_right ()
$std::move_up ()
$std::move_down ()
$std::move_page_up ()
$std::move_page_down ()
$std::move_home ()
$std::move_end ()
$std::move_top ()
$std::move_bottom ()
$std::goto_xy ()
$std::get_xy ()
$std::get_size ()
$std::window_count_of ()
$std::set_title ()
$std::get_title ()
$std::set_buttons ()
$std::get_buttons ()
$std::set_content ()
$std::get_content ()
$std::set_inbounds_width ()
$std::get_inbounds_width ()
$std::set_plain_text_mode ()
$std::get_id ()
$std::get_focused_window ()
$std::get_window_at ()
$std::set_default_message ()
$std::show_message ()
$std::remove_message ()
$std::focus_next_window ()
$std::focus_previous_window ()
$std::focus_window ()
$std::move_window_down ()
$std::move_window_up ()
$std::set_selection ()
$std::unset_selection ()
$std::needs_updating ()
$std::prepare_update ()
$std::handle_window_event ()

# Create Window Options

$std::ID .
$std::USE_CURSOR .
$std::AS_FIRST . # make the window the first in its pane
$std::DO_NOT_FOCUS .
$std::CONTENT .
$std::HORIZONTAL_SCROLLBAR .
$std::VERTICAL_SCROLLBAR .
$std::BUTTONS .
$std::SHRINK .
$std::ENLARGE .
$std::CLOSE .
$std::CURSOR_X .
$std::CURSOR_Y .
$std::FIRST_VISIBLE_COLUMN .
$std::FIRST_VISIBLE_ROW .
$std::MODAL .
$std::PARENT_ID .

$std::SIZE .

$std::DEFAULT .
$std::MINIMIZED .
$std::MAXIMIZED .

$next_window_id_of ()

# Window Manager

$template_screen_of ()
$current_time_of ()
$windows_of ()
$focused_of ()
$maximized_of ()
$message_height_of ()
$dialog_of ()
$menus_of ()
$status_of ()
$current_menu_of ()
$current_menu_index_of ()
$default_message_of ()
$messages_of ()
$has_a_valid_layout ()
$has_a_new_size ()
$is_up_to_date ()
$is_prepared ()

$std_types::window_manager std_types::object
  .current_time_of undefined
  .template_screen_of undefined
  .width_of undefined
  .height_of undefined
  .windows_of empty_list
  .message_height_of 0
  .dialog_of undefined
  .menus_of undefined
  .status_of undefined
  .current_menu_of undefined
  .current_menu_index_of undefined
  .default_message_of undefined
  .messages_of empty_list
  .next_window_id_of 1
  .focused_of undefined
  .maximized_of undefined
  .has_a_valid_layout false
  .has_a_new_size false
  .is_up_to_date false
  .is_prepared false

# Window Prototype

$id_of ()
$parent_id_of () # the id of the window that opened this window (optional)
$size_of () # DEFAULT, MINIMIZED or line count
$is_minimized ()
$cursor_x_of ()
$cursor_y_of ()
$title_of ()
$content_of ()
$content_width_of ()
$content_height_of ()
$inbounds_width_of ()
$buttons_of ()
$additional_buttons_of ()
$selection_of ()
$needs_a_horizontal_scrollbar ()
$needs_a_vertical_scrollbar ()
$has_a_horizontal_scrollbar ()
$has_a_vertical_scrollbar ()
$is_in_plain_text_mode ()
$first_visible_column_of ()
$first_visible_row_of ()
$is_modal ()

$proto_window std_types::object
  .id_of undefined
  .parent_id_of undefined
  .size_of DEFAULT
  .is_minimized false
  .x_of undefined
  .y_of undefined
  .width_of undefined
  .height_of undefined
  .cursor_x_of undefined
  .cursor_y_of undefined
  .clear_colour_of undefined
  .title_of undefined
  .content_of undefined
  .content_width_of undefined
  .content_height_of undefined
  .inbounds_width_of 80
  .buttons_of empty_list
  .additional_buttons_of empty_list
  .selection_of undefined
  .needs_a_horizontal_scrollbar undefined
  .needs_a_vertical_scrollbar undefined
  .has_a_horizontal_scrollbar false
  .has_a_vertical_scrollbar false
  .is_in_plain_text_mode false
  .first_visible_column_of 1
  .first_visible_row_of 1
  .is_modal false

$std::current_cursor_x undefined
$std::current_cursor_y undefined

$BUTTON_COLOUR '@0xb0b0b0;'

$SHRINK.to_string "－"
$ENLARGE.to_string "＋"
$CLOSE.to_string "Ｘ"

$std_types::terminal/create_window_manager:
  (
    terminal
  )
  ->
    std_types::window_manager
      .template_screen_of create_screen(terminal 0 0)
      .width_of width_of(terminal)
      .height_of height_of(terminal)

$std_types::window_manager/create_window:
  (
    wm
    options*
  )
  $rc result_count()
  get_options options
    ID = undefined $window_id
    USE_CURSOR = false $use_cursor
    AS_FIRST = false $as_first
    DO_NOT_FOCUS = false $do_not_focus
    TITLE = "<untitled>" $title
    CONTENT = undefined $content
    CLEAR_COLOUR = WHITE $clear_colour
    HORIZONTAL_SCROLLBAR = true $horizontal_scrollbar
    VERTICAL_SCROLLBAR = true $vertical_scrollbar
    BUTTONS = empty_list $additional_buttons
    SIZE = DEFAULT $size
    CURSOR_X = 1 $cursor_x
    CURSOR_Y = 1 $cursor_y
    FIRST_VISIBLE_COLUMN = 1 $first_visible_column
    FIRST_VISIBLE_ROW = 1 $first_visible_row
    MODAL = false $modal
    PARENT_ID = undefined $parent_id
  update_if window_id.is_undefined &window_id &wm.next_window_id_of
    -> next_window_id_of(wm) next_window_id_of(wm)+1
  $new_window
    proto_window
      .id_of window_id
      .parent_id_of parent_id
      .size_of if(size.is_a_number (-> size) (-> undefined))
      .is_minimized size == MINIMIZED
      .cursor_x_of if(use_cursor (-> cursor_x) (-> undefined))
      .cursor_y_of if(use_cursor (-> cursor_y) (-> undefined))
      .title_of title
      .clear_colour_of clear_colour
      .content_of content
      .additional_buttons_of additional_buttons
      .has_a_horizontal_scrollbar horizontal_scrollbar
      .has_a_vertical_scrollbar vertical_scrollbar
      .first_visible_column_of first_visible_column
      .first_visible_row_of first_visible_row
      .is_modal modal
  !wm.windows_of
    if
      as_first:
	put windows_of(wm) new_window
      :
	push windows_of(wm) new_window
  $focused focused_of(wm)
  !wm
    .focused_of
      if
	do_not_focus && focused.is_defined
	-> focused
	-> window_id
    .maximized_of
      if
	size == MAXIMIZED
	-> window_id
	-> maximized_of(wm)
    .has_a_valid_layout false
    .is_up_to_date false
    .is_prepared false
  update_window_sizes &wm
  if
    rc == 2
    -> wm window_id
    -> wm

$update_window_sizes: (wm)
  $windows windows_of(wm)
  $focused focused_of(wm)
  $maximized maximized_of(wm)
  $focused_window undefined
  $maximized_window undefined
  $unminimized 0
  for_each windows
    : (window)
      $window_id id_of(window)
      update_if_not window.is_minimized || size_of(window).is_defined
	&unminimized -> unminimized+1
      update_if window_id == focused &focused_window -> window
      update_if window_id == maximized &maximized_window -> window
      next
    :
      if
	&&
	  size_of(focused_window).is_undefined
	  ||
	    unminimized == 0
	    unminimized == 1 && not(focused_window.is_minimized)
	:
	  !maximized focused
	  update_windows
	:
	  if
	    &&
	      maximized_window.is_defined
	      ||
		maximized != focused && size_of(focused_window).is_undefined
		unminimized > 0 && maximized_window.is_minimized
	    :
	      !maximized undefined
	      update_windows
	    update_windows

      $update_windows:
	map &windows
	  : (window)
	    $window_id id_of(window)
	    if
	      window_id == maximized:
		if
		  window.is_minimized
		  -> window(.buttons_of list(ENLARGE CLOSE))
		  -> window(.buttons_of list(SHRINK CLOSE))
	      :
		if
		  window.is_minimized
		  -> window(.buttons_of list(ENLARGE CLOSE))
		  -> window(.buttons_of list(ENLARGE SHRINK CLOSE))
	wm
	  .windows_of windows
	  .maximized_of maximized

$std_types::window_manager/create_dialog:
  (
    wm
    info
    content
  )
  wm
    .dialog_of tuple(content info)
    .is_up_to_date false

$std_types::window_manager/set_menu:
  (
    wm
    menus*
  )
  !wm.is_up_to_date false
  if
    length_of(menus) == 1 && menus(1).is_a_list
    -> wm(.menus_of menus(1))
    -> wm(.menus_of menus)

$std_types::window_manager/set_status:
  (
    wm
    status
  )
  !wm.is_up_to_date false
  -> wm(.status_of status)

$std_types::window_manager/set_time:
  (
    wm
    time
  )
  -> wm(.current_time_of time)

$std_types::window_manager/for_each:
  (
    wm
    body
    continuation
  )
  for_each windows_of(wm)
    : (window) body id_of(window) content_of(window)
    continuation

$std_types::window_manager/needs_updating:
  (
    wm
  )
  not wm.is_up_to_date

$std_types::window_manager/prepare_update:
  (
    wm
    terminal
  )
  if
    wm.is_up_to_date
    -> wm terminal empty_list
    :
      !wm.is_prepared true
      update_size &wm &terminal
      layout_windows &wm
      check_contents &wm
      $update_ranges empty_list
      for_each windows_of(wm)
	: (window)
	  $first_visible_row first_visible_row_of(window)
	  if
	    first_visible_row > height_of(content_of(window))
	    next
	    :
	      $content content_of(window)
	      $last_visible_row
		min
		  first_visible_row+content_height_of(window)-1
		  height_of(content)
	      push &update_ranges
		tuple
		  first_visible_row .. last_visible_row
		  id_of(window)
		  content
	      next
	-> wm terminal update_ranges

$check_contents: (wm)
  for_each windows_of(wm)
    : (idx window)
      $width content_width_of(window)
      $height content_height_of(window)
      $first_visible_column first_visible_column_of(window)
      $first_visible_row first_visible_row_of(window)
      $cursor_x cursor_x_of(window)
      $cursor_y cursor_y_of(window)
      if
	cursor_y.is_defined:
	  $delta height >> 2
	  $top_y first_visible_row+delta
	  if
	    cursor_y < top_y:
	      !first_visible_row max(cursor_y-delta 1)
	      !window.first_visible_row_of first_visible_row
	      !wm.windows_of(idx) window
	      check_column
	    :
	      $bottom_y first_visible_row+height-1-delta
	      if
		cursor_y > bottom_y && bottom_y > 0:
		  $last_y height_of(content_of(window))
		  $last_visible_row max(min(cursor_y+delta last_y) cursor_y)
		  !first_visible_row max(last_visible_row-height+1 1)
		  !window.first_visible_row_of first_visible_row
		  !wm.windows_of(idx) window
		  check_column
		check_column
	check_column

      $check_column:
	if
	  cursor_x.is_defined:
	    $delta width >> 2
	    $left_x first_visible_column+delta
	    if
	      cursor_x < left_x:
		!first_visible_column max(cursor_x-delta 1)
		!window.first_visible_column_of first_visible_column
		!wm.windows_of(idx) window
		next
	      :
		$right_x first_visible_column+width-1-delta
		if
		  cursor_x > right_x:
		    $last_x inbounds_width_of(window)
		    $last_visible_column
		      max(min(cursor_x+delta last_x) cursor_x)
		    !first_visible_column max(last_visible_column-width+1 1)
		    !window.first_visible_column_of first_visible_column
		    !wm.windows_of(idx) window
		    next
		  next
	  next
    -> wm

$std_types::window_manager/update:
  (
    wm
    terminal
  )
  if
    wm.is_up_to_date
    -> wm terminal
    :
      !wm.is_up_to_date true
      check_layout

  $check_layout:
    if
      wm.is_prepared:
	!wm.is_prepared false
	update_everything
      :
	update_size &wm &terminal
	layout_windows &wm
	check_contents &wm
	update_everything

  $update_everything:
    $windows windows_of(wm)
    if
      windows.is_empty:
	$first_y
	  if
	    menus_of(wm).is_defined || status_of(wm).is_defined
	    -> 2
	    -> 1
	set_clear_colour &terminal LIGHT_GREY
	clear &terminal 1 first_y
	  width_of(wm) height_of(wm)-(first_y-1)-message_height_of(wm)
	switch_cursor_off &terminal
	draw_messages
      :
	$focused focused_of(wm)
	$do_show_mouse_ui get_mouse_reporting(terminal) != DISABLED
	for_each windows
	  : (window)
	    $x x_of(window)
	    $y y_of(window)
	    $width content_width_of(window)
	    $height content_height_of(window)
	    $first_visible_column first_visible_column_of(window)
	    $first_visible_row first_visible_row_of(window)
	    $content content_of(window)
	    $content_width width_of(content)
	    $content_height height_of(content)
	    $is_focused id_of(window) == focused
	    set_clear_colour &terminal
	      if
		is_focused
		-> '@0x00c0c0;'
		-> '@0x70a0a0;'
	    set_draw_colour &terminal BLACK
	    set_text_attributes &terminal NORMAL
	    clear &terminal x y width+2 1
	    $additional_icons
	      map_reduce
		additional_buttons_of(window) to_string concatenate(" ")
	    $title_x x
	    if
	      additional_icons.is_defined:
		draw_text &terminal x y additional_icons
		!title_x x+width_of(additional_icons)+1
		show_title_and_icons
	      show_title_and_icons

	    $show_title_and_icons:
	      draw_text &terminal title_x y title_of(window)
	      if
		do_show_mouse_ui:
		  $right_x
		    if
		      window.needs_a_vertical_scrollbar
		      -> x+width+2
		      -> x+width
		  $icons
		    map_reduce(buttons_of(window) to_string concatenate(" "))
		  draw_text &terminal right_x-width_of(icons) y icons
		  show_contents
		show_contents

	    $show_contents:
	      if
		window.is_minimized && id_of(window) != focused
		next
		:
		  inc &y # skip title bar
		  $view create_view(terminal x y x+width-1 y+height-1)
		  set_clear_colour &view clear_colour_of(window)
		  clear view &terminal
		  if
		    content.is_a_screen:
		      copy view &terminal content
			2-first_visible_column_of(window)
			2-first_visible_row_of(window)
		      show_selection
		    : # content consists of lines that can be accessed by index
		      from_to first_visible_row first_visible_row+height-1
			: (cy)
			  if
			    cy > content_height
			    break
			    :
			      !current_cursor_x cursor_x_of(window)
			      !current_cursor_y cursor_y_of(window)
			      $source content(cy)
			      $draw_y cy+1-first_visible_row
			      copy view &terminal source
				2-first_visible_column
				draw_y
			      $rx 2-first_visible_column+width_of(source)
			      if
				rx <= width:
				  set_clear_colour &view clear_colour_of(source)
				  clear view &terminal rx draw_y undefined 1
				  next
				next
			show_selection

		  $show_selection:
		    $selection selection_of(window)
		    if
		      &&
			selection.is_defined
			not(is_in_plain_text_mode(window))
		      :
			selection $sx $sy $w $h
			draw_shadow view &terminal
			  #invert view &terminal
			  sx+1-first_visible_column_of(window)
			  sy+1-first_visible_row_of(window)
			  w
			  h
			check_cursor
		      check_cursor

		  $check_cursor:
		    if
		      ||
			current_menu_of(wm).is_defined
			dialog_of(wm).is_defined
		      :
			switch_cursor_off &terminal
			draw_scrollbars
		      :
			if
			  is_focused:
			    $cx cursor_x_of(window)
			    if
			      cx.is_defined:
				$cy cursor_y_of(window)
				set_cursor view &terminal
				  cx+1-first_visible_column_of(window)
				  cy+1-first_visible_row_of(window)
				switch_cursor_on &terminal
				draw_scrollbars
			      :
				switch_cursor_off &terminal
				draw_scrollbars
			  draw_scrollbars

	    $draw_scrollbars:
	      if
		window.needs_a_vertical_scrollbar:
		  $slider_y y
		  $slider_height height
		  draw_vertical_slider &terminal
		    x+width slider_y 2 slider_height
		    content_height height first_visible_row_of(window)
		  if
		    window.needs_a_horizontal_scrollbar:
		      set_clear_colour &terminal WHITE
		      clear &terminal x+width y+height 2 1
		      draw_horizontal_scrollbar
		    draw_horizontal_scrollbar
		draw_horizontal_scrollbar

	      $draw_horizontal_scrollbar:
		if
		  window.needs_a_horizontal_scrollbar:
		    $slider_x x
		    $slider_width width
		    $cursor_x cursor_x_of(window)
		    update_if cursor_x.is_defined && cursor_x > content_width
		      &content_width -> cursor_x
		    draw_horizontal_slider &terminal
		      slider_x y+height slider_width 1
		      content_width width first_visible_column_of(window)
		    next
		  next
	  draw_messages

  $draw_messages:
    $default_message default_message_of(wm)
    $messages messages_of(wm)
    if
      messages.is_empty:
	if
	  default_message.is_defined:
	    $h height_of(default_message)
	    $y height_of(terminal)-h+1
	    set_clear_colour &terminal clear_colour_of(default_message)
	    clear &terminal 1 y width_of(terminal) h
	    copy &terminal default_message 1 y
	    draw_menus_and_status
	  draw_menus_and_status
      :
	$message_height message_height_of(wm)
	$y height_of(terminal)-message_height+1
	for_each messages
	  : (message)
	    $screen third(message)
	    $h height_of(screen)
	    set_clear_colour &terminal clear_colour_of(screen)
	    clear &terminal 1 y width_of(terminal) h
	    copy &terminal screen 1 y
	    plus &y h
	    next
	  draw_menus_and_status

  $draw_menus_and_status:
    if
      menus_of(wm).is_defined || status_of(wm).is_defined:
	set_clear_colour &terminal VERY_LIGHT_GREY
	clear &terminal 1 1 width_of(terminal) 1
	draw_status
      draw_status

  $draw_status:
    $status status_of(wm)
    if
      status.is_defined:
	set_text_attributes &terminal NORMAL
	set_draw_colour &terminal BLACK
	draw_text &terminal width_of(terminal)-width_of(status)+1 1 status
	draw_menus
      draw_menus

  $draw_menus:
    $menus menus_of(wm)
    if
      menus.is_undefined
      draw_dialog
      :
	$x 1
	for_each menus
	  : (menu)
	    menu $title
	    set_text_attributes &terminal BOLD
	    set_draw_colour &terminal RED
	    draw_character &terminal x 1 title(1)
	    set_draw_colour &terminal BLACK
	    draw_text &terminal x+1 1 range(title 2 -1)
	    plus &x width_of(title)+1
	    next
	  :
	    $menu current_menu_of(wm)
	    if
	      menu.is_defined:
		$menu_x x_of(menu)
		$menu_y y_of(menu)
		$menu_width width_of(menu)
		$menu_height height_of(menu)
		set_clear_colour &terminal VERY_LIGHT_GREY
		set_draw_colour &terminal BLACK
		clear &terminal menu_x menu_y menu_width+4 menu_height+2
		draw_thick_border &terminal
		  menu_x menu_y
		  menu_x+menu_width+3 menu_y+menu_height+1
		copy &terminal menu menu_x+2 menu_y+1
		draw_shadow &terminal
		  menu_x+2 menu_y+menu_height+2
		  menu_width+4 1
		draw_shadow &terminal
		  menu_x+menu_width+4 menu_y+1
		  2 menu_height+1
		draw_dialog
	      draw_dialog

  $draw_dialog:
    $dialog dialog_of(wm)
    if
      dialog.is_undefined
      -> wm terminal
      :
	dialog $content
	layout_dialog wm $x $y $width $height
	set_clear_colour &terminal clear_colour_of(content)
	set_draw_colour &terminal draw_colour_of(content)
	clear &terminal x y width height
	draw_thick_border &terminal x y x+width-1 y+height-1
	copy &terminal content x+3 y+2
	draw_shadow &terminal x+2 y+height width 1
	draw_shadow &terminal x+width y+1 2 height-1
	-> wm terminal

$layout_windows: (wm)
  $windows windows_of(wm)
  $first_y undefined
  $available_height undefined

  !wm.message_height_of calc_message_height(wm)

  if
    wm.has_a_valid_layout
    -> wm
    :
      if
	windows.is_empty
	-> wm(.has_a_valid_layout true)
	:
	  !first_y
	    if
	      menus_of(wm).is_defined
	      -> 2
	      -> 1
	  !available_height height_of(wm)-message_height_of(wm)+1-first_y
	  if
	    maximized_of(wm).is_defined
	    compute_maximized_layout
	    compute_default_layout

  $compute_default_layout:
    $focused focused_of(wm)
    $index find_index(windows focused)
    $focused_window windows(index)
    $parent_id parent_id_of(focused_window)
    $width width_of(wm)
    $n
      count
	windows
	: (window)
	  not
	    ||
	      size_of(window).is_defined
	      &&
		window.is_minimized
		not
		  id_of(window) == focused || id_of(window) == parent_id
    $fixed_size_windows
      filter(windows: (window) -> size_of(window).is_defined)
    minus &available_height
      +
	map_reduce(fixed_size_windows size_of plus 0) # content height of fixed
	length_of(windows) # title bars
    $new_n n
    $new_available_height available_height
    loop
      :
	for_each windows
	  : (window)
	    if
	      &&
		size_of(window).is_undefined
		||
		  not(window.is_minimized)
		  id_of(window) == focused || id_of(window) == parent_id
	      :
		$content content_of(window)
		$content_height height_of(content)
		update_if width_of(content) > width_of(wm)
		  &content_height -> content_height+1
		if
		  n*content_height <= available_height:
		    dec &new_n
		    minus &new_available_height content_height
		    next
		  next
	      next
	  :
	    if
	      new_n > 0:
		!n new_n
		!available_height new_available_height
		layout_variable_sized_windows true
	      :
		layout_variable_sized_windows false

    $layout_variable_sized_windows: (do_shrink)
      $iter bresenham_delta(n available_height)
      $y first_y
      $updated_windows empty_list
      for_each windows
	: (window)
	  !window
	    .x_of 1
	    .y_of y
	    .width_of width
	  cond
	    ->
	      &&
		window.is_minimized
		id_of(window) != focused && id_of(window) != parent_id
	      :
		push &updated_windows
		  window
		    .height_of 1
		    .content_width_of width
		    .content_height_of 0
		    .needs_a_horizontal_scrollbar false
		    .needs_a_vertical_scrollbar false
		inc &y
		next
	    -> size_of(window).is_defined:
	      $height size_of(window)+1
	      push &updated_windows
		window
		  .content_width_of width
		  .height_of height
		  .content_height_of size_of(window)
		  .needs_a_horizontal_scrollbar false
		  .needs_a_vertical_scrollbar false
	      plus &y height
	      next
	    -> true:
	      $content content_of(window)
	      $content_height height_of(content)
	      update_if width_of(content) > width_of(wm)
		&content_height -> content_height+1
	      if
		do_shrink && n*content_height <= available_height:
		  layout_variable_sized_window content_height
		:
		  next_value &iter $height
		  layout_variable_sized_window height

	      $layout_variable_sized_window: (height)
		inc &height # title bar
		!window.height_of height
		maybe_add_scrollbars &window
		push &updated_windows window
		plus &y height
		next
	->
	  wm
	    .windows_of updated_windows
	    .has_a_valid_layout true

  $compute_maximized_layout:
    # show one window maximized, all others minimized
    $maximized maximized_of(wm)
    $fixed_size_windows filter(windows: (window) -> size_of(window).is_defined)
    minus &available_height map_reduce(fixed_size_windows size_of plus 0)
    $updated_windows empty_list
    $y first_y
    for_each windows
      : (idx window)
	if
	  id_of(window) == maximized:
	    !window
	      .x_of 1
	      .y_of idx+first_y-1
	      .width_of width_of(wm)
	      .height_of 1+available_height-length_of(windows)
	    maybe_add_scrollbars &window
	    push &updated_windows window
	    plus &y height_of(window)
	    next
	  :
	    $height
	      if
		size_of(window).is_defined
		-> size_of(window)
		-> 0
	    push &updated_windows
	      window
		.x_of 1
		.y_of y
		.width_of width_of(wm)
		.height_of 1+height
		.content_width_of width_of(wm)
		.content_height_of height
		.needs_a_horizontal_scrollbar false
		.needs_a_vertical_scrollbar false
	    plus &y 1+height
	    next
      ->
	wm
	  .windows_of updated_windows
	  .has_a_valid_layout true

$maybe_add_scrollbars: (window)
  $width width_of(window)
  $content_height height_of(window)-1
  $content content_of(window)
  $max_x width_of(content)
  $max_y height_of(content)
  $cursor_x cursor_x_of(window)
  $cursor_y cursor_y_of(window)
  update_if cursor_x.is_defined && cursor_x > max_x
    &max_x -> cursor_x
  update_if cursor_y.is_defined && cursor_y > max_y
    &max_y -> cursor_y
  $do_show_horizontal_scrollbar
    window.has_a_horizontal_scrollbar && max_x > width
  update_if do_show_horizontal_scrollbar &content_height -> content_height-1
  $do_show_vertical_scrollbar
    &&
      window.has_a_vertical_scrollbar
      max_y > content_height
      not(window.is_in_plain_text_mode)
  update_if do_show_vertical_scrollbar
    &width -> width-2
  # recompute horizontal scrollbar necessity
  update_if not(do_show_horizontal_scrollbar) && max_x > width
    &do_show_horizontal_scrollbar &content_height -> true content_height-1
  window
    .content_width_of width
    .content_height_of content_height
    .first_visible_column_of
      min(first_visible_column_of(window) max(1 max_x-width+1))
    .first_visible_row_of
      min(first_visible_row_of(window) max(1 max_y-content_height+1))
    .needs_a_horizontal_scrollbar do_show_horizontal_scrollbar
    .needs_a_vertical_scrollbar do_show_vertical_scrollbar

$layout_dialog: (wm)
  $dialog dialog_of(wm)
  dialog $content
  $width width_of(content)+6
  $height height_of(content)+4
  $x 1+(width_of(wm)-width .div. 2)
  $y 1+(height_of(wm)-height .div. 2)
  -> x y width height

$calc_message_height: (wm)
  $default_message default_message_of(wm)
  $messages messages_of(wm)
  ->
    if
      messages.is_empty:
	if
	  default_message.is_defined
	  -> height_of(default_message)
	  -> 0
      :
	map_reduce
	  messages: (message) -> height_of(third(message))
	  plus

$horizontal_partial_blocks list('▏' '▎' '▍' '▌' '▋' '▊' '▉')
$vertical_partial_blocks list('▇' '▆' '▅' '▄' '▃' '▂' '▁')

$std_types::terminal/draw_vertical_slider:
  (
    self
    x
    y
    width
    height
    total # the number of total items
    current # the number of currently visible items
    pos # the index of the first visible item (one-based)
  )
  $bar_size 8*height
  $slider_size max(8 8*height*current .div. total)
  if
    $top $bottom
    total == current
    -> 0 slider_size
    :
      $n total-current
      $m bar_size-slider_size
      $t round((pos-1)*m/n).to_integer
      update_if t == 0 && pos != 1 &t -> 1
      update_if t == m && pos-1 != n &t -> m-1
      -> t t+slider_size
  set_clear_colour &self VERY_LIGHT_GREY
  clear &self x y width height
  if
    (top .mod. 8) == 0
    draw_middle
    :
      set_draw_colour &self BUTTON_COLOUR
      draw_text &self x y+(top .div. 8)
	dup(vertical_partial_blocks(top .mod. 8).to_string width)
      draw_middle

  $draw_middle:
    set_clear_colour &self BUTTON_COLOUR
    $top_y top+7 .div. 8
    $bottom_y bottom .div. 8
    clear &self x y+top_y width bottom_y-top_y
    if
      (bottom .mod. 8) == 0
      -> self
      :
	set_clear_colour &self BUTTON_COLOUR
	set_draw_colour &self VERY_LIGHT_GREY
	draw_text self x y+bottom_y
	  dup(vertical_partial_blocks(bottom .mod. 8).to_string width)

$std_types::terminal/draw_horizontal_slider:
  (
    self
    x
    y
    width
    height
    total # the number of total items
    current # the number of currently visible items
    pos # the index of the first visible item (one-based)
  )
  $n total-current
  $bar_size 8*width
  $slider_size max(8 8*width*current .div. total)
  $m bar_size-slider_size
  $left round((pos-1)*m/n).to_integer
  update_if left == 0 && pos != 1 &left -> 2
  update_if left == m && pos-1 != n &left -> m-1
  $right left+slider_size
  set_clear_colour &self VERY_LIGHT_GREY
  clear &self x y width height
  if
    (left .mod. 8) == 0
    draw_middle
    :
      set_clear_colour &self BUTTON_COLOUR
      set_draw_colour &self VERY_LIGHT_GREY
      from_to y y+height-1
	: (cy)
	  draw_character &self x+(left .div. 8) cy
	    horizontal_partial_blocks(left .mod. 8)
	  next
	draw_middle

  $draw_middle:
    set_clear_colour &self BUTTON_COLOUR
    $left_x left+7 .div. 8
    $right_x right .div. 8
    clear &self x+left_x y right_x-left_x height
    if
      (right .mod. 8) == 0
      -> self
      :
	set_clear_colour &self VERY_LIGHT_GREY
	set_draw_colour &self BUTTON_COLOUR
	from_to y y+height-1
	  : (cy)
	    draw_character &self x+right_x cy
	      horizontal_partial_blocks(right .mod. 8)
	    next
	  -> self

$std_types::window_manager/move_left:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $first_visible_column first_visible_column_of(window)
      $cursor_x cursor_x_of(window)
      if
	cursor_x.is_defined:
	  if
	    cursor_x <= 1
	    -> wm
	    :
	      !window.cursor_x_of cursor_x-1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	:
	  if
	    first_visible_column > 1:
	      !window.first_visible_column_of first_visible_column-1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	    -> wm
    -> wm

$std_types::window_manager/move_right:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $content content_of(window)
      $content_width width_of(content)
      $window_width content_width_of(window)
      $first_visible_column first_visible_column_of(window)
      $cursor_x cursor_x_of(window)
      $inbounds_width inbounds_width_of(window)
      if
	cursor_x.is_defined:
	  $max_x max(content_width inbounds_width)+10
	  if
	    cursor_x < max_x:
	      !window.cursor_x_of cursor_x+1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false             :
	    -> wm
	:
	  if
	    first_visible_column+window_width <= content_width:
	      !window.first_visible_column_of first_visible_column+1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	    -> wm
    -> wm

$std_types::window_manager/move_up:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $first_visible_row first_visible_row_of(window)
      $cursor_y cursor_y_of(window)
      if
	cursor_y.is_defined:
	  if
	    cursor_y <= 1
	    -> wm
	    :
	      !window.cursor_y_of cursor_y-1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	:
	  if
	    first_visible_row > 1:
	      !window.first_visible_row_of first_visible_row-1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	    -> wm
    -> wm

$std_types::window_manager/move_page_up:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $first_visible_row first_visible_row_of(window)
      $window_height content_height_of(window)
      $cursor_y cursor_y_of(window)
      if
	cursor_y.is_defined:
	  if
	    cursor_y <= 1
	    -> wm
	    :
	      !window.cursor_y_of max(1 cursor_y-window_height)
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	:
	  if
	    first_visible_row > 1:
	      $new_first_visible_row max(1 first_visible_row-window_height)
	      !window.first_visible_row_of new_first_visible_row
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	    -> wm
    -> wm

$std_types::window_manager/move_down:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $content content_of(window)
      $content_height height_of(content)
      $window_height content_height_of(window)
      $first_visible_row first_visible_row_of(window)
      $cursor_y cursor_y_of(window)
      if
	cursor_y.is_defined:
	  if
	    cursor_y >= content_height
	    -> wm
	    :
	      !window.cursor_y_of cursor_y+1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	:
	  if
	    first_visible_row+window_height <= content_height:
	      !window.first_visible_row_of first_visible_row+1
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	    -> wm
    -> wm

$std_types::window_manager/move_page_down:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $content content_of(window)
      $content_height height_of(content)
      $window_height content_height_of(window)
      $first_visible_row first_visible_row_of(window)
      $cursor_y cursor_y_of(window)
      if
	cursor_y.is_defined:
	  if
	    cursor_y >= content_height
	    -> wm
	    :
	      !window.cursor_y_of min(content_height cursor_y+window_height)
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	:
	  if
	    first_visible_row+window_height <= content_height:
	      $new_first_visible_row
		min
		  content_height+1-window_height
		  first_visible_row+window_height
	      !window.first_visible_row_of new_first_visible_row
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	    -> wm
    -> wm

$std_types::window_manager/move_home:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      !window.first_visible_column_of 1
      update_if cursor_x_of(window).is_defined &window.cursor_x_of -> 1
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/move_end:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $content content_of(window)
      $content_width width_of(content)
      $window_width content_width_of(window)
      if
	cursor_x_of(window).is_defined:
	  if
	    content.is_a_screen:
	      set_x content_width+1
	    :
	      set_x width_of(content(cursor_y_of(window)))+1

	  $set_x: (x)
	    !window.cursor_x_of x
	    wm
	      .windows_of windows(index window)
	      .is_up_to_date false
	:
	  !window.first_visible_column_of content_width-window_width+1
	  wm
	    .windows_of windows(index window)
	    .is_up_to_date false
    -> wm

$std_types::window_manager/move_top:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      !window.first_visible_row_of 1
      update_if cursor_y_of(window).is_defined &window.cursor_y_of -> 1
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/move_bottom:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $content content_of(window)
      $content_height height_of(content)
      $window_height content_height_of(window)
      if
	cursor_y_of(window).is_defined:
	  !window.cursor_y_of content_height
	  wm
	    .windows_of windows(index window)
	    .is_up_to_date false
	:
	  !window.first_visible_row_of content_height-window_height+1
	  wm
	    .windows_of windows(index window)
	    .is_up_to_date false
    -> wm

$std_types::window_manager/goto_xy:
  (
    wm
    id = undefined
    x
    y
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      if
	cursor_y_of(window).is_defined:
	  $content content_of(window)
	  $content_width width_of(content)
	  $content_height height_of(content)
	  $inbounds_width inbounds_width_of(window)
	  $max_x max(content_width inbounds_width)+10
	  $max_y content_height+10
	  min &x max_x
	  min &y max_y
	  if
	    x == cursor_x_of(window) && y == cursor_y_of(window)
	    -> wm
	    :
	      !window
		.cursor_x_of x
		.cursor_y_of y
	      wm
		.windows_of windows(index window)
		.is_up_to_date false
	-> wm
    -> wm

$std_types::window_manager/get_xy:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      -> cursor_x_of(window) cursor_y_of(window)
    -> undefined undefined

$std_types::window_manager/get_size:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      -> content_width_of(window) content_height_of(window)
    -> undefined undefined

$find_index: (windows id)
  if
    id.is_undefined
    -> undefined
    :
      for_each windows
	: (idx window)
	  if
	    id_of(window) == id
	    -> idx
	    next
	-> undefined

$std_types::window_manager/focus_next_window:
  (
    wm
  )
  $focused focused_of(wm)
  $windows windows_of(wm)
  for_each windows
    : (idx window)
      if
	id_of(window) == focused:
	  if
	    idx == length_of(windows)
	    -> wm
	    -> focus_window(wm id_of(windows(idx+1)))
	next
    -> wm # should never be reached

$std_types::window_manager/focus_previous_window:
  (
    wm
  )
  $focused focused_of(wm)
  $windows windows_of(wm)
  for_each windows
    : (idx window)
      if
	id_of(window) == focused:
	  if
	    idx == 1
	    -> wm
	    -> focus_window(wm id_of(windows(idx-1)))
	next
    -> wm # should never be reached

$std_types::window_manager/focus_window:
  (
    wm
    id
  )
  if
    focused_of(wm) == id
    -> wm
    :
      for_each windows_of(wm)
	: (window)
	  if
	    id_of(window) == id:
	      update_window_sizes
		wm
		  .focused_of id
		  .is_up_to_date false
		  .has_a_valid_layout false
	    next
	-> wm # no such window

$std_types::window_manager/move_window_down:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  if
    length_of(windows) > 1:
      for_each windows
	: (idx window)
	  if
	    id_of(window) == id:
	      if
		idx == length_of(windows)
		-> wm
		:
		  $next_idx idx+1
		  $next_window windows(next_idx)
		  !windows(next_idx) window
		  !windows(idx) next_window
		  update_window_sizes
		    wm
		      .windows_of windows
		      .is_up_to_date false
		      .has_a_valid_layout false
	    next
	-> wm
    -> wm

$std_types::window_manager/move_window_up:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  if
    length_of(windows) > 1:
      for_each windows
	: (idx window)
	  if
	    id_of(window) == id:
	      if
		idx == 1
		-> wm
		:
		  $prev_idx idx-1
		  $prev_window windows(prev_idx)
		  !windows(prev_idx) window
		  !windows(idx) prev_window
		  update_window_sizes
		    wm
		      .windows_of windows
		      .is_up_to_date false
		      .has_a_valid_layout false
	    next
	-> wm
    -> wm

$std_types::window_manager/close:
  (
    wm
    id = undefined
  )
  $focused focused_of(wm)
  update_if id.is_undefined &id -> focused
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $parent_id parent_id_of(windows(index))
      !windows append(range(windows 1 index-1) range(windows index+1 -1))
      !wm.has_a_valid_layout false
      if
	windows.is_empty
	->
	  wm
	    .windows_of windows
	    .focused_of undefined
	    .is_up_to_date false
	:
	  min &index length_of(windows)
	  update_if id == focused &wm.focused_of:
	    if
	      &&
		parent_id.is_defined
		any_of
		  windows: (window) -> id_of(window) == parent_id
	      -> parent_id
	      -> id_of(windows(index))
	  update_window_sizes
	    wm
	      .windows_of windows
	      .has_a_valid_layout false
	      .is_up_to_date false
    -> wm

$std_types::window_manager/shrink:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      if
	window.is_minimized
	-> wm
	:
	  !windows(index).is_minimized true
	  update_window_sizes
	    wm
	      .windows_of windows
	      .has_a_valid_layout false
	      .is_up_to_date false
    -> wm

$std_types::window_manager/enlarge:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      if
	window.is_minimized:
	  !windows(index).is_minimized false
	  update_if maximized_of(wm) != id_of(window)
	    &wm.maximized_of -> undefined
	  update_window_sizes
	    wm
	      .windows_of windows
	      .has_a_valid_layout false
	      .is_up_to_date false
	:
	  update_window_sizes
	    wm
	      .focused_of id
	      .maximized_of id
	      .has_a_valid_layout false
	      .is_up_to_date false
    -> wm

$std_types::window_manager/window_count_of:
  (
    wm
  )
  -> length_of(windows_of(wm))

$std_types::window_manager/set_title:
  (
    wm
    id = undefined
    title
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      !window.title_of title
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/get_title:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      -> title_of(window)
    -> undefined

$std_types::window_manager/set_buttons:
  (
    wm
    id = undefined
    buttons
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      !window.additional_buttons_of buttons
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/get_buttons:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      -> additional_buttons_of(window)
    -> undefined

$std_types::window_manager/set_content:
  (
    wm
    id = undefined
    content
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $old_content_height
	if
	  content_of(window).is_defined
	  -> height_of(content_of(window))
	  -> 0
      $new_content_height height_of(content)
      update_if new_content_height != old_content_height &wm.has_a_valid_layout
	-> false
      !window.content_of content
      if
	height_of(window).is_defined && height_of(window) > 1:
	  maybe_add_scrollbars &window
	  return
	return

      $return:
	wm
	  .windows_of windows(index window)
	  .is_up_to_date false
    -> wm

$std_types::window_manager/get_content:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      -> content_of(windows(index))
    -> undefined

$std_types::window_manager/set_inbounds_width:
  (
    wm
    id = undefined
    width
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined
    -> wm(.windows_of windows(index windows(index)(.inbounds_width_of width)))
    -> wm

$std_types::window_manager/get_inbounds_width:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined
    -> inbounds_width_of(windows(index))
    -> undefined

$std_types::window_manager/set_plain_text_mode:
  (
    wm
    id = undefined
    mode
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      !window.is_in_plain_text_mode mode
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/set_selection:
  (
    wm
    id = undefined
    x
    y
    w
    h
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      $first_visible_column first_visible_column_of(window)
      $first_visible_row first_visible_row_of(window)
      $window_width content_width_of(window)
      $window_height content_height_of(window)
      $new_first_visible_column first_visible_column
      $new_first_visible_row first_visible_row
      update_if x < first_visible_column &new_first_visible_column -> x
      update_if x+w > first_visible_column+window_width
	&new_first_visible_column -> x+w-window_width
      update_if y < first_visible_row &new_first_visible_row -> y
      update_if y+h > first_visible_row+window_height
	&new_first_visible_row -> y+h-window_height
      !window
	.selection_of tuple(x y w h)
	.first_visible_column_of new_first_visible_column
	.first_visible_row_of new_first_visible_row
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/unset_selection:
  (
    wm
    id = undefined
  )
  update_if id.is_undefined &id -> focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  if
    index.is_defined:
      $window windows(index)
      !window.selection_of undefined
      wm
	.windows_of windows(index window)
	.is_up_to_date false
    -> wm

$std_types::window_manager/resize:
  (
    wm
    width
    height
  )
  wm
    .width_of width
    .height_of height
    .has_a_valid_layout false
    .has_a_new_size true
    .is_up_to_date false

$update_size: (wm terminal)
  if
    wm.has_a_new_size
    ->
      wm(.has_a_new_size false)
      resize(terminal width_of(wm) height_of(wm))
    ->
      wm
	.width_of width_of(terminal)
	.height_of height_of(terminal)
      terminal

$std_types::window_manager/get_id:
  (
    wm
  )
  -> focused_of(wm)

$std_types::window_manager/get_focused_window:
  (
    wm
  )
  $id focused_of(wm)
  $windows windows_of(wm)
  $index find_index(windows id)
  $window windows(index)
  -> id content_of(window)

$std_types::window_manager/get_window_at:
  (
    wm
    x
    y
  )
  $windows windows_of(wm)
  for_each windows
    : (window)
      $win_x x_of(window)
      $win_y y_of(window)+1
      $win_w content_width_of(window)
      $win_h content_height_of(window)
      if
	x >= win_x && x < win_x+win_w && y >= win_y && y < win_y+win_h
	->
	  id_of(window)
	  content_of(window)
	  first_visible_column_of(window)+x-win_x
	  first_visible_row_of(window)+y-win_y
	next
    -> undefined undefined undefined undefined

$std_types::window_manager/set_default_message:
  (
    wm
    screen
  )
  wm
    .default_message_of screen
    .has_a_valid_layout false
    .is_up_to_date false

$std_types::window_manager/show_message:
  (
    wm
    id = undefined
    timeout = 5
    screen
  )
  if
    id.is_defined:
      filter &wm.messages_of: (message) -> first(message) != id
      push_message
    push_message

  $push_message:
    push &wm.messages_of tuple(id current_time_of(wm)+timeout screen)
    wm
      .has_a_valid_layout false
      .is_up_to_date false

$std_types::window_manager/remove_message:
  (
    wm
    id
  )
  $messages messages_of(wm)
  $n length_of(messages)
  filter &messages: (message) -> first(message) != id
  if
    length_of(messages) == n
    -> wm
    ->
      wm
	.messages_of messages
	.has_a_valid_layout false
	.is_up_to_date false

$std_types::window_manager/handle_event:
  #
    events effecting the window manager as a whole
  (
    wm
    event
    wm_fd
  )
  $old_focused focused_of(wm)
  event $type $fd $argument
  if
    fd == wm_fd:
      case type
	MOUSE_CLICK:
	  argument $x $y $button
	  if
	    button == 0:
	      handle_mouse_click &wm $new_event wm_fd x y
	      return new_event
	    :
	      return undefined
	KEY_PRESS:
	  handle_key_press &wm $new_event wm_fd argument
	  return new_event
	NEW_WINDOW_SIZE:
	  argument $width $height
	  resize &wm width height
	  -> wm undefined
	-> wm event
    -> wm event

  $return: (new_event)
    remove_outdated_messages &wm
    if
      new_event.is_defined:
	if
	  new_event.is_a_tuple
	  -> wm new_event # changed event
	  :
	    if
	      focused_of(wm) == old_focused
	      -> wm undefined # consumed event
	      -> wm tuple(FOCUS_CHANGED wm_fd focused_of(wm))
      -> wm event # kept event

$handle_mouse_click: (wm fd mouse_x mouse_y)
  $dialog dialog_of(wm)
  if
    dialog.is_defined:
      dialog $content $info
      layout_dialog wm $dialog_x $dialog_y $_dialog_width $_dialog_height
      $rect get_rectangle_at(content mouse_x-dialog_x-2 mouse_y-dialog_y-1)
      if
	rect.is_defined:
	  !wm.dialog_of undefined
	  rect $action
	  action $_shortcut $key
	  -> wm(.is_up_to_date false) tuple(KEY_PRESS fd key info)
	-> wm true
    :
      $menus menus_of(wm)
      if
	menus.is_defined && mouse_y == 1:
	  $x 1
	  for_each menus
	    : (idx menu)
	      menu $title $content
	      if
		mouse_x < x
		-> wm true
		:
		  $width width_of(title)
		  if
		    mouse_x < x+width:
		      if
			current_menu_index_of(wm) == idx:
			  !wm
			    .current_menu_index_of undefined
			    .current_menu_of undefined
			    .is_up_to_date false
			  -> wm true
			:
			  !wm
			    .current_menu_index_of idx
			    .current_menu_of create_menu(wm x 2 content)
			    .is_up_to_date false
			  -> wm true
		    :
		      plus &x width+1
		      next
	    -> wm true
	:
	  $menu current_menu_of(wm)
	  if
	    menu.is_defined:
	      $x x_of(menu)
	      $y y_of(menu)
	      $width width_of(menu)
	      $height height_of(menu)
	      if
		||
		  mouse_x <= x
		  mouse_x > x+width+2
		  mouse_y <= y
		  mouse_y > y+height
		:
		  !wm
		    .current_menu_index_of undefined
		    .current_menu_of undefined
		    .is_up_to_date false
		  handle_windows
		:
		  $rect get_rectangle_at(menu 1 mouse_y-y)
		  if
		    rect.is_defined:
		      !wm
			.current_menu_index_of undefined
			.current_menu_of undefined
			.is_up_to_date false
		      rect $action
		      action $_shortcut $key
		      -> wm tuple(KEY_PRESS fd key)
		    -> wm true
	    handle_windows

  $handle_windows:
    $windows windows_of(wm)
    for_each windows
      : (idx window)
	$window_id id_of(window)
	$window_x x_of(window)
	$window_y y_of(window)
	$window_width width_of(window)
	$window_height height_of(window)
	if
	  &&
	    mouse_x >= window_x && mouse_x < window_x+window_width
	    mouse_y >= window_y && mouse_y < window_y+window_height
	  :
	    if
	      &&
		mouse_y == window_y
		mouse_x >= window_x && mouse_x <= window_width
	      :
		$buttons buttons_of(window)
		$bx window_x+window_width+1-3*length_of(buttons)
		for_each buttons
		  : (button)
		    if
		      mouse_x >= bx && mouse_x < bx+2:
			case button
			  SHRINK:
			    shrink &wm window_id
			    -> wm true
			  ENLARGE:
			    enlarge &wm window_id
			    -> wm true
			  -> wm tuple(KEY_PRESS fd button window_id)
		      :
			plus &bx 3
			next
		  :
		    focus_window &wm window_id
		    $additional_buttons additional_buttons_of(window)
		    $abx window_x
		    for_each additional_buttons
		      : (button)
			$button_width width_of(button.to_string)
			if
			  mouse_x >= abx && mouse_x < abx+button_width
			  -> wm tuple(KEY_PRESS fd button)
			  :
			    plus &abx button_width+1
			    next
		      -> wm true
	      :
		focus_window &wm window_id
		$content_y window_y+1
		cond
		  ->
		    &&
		      window.needs_a_vertical_scrollbar
		      mouse_x >= window_x+window_width-2
		      mouse_x < window_x+window_width
		      mouse_y >= content_y && mouse_y < content_y+window_height
		    :
		      minus &mouse_y content_y
		      $content content_of(window)
		      $content_height height_of(content)
		      $scrollbar_height
			if
			  window.needs_a_horizontal_scrollbar
			  -> window_height-2
			  -> window_height-1
		      if
			cursor_y_of(window).is_defined:
			  !window.cursor_y_of
			    +
			      1
			      to_integer
				round
				  (mouse_y*content_height)/(scrollbar_height-1)
			  !wm
			    .windows_of windows(idx window)
			    .is_up_to_date false
			  -> wm true
			:
			  !window.first_visible_row_of
			    +
			      1
			      to_integer
				round
				  /
				    mouse_y*(content_height-scrollbar_height)
				    scrollbar_height-1
			  !wm
			    .windows_of windows(idx window)
			    .is_up_to_date false
			  -> wm true
		  ->
		    &&
		      window.needs_a_horizontal_scrollbar
		      mouse_x >= window_x && mouse_x < window_x+window_width-2
		      mouse_y == window_y+window_height-1
		    :
		      minus &mouse_x window_x
		      $content content_of(window)
		      $content_width width_of(content)
		      $scrollbar_width
			if
			  window.needs_a_vertical_scrollbar
			  -> window_width-2
			  -> window_width
		      if
			cursor_x_of(window).is_defined:
			  !window.cursor_x_of
			    +
			      1
			      to_integer
				round
				  (mouse_x*content_width)/(scrollbar_width-1)
			  !wm
			    .windows_of windows(idx window)
			    .is_up_to_date false
			  -> wm true
			:
			  !window.first_visible_column_of
			    +
			      1
			      to_integer
				round
				  /
				    mouse_x*(content_width-scrollbar_width)
				    scrollbar_width-1
			  !wm
			    .windows_of windows(idx window)
			    .is_up_to_date false
			  -> wm true
		  -> true:
		    -> wm undefined
	  next
      -> wm undefined

$handle_key_press: (wm fd key)
  $dialog dialog_of(wm)
  if
    dialog.is_defined:
      dialog $content $info
      $rect get_rectangle_by_key(content key)
      if
	rect.is_defined:
	  !wm
	    .dialog_of undefined
	    .is_up_to_date false
	  rect $_kind $action
	  action $_shortcut $action_key
	  -> wm tuple(KEY_PRESS fd action_key info)
	-> wm true
    :
      $menus menus_of(wm)
      if
	menus.is_defined:
	  $x 1
	  for_each menus
	    : (idx menu)
	      menu $title $content
	      $shortcut alt_key(title(1).to_lower_case)
	      if
		shortcut == key:
		  !wm
		    .current_menu_index_of idx
		    .current_menu_of create_menu(wm x 2 content)
		    .is_up_to_date false
		  -> wm true
		:
		  plus &x width_of(title)+1
		  next
	    handle_current_menu
	handle_current_menu

  $handle_current_menu:
    $menu current_menu_of(wm)
    if
      menu.is_defined:
	if
	  key == ESCAPE:
	    !wm
	      .current_menu_index_of undefined
	      .current_menu_of undefined
	      .is_up_to_date false
	    -> wm true
	  :
	    $rect get_rectangle_by_key(menu key)
	    if
	      rect.is_defined:
		!wm
		  .current_menu_index_of undefined
		  .current_menu_of undefined
		  .is_up_to_date false
		rect $_kind $action
		action $_shortcut $action_key
		-> wm tuple(KEY_PRESS fd action_key)
	      handle_windows
      handle_windows

  $handle_windows:
    case key
      CTRL_PAGE_DOWN:
	focus_next_window &wm
	-> wm true
      CTRL_PAGE_UP:
	focus_previous_window &wm
	-> wm true
      CTRL_F11:
	enlarge &wm
	-> wm true
      CTRL_F12:
	shrink &wm
	-> wm true
      -> wm undefined

$std_types::window_manager/handle_window_event:
  #
    events effecting a window's contents
  (
    wm
    event
    wm_fd
  )
  event $type $fd $key
  if
    fd == wm_fd && type == KEY_PRESS:
      case key
	CURSOR_LEFT:
	  move_left &wm
	  -> wm undefined
	CURSOR_RIGHT:
	  move_right &wm
	  -> wm undefined
	CURSOR_UP:
	  move_up &wm
	  -> wm undefined
	CURSOR_DOWN:
	  move_down &wm
	  -> wm undefined
	PAGE_UP:
	  move_page_up &wm
	  -> wm undefined
	PAGE_DOWN:
	  move_page_down &wm
	  -> wm undefined
	HOME:
	  move_home &wm
	  -> wm undefined
	END:
	  move_end &wm
	  -> wm undefined
	CTRL_HOME:
	  move_top &wm
	  -> wm undefined
	CTRL_END:
	  move_bottom &wm
	  -> wm undefined
	-> wm event
    -> wm event

$create_menu: (wm x y content)
  $width
    map_reduce
      content
      : (item)
	item $label
	-> width_of(label)
      max
  $shortcuts ""
  $shortcut_positions empty_list
  for_each content
    : (item)
      item $label
      $word_start_shortcut undefined
      $word_start_position undefined
      $shortcut undefined
      $position undefined
      for_each label
	: (idx chr)
	  to_lower_case &chr
	  if
	    shortcuts .contains. chr
	    next
	    :
	      if
		idx == 1 || label(idx-1) == ' ':
		  !word_start_shortcut chr
		  !word_start_position idx
		  break
		:
		  if
		    shortcut.is_undefined:
		      !shortcut chr
		      !position idx
		      next
		    next
	:
	  if
	    word_start_shortcut.is_defined:
	      push &shortcuts word_start_shortcut
	      push &shortcut_positions word_start_position
	      next
	    :
	      if
		shortcut.is_defined:
		  push &shortcuts shortcut
		  push &shortcut_positions position
		  next
		:
		  push &shortcuts '@nul;'
		  push &shortcut_positions undefined
		  next
    :
      $menu
	map_reduce
	  content
	  : (idx item)
	    item $label $action_key
	    $screen
	      create_text_screen
		template_screen_of(wm)
		  .clear_colour_of VERY_LIGHT_GREY
		  .draw_colour_of BLACK
		  .text_attributes_of BOLD
		label
		tuple(label(1).to_lower_case action_key)
	    set_draw_colour &screen RED
	    $pos shortcut_positions(idx)
	    draw_character &screen pos 1 label(pos)
	    pad_right screen width
      menu
	.x_of x
	.y_of y

$remove_outdated_messages: (wm)
  $messages messages_of(wm)
  $remaining_messages empty_list
  for_each messages
    : (message)
      message $_id $time
      if
	time > current_time_of(wm):
	  push &remaining_messages message
	  next
	:
	  !wm
	    .has_a_valid_layout false
	    .is_up_to_date false
	  next
    -> wm(.messages_of remaining_messages)
