// This file is automatically generated by "builtins.sim"; do not edit manually!

#define _GNU_SOURCE
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <inttypes.h>
#include <limits.h>
#include <unistd.h>
#include <math.h>
#include <pwd.h>
#include <time.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <netinet/in.h>
#ifndef __CYGWIN__
  #include <ifaddrs.h>
  #include <arpa/inet.h>
  #include <netpacket/packet.h>
#endif
#include <netdb.h>
#include <dirent.h>

#include "common.h"
#include "builtins.h"
#include "fko.h"
#include "linker.h"
#include "memory.h"
#include "interpreter.h"

enum {
  func__std_types___array___std___length_of = 1,
  func__std_types___array___std___dimension_count_of,
  func__std___array,
  func__std___initialized_array,
  func__std_types___array___std___new,
  func__std_types___array___std___range,
  func__std_types___boolean_array___std___length_of,
  func__std_types___boolean_array___std___dimension_count_of,
  func__std_types___boolean_array___std___equal,
  func__std_types___boolean_array___std___bit_and,
  func__std_types___boolean_array___std___bit_or,
  func__std_types___boolean_array___std___bit_xor,
  func__std___boolean_array,
  func__std___initialized_boolean_array,
  func__std_types___boolean_array___std___new,
  func__std_types___boolean_array___std___range,
  func__std_types___character_array___std___length_of,
  func__std_types___character_array___std___dimension_count_of,
  func__std_types___character_array___std___equal,
  func__std___character_array,
  func__std___initialized_character_array,
  func__std_types___character_array___std___new,
  func__std_types___character_array___std___range,
  func__std_types___int8_array___std___length_of,
  func__std_types___int8_array___std___dimension_count_of,
  func__std_types___int8_array___std___equal,
  func__std_types___int8_array___std___times,
  func__std___int8_array,
  func__std___initialized_int8_array,
  func__std_types___int8_array___std___new,
  func__std_types___int8_array___std___range,
  func__std_types___uint8_array___std___length_of,
  func__std_types___uint8_array___std___dimension_count_of,
  func__std_types___uint8_array___std___equal,
  func__std_types___uint8_array___std___bit_and,
  func__std_types___uint8_array___std___bit_or,
  func__std_types___uint8_array___std___bit_xor,
  func__std_types___uint8_array___std___times,
  func__std___uint8_array,
  func__std___initialized_uint8_array,
  func__std_types___uint8_array___std___new,
  func__std_types___uint8_array___std___range,
  func__std_types___int16_array___std___length_of,
  func__std_types___int16_array___std___dimension_count_of,
  func__std_types___int16_array___std___equal,
  func__std_types___int16_array___std___times,
  func__std___int16_array,
  func__std___initialized_int16_array,
  func__std_types___int16_array___std___new,
  func__std_types___int16_array___std___range,
  func__std_types___uint16_array___std___length_of,
  func__std_types___uint16_array___std___dimension_count_of,
  func__std_types___uint16_array___std___equal,
  func__std_types___uint16_array___std___bit_and,
  func__std_types___uint16_array___std___bit_or,
  func__std_types___uint16_array___std___bit_xor,
  func__std_types___uint16_array___std___times,
  func__std___uint16_array,
  func__std___initialized_uint16_array,
  func__std_types___uint16_array___std___new,
  func__std_types___uint16_array___std___range,
  func__std_types___int32_array___std___length_of,
  func__std_types___int32_array___std___dimension_count_of,
  func__std_types___int32_array___std___equal,
  func__std_types___int32_array___std___times,
  func__std___int32_array,
  func__std___initialized_int32_array,
  func__std_types___int32_array___std___new,
  func__std_types___int32_array___std___range,
  func__std_types___uint32_array___std___length_of,
  func__std_types___uint32_array___std___dimension_count_of,
  func__std_types___uint32_array___std___equal,
  func__std_types___uint32_array___std___bit_and,
  func__std_types___uint32_array___std___bit_or,
  func__std_types___uint32_array___std___bit_xor,
  func__std_types___uint32_array___std___times,
  func__std___uint32_array,
  func__std___initialized_uint32_array,
  func__std_types___uint32_array___std___new,
  func__std_types___uint32_array___std___range,
  func__std_types___int64_array___std___length_of,
  func__std_types___int64_array___std___dimension_count_of,
  func__std_types___int64_array___std___equal,
  func__std_types___int64_array___std___times,
  func__std___int64_array,
  func__std___initialized_int64_array,
  func__std_types___int64_array___std___new,
  func__std_types___int64_array___std___range,
  func__std_types___uint64_array___std___length_of,
  func__std_types___uint64_array___std___dimension_count_of,
  func__std_types___uint64_array___std___equal,
  func__std_types___uint64_array___std___bit_and,
  func__std_types___uint64_array___std___bit_or,
  func__std_types___uint64_array___std___bit_xor,
  func__std_types___uint64_array___std___times,
  func__std___uint64_array,
  func__std___initialized_uint64_array,
  func__std_types___uint64_array___std___new,
  func__std_types___uint64_array___std___range,
  func__std_types___float32_array___std___length_of,
  func__std_types___float32_array___std___dimension_count_of,
  func__std_types___float32_array___std___equal,
  func__std_types___float32_array___std___times,
  func__std___float32_array,
  func__std___initialized_float32_array,
  func__std_types___float32_array___std___new,
  func__std_types___float32_array___std___range,
  func__std_types___float64_array___std___length_of,
  func__std_types___float64_array___std___dimension_count_of,
  func__std_types___float64_array___std___equal,
  func__std_types___float64_array___std___times,
  func__std___float64_array,
  func__std___initialized_float64_array,
  func__std_types___float64_array___std___new,
  func__std_types___float64_array___std___range,
  func__std___pass,
  func__std___result_count,
  func__std_types___true___std___equal,
  func__std_types___false___std___equal,
  func__c_function___std___parameter_count_of,
  func__std___character,
  func__std_types___character___std___plus,
  func__std_types___character___std___minus,
  func__std_types___character___std___equal,
  func__std_types___character___std___less,
  func__std_types___character___std___hash,
  func__std_types___character___std___to_string,
  func__std_types___character___std___to_integer,
  func__std_types___character___std___width_of,
  func__std___from_unix_time,
  func__std___date_and_time,
  func__std_types___date_and_time___std___year_of,
  func__std_types___date_and_time___std___month_of,
  func__std_types___date_and_time___std___day_of,
  func__std_types___date_and_time___std___day_of_week_of,
  func__std_types___date_and_time___std___hour_of,
  func__std_types___date_and_time___std___minute_of,
  func__std_types___date_and_time___std___second_of,
  func__std_types___date_and_time___std___time_shift_of,
  func__std_types___date_and_time___std___seconds_since_epoch,
  func__std_types___date_and_time___std___plus,
  func__std_types___date_and_time___std___minus,
  func__std_types___date_and_time___std___equal,
  func__std_types___date_and_time___std___less,
  func__std___current_time,
  func__debug___string,
  func__debug___write,
  func__debug___dump_object,
  func__debug___exit,
  func__std___error_check,
  func__debug___total_garbage_collections,
  unique__std___IO_ERROR,
  unique__std___RUNTIME_ERROR,
  unique__std___APPLICATION_ERROR,
  func__std_types___error___std___error_category_of,
  func__std_types___error___std___error_message_text_of,
  func__std_types___error___std___error_details_of,
  func__std_types___error___std___errno_of,
  func__std_types___error___std___failed_attribute_of,
  func__std___error,
  func__std___exec,
  func__std___create_process,
  func__std_types___function___std___parameter_count_of,
  func__std_types___list___std___new,
  func__std___list,
  func__std_types___list___std___length_of,
  func__std_types___list___std___is_empty,
  func__std_types___list___std___is_not_empty,
  func__std_types___list___std___push,
  func__std_types___list___std___drop,
  func__std_types___list___std___pop,
  func__std_types___list___std___peek,
  func__std_types___list___std___append,
  func__std_types___list___std___range,
  func__std_types___list___std___spread,
  func__std_types___positive_integer___std___negate,
  func__negative_integer___std___negate,
  func__std_types___real___std___negate,
  func__std_types___positive_integer___std___times,
  func__negative_integer___std___times,
  func__std_types___positive_integer___std___to_integer,
  func__negative_integer___std___to_integer,
  func__std_types___real___std___to_integer,
  func__std_types___real___std___floor,
  func__std_types___real___std___ceil,
  func__std_types___real___std___round,
  func__negative_integer___std___to_string,
  func__std_types___positive_integer___std___to_string,
  func__std_types___real___std___to_string,
  func__std_types___positive_integer___std___over,
  func__negative_integer___std___over,
  func__std_types___positive_integer___std___div,
  func__negative_integer___std___div,
  func__std_types___positive_integer___std___mod,
  func__negative_integer___std___mod,
  func__std_types___positive_integer___std___hash,
  func__negative_integer___std___hash,
  func__std_types___real___std___hash,
  func__std_types___positive_integer___std___ln,
  func__negative_integer___std___ln,
  func__std_types___real___std___ln,
  func__std_types___positive_integer___std___exp,
  func__negative_integer___std___exp,
  func__std_types___real___std___exp,
  func__std___real,
  func__std___integer,
  func__std___sqrt,
  func__std___pow,
  func__std_types___positive_integer___std___exit,
  func__std_types___positive_integer___std___plus,
  func__negative_integer___std___plus,
  func__std_types___real___std___plus,
  func__std_types___positive_integer___std___minus,
  func__negative_integer___std___minus,
  func__std_types___real___std___minus,
  func__std_types___real___std___times,
  func__std_types___real___std___over,
  func__std_types___positive_integer___std___equal,
  func__negative_integer___std___equal,
  func__std_types___real___std___equal,
  func__std_types___positive_integer___std___less,
  func__negative_integer___std___less,
  func__std_types___real___std___less,
  func__std_types___positive_integer___std___shift_left,
  func__std_types___positive_integer___std___shift_right,
  func__std_types___positive_integer___std___bit_and,
  func__std_types___positive_integer___std___bit_or,
  func__std_types___positive_integer___std___bit_xor,
  func__std___sin,
  func__std___cos,
  func__std___tan,
  func__std___asin,
  func__std___acos,
  func__std___atan,
  func__std_types___file_type___std___equal,
  func__std_types___file_type___std___hash,
  func__std___file_type,
  func__std_types___file_type___std___to_integer,
  func__std_types___file_descriptor___std___equal,
  func__std_types___file_descriptor___std___hash,
  func__std___file_descriptor,
  func__std_types___file_descriptor___std___to_integer,
  func__std_types___shutdown_type___std___equal,
  func__std_types___shutdown_type___std___hash,
  func__std___shutdown_type,
  func__std_types___shutdown_type___std___to_integer,
  func__std_types___device_id___std___equal,
  func__std_types___device_id___std___hash,
  func__std___device_id,
  func__std_types___device_id___std___to_integer,
  func__std_types___directory___std___equal,
  func__std_types___directory___std___hash,
  func__std_types___group_id___std___equal,
  func__std_types___group_id___std___hash,
  func__std___group_id,
  func__std_types___group_id___std___to_integer,
  func__std_types___inode_number___std___equal,
  func__std_types___inode_number___std___hash,
  func__std___inode_number,
  func__std_types___inode_number___std___to_integer,
  func__std_types___process_id___std___equal,
  func__std_types___process_id___std___hash,
  func__std___process_id,
  func__std_types___process_id___std___to_integer,
  func__std_types___user_id___std___equal,
  func__std_types___user_id___std___hash,
  func__std___user_id,
  func__std_types___user_id___std___to_integer,
  func__std_types___error_number___std___equal,
  func__std_types___error_number___std___hash,
  func__std___error_number,
  func__std_types___error_number___std___to_integer,
  func__std___access,
  func__std___chdir,
  func__std___chmod,
  func__std___chown,
  func__std___chroot,
  func__std_types___file_descriptor___std___close,
  func__std___closedir,
  func__std___dup2,
  func__std___fstat,
  func__std___fsync,
  func__std___getcwd,
  func__std___getenv,
  func__std___getegid,
  func__std___geteuid,
  func__std___getgid,
  func__std___gethostname,
  func__std___getlogin,
  func__std___getpid,
  func__std___getppid,
  func__std___getpwuid,
  func__std___getsid,
  func__std___getuid,
  func__std___isatty,
  func__std___mkdir,
  func__std___mkfifo,
  func__std___open,
  func__std___opendir,
  func__std_types___file_descriptor___std___read,
  func__std___readdir,
  func__std___realpath,
  func__std___rename,
  func__std___sethostname,
  func__std___shutdown,
  func__std___stat,
  func__std___strerror,
  func__std___wait,
  func__std_types___file_descriptor___std___write,
  func__std___umask,
  func__std___unlink,
  func__std___usleep,
  func__std_types___octet_string___std___length_of,
  func__quad_octet_string___std___length_of,
  func__std_types___octet_string___std___is_empty,
  func__std_types___octet_string___std___is_not_empty,
  func__quad_octet_string___std___is_empty,
  func__quad_octet_string___std___is_not_empty,
  func__std_types___octet_string___std___push,
  func__quad_octet_string___std___push,
  func__std_types___octet_string___std___append,
  func__quad_octet_string___std___append,
  func__std_types___octet_string___std___range,
  func__quad_octet_string___std___range,
  func__std_types___octet_string___std___hash,
  func__quad_octet_string___std___hash,
  func__std_types___octet_string___std___equal,
  func__quad_octet_string___std___equal,
  func__std_types___octet_string___std___less,
  func__quad_octet_string___std___less,
  func__std_types___octet_string___std___width_of,
  func__quad_octet_string___std___width_of,
  func__std_types___octet_string___std___from_utf8,
  func__std_types___octet_string___std___to_utf8,
  func__quad_octet_string___std___to_utf8,
  func__std_types___file_descriptor___std___get_terminal_attributes,
  func__std_types___file_descriptor___std___set_terminal_attributes,
  func__std_types___terminal_attributes___std___backspace_character_of,
  func__std_types___terminal_attributes___std___use_canonical_mode,
  func__std_types___terminal_attributes___std___echo_characters,
  func__std_types___terminal_attributes___std___echo_new_lines,
  func__std_types___terminal_attributes___std___enable_xon_xoff_for_input,
  func__std_types___terminal_attributes___std___enable_xon_xoff_for_output,
  func__std_types___terminal_attributes___std___restart_output_on_any_character,
  func__std_types___terminal_attributes___std___ignore_cr_on_input,
  func__std_types___terminal_attributes___std___generate_signals,
  func__std_types___terminal_attributes___std___map_cr_to_lf_on_input,
  func__std_types___terminal_attributes___std___hangup_on_close,
  func__std_types___terminal_attributes___std___map_lf_to_crlf_on_output,
  func__std_types___terminal_attributes___std___minimum_characters_for_canoncial_read,
  func__std_types___terminal_attributes___std___timeout_for_reads,
  func__std_types___terminal_attributes___std___input_speed,
  func__std_types___terminal_attributes___std___output_speed,
  func__std_types___tuple___std___new,
  func__builtin___tuple2___std___to_list,
  func__builtin___tuple2___std___new,
  func__builtin___tuple3___std___to_list,
  func__builtin___tuple3___std___new,
  func__builtin___tuple4___std___to_list,
  func__builtin___tuple4___std___new,
  func__builtin___tuple5___std___to_list,
  func__builtin___tuple5___std___new,
  func__builtin___tuple6___std___to_list,
  func__builtin___tuple6___std___new,
  func__builtin___tuple7___std___to_list,
  func__builtin___tuple7___std___new,
  func__builtin___tuple8___std___to_list,
  func__builtin___tuple8___std___new,
  func__std___tuple,
  func__std___tuple_or_error,
  func__std___new_tuple,
  func__std_types___character___std___to_upper_case,
  func__std___is_an_upper_case_letter_character,
  func__std_types___character___std___to_lower_case,
  func__std___is_a_lower_case_letter_character,
  func__std_types___character___std___to_title_case,
  func__std___is_a_title_case_letter_character,
  func__std___is_a_letter_character,
  func__std___is_a_whitespace_character,
  func__std___is_a_zero_width_character,
  func__std___is_a_wide_character,
  func__std_types___unique_item___std___to_string,
  func__std_types___unique_item___std___equal,
  func__std_types___unique_item___std___hash,
  func__std___unique_item,
  unique__std___SIGHUP,
  unique__std___SIGUSR1,
  unique__std___SIGUSR2,
  unique__std___CHILD_CHANGED_STATE,
  unique__std___WINDOW_CHANGED_SIZE,
  func__std_types___file_descriptor___std___get_terminal_size,
  func__std___exitstatus,
  func__std___pselect,
  func__std___do_not_close,
  func__std___waitpid,
  func__std___open_tcp_client_socket,
  func__std___open_tcp_server_socket,
  func__std___accept,
  func__std___is_listening,
  func__std___get_first_mac_address
};

enum {
  var_no__std___new = FIRST_VAR+0,
  var_no__std___plus,
  var_no__std___minus,
  var_no__std___times,
  var_no__std___over,
  var_no__std___div,
  var_no__std___mod,
  var_no__std___negate,
  var_no__std___floor,
  var_no__std___ceil,
  var_no__std___round,
  var_no__std___ln,
  var_no__std___exp,
  var_no__std___equal,
  var_no__std___less,
  var_no__std___shift_left,
  var_no__std___shift_right,
  var_no__std___bit_and,
  var_no__std___bit_or,
  var_no__std___bit_xor,
  var_no__std___parameter_count_of,
  var_no__std___to_string,
  var_no__std___to_integer,
  var_no__std___to_real,
  var_no__std___to_number,
  var_no__std___to_lower_case,
  var_no__std___to_upper_case,
  var_no__std___to_title_case,
  var_no__std___is_empty,
  var_no__std___is_not_empty,
  var_no__std___length_of,
  var_no__std___dimension_count_of,
  var_no__std___width_of,
  var_no__std___height_of,
  var_no__std___hash,
  var_no__std___push,
  var_no__std___pop,
  var_no__std___peek,
  var_no__std___drop,
  var_no__std___put,
  var_no__std___get,
  var_no__std___append,
  var_no__std___range,
  var_no__std___spread,
  var_no__std___to_list,
  var_no__std___exit,
  var_no__std___from_utf8,
  var_no__std___read,
  var_no__std___write,
  var_no__std___close,
  var_no__std___flush,
  var_no__std_types___generic_array,
  var_no__std_types___array,
  var_no__std___array,
  var_no__std___initialized_array,
  var_no__std_types___boolean_array,
  var_no__std___boolean_array,
  var_no__std___initialized_boolean_array,
  var_no__std_types___character_array,
  var_no__std___character_array,
  var_no__std___initialized_character_array,
  var_no__std_types___int8_array,
  var_no__std___int8_array,
  var_no__std___initialized_int8_array,
  var_no__std_types___uint8_array,
  var_no__std___uint8_array,
  var_no__std___initialized_uint8_array,
  var_no__std_types___int16_array,
  var_no__std___int16_array,
  var_no__std___initialized_int16_array,
  var_no__std_types___uint16_array,
  var_no__std___uint16_array,
  var_no__std___initialized_uint16_array,
  var_no__std_types___int32_array,
  var_no__std___int32_array,
  var_no__std___initialized_int32_array,
  var_no__std_types___uint32_array,
  var_no__std___uint32_array,
  var_no__std___initialized_uint32_array,
  var_no__std_types___int64_array,
  var_no__std___int64_array,
  var_no__std___initialized_int64_array,
  var_no__std_types___uint64_array,
  var_no__std___uint64_array,
  var_no__std___initialized_uint64_array,
  var_no__std_types___float32_array,
  var_no__std___float32_array,
  var_no__std___initialized_float32_array,
  var_no__std_types___float64_array,
  var_no__std___float64_array,
  var_no__std___initialized_float64_array,
  var_no__std___EXIT_SUCCESS,
  var_no__std___EXIT_FAILURE,
  var_no__std___pass,
  var_no__std___result_count,
  var_no__std_types___true,
  var_no__std_types___false,
  var_no__c_function,
  var_no__std_types___character,
  var_no__std___character,
  var_no__std___year_of,
  var_no__std___month_of,
  var_no__std___day_of,
  var_no__std___day_of_week_of,
  var_no__std___hour_of,
  var_no__std___minute_of,
  var_no__std___second_of,
  var_no__std___time_shift_of,
  var_no__std___seconds_since_epoch,
  var_no__std_types___date_and_time,
  var_no__std___from_unix_time,
  var_no__std___date_and_time,
  var_no__std___current_time,
  var_no__debug___string,
  var_no__debug___write,
  var_no__debug___dump_object,
  var_no__debug___exit,
  var_no__std___error_check,
  var_no__debug___total_garbage_collections,
  var_no__std___program_name,
  var_no__std___command_line_arguments,
  var_no__std___environment_variables,
  var_no__std___IO_ERROR,
  var_no__std___RUNTIME_ERROR,
  var_no__std___APPLICATION_ERROR,
  var_no__std_types___error,
  var_no__std___error_category_of,
  var_no__std___error_message_text_of,
  var_no__std___error_details_of,
  var_no__std___errno_of,
  var_no__std___failed_attribute_of,
  var_no__std___error,
  var_no__std_types___object,
  var_no__std_types___undefined,
  var_no__std___exec,
  var_no__std___create_process,
  var_no__std_types___function,
  var_no__tabular_function,
  var_no__std_types___key_value_pair,
  var_no__std_types___generic_list,
  var_no__std_types___list,
  var_no__std___empty_list,
  var_no__std___list,
  var_no__std_types___number,
  var_no__std_types___integer,
  var_no__std_types___positive_integer,
  var_no__negative_integer,
  var_no__std_types___real,
  var_no__std___real,
  var_no__std___integer,
  var_no__std___sqrt,
  var_no__std___pow,
  var_no__std___sin,
  var_no__std___cos,
  var_no__std___tan,
  var_no__std___asin,
  var_no__std___acos,
  var_no__std___atan,
  var_no__std_types___polymorphic_function,
  var_no__std_types___polymorphic_function_with_setter,
  var_no__std___subtype_of,
  var_no__std___BLOCK_DEVICE,
  var_no__std___CHARACTER_DEVICE,
  var_no__std___DIRECTORY,
  var_no__std___NAMED_PIPE,
  var_no__std___SYMBOLIC_LINK,
  var_no__std___REGULAR_FILE,
  var_no__std___SOCKET,
  var_no__std___UNKNOWN_FILE_TYPE,
  var_no__std___STDIN_FILENO,
  var_no__std___STDOUT_FILENO,
  var_no__std___STDERR_FILENO,
  var_no__std___SHUT_RD,
  var_no__std___SHUT_WR,
  var_no__std___SHUT_RDWR,
  var_no__std___ENOERR,
  var_no__std___EPERM,
  var_no__std___ENOENT,
  var_no__std___ESRCH,
  var_no__std___EINTR,
  var_no__std___EIO,
  var_no__std___ENXIO,
  var_no__std___E2BIG,
  var_no__std___ENOEXEC,
  var_no__std___EBADF,
  var_no__std___ECHILD,
  var_no__std___EAGAIN,
  var_no__std___ENOMEM,
  var_no__std___EACCES,
  var_no__std___EFAULT,
  var_no__std___ENOTBLK,
  var_no__std___EBUSY,
  var_no__std___EEXIST,
  var_no__std___EXDEV,
  var_no__std___ENODEV,
  var_no__std___ENOTDIR,
  var_no__std___EISDIR,
  var_no__std___EINVAL,
  var_no__std___ENFILE,
  var_no__std___EMFILE,
  var_no__std___ENOTTY,
  var_no__std___ETXTBSY,
  var_no__std___EFBIG,
  var_no__std___ENOSPC,
  var_no__std___ESPIPE,
  var_no__std___EROFS,
  var_no__std___EMLINK,
  var_no__std___EPIPE,
  var_no__std___EDOM,
  var_no__std___ERANGE,
  var_no__std___EDEADLK,
  var_no__std___ENAMETOOLONG,
  var_no__std___ENOLCK,
  var_no__std___ENOSYS,
  var_no__std___ENOTEMPTY,
  var_no__std___EILSEQ,
  var_no__std___ELOOP,
  var_no__std___ENOMSG,
  var_no__std___EIDRM,
  var_no__std___ECHRNG,
  var_no__std___EL2NSYNC,
  var_no__std___EL3HLT,
  var_no__std___EL3RST,
  var_no__std___ELNRNG,
  var_no__std___EUNATCH,
  var_no__std___ENOCSI,
  var_no__std___EL2HLT,
  var_no__std___EBADE,
  var_no__std___EBADR,
  var_no__std___EXFULL,
  var_no__std___ENOANO,
  var_no__std___EBADRQC,
  var_no__std___EBADSLT,
  var_no__std___EBFONT,
  var_no__std___ENOSTR,
  var_no__std___ENODATA,
  var_no__std___ETIME,
  var_no__std___ENOSR,
  var_no__std___ENONET,
  var_no__std___ENOPKG,
  var_no__std___EREMOTE,
  var_no__std___ENOLINK,
  var_no__std___EADV,
  var_no__std___ESRMNT,
  var_no__std___ECOMM,
  var_no__std___EPROTO,
  var_no__std___EMULTIHOP,
  var_no__std___EDOTDOT,
  var_no__std___EBADMSG,
  var_no__std___EOVERFLOW,
  var_no__std___ENOTUNIQ,
  var_no__std___EBADFD,
  var_no__std___EREMCHG,
  var_no__std___ELIBACC,
  var_no__std___ELIBBAD,
  var_no__std___ELIBSCN,
  var_no__std___ELIBMAX,
  var_no__std___ELIBEXEC,
  var_no__std___ESTRPIPE,
  var_no__std___EUSERS,
  var_no__std___ENOTSOCK,
  var_no__std___EDESTADDRREQ,
  var_no__std___EMSGSIZE,
  var_no__std___EPROTOTYPE,
  var_no__std___ENOPROTOOPT,
  var_no__std___EPROTONOSUPPORT,
  var_no__std___ESOCKTNOSUPPORT,
  var_no__std___EOPNOTSUPP,
  var_no__std___EPFNOSUPPORT,
  var_no__std___EAFNOSUPPORT,
  var_no__std___EADDRINUSE,
  var_no__std___EADDRNOTAVAIL,
  var_no__std___ENETDOWN,
  var_no__std___ENETUNREACH,
  var_no__std___ENETRESET,
  var_no__std___ECONNABORTED,
  var_no__std___ECONNRESET,
  var_no__std___ENOBUFS,
  var_no__std___EISCONN,
  var_no__std___ENOTCONN,
  var_no__std___ESHUTDOWN,
  var_no__std___ETOOMANYREFS,
  var_no__std___ETIMEDOUT,
  var_no__std___ECONNREFUSED,
  var_no__std___EHOSTDOWN,
  var_no__std___EHOSTUNREACH,
  var_no__std___EALREADY,
  var_no__std___EINPROGRESS,
  var_no__std___ESTALE,
  var_no__std___EDQUOT,
  var_no__std___ENOMEDIUM,
  var_no__std___ECANCELED,
  var_no__std___EOWNERDEAD,
  var_no__std___ENOTRECOVERABLE,
  var_no__std___access_time_nanoseconds_of,
  var_no__std___access_time_seconds_of,
  var_no__std___block_count_of,
  var_no__std___block_size_of,
  var_no__std___device_of,
  var_no__std___group_id_of,
  var_no__std___home_directory_of,
  var_no__std___inode_number_of,
  var_no__std___link_count_of,
  var_no__std___mode_of,
  var_no__std___modification_time_nanoseconds_of,
  var_no__std___modification_time_seconds_of,
  var_no__std___password_of,
  var_no__std___root_device_of,
  var_no__std___shell_of,
  var_no__std___size_of,
  var_no__std___status_change_time_nanoseconds_of,
  var_no__std___status_change_time_seconds_of,
  var_no__std___type_of,
  var_no__std___user_id_of,
  var_no__std___user_information_of,
  var_no__std___username_of,
  var_no__std___name_of,
  var_no__std_types___file_type,
  var_no__std___file_type,
  var_no__std_types___file_descriptor,
  var_no__std___file_descriptor,
  var_no__std_types___shutdown_type,
  var_no__std___shutdown_type,
  var_no__std_types___device_id,
  var_no__std___device_id,
  var_no__std_types___directory,
  var_no__std_types___group_id,
  var_no__std___group_id,
  var_no__std_types___inode_number,
  var_no__std___inode_number,
  var_no__std_types___process_id,
  var_no__std___process_id,
  var_no__std_types___user_id,
  var_no__std___user_id,
  var_no__std_types___error_number,
  var_no__std___error_number,
  var_no__std_types___passwd,
  var_no__std_types___stat,
  var_no__std_types___dirent,
  var_no__std___access,
  var_no__std___chdir,
  var_no__std___chmod,
  var_no__std___chown,
  var_no__std___chroot,
  var_no__std___closedir,
  var_no__std___dup2,
  var_no__std___fstat,
  var_no__std___fsync,
  var_no__std___getcwd,
  var_no__std___getenv,
  var_no__std___getegid,
  var_no__std___geteuid,
  var_no__std___getgid,
  var_no__std___gethostname,
  var_no__std___getlogin,
  var_no__std___getpid,
  var_no__std___getppid,
  var_no__std___getpwuid,
  var_no__std___getsid,
  var_no__std___getuid,
  var_no__std___isatty,
  var_no__std___mkdir,
  var_no__std___mkfifo,
  var_no__std___open,
  var_no__std___opendir,
  var_no__std___readdir,
  var_no__std___realpath,
  var_no__std___rename,
  var_no__std___sethostname,
  var_no__std___shutdown,
  var_no__std___stat,
  var_no__std___strerror,
  var_no__std___wait,
  var_no__std___umask,
  var_no__std___unlink,
  var_no__std___usleep,
  var_no__std_types___sequence,
  var_no__std___to_utf8,
  var_no__std_types___string,
  var_no__std_types___octet_string,
  var_no__quad_octet_string,
  var_no__std___empty_string,
  var_no__std___get_terminal_attributes,
  var_no__std___set_terminal_attributes,
  var_no__std___backspace_character_of,
  var_no__std___use_canonical_mode,
  var_no__std___echo_characters,
  var_no__std___echo_new_lines,
  var_no__std___enable_xon_xoff_for_input,
  var_no__std___enable_xon_xoff_for_output,
  var_no__std___restart_output_on_any_character,
  var_no__std___ignore_cr_on_input,
  var_no__std___generate_signals,
  var_no__std___map_cr_to_lf_on_input,
  var_no__std___hangup_on_close,
  var_no__std___map_lf_to_crlf_on_output,
  var_no__std___minimum_characters_for_canoncial_read,
  var_no__std___timeout_for_reads,
  var_no__std___input_speed,
  var_no__std___output_speed,
  var_no__std_types___terminal_attributes,
  var_no__std_types___tuple,
  var_no__builtin___tuple2,
  var_no__builtin___tuple3,
  var_no__builtin___tuple4,
  var_no__builtin___tuple5,
  var_no__builtin___tuple6,
  var_no__builtin___tuple7,
  var_no__builtin___tuple8,
  var_no__std___tuple,
  var_no__std___tuple_or_error,
  var_no__std___new_tuple,
  var_no__std___is_an_upper_case_letter_character,
  var_no__std___is_a_lower_case_letter_character,
  var_no__std___is_a_title_case_letter_character,
  var_no__std___is_a_letter_character,
  var_no__std___is_a_whitespace_character,
  var_no__std___is_a_zero_width_character,
  var_no__std___is_a_wide_character,
  var_no__std_types___unique_item,
  var_no__std___unique_item,
  var_no__std_types___value_range,
  var_no__std___SIGHUP,
  var_no__std___SIGUSR1,
  var_no__std___SIGUSR2,
  var_no__std___CHILD_CHANGED_STATE,
  var_no__std___WINDOW_CHANGED_SIZE,
  var_no__std___get_terminal_size,
  var_no__std___exitstatus,
  var_no__std___pselect,
  var_no__std___do_not_close,
  var_no__std___waitpid,
  var_no__std___open_tcp_client_socket,
  var_no__std___open_tcp_server_socket,
  var_no__std___accept,
  var_no__std___is_listening,
  var_no__std___get_first_mac_address
};

static FUNKY_VARIABLE variables_table[];

static POSITIVE_INTEGER std___EXIT_SUCCESS;
static POSITIVE_INTEGER std___EXIT_FAILURE;
static OCTET_STRING std___program_name;
static LIST std___command_line_arguments;
static LIST std___environment_variables;
static FILE_TYPE std___BLOCK_DEVICE;
static FILE_TYPE std___CHARACTER_DEVICE;
static FILE_TYPE std___DIRECTORY;
static FILE_TYPE std___NAMED_PIPE;
static FILE_TYPE std___SYMBOLIC_LINK;
static FILE_TYPE std___REGULAR_FILE;
static FILE_TYPE std___SOCKET;
static FILE_TYPE std___UNKNOWN_FILE_TYPE;
static FILE_DESCRIPTOR std___STDIN_FILENO;
static FILE_DESCRIPTOR std___STDOUT_FILENO;
static FILE_DESCRIPTOR std___STDERR_FILENO;
static SHUTDOWN_TYPE std___SHUT_RD;
static SHUTDOWN_TYPE std___SHUT_WR;
static SHUTDOWN_TYPE std___SHUT_RDWR;
static ERROR_NUMBER std___ENOERR;
static ERROR_NUMBER std___EPERM;
static ERROR_NUMBER std___ENOENT;
static ERROR_NUMBER std___ESRCH;
static ERROR_NUMBER std___EINTR;
static ERROR_NUMBER std___EIO;
static ERROR_NUMBER std___ENXIO;
static ERROR_NUMBER std___E2BIG;
static ERROR_NUMBER std___ENOEXEC;
static ERROR_NUMBER std___EBADF;
static ERROR_NUMBER std___ECHILD;
static ERROR_NUMBER std___EAGAIN;
static ERROR_NUMBER std___ENOMEM;
static ERROR_NUMBER std___EACCES;
static ERROR_NUMBER std___EFAULT;
static ERROR_NUMBER std___ENOTBLK;
static ERROR_NUMBER std___EBUSY;
static ERROR_NUMBER std___EEXIST;
static ERROR_NUMBER std___EXDEV;
static ERROR_NUMBER std___ENODEV;
static ERROR_NUMBER std___ENOTDIR;
static ERROR_NUMBER std___EISDIR;
static ERROR_NUMBER std___EINVAL;
static ERROR_NUMBER std___ENFILE;
static ERROR_NUMBER std___EMFILE;
static ERROR_NUMBER std___ENOTTY;
static ERROR_NUMBER std___ETXTBSY;
static ERROR_NUMBER std___EFBIG;
static ERROR_NUMBER std___ENOSPC;
static ERROR_NUMBER std___ESPIPE;
static ERROR_NUMBER std___EROFS;
static ERROR_NUMBER std___EMLINK;
static ERROR_NUMBER std___EPIPE;
static ERROR_NUMBER std___EDOM;
static ERROR_NUMBER std___ERANGE;
static ERROR_NUMBER std___EDEADLK;
static ERROR_NUMBER std___ENAMETOOLONG;
static ERROR_NUMBER std___ENOLCK;
static ERROR_NUMBER std___ENOSYS;
static ERROR_NUMBER std___ENOTEMPTY;
static ERROR_NUMBER std___EILSEQ;
static ERROR_NUMBER std___ELOOP;
static ERROR_NUMBER std___ENOMSG;
static ERROR_NUMBER std___EIDRM;
static ERROR_NUMBER std___ECHRNG;
static ERROR_NUMBER std___EL2NSYNC;
static ERROR_NUMBER std___EL3HLT;
static ERROR_NUMBER std___EL3RST;
static ERROR_NUMBER std___ELNRNG;
static ERROR_NUMBER std___EUNATCH;
static ERROR_NUMBER std___ENOCSI;
static ERROR_NUMBER std___EL2HLT;
static ERROR_NUMBER std___EBADE;
static ERROR_NUMBER std___EBADR;
static ERROR_NUMBER std___EXFULL;
static ERROR_NUMBER std___ENOANO;
static ERROR_NUMBER std___EBADRQC;
static ERROR_NUMBER std___EBADSLT;
static ERROR_NUMBER std___EBFONT;
static ERROR_NUMBER std___ENOSTR;
static ERROR_NUMBER std___ENODATA;
static ERROR_NUMBER std___ETIME;
static ERROR_NUMBER std___ENOSR;
static ERROR_NUMBER std___ENONET;
static ERROR_NUMBER std___ENOPKG;
static ERROR_NUMBER std___EREMOTE;
static ERROR_NUMBER std___ENOLINK;
static ERROR_NUMBER std___EADV;
static ERROR_NUMBER std___ESRMNT;
static ERROR_NUMBER std___ECOMM;
static ERROR_NUMBER std___EPROTO;
static ERROR_NUMBER std___EMULTIHOP;
static ERROR_NUMBER std___EDOTDOT;
static ERROR_NUMBER std___EBADMSG;
static ERROR_NUMBER std___EOVERFLOW;
static ERROR_NUMBER std___ENOTUNIQ;
static ERROR_NUMBER std___EBADFD;
static ERROR_NUMBER std___EREMCHG;
static ERROR_NUMBER std___ELIBACC;
static ERROR_NUMBER std___ELIBBAD;
static ERROR_NUMBER std___ELIBSCN;
static ERROR_NUMBER std___ELIBMAX;
static ERROR_NUMBER std___ELIBEXEC;
static ERROR_NUMBER std___ESTRPIPE;
static ERROR_NUMBER std___EUSERS;
static ERROR_NUMBER std___ENOTSOCK;
static ERROR_NUMBER std___EDESTADDRREQ;
static ERROR_NUMBER std___EMSGSIZE;
static ERROR_NUMBER std___EPROTOTYPE;
static ERROR_NUMBER std___ENOPROTOOPT;
static ERROR_NUMBER std___EPROTONOSUPPORT;
static ERROR_NUMBER std___ESOCKTNOSUPPORT;
static ERROR_NUMBER std___EOPNOTSUPP;
static ERROR_NUMBER std___EPFNOSUPPORT;
static ERROR_NUMBER std___EAFNOSUPPORT;
static ERROR_NUMBER std___EADDRINUSE;
static ERROR_NUMBER std___EADDRNOTAVAIL;
static ERROR_NUMBER std___ENETDOWN;
static ERROR_NUMBER std___ENETUNREACH;
static ERROR_NUMBER std___ENETRESET;
static ERROR_NUMBER std___ECONNABORTED;
static ERROR_NUMBER std___ECONNRESET;
static ERROR_NUMBER std___ENOBUFS;
static ERROR_NUMBER std___EISCONN;
static ERROR_NUMBER std___ENOTCONN;
static ERROR_NUMBER std___ESHUTDOWN;
static ERROR_NUMBER std___ETOOMANYREFS;
static ERROR_NUMBER std___ETIMEDOUT;
static ERROR_NUMBER std___ECONNREFUSED;
static ERROR_NUMBER std___EHOSTDOWN;
static ERROR_NUMBER std___EHOSTUNREACH;
static ERROR_NUMBER std___EALREADY;
static ERROR_NUMBER std___EINPROGRESS;
static ERROR_NUMBER std___ESTALE;
static ERROR_NUMBER std___EDQUOT;
static ERROR_NUMBER std___ENOMEDIUM;
static ERROR_NUMBER std___ECANCELED;
static ERROR_NUMBER std___EOWNERDEAD;
static ERROR_NUMBER std___ENOTRECOVERABLE;
static OCTET_STRING std___empty_string;

static void *create__std_types___array
  (
    long updates_length,
    ARRAY_VIEW *view,
    ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___boolean_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    BOOLEAN_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___character_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    CHARACTER_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___int8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___uint8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___int16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___uint16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___int32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___uint32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___int64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___uint64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___float32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types___float64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__c_function
  (
    int32_t parameter_count
  );

static void *create__std_types___character
  (
    uint32_t code
  );

static void *create__std_types___date_and_time
  (
    int64_t seconds,
    int32_t nanoseconds
  );

static void *create__tabular_function
  (

  );

static void *create__std_types___integer
  (
    uint64_t value
  );

static void *create__std_types___positive_integer
  (
    uint64_t value
  );

static void *create__std_types___real
  (
    double value
  );

static void *create__std_types___file_type
  (
    int value
  );

static void *create__std_types___file_descriptor
  (
    int value
  );

static void *create__std_types___shutdown_type
  (
    int value
  );

static void *create__std_types___device_id
  (
    unsigned long value
  );

static void *create__std_types___directory
  (
    void *value
  );

static void *create__std_types___group_id
  (
    int value
  );

static void *create__std_types___inode_number
  (
    unsigned long value
  );

static void *create__std_types___process_id
  (
    int value
  );

static void *create__std_types___user_id
  (
    int value
  );

static void *create__std_types___error_number
  (
    int value
  );

static void *create__std_types___octet_string
  (
    long offset,
    long length,
    OCTET_DATA *data
  );

static void *create__quad_octet_string
  (
    long offset,
    long length,
    QUAD_OCTET_DATA *data
  );

static void *create__std_types___terminal_attributes
  (
    TERMIO_DATA *data
  );

static void *create__builtin___tuple2
  (
    NODE *node_0,
    NODE *node_1
  );

static void *create__builtin___tuple3
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2
  );

static void *create__builtin___tuple4
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3
  );

static void *create__builtin___tuple5
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4
  );

static void *create__builtin___tuple6
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5
  );

static void *create__builtin___tuple7
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6
  );

static void *create__builtin___tuple8
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6,
    NODE *node_7
  );

static void *create__std_types___unique_item
  (
    long id
  );
static void *collect_array_info(ARRAY_INFO *info);
static void *collect_dimension_info(DIMENSION_INFO *info);
static void *collect_array_view(ARRAY_VIEW *view);
static void *collect_array_updates(ARRAY_UPDATES *updates);
static void *collect_array_data(ARRAY_DATA *data);
static void *std_types___array____collect(ARRAY *node);
static long std_types___array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_boolean_array_data(BOOLEAN_ARRAY_DATA *data);
static void *std_types___boolean_array____collect(BOOLEAN_ARRAY *node);
static long std_types___boolean_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_character_array_data(CHARACTER_ARRAY_DATA *data);
static void *std_types___character_array____collect(CHARACTER_ARRAY *node);
static long std_types___character_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int8_array_data(INT8_ARRAY_DATA *data);
static void *std_types___int8_array____collect(INT8_ARRAY *node);
static long std_types___int8_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint8_array_data(UINT8_ARRAY_DATA *data);
static void *std_types___uint8_array____collect(UINT8_ARRAY *node);
static long std_types___uint8_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int16_array_data(INT16_ARRAY_DATA *data);
static void *std_types___int16_array____collect(INT16_ARRAY *node);
static long std_types___int16_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint16_array_data(UINT16_ARRAY_DATA *data);
static void *std_types___uint16_array____collect(UINT16_ARRAY *node);
static long std_types___uint16_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int32_array_data(INT32_ARRAY_DATA *data);
static void *std_types___int32_array____collect(INT32_ARRAY *node);
static long std_types___int32_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint32_array_data(UINT32_ARRAY_DATA *data);
static void *std_types___uint32_array____collect(UINT32_ARRAY *node);
static long std_types___uint32_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int64_array_data(INT64_ARRAY_DATA *data);
static void *std_types___int64_array____collect(INT64_ARRAY *node);
static long std_types___int64_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint64_array_data(UINT64_ARRAY_DATA *data);
static void *std_types___uint64_array____collect(UINT64_ARRAY *node);
static long std_types___uint64_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_float32_array_data(FLOAT32_ARRAY_DATA *data);
static void *std_types___float32_array____collect(FLOAT32_ARRAY *node);
static long std_types___float32_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_float64_array_data(FLOAT64_ARRAY_DATA *data);
static void *std_types___float64_array____collect(FLOAT64_ARRAY *node);
static long std_types___float64_array____debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types___true____to_bool(NODE *node, int *result_p);
static long std_types___true____debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types___false____to_bool(NODE *node, int *result_p);
static long std_types___false____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *c_function____collect(C_FUNCTION *node);
static long c_function____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___character____collect(CHARACTER *node);
static uint32_t std_types___character____to_uchar32(NODE *node, uint32_t *result_p);
static long std_types___character____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___date_and_time____collect(DATE_AND_TIME *node);
static long std_types___date_and_time____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___error____collect(ERROR *node);
static long std_types___error____debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types___object____to_int8(NODE *node);
static int std_types___undefined____to_int8(NODE *node);
static int std_types___object____to_int16(NODE *node);
static int std_types___undefined____to_int16(NODE *node);
static int std_types___object____to_int32(NODE *node);
static int std_types___undefined____to_int32(NODE *node);
static int std_types___object____to_int64(NODE *node);
static int std_types___undefined____to_int64(NODE *node);
static int std_types___object____to_uint8(NODE *node);
static int std_types___undefined____to_uint8(NODE *node);
static int std_types___object____to_uint16(NODE *node);
static int std_types___undefined____to_uint16(NODE *node);
static int std_types___object____to_uint32(NODE *node);
static int std_types___undefined____to_uint32(NODE *node);
static int std_types___object____to_uint64(NODE *node);
static int std_types___undefined____to_uint64(NODE *node);
static int std_types___object____to_uchar32(NODE *node);
static int std_types___undefined____to_uchar32(NODE *node);
static int std_types___object____to_bool(NODE *node);
static int std_types___undefined____to_bool(NODE *node);
static int std_types___object____to_int(NODE *node);
static int std_types___undefined____to_int(NODE *node);
static int std_types___object____to_uint(NODE *node);
static int std_types___undefined____to_uint(NODE *node);
static int std_types___object____to_long(NODE *node);
static int std_types___undefined____to_long(NODE *node);
static int std_types___object____to_ulong(NODE *node);
static int std_types___undefined____to_ulong(NODE *node);
static int std_types___object____to_double(NODE *node);
static int std_types___undefined____to_double(NODE *node);
static int std_types___object____to_c_string(NODE *node);
static int std_types___undefined____to_c_string(NODE *node);
static int std_types___object____to_octets(NODE *node);
static int std_types___undefined____to_octets(NODE *node);
static int std_types___object____get_item_of(NODE *node);
static int std_types___undefined____get_item_of(NODE *node);
static int std_types___object____length_of(NODE *node);
static int std_types___undefined____length_of(NODE *node);
static int std_types___object____unfold(NODE *node);
static int std_types___undefined____unfold(NODE *node);
static long std_types___function____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___list____collect(LIST *node);
static long std_types___list____debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types___list____get_item_of(NODE *node, long idx, NODE **result_p);
static int std_types___list____unfold(NODE *list);
static int std_types___list____length_of(NODE *node, long *result_p);
static void *std_types___integer____collect(INTEGER *node);
static void *std_types___real____collect(REAL *node);
static long std_types___positive_integer____debug_string(NODE *node, int indent, int max_depth, char *buf);
static long negative_integer____debug_string(NODE *node, int indent, int max_depth, char *buf);
static long std_types___real____debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types___positive_integer____to_double(NODE *node, double *result_p);
static int std_types___positive_integer____to_float(NODE *node, float *result_p);
static int negative_integer____to_double(NODE *node, double *result_p);
static int negative_integer____to_float(NODE *node, float *result_p);
static int std_types___real____to_double(NODE *node, double *result_p);
static int std_types___real____to_float(NODE *node, float *result_p);
static int std_types___positive_integer____to_int(NODE *node, int *result_p);
static int negative_integer____to_int(NODE *node, int *result_p);
static int std_types___positive_integer____to_long(NODE *node, long *result_p);
static int negative_integer____to_long(NODE *node, long *result_p);
static int std_types___positive_integer____to_uint(NODE *node, uint *result_p);
static int std_types___positive_integer____to_ulong(NODE *node, unsigned long *result_p);
static int std_types___positive_integer____to_int8(NODE *node, int8_t *result_p);
static int negative_integer____to_int8(NODE *node, int8_t *result_p);
static int std_types___positive_integer____to_int16(NODE *node, int16_t *result_p);
static int negative_integer____to_int16(NODE *node, int16_t *result_p);
static int std_types___positive_integer____to_int32(NODE *node, int32_t *result_p);
static int negative_integer____to_int32(NODE *node, int32_t *result_p);
static int std_types___positive_integer____to_int64(NODE *node, int64_t *result_p);
static int negative_integer____to_int64(NODE *node, int64_t *result_p);
static int std_types___positive_integer____to_uint8(NODE *node, uint8_t *result_p);
static int std_types___positive_integer____to_uint16(NODE *node, uint16_t *result_p);
static int std_types___positive_integer____to_uint32(NODE *node, uint32_t *result_p);
static int std_types___positive_integer____to_uint64(NODE *node, uint64_t *result_p);
static void *std_types___object____collect(SIMPLE_NODE *node);
static long std_types___object____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___file_type____collect(FILE_TYPE *node);
static long std_types___file_type____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___file_descriptor____collect(FILE_DESCRIPTOR *node);
static long std_types___file_descriptor____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___shutdown_type____collect(SHUTDOWN_TYPE *node);
static long std_types___shutdown_type____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___device_id____collect(DEVICE_ID *node);
static long std_types___device_id____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___directory____collect(DIRECTORY *node);
static long std_types___directory____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___group_id____collect(GROUP_ID *node);
static long std_types___group_id____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___inode_number____collect(INODE_NUMBER *node);
static long std_types___inode_number____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___process_id____collect(PROCESS_ID *node);
static long std_types___process_id____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___user_id____collect(USER_ID *node);
static long std_types___user_id____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___error_number____collect(ERROR_NUMBER *node);
static long std_types___error_number____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___octet_string____collect(OCTET_STRING *node);
static void *quad_octet_string____collect(QUAD_OCTET_STRING *node);
static long std_types___octet_string____debug_string(NODE *node, int indent, int max_depth, char *buf);
static long quad_octet_string____debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types___octet_string____get_item_of(NODE *node, long idx, NODE **result_p);
static int quad_octet_string____get_item_of(NODE *node, long idx, NODE **result_p);
static int std_types___octet_string____to_c_string(NODE *node, char **result_p);
static int std_types___octet_string____to_octets(NODE *node, const uint8_t **buf_p, long *size_p);
static int std_types___octet_string____length_of(NODE *node, long *result_p);
static int quad_octet_string____length_of(NODE *node, long *result_p);
static void *std_types___terminal_attributes____collect(TERMINAL_ATTRIBUTES *node);
static long std_types___terminal_attributes____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple2____collect(TUPLE2 *node);
static long builtin___tuple2____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple3____collect(TUPLE3 *node);
static long builtin___tuple3____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple4____collect(TUPLE4 *node);
static long builtin___tuple4____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple5____collect(TUPLE5 *node);
static long builtin___tuple5____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple6____collect(TUPLE6 *node);
static long builtin___tuple6____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple7____collect(TUPLE7 *node);
static long builtin___tuple7____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin___tuple8____collect(TUPLE8 *node);
static long builtin___tuple8____debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types___undefined____collect(SIMPLE_NODE *node);
static long std_types___undefined____debug_string(NODE *node, int indent, int max_depth, char *buf);
static uint32_t to_upper_case(uint32_t chr);
static uint32_t to_lower_case(uint32_t chr);
static uint32_t to_title_case(uint32_t chr);
static void *std_types___unique_item____collect(UNIQUE_ITEM *node);
static long std_types___unique_item____debug_string(NODE *node, int indent, int max_depth, char *buf);

int to_int8
  (
    NODE *node, int8_t *result_p
  )
  {
    return node->attributes->vtable->to_int8(node, result_p);
  }

int to_int16
  (
    NODE *node, int16_t *result_p
  )
  {
    return node->attributes->vtable->to_int16(node, result_p);
  }

int to_int32
  (
    NODE *node, int32_t *result_p
  )
  {
    return node->attributes->vtable->to_int32(node, result_p);
  }

int to_int64
  (
    NODE *node, int64_t *result_p
  )
  {
    return node->attributes->vtable->to_int64(node, result_p);
  }

int to_uint8
  (
    NODE *node, uint8_t *result_p
  )
  {
    return node->attributes->vtable->to_uint8(node, result_p);
  }

int to_uint16
  (
    NODE *node, uint16_t *result_p
  )
  {
    return node->attributes->vtable->to_uint16(node, result_p);
  }

int to_uint32
  (
    NODE *node, uint32_t *result_p
  )
  {
    return node->attributes->vtable->to_uint32(node, result_p);
  }

int to_uint64
  (
    NODE *node, uint64_t *result_p
  )
  {
    return node->attributes->vtable->to_uint64(node, result_p);
  }

int to_uchar32
  (
    NODE *node, uint32_t *result_p
  )
  {
    return node->attributes->vtable->to_uchar32(node, result_p);
  }

int to_bool
  (
    NODE *node, int *result_p
  )
  {
    return node->attributes->vtable->to_bool(node, result_p);
  }

int to_int
  (
    NODE *node, int *result_p
  )
  {
    return node->attributes->vtable->to_int(node, result_p);
  }

int to_uint
  (
    NODE *node, unsigned int *result_p
  )
  {
    return node->attributes->vtable->to_uint(node, result_p);
  }

int to_long
  (
    NODE *node, long *result_p
  )
  {
    return node->attributes->vtable->to_long(node, result_p);
  }

int to_ulong
  (
    NODE *node, unsigned long *result_p
  )
  {
    return node->attributes->vtable->to_ulong(node, result_p);
  }

int to_float
  (
    NODE *node, float *result_p
  )
  {
    return node->attributes->vtable->to_float(node, result_p);
  }

int to_double
  (
    NODE *node, double *result_p
  )
  {
    return node->attributes->vtable->to_double(node, result_p);
  }

int to_c_string
  (
    NODE *node, char **result_p
  )
  {
    return node->attributes->vtable->to_c_string(node, result_p);
  }

int to_octets
  (
    NODE *node, const uint8_t** buf_p, long *size_p
  )
  {
    return node->attributes->vtable->to_octets(node, buf_p, size_p);
  }

int get_item_of
  (
    NODE *node, long idx, NODE **result_p
  )
  {
    return node->attributes->vtable->get_item_of(node, idx, result_p);
  }

int length_of
  (
    NODE *node, long *result_p
  )
  {
    return node->attributes->vtable->length_of(node, result_p);
  }

int unfold
  (
    NODE *node
  )
  {
    return node->attributes->vtable->unfold(node);
  }

int debug_string
  (
    NODE *node, int indent, int max_depth, char *buf
  )
  {
    return node->attributes->vtable->debug_string(node, indent, max_depth, buf);
  }

static void *collect_array_info
  (
    ARRAY_INFO *info
  )
  {
    ARRAY_INFO *new_info = info;
    long size = info->dimension_count; // might be garbage if already collected
    int is_collected = IS_COLLECTED(info);
    if (is_collected) {
      void *new_location = *(void **)info;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_info = allocate(ALLOCATION_SIZE(sizeof(ARRAY_INFO)+size*sizeof(long)));
      new_info->dimension_count = info->dimension_count;
      memcpy(new_info->dimensions, info->dimensions, size*sizeof(long));
    }
    if (is_collected) *(void **)info = ENCODE_TO_LENGTH(new_info);
    return new_info;
  }

static void *collect_dimension_info
  (
    DIMENSION_INFO *info
  )
  {
    DIMENSION_INFO *new_info = info;
    int is_collected = IS_COLLECTED(info);
    if (is_collected) {
      void *new_location = *(void **)info;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_info = allocate(sizeof(DIMENSION_INFO));
      new_info->first_index = info->first_index;
      new_info->width = info->width;
    }
    if (is_collected) *(void **)info = ENCODE_TO_LENGTH(new_info);
    return new_info;
  }

static void *collect_array_view
  (
    ARRAY_VIEW *view
  )
  {
    ARRAY_VIEW *new_view = view;
    long size = view->dimension_count; // might be garbage if already collected
    int is_collected = IS_COLLECTED(view);
    if (is_collected) {
      void *new_location = *(void **)view;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_view = allocate(ALLOCATION_SIZE(sizeof(ARRAY_VIEW)+size*sizeof(DIMENSION_INFO)));
      new_view->dimension_count = view->dimension_count;
      memcpy(new_view->dimensions, view->dimensions, size*sizeof(DIMENSION_INFO));
    }
    if (is_collected) *(void **)view = ENCODE_TO_LENGTH(new_view);
    return new_view;
  }

static void *collect_array_updates
  (
    ARRAY_UPDATES *updates
  )
  {
    if (!updates) return updates;
    ARRAY_UPDATES *new_updates = updates;
    long size = updates->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(updates);
    if (is_collected) {
      void *new_location = *(void **)updates;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_updates = allocate(ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+size*sizeof(char)));
      new_updates->size = size;
      new_updates->length = size;
      memcpy(new_updates->buffer, updates->buffer, size*sizeof(char));
    } else {
      if (!IS_STATIC(updates)) {
	if (IS_ALREADY_MARKED(updates)) return updates;
	MARK(updates)
      }
    }
    if (is_collected) *(void **)updates = ENCODE_TO_LENGTH(new_updates);
    return new_updates;
  }

static ARRAY_VIEW *create_array_view
  (
    int dimension_count
  )
  {
    ARRAY_VIEW *view =
      allocate(ALLOCATION_SIZE(
	sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
    view->dimension_count = dimension_count;
    for (int i = 0; i < dimension_count; ++i) {
      long dimension;
      if (!to_long(TLS_arguments[i], &dimension)) return NULL;
      if (dimension < 1) {
	invalid_arguments();
	return NULL;
      }
      view->dimensions[i].first_index = 0;
      view->dimensions[i].width = dimension;
    }
    return view;
  }

static ARRAY_VIEW *create_new_array_view
  (
    ARRAY_VIEW *view
  )
  {
    int dimension_count = view->dimension_count;
    ARRAY_VIEW *new_view =
      allocate(ALLOCATION_SIZE(
	sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
    new_view->dimension_count = dimension_count;
    for (int i = 0; i < dimension_count; ++i) {
      new_view->dimensions[i].first_index = 0;
      new_view->dimensions[i].width = view->dimensions[i].width;
    }
    return new_view;
  }

static ARRAY_DATA *create_array_info_and_data
  (
    ARRAY_VIEW *view,
    int item_size
  )
  {
    int dimension_count = view->dimension_count;
    ARRAY_INFO *info =
      allocate(
	ALLOCATION_SIZE(sizeof(ARRAY_INFO)+dimension_count*sizeof(long)));
    info->dimension_count = dimension_count;
    long size = 1;
    for (int i = dimension_count-1; i >= 0; --i) {
      info->dimensions[i] = size;
      size *= view->dimensions[i].width;
    }
    ARRAY_DATA *data =
      allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
    data->info = info;
    data->size = size;
    return data;
  }

static ARRAY_DATA *create_array_data
  (
    ARRAY_INFO *info,
    long size,
    int item_size
  )
  {
    ARRAY_DATA *data =
      allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
    data->info = info;
    data->size = size;
    return data;
  }

static void *copy_array
  (
    ARRAY_VIEW *source_view,
    ARRAY_DATA *source_data,
    long source_offset,
    int i,
    int item_size,
    void *destination
  )
  {
    int dimension_count = source_view->dimension_count;
    long first_index = source_view->dimensions[i].first_index;
    long width = source_view->dimensions[i].width;
    if (i == dimension_count-1) {
      // last dimension
      source_offset += first_index;
      memcpy(
	destination,
	(char *)source_data->items+source_offset*item_size,
	width*item_size);
      return (char *)destination+width*item_size;
    } else {
      long dimension = source_data->info->dimensions[i];
      source_offset += first_index*dimension;
      while (--width >= 0) {
	destination = copy_array(
	  source_view, source_data, source_offset, i+1, item_size,
	  destination);
	source_offset += dimension;
      }
      return destination;
    }
  }

static ARRAY_DATA *new_array_data
  (
    ARRAY_INFO *info,
    int item_size
  )
  {
    int dimension_count = info->dimension_count;
    long size = info->dimensions[0];
    for (int i = 1; i < dimension_count; ++i) {
      size *= info->dimensions[i];
    }
    ARRAY_DATA *data =
      allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
    data->info = info;
    data->size = size;
    return data;
  }

static ARRAY_VIEW *create_sub_view
  (
    ARRAY_VIEW *view
  )
  {
    int dimension_count = view->dimension_count;
    ARRAY_VIEW *sub_view =
      allocate(ALLOCATION_SIZE(
	sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
    sub_view->dimension_count = dimension_count;
    int i;
    for (i = 0; i < dimension_count; ++i) {
      NODE *argument = TLS_arguments[1+i];
      if ((argument)->type != std_types___value_range.type) {
	invalid_arguments();
	return NULL;
      }
      long first;
      long last;
      if (
	!to_long(argument->tuple2.node_0, &first) ||
	!to_long(argument->tuple2.node_1, &last)
      ) {
	invalid_arguments();
	return NULL;
      }
      if (first < 0) {
	first += view->dimensions[i].width;
      } else {
	--first;
      }

      if (last < 0) {
	last += view->dimensions[i].width;
      } else {
	--last;
      }
      if (
	first < 0 || first >= view->dimensions[i].width ||
	last < 0 || last >= view->dimensions[i].width ||
	first > last
      ) {
	invalid_arguments();
	return NULL;
      }
      sub_view->dimensions[i].first_index =
	view->dimensions[i].first_index+first;
      sub_view->dimensions[i].width = last-first+1;
    }
    return sub_view;
  }

static void *add_update
  (
    ARRAY *node,
    long item_size
  )
  {
    long length = node->updates_length;
    ARRAY_UPDATES *updates = node->updates;
    if (length == 0) {
      long size = ALLOCATION_SIZE(item_size);
      updates = allocate_large(sizeof(ARRAY_UPDATES)+size);
      updates->size = size;
      updates->length = length+item_size;
    } else if (
      length != node->updates->length ||
      length+item_size > node->updates->size
    ) {
      long size = ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+2*length+item_size);
      updates = allocate_large(size);
      updates->size = size;
      memcpy(updates->buffer, node->updates->buffer, length);
    }
    updates->length = length+item_size;
    ARRAY *new_node = allocate(sizeof(ARRAY));
    new_node->type = node->type;
    new_node->attributes = node->attributes;
    new_node->updates_length = length+item_size;
    new_node->data = node->data;
    new_node->view = node->view;
    new_node->updates = updates;
    return new_node;
  }

static long compute_array_read_offset
  (
    NODE *array,
    ARRAY_INFO *info,
    ARRAY_VIEW *view
  )
  {
    long offset = 0;
    int i = 0;
    long idx;
    next:
    if (!to_long(TLS_arguments[i], &idx)) return -1;
    if (idx < 0) {
      idx += view->dimensions[i].width;
    } else {
      --idx;
    }
    if (idx < 0 || idx >= view->dimensions[i].width) {
      invalid_index(array);
      return -1;
    }
    idx += view->dimensions[i].first_index;
    offset += idx*info->dimensions[i];
    if (++i >= view->dimension_count) return offset;
    goto next;
  }

static long compute_array_write_offset
  (
    NODE *array,
    ARRAY_INFO *info,
    ARRAY_VIEW *view
  )
  {
    long offset = 0;
    int i = 0;
    long idx;
    next:
    if (!to_long(TLS_arguments[i], &idx)) return -1;
    if (idx < 0) {
      idx += view->dimensions[i].width;
    } else {
      --idx;
    }
    if (idx < 0 || idx >= view->dimensions[i].width) {
      invalid_index(array);
      return -1;
    }
    offset += idx;
    if (++i >= view->dimension_count) return offset;
    offset *= view->dimensions[i].width;
    goto next;
  }

static long array_debug_string
  (
    ARRAY_INFO *info,
    ARRAY_VIEW *view,
    int indent,
    char *buf,
    const char *typename
  )
  {
    char type[1024];
    char *p = type;
    print(&p, "<%s_array(", typename);
    int i;
    int dimension_count = view->dimension_count;
    for (i = 0; i < dimension_count; ++i) {
      if (i) *p++ = ' ';
      print(&p,
	"%d..%d",
	view->dimensions[i].first_index+1,
	view->dimensions[i].first_index+view->dimensions[i].width
      );
    }
    *p++ = ')';
    *p++ = '>';
    *p = 0;
    return debug_print(indent, buf, type);
  }

static int equal_array_type
  (
    NODE *left,
    NODE *right
  )
  {
    if ((left)->type != (right)->type) {
      error:
      invalid_arguments();
      return false;
    }
    ARRAY_VIEW *left_view = ((ARRAY *)left)->view;
    ARRAY_VIEW *right_view = ((ARRAY *)right)->view;
    if (
      left_view->dimension_count != right_view->dimension_count
    ) goto error;
    int i;
    for (i = 0; i < left_view->dimension_count; ++i) {
      if (
	left_view->dimensions[i].width != right_view->dimensions[i].width
      ) goto error;
    }
    return true;
  }

static void *collect_array_data
  (
    ARRAY_DATA *data
  )
  {
    if (!data) return data;
    ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*sizeof(NODE *)));
      new_data->size = size;
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    int i;
    for (i = 0; i < size; ++i) {
      new_data->items[i] = collect_node(data->items[i]);
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___array____collect
  (
    ARRAY *node
  )
  {
    ARRAY *new_node;
    new_node = allocate(sizeof(ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static ARRAY_DATA *apply_array_updates(ARRAY *node)
  {
    ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(NODE *));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(NODE *), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->array.data->info, node->array.view,
      indent, buf, "");
  }

static void *collect_boolean_array_data
  (
    BOOLEAN_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    BOOLEAN_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___boolean_array____collect
  (
    BOOLEAN_ARRAY *node
  )
  {
    BOOLEAN_ARRAY *new_node;
    new_node = allocate(sizeof(BOOLEAN_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_boolean_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static BOOLEAN_ARRAY_DATA *apply_boolean_array_updates(BOOLEAN_ARRAY *node)
  {
    BOOLEAN_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (BOOLEAN_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___boolean_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->boolean_array.data->info, node->boolean_array.view,
      indent, buf, "boolean");
  }

static void *collect_character_array_data
  (
    CHARACTER_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    CHARACTER_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(CHARACTER_ARRAY_DATA)+size*sizeof(uint32_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___character_array____collect
  (
    CHARACTER_ARRAY *node
  )
  {
    CHARACTER_ARRAY *new_node;
    new_node = allocate(sizeof(CHARACTER_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_character_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static CHARACTER_ARRAY_DATA *apply_character_array_updates(CHARACTER_ARRAY *node)
  {
    CHARACTER_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (CHARACTER_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint32_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint32_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___character_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->character_array.data->info, node->character_array.view,
      indent, buf, "uchar32");
  }

static void *collect_int8_array_data
  (
    INT8_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT8_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT8_ARRAY_DATA)+size*sizeof(int8_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int8_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___int8_array____collect
  (
    INT8_ARRAY *node
  )
  {
    INT8_ARRAY *new_node;
    new_node = allocate(sizeof(INT8_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int8_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT8_ARRAY_DATA *apply_int8_array_updates(INT8_ARRAY *node)
  {
    INT8_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT8_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int8_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int8_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___int8_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int8_array.data->info, node->int8_array.view,
      indent, buf, "int8");
  }

static long int8_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT8_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT8_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int8_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint8_array_data
  (
    UINT8_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT8_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint8_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___uint8_array____collect
  (
    UINT8_ARRAY *node
  )
  {
    UINT8_ARRAY *new_node;
    new_node = allocate(sizeof(UINT8_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint8_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT8_ARRAY_DATA *apply_uint8_array_updates(UINT8_ARRAY *node)
  {
    UINT8_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT8_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint8_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint8_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___uint8_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint8_array.data->info, node->uint8_array.view,
      indent, buf, "uint8");
  }

static ulong uint8_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT8_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT8_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    ulong result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint8_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_int16_array_data
  (
    INT16_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT16_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT16_ARRAY_DATA)+size*sizeof(int16_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int16_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___int16_array____collect
  (
    INT16_ARRAY *node
  )
  {
    INT16_ARRAY *new_node;
    new_node = allocate(sizeof(INT16_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int16_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT16_ARRAY_DATA *apply_int16_array_updates(INT16_ARRAY *node)
  {
    INT16_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT16_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int16_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int16_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___int16_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int16_array.data->info, node->int16_array.view,
      indent, buf, "int16");
  }

static long int16_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT16_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT16_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int16_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint16_array_data
  (
    UINT16_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT16_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint16_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___uint16_array____collect
  (
    UINT16_ARRAY *node
  )
  {
    UINT16_ARRAY *new_node;
    new_node = allocate(sizeof(UINT16_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint16_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT16_ARRAY_DATA *apply_uint16_array_updates(UINT16_ARRAY *node)
  {
    UINT16_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT16_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint16_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint16_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___uint16_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint16_array.data->info, node->uint16_array.view,
      indent, buf, "uint16");
  }

static ulong uint16_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT16_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT16_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    ulong result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint16_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_int32_array_data
  (
    INT32_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT32_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT32_ARRAY_DATA)+size*sizeof(int32_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___int32_array____collect
  (
    INT32_ARRAY *node
  )
  {
    INT32_ARRAY *new_node;
    new_node = allocate(sizeof(INT32_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int32_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT32_ARRAY_DATA *apply_int32_array_updates(INT32_ARRAY *node)
  {
    INT32_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT32_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int32_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int32_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___int32_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int32_array.data->info, node->int32_array.view,
      indent, buf, "int32");
  }

static long int32_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT32_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT32_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int32_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint32_array_data
  (
    UINT32_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT32_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___uint32_array____collect
  (
    UINT32_ARRAY *node
  )
  {
    UINT32_ARRAY *new_node;
    new_node = allocate(sizeof(UINT32_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint32_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT32_ARRAY_DATA *apply_uint32_array_updates(UINT32_ARRAY *node)
  {
    UINT32_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT32_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint32_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint32_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___uint32_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint32_array.data->info, node->uint32_array.view,
      indent, buf, "uint32");
  }

static ulong uint32_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT32_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT32_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    ulong result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint32_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_int64_array_data
  (
    INT64_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT64_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT64_ARRAY_DATA)+size*sizeof(int64_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int64_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___int64_array____collect
  (
    INT64_ARRAY *node
  )
  {
    INT64_ARRAY *new_node;
    new_node = allocate(sizeof(INT64_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int64_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT64_ARRAY_DATA *apply_int64_array_updates(INT64_ARRAY *node)
  {
    INT64_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT64_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int64_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int64_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___int64_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int64_array.data->info, node->int64_array.view,
      indent, buf, "int64");
  }

static long int64_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT64_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT64_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int64_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint64_array_data
  (
    UINT64_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT64_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint64_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___uint64_array____collect
  (
    UINT64_ARRAY *node
  )
  {
    UINT64_ARRAY *new_node;
    new_node = allocate(sizeof(UINT64_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint64_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT64_ARRAY_DATA *apply_uint64_array_updates(UINT64_ARRAY *node)
  {
    UINT64_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT64_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint64_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint64_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___uint64_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint64_array.data->info, node->uint64_array.view,
      indent, buf, "uint64");
  }

static ulong uint64_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT64_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT64_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    ulong result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint64_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_float32_array_data
  (
    FLOAT32_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    FLOAT32_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(FLOAT32_ARRAY_DATA)+size*sizeof(float)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(float));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___float32_array____collect
  (
    FLOAT32_ARRAY *node
  )
  {
    FLOAT32_ARRAY *new_node;
    new_node = allocate(sizeof(FLOAT32_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_float32_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static FLOAT32_ARRAY_DATA *apply_float32_array_updates(FLOAT32_ARRAY *node)
  {
    FLOAT32_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (FLOAT32_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(float));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(float), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___float32_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float32_array.data->info, node->float32_array.view,
      indent, buf, "float32");
  }

static double float32_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    FLOAT32_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    FLOAT32_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    double result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += float32_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_float64_array_data
  (
    FLOAT64_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    FLOAT64_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(FLOAT64_ARRAY_DATA)+size*sizeof(double)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(double));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___float64_array____collect
  (
    FLOAT64_ARRAY *node
  )
  {
    FLOAT64_ARRAY *new_node;
    new_node = allocate(sizeof(FLOAT64_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_float64_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static FLOAT64_ARRAY_DATA *apply_float64_array_updates(FLOAT64_ARRAY *node)
  {
    FLOAT64_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (FLOAT64_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(double));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(double), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types___float64_array____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float64_array.data->info, node->float64_array.view,
      indent, buf, "float64");
  }

static double float64_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    FLOAT64_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    FLOAT64_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    double result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += float64_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static int std_types___true____to_bool
  (
    NODE *node,
    int *result_p
  )
  {
    *result_p = true;
    return true;
  }

static long std_types___true____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "true");
  }

static int std_types___false____to_bool
  (
    NODE *node,
    int *result_p
  )
  {
    *result_p = false;
    return true;
  }

static long std_types___false____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "false");
  }

NODE *from_bool
  (
    int val
  )
  {
    if (val)
      return (NODE *)&std_types___true;
    else
      return (NODE *)&std_types___false;
  }

static void *c_function____collect
  (
    C_FUNCTION *node
  )
  {
    C_FUNCTION *new_node;
    new_node = allocate(sizeof(C_FUNCTION));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->parameter_count = node->parameter_count;
    return new_node;
  }

static long c_function____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<c function>");
  }

NODE *create_c_function
  (
    FUNC func,
    int par_cnt
  )
  {
    NODE *node = create__c_function(par_cnt);
    node->type = func;
    return node;
  }

static void *std_types___character____collect
  (
    CHARACTER *node
  )
  {
    CHARACTER *new_node;
    new_node = allocate(sizeof(CHARACTER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->code = node->code;
    return new_node;
  }

NODE *from_uchar32
  (
    uint32_t code
  )
  {
    return create__std_types___character(code);
  }

static uint32_t std_types___character____to_uchar32
  (
    NODE *node,
    uint32_t *result_p
  )
  {
    *result_p = node->character.code;
    return true;
  }

static long std_types___character____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    if (node->character.code == '@') {
      return debug_print(indent, buf, "'@@'");
    } else if (node->character.code == '\'') {
      return debug_print(indent, buf, "'@apos;'");
    } else if (
      node->character.code >= 0x20 && node->character.code < 0x7f /*||
      node->character.code >= 0xa0 && node->character.code < 0x100*/
    ) {
      return debug_print(indent, buf, "'%c'", node->character.code);
    } else {
      return debug_print(indent, buf, "'@0x%x;'", node->character.code);
    }
  }

static void *std_types___date_and_time____collect
  (
    DATE_AND_TIME *node
  )
  {
    DATE_AND_TIME *new_node;
    new_node = allocate(sizeof(DATE_AND_TIME));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->seconds = node->seconds;
    new_node->nanoseconds = node->nanoseconds;
    return new_node;
  }

static long std_types___date_and_time____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<date and time %d.%09d>",
      node->date_and_time.seconds, node->date_and_time.nanoseconds);
  }

static void year_month_day
  (
    NODE *node,
    int *year_p,
    int *month_p,
    int *day_p
  )
  {
    long days;
    int year, month, day, quads;
    int is_a_leap_year;
    days = node->date_and_time.seconds/86400;
    is_a_leap_year = false;
    if (days < 730) { // 1970, 1971
      year = days/365;
      days -= 365*year;
      year += 1970;
    } else { // 1972 and later
      days -= 730;
      quads = days/1461;
      days -= 1461*quads;
      year = 1972+4*quads;
      if (days >= 1096) {
	year += 3;
	days -= 1096;
      } else if (days >= 731) {
	year += 2;
	days -= 731;
      } else if (days >= 366) {
	++year;
	days -= 366;
      } else {
	is_a_leap_year = true;
      }
    }
    month = 1;
    if (days < 31) goto done; // January
    days -= 31;
    ++month;
    if (is_a_leap_year) {
      if (days < 29) goto done; // February
      days -= 29;
    } else {
      if (days < 28) goto done; // February
      days -= 28;
    }
    ++month;
    if (days < 31) goto done; // March
    days -= 31;
    ++month;
    if (days < 30) goto done; // April
    days -= 30;
    ++month;
    if (days < 31) goto done; // May
    days -= 31;
    ++month;
    if (days < 30) goto done; // June
    days -= 30;
    ++month;
    if (days < 31) goto done; // July
    days -= 31;
    ++month;
    if (days < 31) goto done; // August
    days -= 31;
    ++month;
    if (days < 30) goto done; // September
    days -= 30;
    ++month;
    if (days < 31) goto done; // October
    days -= 31;
    ++month;
    if (days < 30) goto done; // November
    days -= 30;
    ++month; // December
    done:
    if (year_p) *year_p = year;
    if (month_p) *month_p = month;
    if (day_p) *day_p = days+1;
  }

extern char **environ;

void initialize_environment
  (
    void
  )
  {
    memcpy(
      (NODE *)&std___program_name, from_c_string(main_argv[0]),
      sizeof(std___program_name));
    NODE *args = create_list(main_argc-1);
    int i;
    for (i = 1; i < main_argc; ++i) {
      set_list_item(args, i-1, from_c_string(main_argv[i]));
    }
    memcpy(
      (NODE *)&std___command_line_arguments, args,
      sizeof(std___command_line_arguments));
    char **p = environ;
    while (*p++);
    int n = p-environ-1;
    NODE *env_vars = create_list(n);
    for (i = 0; i < n; ++i) {
      set_list_item(env_vars, i, from_c_string(environ[i]));
    }
    memcpy(
      (NODE *)&std___environment_variables, env_vars,
      sizeof(std___environment_variables));
  }

static MESSAGE_TEXT *collect_message_text
  (
    MESSAGE_TEXT *text
  )
  {
    if (!text) return text;
    MESSAGE_TEXT *new_text = text;
    long size = text->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(text);
    if (is_collected) {
      void *new_location = *(void **)text;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_text = allocate(ALLOCATION_SIZE(sizeof(MESSAGE_TEXT)+size*sizeof(char)));
      new_text->size = size;
      memcpy(new_text->text, text->text, size*sizeof(char));
    } else {
      if (!IS_STATIC(text)) {
	if (IS_ALREADY_MARKED(text)) return text;
	MARK(text)
      }
    }
    if (is_collected) *(void **)text = ENCODE_TO_LENGTH(new_text);
    return new_text;
  }

static FUNC_DATA *collect_func_data
  (
    FUNC_DATA *data
  )
  {
    if (!data) return data;
    FUNC_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(FUNC_DATA)+size*sizeof(const TAB_NUM *)));
      new_data->length = size;
      memcpy(new_data->entries, data->entries, size*sizeof(const TAB_NUM *));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___error____collect
  (
    ERROR *node
  )
  {
    ERROR *new_node;
    new_node = allocate(sizeof(ERROR));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->err_no = node->err_no;
    new_node->attr_idx = node->attr_idx;
    new_node->instruction_counter = node->instruction_counter;
    new_node->category = collect_node(node->category);
    new_node->message = collect_message_text(node->message);
    new_node->object = collect_node(node->object);
    new_node->data = collect_func_data(node->data);
    return new_node;
  }

static long std_types___error____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    if (max_depth <= 1) {
      if (node->error.err_no) {
	return debug_print(
	  indent, buf, "<%s - %s>",
	  node->error.message->text, strerror(node->error.err_no));
      } else if (node->error.attr_idx) {
	return debug_print(
	  indent, buf, "<%s - %s>",
	  node->error.message->text, poly_name(node->error.attr_idx));
      } else {
	return debug_print(indent, buf, "<%s>", node->error.message->text);
      }
    } else {
      FUNC_DATA *data = node->error.data;
      long n, len;
      long i;
      n = debug_print_indent(&indent, &buf);
      if (node->error.err_no) {
	if (node->error.instruction_counter) {
	  n += print(
	    &buf, "%s - %s! (instruction counter: %ld)\n",
	    node->error.message->text, strerror(node->error.err_no),
	    node->error.instruction_counter);
	} else {
	  n += print(
	    &buf, "%s - %s!\n",
	    node->error.message->text, strerror(node->error.err_no));
	}
      } else if (node->error.attr_idx) {
	if (node->error.instruction_counter) {
	  n += print(
	    &buf, "%s (%s)! (instruction counter: %ld)\n",
	    node->error.message->text,
	    poly_name(node->error.attr_idx),
	    node->error.instruction_counter);
	} else {
	  n += print(
	    &buf, "%s (%s)!\n",
	    node->error.message->text,
	    poly_name(node->error.attr_idx));
	}
      } else {
	if (node->error.instruction_counter) {
	  n += print(
	    &buf, "%s! (instruction counter: %ld)\n",
	    node->error.message->text, node->error.instruction_counter);
	} else {
	  n += print(&buf, "%s!\n", node->error.message->text);
	}
      }
      if (node->error.object) {
	n += print(&buf, "%son object ", indent_to_string(indent));
	len = debug_string(node->error.object, indent, 1, buf);
	if (buf) buf += len;
	n += len;
      }
      const char *contents_indent = indent_to_string(indent);
      --max_depth;
      if (data->length < max_depth) {
	max_depth = data->length;
      }
      n += print(&buf, contents_indent);
      n += print(&buf, "stack trace:\n");
      for (i = 0; i < max_depth; ++i) {
	const char *module_name, *function_name;
	int line_no, column_no;
	const TAB_NUM *code = data->entries[i];
	n += print(&buf, contents_indent);
	retrieve_continuation_info(
	  code, &module_name, &function_name, &line_no, &column_no);
	if (function_name) {
	  n += print(&buf, "%s ", function_name);
	} else {
	  n += print(&buf, "<anonymous function> ");
	}
	n += print(&buf, "(called from %s", module_name);
	if (line_no > 0) {
	  n += print(&buf, ", line: %d, column: %d", line_no, column_no);
	}
	n += print(&buf, ")\n");
      }
      return n;
    }
  }

int propagate_error
  (
    NODE *node
  )
  {
    {
      NODE *result__node = (NODE *)(node);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
    return false;
  }

extern const TAB_NUM *tail_call_stack[256];
extern const TAB_NUM **tail_call_sp;
extern int do_dump_errors;

void print_code_reference
  (
    const TAB_NUM *code
  )
  {
    const char *module_name, *function_name;
    int line_no, column_no;
    retrieve_continuation_info(
      code, &module_name, &function_name, &line_no, &column_no);
    if (function_name) {
      fprintf(stderr, "%s ", function_name);
    } else {
      fprintf(stderr, "<anonymous function> ");
    }
    fprintf(stderr, "(called from %s", module_name);
    if (line_no > 0) {
      fprintf(stderr, ", line: %d, column: %d", line_no, column_no);
    }
    fprintf(stderr, ")\n");
  }

void create_error_message
  (
    NODE *category,
    const char *msg,
    int err_no,
    int attr_idx,
    NODE *node
  )
  {
    NODE *err = NULL;
    int i;
    for (i = 0; i < TLS_argument_count; ++i) {
      if (TLS_arguments[i]->type == std_types___error.type) {
	err = TLS_arguments[i];
	break;
      }
    }
    if (!err) {
      if (do_dump_errors) {
	fprintf(stderr, "create error message \"%s\"\n", msg);
      }
      long size = ALLOCATION_SIZE(strlen(msg)+1);
      MESSAGE_TEXT *message = allocate(sizeof(MESSAGE_TEXT)+size);
      message->size = size;
      strcpy(message->text, msg);
      TLS_frame->code = TLS_code; // this was not initialized by the caller!
      long n = tail_call_sp-tail_call_stack;
      FRAME *trace = TLS_frame;
      while (trace) {
	++n;
	trace = trace->link;
      }
      FUNC_DATA *data = allocate_large(sizeof(FUNC_DATA)+n*sizeof(TAB_NUM *));
      data->length = n;
      n = 0;
      while (tail_call_sp > tail_call_stack) {
	const TAB_NUM *code = *--tail_call_sp;
	if (do_dump_errors) {
	  fprintf(stderr, "tail call: ");
	  print_code_reference(code);
	}
	data->entries[n++] = code;
      }
      trace = TLS_frame;
      while (trace) {
	if (do_dump_errors) print_code_reference(trace->code);
	data->entries[n++] = trace->code;
	trace = trace->link;
      }
      err =
	create__std_types___error(category, message, err_no, attr_idx, node, instruction_counter, data);
    }
    if (TLS_result_count < 1) TLS_result_count = 1;
    TLS_argument_count = TLS_result_count;
    for (i = 0; i < TLS_result_count; ++i) {
      TLS_arguments[i] = err;
    }
    {
      return;
    }
  }

static int std_types___object____to_int8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_int8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_int16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_int16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_int32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_int32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_int64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_int64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_uint8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_uint8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_uint16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_uint16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_uint32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_uint32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_uint64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_uint64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_uchar32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A CHARACTER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_uchar32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A CHARACTER", 0, 0, node);
    return false;
  }

static int std_types___object____to_bool
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A BOOLEAN", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_bool
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A BOOLEAN", 0, 0, node);
    return false;
  }

static int std_types___object____to_int
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_int
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_uint
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_uint
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_long
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_long
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_ulong
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_ulong
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types___object____to_double
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A NUMBER", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_double
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A NUMBER", 0, 0, node);
    return false;
  }

static int std_types___object____to_c_string
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_c_string
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types___object____to_octets
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types___undefined____to_octets
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types___object____get_item_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE UNDEFINED INTERNAL FUNCTION \"get_item_of\"",
      0, 0, node);
    return false;
  }

static int std_types___undefined____get_item_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE INTERNAL FUNCTION \"get_item_of\" ON AN UNDEFINED OBJECT", 0, 0, node);
    return false;
  }

static int std_types___object____length_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE UNDEFINED INTERNAL FUNCTION \"length_of\"",
      0, 0, node);
    return false;
  }

static int std_types___undefined____length_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE INTERNAL FUNCTION \"length_of\" ON AN UNDEFINED OBJECT", 0, 0, node);
    return false;
  }

static int std_types___object____unfold
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE UNDEFINED INTERNAL FUNCTION \"unfold\"",
      0, 0, node);
    return false;
  }

static int std_types___undefined____unfold
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE INTERNAL FUNCTION \"unfold\" ON AN UNDEFINED OBJECT", 0, 0, node);
    return false;
  }

void no_such_function
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "NO SUCH FUNCTION", 0, 0, NULL);
  }

void too_few_arguments
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "TOO FEW ARGUMENTS", 0, 0, NULL);
  }

void too_many_arguments
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "TOO MANY ARGUMENTS", 0, 0, NULL);
  }

void invalid_arguments
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "INVALID ARGUMENTS", 0, 0, NULL);
  }

void result_count_mismatch
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "RESULT COUNT MISMATCH", 0, 0, NULL);
  }

void too_few_results
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "TOO FEW RESULTS", 0, 0, NULL);
  }

void too_many_results
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "TOO MANY RESULTS", 0, 0, NULL);
  }

void invalid_results
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "INVALID RESULTS", 0, 0, NULL);
  }

void invalid_index
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "INVALID INDEX", 0, 0, node);
  }

void invalid_dimension
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "INVALID DIMENSION", 0, 0, node);
  }

void divide_by_zero
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "DIVIDE BY ZERO", 0, 0, NULL);
  }

void missing_io_access_rights
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "MISSING IO ACCESS RIGHTS", 0, 0, NULL);
  }

void not_yet_implemented
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "NOT YET IMPLEMENTED", 0, 0, NULL);
  }

void open_failed
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___IO_ERROR-1],
      "OPEN FAILED", errno, 0, NULL);
  }

void close_failed
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___IO_ERROR-1],
      "CLOSE FAILED", errno, 0, NULL);
  }

void read_error
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___IO_ERROR-1],
      "READ ERROR", errno, 0, NULL);
  }

void write_error
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___IO_ERROR-1],
      "WRITE ERROR", errno, 0, NULL);
  }

void flush_failed
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std___IO_ERROR-1],
      "FLUSH FAILED", errno, 0, NULL);
  }

int close_fd(int *fd_p) {
  int err = 0;
  if (*fd_p >= 0) {
    do {
      err = close(*fd_p);
    } while (err == -1 && errno == EINTR);
    *fd_p = -1;
  }
  return err;
}

int dup2_fd(int src_fd, int dest_fd) {
  int err;
  do {
    err = dup2(src_fd, dest_fd);
  } while (err == -1 && errno == EINTR);
  return err;
}

static long std_types___function____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<tabular function>");
  }

NODE *create_function
  (
    const TAB_NUM *code
  )
  {
    NODE *node = create__tabular_function();
    node->type = (FUNC)((unsigned long)code|TABULAR_FUNCTION_TAG);
    return node;
  }

static LIST_DATA *collect_list_data
  (
    LIST_DATA *data
  )
  {
    if (!data) return data;
    LIST_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(LIST_DATA)+size*sizeof(NODE *)));
      new_data->size = size;
      new_data->length = size;
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    int i;
    for (i = 0; i < size; ++i) {
      new_data->items[i] = collect_node(data->items[i]);
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___list____collect
  (
    LIST *node
  )
  {
    if (!node) return node;
    LIST *new_node;
    long size = node->length; // might be garbage if already collected
    new_node = allocate(sizeof(LIST));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->offset = node->offset;
    new_node->length = size;
    new_node->data = collect_list_data(node->data);
    return new_node;
  }

static long std_types___list____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (node->list.length == 0) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  n = 1;
	}
	n += print(&buf, "<empty_list-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<empty_list>", node);
      /*}*/
    } else {
      if (max_depth <= 1) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<list");
	/*if (subtype) {
	  if (buf) *buf++ = '-';
	  ++n;
	  len = debug_string(subtype, 0, max_depth, buf);
	  --len; // remove trailing newline
	  if (buf) buf += len;
	  n += len;
	}*/
	if (node->list.length == 1) {
	  n += print(&buf, " of 1 item>\n", node);
	} else {
	  n += print(&buf, " of %ld items>\n", node->list.length);
	}
	return n;
      } else {
	long i;
	n = debug_print_indent(&indent, &buf);
	n += print(&buf, "list");
	/*if (subtype) {
	  if (buf) *buf++ = '-';
	  ++n;
	  len = debug_string(subtype, 0, max_depth, buf);
	  if (buf) buf += len;
	  n += len;
	} else {*/
	  if (buf) *buf++ = '\n';
	  ++n;
	/*}*/
	const char *contents_indent = indent_to_string(indent);
	long offset = node->list.offset;
	for (i = 0; i < node->list.length; ++i) {
	  n += print(&buf, contents_indent);
	  len =
	    debug_string(
	      node->list.data->items[offset+i], indent, max_depth-1, buf);
	  if (buf) buf += len;
	  n += len;
	}
	return n;
      }
    }
  }

static int std_types___list____get_item_of
  (
    NODE *node,
    long idx,
    NODE **result_p
  )
  {
    long length = node->list.length;
    if (idx < 0 || idx >= length) {
      invalid_index(node);
      return false;
    }
    *result_p = node->list.data->items[node->list.offset+idx];
    return true;
  }

NODE *create_list
  (
    long count
  )
  {
    if (count ==  0) return (NODE *)&std___empty_list;
    LIST_DATA *data = allocate_large(sizeof(LIST_DATA)+count*sizeof(NODE *));
    data->size = count;
    data->length = count;
    return create__std_types___list(0, count, data);
  }

void set_list_item
  (
    NODE *list,
    long idx,
    NODE *value
  )
  {
    list->list.data->items[list->list.offset+idx] = value;
  }

static int std_types___list____unfold
  (
    NODE *list
  )
  {
    long offset = list->list.offset;
    int i;
    for (i = 0; i < list->list.length; ++i) {
      TLS_arguments[TLS_argument_count++] = list->list.data->items[offset+i];
    }
    return true;
  }

static int std_types___list____length_of
  (
    NODE *node,
    long *result_p
  )
  {
    *result_p = node->list.length;
    return true;
  }

static void *std_types___integer____collect
  (
    INTEGER *node
  )
  {
    INTEGER *new_node;
    new_node = allocate(sizeof(INTEGER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static void *std_types___real____collect
  (
    REAL *node
  )
  {
    REAL *new_node;
    new_node = allocate(sizeof(REAL));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___positive_integer____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "%" PRIu64, node->integer.value);
  }

static long negative_integer____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "-%" PRIu64, node->integer.value);
  }

static long std_types___real____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "%.15g", node->real.value);
  }

NODE *from_float
  (
    float value
  )
  {
    return create__std_types___real(value);
  }

NODE *from_double
  (
    double value
  )
  {
    return create__std_types___real(value);
  }

static int std_types___positive_integer____to_double
  (
    NODE *node,
    double *result_p
  )
  {
    *result_p = node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_float
  (
    NODE *node,
    float *result_p
  )
  {
    *result_p = (float) node->integer.value;
    return true;
  }

static int negative_integer____to_double
  (
    NODE *node,
    double *result_p
  )
  {
    *result_p = -(double)node->integer.value;
    return true;
  }

static int negative_integer____to_float
  (
    NODE *node,
    float *result_p
  )
  {
    *result_p = -(float)node->integer.value;
    return true;
  }

static int std_types___real____to_double
  (
    NODE *node,
    double *result_p
  )
  {
    *result_p = node->real.value;
    return true;
  }

static int std_types___real____to_float
  (
    NODE *node,
    float *result_p
  )
  {
    *result_p = (float) node->real.value;
    return true;
  }

#if TARGET_64
  static inline uint64_t umul64
    (
      uint64_t left,
      uint64_t right,
      uint64_t *result_low_p
    )
    {
      __uint128_t result = (__uint128_t)left * right;

      *result_low_p = result;
      return result >> 64;
    }
#else
  static uint64_t umul64
    (
      uint64_t left,
      uint64_t right,
      uint64_t *result_low_p
    )
    {
      uint64_t left_high = left >> 32;
      uint64_t left_low  = left & 0xffffffff;
      uint64_t right_high = right >> 32;
      uint64_t right_low  = right & 0xffffffff;

      uint64_t result_low = left_low * right_low;
      uint64_t result_mid_1 = left_low * right_high;
      uint64_t result_mid_2 = left_high * right_low;
      uint64_t result_high = left_high * right_high;

      uint64_t carry =
	(
	  (result_low >> 32) +
	  (result_mid_1 & 0xffffffff) +
	  (result_mid_2 & 0xffffffff)
	) >> 32;

      *result_low_p =
	result_low + (result_mid_1 << 32) + (result_mid_2 << 32);
      return
	result_high + (result_mid_1 >> 32) + (result_mid_2 >> 32) + carry;
    }
#endif

NODE *from_int
  (
    int value
  )
  {
    if (value >= 0)
      return create__std_types___positive_integer(value);
    else
      return create__negative_integer(-value);
  }

NODE *from_long
  (
    long value
  )
  {
    if (value >= 0)
      return create__std_types___positive_integer(value);
    else
      return create__negative_integer(-value);
  }

NODE *from_uint
  (
    unsigned int value
  )
  {
    return create__std_types___positive_integer(value);
  }

NODE *from_ulong
  (
    unsigned long value
  )
  {
    return create__std_types___positive_integer(value);
  }

NODE *from_int8
  (
    int8_t value
  )
  {
    if (value >= 0)
      return create__std_types___positive_integer(value);
    else
      return create__negative_integer(-value);
  }

NODE *from_int16
  (
    int16_t value
  )
  {
    if (value >= 0)
      return create__std_types___positive_integer(value);
    else
      return create__negative_integer(-value);
  }

NODE *from_int32
  (
    int32_t value
  )
  {
    if (value >= 0)
      return create__std_types___positive_integer(value);
    else
      return create__negative_integer(-value);
  }

NODE *from_int64
  (
    int64_t value
  )
  {
    if (value >= 0)
      return create__std_types___positive_integer(value);
    else
      return create__negative_integer(-value);
  }

NODE *from_uint8
  (
    uint8_t value
  )
  {
    return create__std_types___positive_integer(value);
  }

NODE *from_uint16
  (
    uint16_t value
  )
  {
    return create__std_types___positive_integer(value);
  }

NODE *from_uint32
  (
    uint32_t value
  )
  {
    return create__std_types___positive_integer(value);
  }

NODE *from_uint64
  (
    uint64_t value
  )
  {
    return create__std_types___positive_integer(value);
  }

static int std_types___positive_integer____to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if (node->integer.value > INT_MAX) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int negative_integer____to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if (node->integer.value > -(uint64_t)INT_MIN) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_long
  (
    NODE *node,
    long *result_p
  )
  {
    if (node->integer.value > LONG_MAX) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"long\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int negative_integer____to_long
  (
    NODE *node,
    long *result_p
  )
  {
    if (node->integer.value > -(uint64_t)LONG_MIN) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"long\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_uint
  (
    NODE *node,
    uint *result_p
  )
  {
    if (node->integer.value > UINT_MAX) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_ulong
  (
    NODE *node,
    unsigned long *result_p
  ) {
    *result_p = node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_int8
  (
    NODE *node,
    int8_t *result_p
  )
  {
    if (node->integer.value > 0x7f) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int8\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int negative_integer____to_int8
  (
    NODE *node,
    int8_t *result_p
  )
  {
    if (node->integer.value > 0x80) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int8\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_int16
  (
    NODE *node,
    int16_t *result_p
  )
  {
    if (node->integer.value > 0x7fff) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int16\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int negative_integer____to_int16
  (
    NODE *node,
    int16_t *result_p
  )
  {
    if (node->integer.value > 0x8000) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int16\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_int32
  (
    NODE *node,
    int32_t *result_p
  )
  {
    if (node->integer.value > 0x7fffffff) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int32\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int negative_integer____to_int32
  (
    NODE *node,
    int32_t *result_p
  )
  {
    if (node->integer.value > 0x80000000) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int32\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_int64
  (
    NODE *node,
    int64_t *result_p
  )
  {
    if (node->integer.value > 0x7fffffffffffffff) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int64\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int negative_integer____to_int64
  (
    NODE *node,
    int64_t *result_p
  )
  {
    if (node->integer.value > 0x8000000000000000) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"int64\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_uint8
  (
    NODE *node,
    uint8_t *result_p
  )
  {
    if (node->integer.value > 0xff) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint8\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_uint16
  (
    NODE *node,
    uint16_t *result_p
  )
  {
    if (node->integer.value > 0xffff) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint16\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_uint32
  (
    NODE *node,
    uint32_t *result_p
  )
  {
    if (node->integer.value > 0xffffffff) {
      create_error_message(
	module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint32\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int std_types___positive_integer____to_uint64
  (
    NODE *node,
    uint64_t *result_p
  ) {
    *result_p = node->integer.value;
    return true;
  }

static void *std_types___object____collect
  (
    SIMPLE_NODE *node
  )
  {
    SIMPLE_NODE *new_node;
    new_node = allocate(sizeof(SIMPLE_NODE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    return new_node;
  }

static long std_types___object____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    if (max_depth == 0) {
      return debug_print(indent, buf, "<object>");
    } else {
      int i, n, len;
      n = debug_print_head(&indent, &buf, "object");
      const char *contents_indent = indent_to_string(indent);
      int count =
	next_polymorphic_function > next_polymorphic_function_with_setter
	? next_polymorphic_function
	: next_polymorphic_function_with_setter;
      for (i = 1; i < count; ++i) { // 0 is no valid attribute id
	if (
	  (i & 7) != 0 &&
	  (
	    (i & 1) != 0 && i < next_polymorphic_function ||
	    (i & 1) == 0 && i < next_polymorphic_function_with_setter
	  )
	) {
	  NODE *attr = get_attribute(node, i);
	  NODE *attr_addr = (NODE *)((long)attr-1);
	  const char *poly_name = polymorphic_function_names[i];
	  const char *poly_namespace = poly_name;
	  while (*poly_namespace++);
	  if (
	    (long)attr & 1 &&
	    attr_addr != (NODE *)&std_types___undefined &&
	    (
	      attr_addr == (NODE *)&std_types___true ||
	      strncmp(poly_name, "is_", 3) != 0
	    ) &&
	    (
	      strcmp(poly_namespace, "std") != 0 ||
	      (
		strcmp(poly_name, "is_defined") != 0 &&
		strncmp(poly_name, "serialization_", 14) != 0 &&
		strcmp(poly_name, "deserializer_of") != 0
	      )
	    )
	  ) {
	    n += print(&buf, contents_indent);
	    if (*poly_namespace) {
	      n += print(&buf, "%s::", poly_namespace);
	    }
	    n += print(&buf, "%s:", poly_name);
	    len = debug_string(attr_addr, -indent-2, max_depth-1, buf);
	    if (buf) buf += len;
	    n += len;
	  }
	}
      }
      return n;
    }
  }

NODE *create_polymorphic_function
  (
    int poly_idx
  )
  {
    NODE *node = allocate(sizeof(SIMPLE_NODE));
    node->type =
      (FUNC)(unsigned long)
      (POLYMORPHIC_FUNCTION_TAG|(poly_idx << 3));
    node->attributes =
      std_types___polymorphic_function.attributes;
    return node;
  }

NODE *create_polymorphic_function_with_setter
  (
    int poly_idx
  )
  {
    NODE *node = allocate(sizeof(SIMPLE_NODE));
    node->type =
      (FUNC)(unsigned long)
      (POLYMORPHIC_FUNCTION_WITH_SETTER_TAG|(poly_idx << 3));
    node->attributes =
      std_types___polymorphic_function_with_setter.attributes;
    return node;
  }

static void *std_types___file_type____collect
  (
    FILE_TYPE *node
  )
  {
    FILE_TYPE *new_node;
    new_node = allocate(sizeof(FILE_TYPE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___file_type____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<file_type %d>", node->file_type.value);
  }

static int file_type_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___file_type.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->file_type.value;
      return true;
    }
  }

static NODE *file_type_from_int
  (
    int value
  )
  {
    return create__std_types___file_type(value);
  }

static void *std_types___file_descriptor____collect
  (
    FILE_DESCRIPTOR *node
  )
  {
    FILE_DESCRIPTOR *new_node;
    new_node = allocate(sizeof(FILE_DESCRIPTOR));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___file_descriptor____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<file_descriptor %d>", node->file_descriptor.value);
  }

static int file_descriptor_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___file_descriptor.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->file_descriptor.value;
      return true;
    }
  }

static NODE *file_descriptor_from_int
  (
    int value
  )
  {
    return create__std_types___file_descriptor(value);
  }

static void *std_types___shutdown_type____collect
  (
    SHUTDOWN_TYPE *node
  )
  {
    SHUTDOWN_TYPE *new_node;
    new_node = allocate(sizeof(SHUTDOWN_TYPE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___shutdown_type____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<shutdown_type %d>", node->shutdown_type.value);
  }

static int shutdown_type_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___shutdown_type.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->shutdown_type.value;
      return true;
    }
  }

static NODE *shutdown_type_from_int
  (
    int value
  )
  {
    return create__std_types___shutdown_type(value);
  }

static void *std_types___device_id____collect
  (
    DEVICE_ID *node
  )
  {
    DEVICE_ID *new_node;
    new_node = allocate(sizeof(DEVICE_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___device_id____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<device_id %d>", node->device_id.value);
  }

static int device_id_to_ulong
  (
    NODE *node,
    unsigned long *result_p
  )
  {
    if ((node)->type != std_types___device_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->device_id.value;
      return true;
    }
  }

static NODE *device_id_from_ulong
  (
    unsigned long value
  )
  {
    return create__std_types___device_id(value);
  }

static void *std_types___directory____collect
  (
    DIRECTORY *node
  )
  {
    DIRECTORY *new_node;
    new_node = allocate(sizeof(DIRECTORY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___directory____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<directory %d>", node->directory.value);
  }

static int directory_to_ptr
  (
    NODE *node,
    void * *result_p
  )
  {
    if ((node)->type != std_types___directory.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->directory.value;
      return true;
    }
  }

static NODE *directory_from_ptr
  (
    void * value
  )
  {
    return create__std_types___directory(value);
  }

static void *std_types___group_id____collect
  (
    GROUP_ID *node
  )
  {
    GROUP_ID *new_node;
    new_node = allocate(sizeof(GROUP_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___group_id____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<group_id %d>", node->group_id.value);
  }

static int group_id_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___group_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->group_id.value;
      return true;
    }
  }

static NODE *group_id_from_int
  (
    int value
  )
  {
    return create__std_types___group_id(value);
  }

static void *std_types___inode_number____collect
  (
    INODE_NUMBER *node
  )
  {
    INODE_NUMBER *new_node;
    new_node = allocate(sizeof(INODE_NUMBER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___inode_number____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<inode_number %d>", node->inode_number.value);
  }

static int inode_number_to_ulong
  (
    NODE *node,
    unsigned long *result_p
  )
  {
    if ((node)->type != std_types___inode_number.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->inode_number.value;
      return true;
    }
  }

static NODE *inode_number_from_ulong
  (
    unsigned long value
  )
  {
    return create__std_types___inode_number(value);
  }

static void *std_types___process_id____collect
  (
    PROCESS_ID *node
  )
  {
    PROCESS_ID *new_node;
    new_node = allocate(sizeof(PROCESS_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___process_id____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<process_id %d>", node->process_id.value);
  }

static int process_id_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___process_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->process_id.value;
      return true;
    }
  }

static NODE *process_id_from_int
  (
    int value
  )
  {
    return create__std_types___process_id(value);
  }

static void *std_types___user_id____collect
  (
    USER_ID *node
  )
  {
    USER_ID *new_node;
    new_node = allocate(sizeof(USER_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___user_id____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<user_id %d>", node->user_id.value);
  }

static int user_id_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___user_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->user_id.value;
      return true;
    }
  }

static NODE *user_id_from_int
  (
    int value
  )
  {
    return create__std_types___user_id(value);
  }

static void *std_types___error_number____collect
  (
    ERROR_NUMBER *node
  )
  {
    ERROR_NUMBER *new_node;
    new_node = allocate(sizeof(ERROR_NUMBER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types___error_number____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<error_number %d>", node->error_number.value);
  }

static int error_number_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types___error_number.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->error_number.value;
      return true;
    }
  }

static NODE *error_number_from_int
  (
    int value
  )
  {
    return create__std_types___error_number(value);
  }

static OCTET_DATA *collect_octet_data
  (
    OCTET_DATA *data
  )
  {
    if (!data) return data;
    OCTET_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(OCTET_DATA)+size*sizeof(uint8_t)));
      new_data->size = size;
      new_data->length = size;
      memcpy(new_data->buffer, data->buffer, size*sizeof(uint8_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___octet_string____collect
  (
    OCTET_STRING *node
  )
  {
    if (!node) return node;
    OCTET_STRING *new_node;
    long size = node->length; // might be garbage if already collected
    new_node = allocate(sizeof(OCTET_STRING));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->offset = node->offset;
    new_node->length = size;
    new_node->data = collect_octet_data(node->data);
    return new_node;
  }

static QUAD_OCTET_DATA *collect_quad_octet_data
  (
    QUAD_OCTET_DATA *data
  )
  {
    if (!data) return data;
    QUAD_OCTET_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(QUAD_OCTET_DATA)+size*sizeof(uint32_t)));
      new_data->size = size;
      new_data->length = size;
      memcpy(new_data->buffer, data->buffer, size*sizeof(uint32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *quad_octet_string____collect
  (
    QUAD_OCTET_STRING *node
  )
  {
    if (!node) return node;
    QUAD_OCTET_STRING *new_node;
    long size = node->length; // might be garbage if already collected
    new_node = allocate(sizeof(QUAD_OCTET_STRING));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->offset = node->offset;
    new_node->length = size;
    new_node->data = collect_quad_octet_data(node->data);
    return new_node;
  }

static long std_types___octet_string____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    long len = 0;
    if (indent < 0) {
      if (buf) *buf++ = ' ';
      ++len;
    }
    if (buf) *buf++ = '\"';
    ++len;
    long i;
    long s = node->octet_string.offset;
    long e = s+node->octet_string.length;
    for (i = s; i < e; ++i) {
      uint8_t chr = node->octet_string.data->buffer[i];
      if (chr >= 0x20 && chr <= 0x7e) {
	if (chr == '\"') {
	  len += print(&buf, "@quot;");
	} else if (chr == '@') {
	  len += print(&buf, "@@");
	} else {
	  if (buf) *buf++ = chr;
	  ++len;
	}
      } else {
	len += print(&buf, "@0x%x;", chr);
      }
    }
    len += print(&buf, "\"\n");
    return len;
  }

static long quad_octet_string____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    long len = 0;
    if (indent < 0) {
      if (buf) *buf++ = ' ';
      ++len;
    }
    if (buf) *buf++ = '\"';
    ++len;
    long i;
    long s = node->quad_octet_string.offset;
    long e = s+node->quad_octet_string.length;
    for (i = s; i < e; ++i) {
      uint32_t chr = node->quad_octet_string.data->buffer[i];
      if (chr >= 0x20 && chr <= 0x7e) {
	if (chr == '\"') {
	  len += print(&buf, "@quot;");
	} else if (chr == '@') {
	  len += print(&buf, "@@");
	} else {
	  if (buf) *buf++ = chr;
	  ++len;
	}
      } else {
	len += print(&buf, "@0x%x;", chr);
      }
    }
    len += print(&buf, "\"\n");
    return len;
  }

static int std_types___octet_string____get_item_of
  (
    NODE *node,
    long idx,
    NODE **result_p
  )
  {
    long length = node->octet_string.length;
    if (idx < 0 || idx >= length) {
      invalid_index(node);
      return false;
    }
    *result_p =
      from_uchar32(
	node->octet_string.data->buffer[node->octet_string.offset+idx]);
    return true;
  }

static int quad_octet_string____get_item_of
  (
    NODE *node,
    long idx,
    NODE **result_p
  )
  {
    long length = node->quad_octet_string.length;
    if (idx < 0 || idx >= length) {
      invalid_index(node);
      return false;
    }
    *result_p =
      from_uchar32(
	node->quad_octet_string.data->buffer[node->quad_octet_string.offset+idx]);
    return true;
  }

static int std_types___octet_string____to_c_string
  (
    NODE *node,
    char **result_p
  )
  {
    long offset = node->octet_string.offset;
    long size = node->octet_string.length;
    char *buf = allocate_memory(size+1);
    memcpy(buf, node->octet_string.data->buffer+offset, size);
    buf[size] = 0;
    *result_p = buf;
    return true;
  }

static int std_types___octet_string____to_octets
  (
    NODE *node,
    const uint8_t **buf_p,
    long *size_p
  )
  {
    long offset = node->octet_string.offset;
    long size = node->octet_string.length;
    uint8_t *buf = allocate_memory(size);
    memcpy(buf, node->octet_string.data->buffer+offset, size);
    *buf_p = buf;
    *size_p = size;
    return true;
  }

NODE *from_latin_1_string
  (
    const uint8_t *str,
    long len
  )
  {
    if (len == 0) return (NODE *)&std___empty_string;
    long size = ALLOCATION_SIZE(len);
    OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+size);
    data->size = size;
    data->length = len;
    memcpy(data->buffer, str, len);
    return create__std_types___octet_string(0, len, data);
  }

NODE *from_uint32_string
  (
    const uint32_t *str,
    long len
  )
  {
    long size = ALLOCATION_SIZE(4*len);
    QUAD_OCTET_DATA *data = allocate_large(sizeof(QUAD_OCTET_DATA)+size);
    data->size = size;
    data->length = len;
    memcpy(data->buffer, str, 4*len);
    return create__quad_octet_string(0, len, data);
  }

NODE *from_c_string
  (
    const char *str
  )
  {
    return from_latin_1_string((const uint8_t *)str, strlen(str));
  }

static int std_types___octet_string____length_of
  (
    NODE *node,
    long *result_p
  )
  {
    *result_p = node->octet_string.length;
    return true;
  }

static int quad_octet_string____length_of
  (
    NODE *node,
    long *result_p
  )
  {
    *result_p = node->quad_octet_string.length;
    return true;
  }

static TERMIO_DATA *collect_termio_data
  (
    TERMIO_DATA *data
  )
  {
    TERMIO_DATA *new_data = data;
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(sizeof(TERMIO_DATA));
      new_data->termios = data->termios;
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types___terminal_attributes____collect
  (
    TERMINAL_ATTRIBUTES *node
  )
  {
    TERMINAL_ATTRIBUTES *new_node;
    new_node = allocate(sizeof(TERMINAL_ATTRIBUTES));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->data = collect_termio_data(node->data);
    return new_node;
  }

static long std_types___terminal_attributes____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<terminal_attributes>");
  }

NODE *create_tuple
  (
    long count
  )
  {
    switch (count) {
      case 2:
	return create__builtin___tuple2(NULL, NULL);
      case 3:
	return create__builtin___tuple3(NULL, NULL, NULL);
      case 4:
	return create__builtin___tuple4(NULL, NULL, NULL, NULL);
      case 5:
	return create__builtin___tuple5(NULL, NULL, NULL, NULL, NULL);
      case 6:
	return create__builtin___tuple6(NULL, NULL, NULL, NULL, NULL, NULL);
      case 7:
	return create__builtin___tuple7(NULL, NULL, NULL, NULL, NULL, NULL, NULL);
      case 8:
	return create__builtin___tuple8(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
      default:
	unrecoverable_error("Invalid tuple element count!");
    }
  }

void set_tuple_item
  (
    NODE *tuple,
    long idx,
    NODE *value
  )
  {
    ((NODE **)((SIMPLE_NODE *)tuple+1))[idx] = value;
  }

static void *builtin___tuple2____collect
  (
    TUPLE2 *node
  )
  {
    TUPLE2 *new_node;
    new_node = allocate(sizeof(TUPLE2));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    return new_node;
  }

static long builtin___tuple2____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 2 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple2.node_0;
      for (i = 0; i < 2; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin___tuple3____collect
  (
    TUPLE3 *node
  )
  {
    TUPLE3 *new_node;
    new_node = allocate(sizeof(TUPLE3));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    return new_node;
  }

static long builtin___tuple3____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 3 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple3.node_0;
      for (i = 0; i < 3; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin___tuple4____collect
  (
    TUPLE4 *node
  )
  {
    TUPLE4 *new_node;
    new_node = allocate(sizeof(TUPLE4));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    return new_node;
  }

static long builtin___tuple4____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 4 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple4.node_0;
      for (i = 0; i < 4; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin___tuple5____collect
  (
    TUPLE5 *node
  )
  {
    TUPLE5 *new_node;
    new_node = allocate(sizeof(TUPLE5));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    return new_node;
  }

static long builtin___tuple5____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 5 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple5.node_0;
      for (i = 0; i < 5; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin___tuple6____collect
  (
    TUPLE6 *node
  )
  {
    TUPLE6 *new_node;
    new_node = allocate(sizeof(TUPLE6));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    new_node->node_5 = collect_node(node->node_5);
    return new_node;
  }

static long builtin___tuple6____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 6 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple6.node_0;
      for (i = 0; i < 6; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin___tuple7____collect
  (
    TUPLE7 *node
  )
  {
    TUPLE7 *new_node;
    new_node = allocate(sizeof(TUPLE7));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    new_node->node_5 = collect_node(node->node_5);
    new_node->node_6 = collect_node(node->node_6);
    return new_node;
  }

static long builtin___tuple7____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 7 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple7.node_0;
      for (i = 0; i < 7; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin___tuple8____collect
  (
    TUPLE8 *node
  )
  {
    TUPLE8 *new_node;
    new_node = allocate(sizeof(TUPLE8));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    new_node->node_5 = collect_node(node->node_5);
    new_node->node_6 = collect_node(node->node_6);
    new_node->node_7 = collect_node(node->node_7);
    return new_node;
  }

static long builtin___tuple8____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std___subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types___undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 8 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple8.node_0;
      for (i = 0; i < 8; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *std_types___undefined____collect
  (
    SIMPLE_NODE *node
  )
  {
    SIMPLE_NODE *new_node;
    new_node = allocate(sizeof(SIMPLE_NODE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    return new_node;
  }

static long std_types___undefined____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  ) {
    return debug_print(indent, buf, "undefined");
  }

int is_an_upper_case_letter_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x41) return false;
    if (chr <= 0x5a) return true;
    if (chr < 0xc0) return false;
    if (chr <= 0xd6) return true;
    if (chr < 0xd8) return false;
    if (chr <= 0xde) return true;
    if (chr < 0x100) return false;
    if ((chr & 1) == 0 && chr <= 0x136) return true;
    if (chr < 0x139) return false;
    if ((chr & 1) == 1 && chr <= 0x147) return true;
    if (chr < 0x14a) return false;
    if ((chr & 1) == 0 && chr <= 0x178) return true;
    if (chr < 0x179) return false;
    if ((chr & 1) == 1 && chr <= 0x17d) return true;
    if (chr < 0x181) return false;
    if (chr <= 0x182) return true;
    if (chr < 0x184) return false;
    if ((chr & 1) == 0 && chr <= 0x186) return true;
    if (chr < 0x187) return false;
    if ((chr & 1) == 1 && chr <= 0x189) return true;
    if (chr < 0x18a) return false;
    if (chr <= 0x18b) return true;
    if (chr < 0x18e) return false;
    if (chr <= 0x191) return true;
    if (chr < 0x193) return false;
    if (chr <= 0x194) return true;
    if (chr < 0x196) return false;
    if (chr <= 0x198) return true;
    if (chr < 0x19c) return false;
    if (chr <= 0x19d) return true;
    if (chr < 0x19f) return false;
    if (chr <= 0x1a0) return true;
    if (chr < 0x1a2) return false;
    if ((chr & 1) == 0 && chr <= 0x1a6) return true;
    if (chr < 0x1a7) return false;
    if ((chr & 1) == 1 && chr <= 0x1a9) return true;
    if (chr < 0x1ac) return false;
    if ((chr & 1) == 0 && chr <= 0x1ae) return true;
    if (chr < 0x1af) return false;
    if ((chr & 1) == 1 && chr <= 0x1b1) return true;
    if (chr < 0x1b2) return false;
    if (chr <= 0x1b3) return true;
    if (chr < 0x1b5) return false;
    if ((chr & 1) == 1 && chr <= 0x1b7) return true;
    if (chr == 0x1b8) return true;
    if (chr == 0x1bc) return true;
    if (chr == 0x1c4) return true;
    if (chr == 0x1c7) return true;
    if (chr == 0x1ca) return true;
    if (chr < 0x1cd) return false;
    if ((chr & 1) == 1 && chr <= 0x1db) return true;
    if (chr < 0x1de) return false;
    if ((chr & 1) == 0 && chr <= 0x1ee) return true;
    if (chr == 0x1f1) return true;
    if (chr < 0x1f4) return false;
    if ((chr & 1) == 0 && chr <= 0x1f6) return true;
    if (chr < 0x1f7) return false;
    if (chr <= 0x1f8) return true;
    if (chr < 0x1fa) return false;
    if ((chr & 1) == 0 && chr <= 0x232) return true;
    if (chr < 0x23a) return false;
    if (chr <= 0x23b) return true;
    if (chr < 0x23d) return false;
    if (chr <= 0x23e) return true;
    if (chr < 0x241) return false;
    if ((chr & 1) == 1 && chr <= 0x243) return true;
    if (chr < 0x244) return false;
    if (chr <= 0x246) return true;
    if (chr < 0x248) return false;
    if ((chr & 1) == 0 && chr <= 0x24e) return true;
    if (chr < 0x370) return false;
    if ((chr & 1) == 0 && chr <= 0x372) return true;
    if (chr == 0x376) return true;
    if (chr == 0x37f) return true;
    if (chr < 0x386) return false;
    if ((chr & 1) == 0 && chr <= 0x388) return true;
    if (chr < 0x389) return false;
    if (chr <= 0x38a) return true;
    if (chr < 0x38c) return false;
    if ((chr & 1) == 0 && chr <= 0x38e) return true;
    if (chr < 0x38f) return false;
    if ((chr & 1) == 1 && chr <= 0x391) return true;
    if (chr < 0x392) return false;
    if (chr <= 0x3a1) return true;
    if (chr < 0x3a3) return false;
    if (chr <= 0x3ab) return true;
    if (chr == 0x3cf) return true;
    if (chr < 0x3d2) return false;
    if (chr <= 0x3d4) return true;
    if (chr < 0x3d8) return false;
    if ((chr & 1) == 0 && chr <= 0x3ee) return true;
    if (chr == 0x3f4) return true;
    if (chr < 0x3f7) return false;
    if ((chr & 1) == 1 && chr <= 0x3f9) return true;
    if (chr == 0x3fa) return true;
    if (chr < 0x3fd) return false;
    if (chr <= 0x42f) return true;
    if (chr < 0x460) return false;
    if ((chr & 1) == 0 && chr <= 0x480) return true;
    if (chr < 0x48a) return false;
    if ((chr & 1) == 0 && chr <= 0x4c0) return true;
    if (chr < 0x4c1) return false;
    if ((chr & 1) == 1 && chr <= 0x4cd) return true;
    if (chr < 0x4d0) return false;
    if ((chr & 1) == 0 && chr <= 0x52e) return true;
    if (chr < 0x531) return false;
    if (chr <= 0x556) return true;
    if (chr < 0x10a0) return false;
    if (chr <= 0x10c5) return true;
    if (chr == 0x10c7) return true;
    if (chr == 0x10cd) return true;
    if (chr < 0x13a0) return false;
    if (chr <= 0x13f5) return true;
    if (chr < 0x1c90) return false;
    if (chr <= 0x1cba) return true;
    if (chr < 0x1cbd) return false;
    if (chr <= 0x1cbf) return true;
    if (chr < 0x1e00) return false;
    if ((chr & 1) == 0 && chr <= 0x1e94) return true;
    if (chr < 0x1e9e) return false;
    if ((chr & 1) == 0 && chr <= 0x1efe) return true;
    if (chr < 0x1f08) return false;
    if (chr <= 0x1f0f) return true;
    if (chr < 0x1f18) return false;
    if (chr <= 0x1f1d) return true;
    if (chr < 0x1f28) return false;
    if (chr <= 0x1f2f) return true;
    if (chr < 0x1f38) return false;
    if (chr <= 0x1f3f) return true;
    if (chr < 0x1f48) return false;
    if (chr <= 0x1f4d) return true;
    if (chr < 0x1f59) return false;
    if ((chr & 1) == 1 && chr <= 0x1f5f) return true;
    if (chr < 0x1f68) return false;
    if (chr <= 0x1f6f) return true;
    if (chr < 0x1fb8) return false;
    if (chr <= 0x1fbb) return true;
    if (chr < 0x1fc8) return false;
    if (chr <= 0x1fcb) return true;
    if (chr < 0x1fd8) return false;
    if (chr <= 0x1fdb) return true;
    if (chr < 0x1fe8) return false;
    if (chr <= 0x1fec) return true;
    if (chr < 0x1ff8) return false;
    if (chr <= 0x1ffb) return true;
    if (chr == 0x2102) return true;
    if (chr == 0x2107) return true;
    if (chr < 0x210b) return false;
    if (chr <= 0x210d) return true;
    if (chr < 0x2110) return false;
    if (chr <= 0x2112) return true;
    if (chr == 0x2115) return true;
    if (chr < 0x2119) return false;
    if (chr <= 0x211d) return true;
    if (chr < 0x2124) return false;
    if ((chr & 1) == 0 && chr <= 0x212a) return true;
    if (chr < 0x212b) return false;
    if (chr <= 0x212d) return true;
    if (chr < 0x2130) return false;
    if (chr <= 0x2133) return true;
    if (chr < 0x213e) return false;
    if (chr <= 0x213f) return true;
    if (chr == 0x2145) return true;
    if (chr == 0x2183) return true;
    if (chr < 0x2c00) return false;
    if (chr <= 0x2c2f) return true;
    if (chr < 0x2c60) return false;
    if ((chr & 1) == 0 && chr <= 0x2c62) return true;
    if (chr < 0x2c63) return false;
    if (chr <= 0x2c64) return true;
    if (chr < 0x2c67) return false;
    if ((chr & 1) == 1 && chr <= 0x2c6d) return true;
    if (chr < 0x2c6e) return false;
    if (chr <= 0x2c70) return true;
    if (chr == 0x2c72) return true;
    if (chr == 0x2c75) return true;
    if (chr < 0x2c7e) return false;
    if (chr <= 0x2c80) return true;
    if (chr < 0x2c82) return false;
    if ((chr & 1) == 0 && chr <= 0x2ce2) return true;
    if (chr < 0x2ceb) return false;
    if ((chr & 1) == 1 && chr <= 0x2ced) return true;
    if (chr == 0x2cf2) return true;
    if (chr < 0xa640) return false;
    if ((chr & 1) == 0 && chr <= 0xa66c) return true;
    if (chr < 0xa680) return false;
    if ((chr & 1) == 0 && chr <= 0xa69a) return true;
    if (chr < 0xa722) return false;
    if ((chr & 1) == 0 && chr <= 0xa72e) return true;
    if (chr < 0xa732) return false;
    if ((chr & 1) == 0 && chr <= 0xa76e) return true;
    if (chr < 0xa779) return false;
    if ((chr & 1) == 1 && chr <= 0xa77d) return true;
    if (chr < 0xa77e) return false;
    if ((chr & 1) == 0 && chr <= 0xa786) return true;
    if (chr < 0xa78b) return false;
    if ((chr & 1) == 1 && chr <= 0xa78d) return true;
    if (chr < 0xa790) return false;
    if ((chr & 1) == 0 && chr <= 0xa792) return true;
    if (chr < 0xa796) return false;
    if ((chr & 1) == 0 && chr <= 0xa7aa) return true;
    if (chr < 0xa7ab) return false;
    if (chr <= 0xa7ae) return true;
    if (chr < 0xa7b0) return false;
    if (chr <= 0xa7b4) return true;
    if (chr < 0xa7b6) return false;
    if ((chr & 1) == 0 && chr <= 0xa7c4) return true;
    if (chr < 0xa7c5) return false;
    if (chr <= 0xa7c7) return true;
    if (chr == 0xa7c9) return true;
    if (chr == 0xa7d0) return true;
    if (chr < 0xa7d6) return false;
    if ((chr & 1) == 0 && chr <= 0xa7d8) return true;
    if (chr == 0xa7f5) return true;
    if (chr < 0xff21) return false;
    if (chr <= 0xff3a) return true;
    if (chr < 0x10400) return false;
    if (chr <= 0x10427) return true;
    if (chr < 0x104b0) return false;
    if (chr <= 0x104d3) return true;
    if (chr < 0x10570) return false;
    if (chr <= 0x1057a) return true;
    if (chr < 0x1057c) return false;
    if (chr <= 0x1058a) return true;
    if (chr < 0x1058c) return false;
    if (chr <= 0x10592) return true;
    if (chr < 0x10594) return false;
    if (chr <= 0x10595) return true;
    if (chr < 0x10c80) return false;
    if (chr <= 0x10cb2) return true;
    if (chr < 0x118a0) return false;
    if (chr <= 0x118bf) return true;
    if (chr < 0x16e40) return false;
    if (chr <= 0x16e5f) return true;
    if (chr < 0x1d400) return false;
    if (chr <= 0x1d419) return true;
    if (chr < 0x1d434) return false;
    if (chr <= 0x1d44d) return true;
    if (chr < 0x1d468) return false;
    if (chr <= 0x1d481) return true;
    if (chr < 0x1d49c) return false;
    if ((chr & 1) == 0 && chr <= 0x1d49e) return true;
    if (chr == 0x1d49f) return true;
    if (chr == 0x1d4a2) return true;
    if (chr < 0x1d4a5) return false;
    if (chr <= 0x1d4a6) return true;
    if (chr < 0x1d4a9) return false;
    if (chr <= 0x1d4ac) return true;
    if (chr < 0x1d4ae) return false;
    if (chr <= 0x1d4b5) return true;
    if (chr < 0x1d4d0) return false;
    if (chr <= 0x1d4e9) return true;
    if (chr < 0x1d504) return false;
    if (chr <= 0x1d505) return true;
    if (chr < 0x1d507) return false;
    if (chr <= 0x1d50a) return true;
    if (chr < 0x1d50d) return false;
    if (chr <= 0x1d514) return true;
    if (chr < 0x1d516) return false;
    if (chr <= 0x1d51c) return true;
    if (chr < 0x1d538) return false;
    if (chr <= 0x1d539) return true;
    if (chr < 0x1d53b) return false;
    if (chr <= 0x1d53e) return true;
    if (chr < 0x1d540) return false;
    if (chr <= 0x1d544) return true;
    if (chr == 0x1d546) return true;
    if (chr < 0x1d54a) return false;
    if (chr <= 0x1d550) return true;
    if (chr < 0x1d56c) return false;
    if (chr <= 0x1d585) return true;
    if (chr < 0x1d5a0) return false;
    if (chr <= 0x1d5b9) return true;
    if (chr < 0x1d5d4) return false;
    if (chr <= 0x1d5ed) return true;
    if (chr < 0x1d608) return false;
    if (chr <= 0x1d621) return true;
    if (chr < 0x1d63c) return false;
    if (chr <= 0x1d655) return true;
    if (chr < 0x1d670) return false;
    if (chr <= 0x1d689) return true;
    if (chr < 0x1d6a8) return false;
    if (chr <= 0x1d6c0) return true;
    if (chr < 0x1d6e2) return false;
    if (chr <= 0x1d6fa) return true;
    if (chr < 0x1d71c) return false;
    if (chr <= 0x1d734) return true;
    if (chr < 0x1d756) return false;
    if (chr <= 0x1d76e) return true;
    if (chr < 0x1d790) return false;
    if (chr <= 0x1d7a8) return true;
    if (chr == 0x1d7ca) return true;
    if (chr < 0x1e900) return false;
    if (chr <= 0x1e921) return true;
    return false;
  }

static uint32_t to_upper_case
  (
    uint32_t chr
  )
  {
    if (chr < 0x61) return chr;
    if (chr <= 0x7a) return chr-0x20;
    if (chr == 0xb5) return chr+0x2e7;
    if (chr < 0xe0) return chr;
    if (chr <= 0xf6) return chr-0x20;
    if (chr < 0xf8) return chr;
    if (chr <= 0xfe) return chr-0x20;
    if (chr == 0xff) return chr+0x79;
    if (chr < 0x101) return chr;
    if ((chr & 1) == 1 && chr <= 0x12f) return chr-1;
    if (chr == 0x131) return chr-0xe8;
    if (chr < 0x133) return chr;
    if ((chr & 1) == 1 && chr <= 0x137) return chr-1;
    if (chr < 0x13a) return chr;
    if ((chr & 1) == 0 && chr <= 0x148) return chr-1;
    if (chr < 0x14b) return chr;
    if ((chr & 1) == 1 && chr <= 0x177) return chr-1;
    if (chr < 0x17a) return chr;
    if ((chr & 1) == 0 && chr <= 0x17e) return chr-1;
    if (chr == 0x17f) return chr-0x12c;
    if (chr == 0x180) return chr+0xc3;
    if (chr < 0x183) return chr;
    if ((chr & 1) == 1 && chr <= 0x185) return chr-1;
    if (chr == 0x188) return chr-1;
    if (chr == 0x18c) return chr-1;
    if (chr == 0x192) return chr-1;
    if (chr == 0x195) return chr+0x61;
    if (chr == 0x199) return chr-1;
    if (chr == 0x19a) return chr+0xa3;
    if (chr == 0x19e) return chr+0x82;
    if (chr < 0x1a1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1a5) return chr-1;
    if (chr == 0x1a8) return chr-1;
    if (chr == 0x1ad) return chr-1;
    if (chr == 0x1b0) return chr-1;
    if (chr < 0x1b4) return chr;
    if ((chr & 1) == 0 && chr <= 0x1b6) return chr-1;
    if (chr == 0x1b9) return chr-1;
    if (chr == 0x1bd) return chr-1;
    if (chr == 0x1bf) return chr+0x38;
    if (chr == 0x1c5) return chr-1;
    if (chr == 0x1c6) return chr-2;
    if (chr == 0x1c8) return chr-1;
    if (chr == 0x1c9) return chr-2;
    if (chr == 0x1cb) return chr-1;
    if (chr == 0x1cc) return chr-2;
    if (chr < 0x1ce) return chr;
    if ((chr & 1) == 0 && chr <= 0x1dc) return chr-1;
    if (chr == 0x1dd) return chr-0x4f;
    if (chr < 0x1df) return chr;
    if ((chr & 1) == 1 && chr <= 0x1ef) return chr-1;
    if (chr == 0x1f2) return chr-1;
    if (chr == 0x1f3) return chr-2;
    if (chr == 0x1f5) return chr-1;
    if (chr < 0x1f9) return chr;
    if ((chr & 1) == 1 && chr <= 0x21f) return chr-1;
    if (chr < 0x223) return chr;
    if ((chr & 1) == 1 && chr <= 0x233) return chr-1;
    if (chr == 0x23c) return chr-1;
    if (chr < 0x23f) return chr;
    if (chr <= 0x240) return chr+0x2a3f;
    if (chr == 0x242) return chr-1;
    if (chr < 0x247) return chr;
    if ((chr & 1) == 1 && chr <= 0x24f) return chr-1;
    if (chr == 0x250) return chr+0x2a1f;
    if (chr == 0x251) return chr+0x2a1c;
    if (chr == 0x252) return chr+0x2a1e;
    if (chr == 0x253) return chr-0xd2;
    if (chr == 0x254) return chr-0xce;
    if (chr < 0x256) return chr;
    if (chr <= 0x257) return chr-0xcd;
    if (chr == 0x259) return chr-0xca;
    if (chr == 0x25b) return chr-0xcb;
    if (chr == 0x25c) return chr+0xa54f;
    if (chr == 0x260) return chr-0xcd;
    if (chr == 0x261) return chr+0xa54b;
    if (chr == 0x263) return chr-0xcf;
    if (chr == 0x265) return chr+0xa528;
    if (chr == 0x266) return chr+0xa544;
    if (chr == 0x268) return chr-0xd1;
    if (chr == 0x269) return chr-0xd3;
    if (chr == 0x26a) return chr+0xa544;
    if (chr == 0x26b) return chr+0x29f7;
    if (chr == 0x26c) return chr+0xa541;
    if (chr == 0x26f) return chr-0xd3;
    if (chr == 0x271) return chr+0x29fd;
    if (chr == 0x272) return chr-0xd5;
    if (chr == 0x275) return chr-0xd6;
    if (chr == 0x27d) return chr+0x29e7;
    if (chr == 0x280) return chr-0xda;
    if (chr == 0x282) return chr+0xa543;
    if (chr == 0x283) return chr-0xda;
    if (chr == 0x287) return chr+0xa52a;
    if (chr == 0x288) return chr-0xda;
    if (chr == 0x289) return chr-0x45;
    if (chr < 0x28a) return chr;
    if (chr <= 0x28b) return chr-0xd9;
    if (chr == 0x28c) return chr-0x47;
    if (chr == 0x292) return chr-0xdb;
    if (chr == 0x29d) return chr+0xa515;
    if (chr == 0x29e) return chr+0xa512;
    if (chr == 0x345) return chr+0x54;
    if (chr < 0x371) return chr;
    if ((chr & 1) == 1 && chr <= 0x373) return chr-1;
    if (chr == 0x377) return chr-1;
    if (chr < 0x37b) return chr;
    if (chr <= 0x37d) return chr+0x82;
    if (chr == 0x3ac) return chr-0x26;
    if (chr < 0x3ad) return chr;
    if (chr <= 0x3af) return chr-0x25;
    if (chr < 0x3b1) return chr;
    if (chr <= 0x3c1) return chr-0x20;
    if (chr == 0x3c2) return chr-0x1f;
    if (chr < 0x3c3) return chr;
    if (chr <= 0x3cb) return chr-0x20;
    if (chr == 0x3cc) return chr-0x40;
    if (chr < 0x3cd) return chr;
    if (chr <= 0x3ce) return chr-0x3f;
    if (chr == 0x3d0) return chr-0x3e;
    if (chr == 0x3d1) return chr-0x39;
    if (chr == 0x3d5) return chr-0x2f;
    if (chr == 0x3d6) return chr-0x36;
    if (chr == 0x3d7) return chr-8;
    if (chr < 0x3d9) return chr;
    if ((chr & 1) == 1 && chr <= 0x3ef) return chr-1;
    if (chr == 0x3f0) return chr-0x56;
    if (chr == 0x3f1) return chr-0x50;
    if (chr == 0x3f2) return chr+7;
    if (chr == 0x3f3) return chr-0x74;
    if (chr == 0x3f5) return chr-0x60;
    if (chr == 0x3f8) return chr-1;
    if (chr == 0x3fb) return chr-1;
    if (chr < 0x430) return chr;
    if (chr <= 0x44f) return chr-0x20;
    if (chr < 0x450) return chr;
    if (chr <= 0x45f) return chr-0x50;
    if (chr < 0x461) return chr;
    if ((chr & 1) == 1 && chr <= 0x481) return chr-1;
    if (chr < 0x48b) return chr;
    if ((chr & 1) == 1 && chr <= 0x4bf) return chr-1;
    if (chr < 0x4c2) return chr;
    if ((chr & 1) == 0 && chr <= 0x4ce) return chr-1;
    if (chr == 0x4cf) return chr-0xf;
    if (chr < 0x4d1) return chr;
    if ((chr & 1) == 1 && chr <= 0x52f) return chr-1;
    if (chr < 0x561) return chr;
    if (chr <= 0x586) return chr-0x30;
    if (chr < 0x10d0) return chr;
    if (chr <= 0x10fa) return chr+0xbc0;
    if (chr < 0x10fd) return chr;
    if (chr <= 0x10ff) return chr+0xbc0;
    if (chr < 0x13f8) return chr;
    if (chr <= 0x13fd) return chr-8;
    if (chr == 0x1c80) return chr-0x186e;
    if (chr == 0x1c81) return chr-0x186d;
    if (chr == 0x1c82) return chr-0x1864;
    if (chr < 0x1c83) return chr;
    if (chr <= 0x1c84) return chr-0x1862;
    if (chr == 0x1c85) return chr-0x1863;
    if (chr == 0x1c86) return chr-0x185c;
    if (chr == 0x1c87) return chr-0x1825;
    if (chr == 0x1c88) return chr+0x89c2;
    if (chr == 0x1d79) return chr+0x8a04;
    if (chr == 0x1d7d) return chr+0xee6;
    if (chr == 0x1d8e) return chr+0x8a38;
    if (chr < 0x1e01) return chr;
    if ((chr & 1) == 1 && chr <= 0x1e95) return chr-1;
    if (chr == 0x1e9b) return chr-0x3b;
    if (chr < 0x1ea1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1eff) return chr-1;
    if (chr < 0x1f00) return chr;
    if (chr <= 0x1f07) return chr+8;
    if (chr < 0x1f10) return chr;
    if (chr <= 0x1f15) return chr+8;
    if (chr < 0x1f20) return chr;
    if (chr <= 0x1f27) return chr+8;
    if (chr < 0x1f30) return chr;
    if (chr <= 0x1f37) return chr+8;
    if (chr < 0x1f40) return chr;
    if (chr <= 0x1f45) return chr+8;
    if (chr < 0x1f51) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f57) return chr+8;
    if (chr < 0x1f60) return chr;
    if (chr <= 0x1f67) return chr+8;
    if (chr < 0x1f70) return chr;
    if (chr <= 0x1f71) return chr+0x4a;
    if (chr < 0x1f72) return chr;
    if (chr <= 0x1f75) return chr+0x56;
    if (chr < 0x1f76) return chr;
    if (chr <= 0x1f77) return chr+0x64;
    if (chr < 0x1f78) return chr;
    if (chr <= 0x1f79) return chr+0x80;
    if (chr < 0x1f7a) return chr;
    if (chr <= 0x1f7b) return chr+0x70;
    if (chr < 0x1f7c) return chr;
    if (chr <= 0x1f7d) return chr+0x7e;
    if (chr < 0x1f80) return chr;
    if (chr <= 0x1f87) return chr+8;
    if (chr < 0x1f90) return chr;
    if (chr <= 0x1f97) return chr+8;
    if (chr < 0x1fa0) return chr;
    if (chr <= 0x1fa7) return chr+8;
    if (chr < 0x1fb0) return chr;
    if (chr <= 0x1fb1) return chr+8;
    if (chr == 0x1fb3) return chr+9;
    if (chr == 0x1fbe) return chr-0x1c25;
    if (chr == 0x1fc3) return chr+9;
    if (chr < 0x1fd0) return chr;
    if (chr <= 0x1fd1) return chr+8;
    if (chr < 0x1fe0) return chr;
    if (chr <= 0x1fe1) return chr+8;
    if (chr == 0x1fe5) return chr+7;
    if (chr == 0x1ff3) return chr+9;
    if (chr == 0x214e) return chr-0x1c;
    if (chr < 0x2170) return chr;
    if (chr <= 0x217f) return chr-0x10;
    if (chr == 0x2184) return chr-1;
    if (chr < 0x24d0) return chr;
    if (chr <= 0x24e9) return chr-0x1a;
    if (chr < 0x2c30) return chr;
    if (chr <= 0x2c5f) return chr-0x30;
    if (chr == 0x2c61) return chr-1;
    if (chr == 0x2c65) return chr-0x2a2b;
    if (chr == 0x2c66) return chr-0x2a28;
    if (chr < 0x2c68) return chr;
    if ((chr & 1) == 0 && chr <= 0x2c6c) return chr-1;
    if (chr == 0x2c73) return chr-1;
    if (chr == 0x2c76) return chr-1;
    if (chr < 0x2c81) return chr;
    if ((chr & 1) == 1 && chr <= 0x2ce3) return chr-1;
    if (chr < 0x2cec) return chr;
    if ((chr & 1) == 0 && chr <= 0x2cee) return chr-1;
    if (chr == 0x2cf3) return chr-1;
    if (chr < 0x2d00) return chr;
    if (chr <= 0x2d25) return chr-0x1c60;
    if (chr == 0x2d27) return chr-0x1c60;
    if (chr == 0x2d2d) return chr-0x1c60;
    if (chr < 0xa641) return chr;
    if ((chr & 1) == 1 && chr <= 0xa66d) return chr-1;
    if (chr < 0xa681) return chr;
    if ((chr & 1) == 1 && chr <= 0xa69b) return chr-1;
    if (chr < 0xa723) return chr;
    if ((chr & 1) == 1 && chr <= 0xa72f) return chr-1;
    if (chr < 0xa733) return chr;
    if ((chr & 1) == 1 && chr <= 0xa76f) return chr-1;
    if (chr < 0xa77a) return chr;
    if ((chr & 1) == 0 && chr <= 0xa77c) return chr-1;
    if (chr < 0xa77f) return chr;
    if ((chr & 1) == 1 && chr <= 0xa787) return chr-1;
    if (chr == 0xa78c) return chr-1;
    if (chr < 0xa791) return chr;
    if ((chr & 1) == 1 && chr <= 0xa793) return chr-1;
    if (chr == 0xa794) return chr+0x30;
    if (chr < 0xa797) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7a9) return chr-1;
    if (chr < 0xa7b5) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7c3) return chr-1;
    if (chr < 0xa7c8) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7ca) return chr-1;
    if (chr == 0xa7d1) return chr-1;
    if (chr < 0xa7d7) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7d9) return chr-1;
    if (chr == 0xa7f6) return chr-1;
    if (chr == 0xab53) return chr-0x3a0;
    if (chr < 0xab70) return chr;
    if (chr <= 0xabbf) return chr-0x97d0;
    if (chr < 0xff41) return chr;
    if (chr <= 0xff5a) return chr-0x20;
    if (chr < 0x10428) return chr;
    if (chr <= 0x1044f) return chr-0x28;
    if (chr < 0x104d8) return chr;
    if (chr <= 0x104fb) return chr-0x28;
    if (chr < 0x10597) return chr;
    if (chr <= 0x105a1) return chr-0x27;
    if (chr < 0x105a3) return chr;
    if (chr <= 0x105b1) return chr-0x27;
    if (chr < 0x105b3) return chr;
    if (chr <= 0x105b9) return chr-0x27;
    if (chr < 0x105bb) return chr;
    if (chr <= 0x105bc) return chr-0x27;
    if (chr < 0x10cc0) return chr;
    if (chr <= 0x10cf2) return chr-0x40;
    if (chr < 0x118c0) return chr;
    if (chr <= 0x118df) return chr-0x20;
    if (chr < 0x16e60) return chr;
    if (chr <= 0x16e7f) return chr-0x20;
    if (chr < 0x1e922) return chr;
    if (chr <= 0x1e943) return chr-0x22;
    return chr;
  }

int is_a_lower_case_letter_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x61) return false;
    if (chr <= 0x7a) return true;
    if (chr == 0xb5) return true;
    if (chr < 0xdf) return false;
    if (chr <= 0xf6) return true;
    if (chr < 0xf8) return false;
    if (chr <= 0xff) return true;
    if (chr < 0x101) return false;
    if ((chr & 1) == 1 && chr <= 0x137) return true;
    if (chr < 0x138) return false;
    if ((chr & 1) == 0 && chr <= 0x148) return true;
    if (chr < 0x149) return false;
    if ((chr & 1) == 1 && chr <= 0x177) return true;
    if (chr < 0x17a) return false;
    if ((chr & 1) == 0 && chr <= 0x17e) return true;
    if (chr < 0x17f) return false;
    if (chr <= 0x180) return true;
    if (chr < 0x183) return false;
    if ((chr & 1) == 1 && chr <= 0x185) return true;
    if (chr == 0x188) return true;
    if (chr < 0x18c) return false;
    if (chr <= 0x18d) return true;
    if (chr == 0x192) return true;
    if (chr == 0x195) return true;
    if (chr < 0x199) return false;
    if (chr <= 0x19b) return true;
    if (chr == 0x19e) return true;
    if (chr < 0x1a1) return false;
    if ((chr & 1) == 1 && chr <= 0x1a5) return true;
    if (chr < 0x1a8) return false;
    if ((chr & 1) == 0 && chr <= 0x1aa) return true;
    if (chr < 0x1ab) return false;
    if ((chr & 1) == 1 && chr <= 0x1ad) return true;
    if (chr == 0x1b0) return true;
    if (chr < 0x1b4) return false;
    if ((chr & 1) == 0 && chr <= 0x1b6) return true;
    if (chr < 0x1b9) return false;
    if (chr <= 0x1ba) return true;
    if (chr < 0x1bd) return false;
    if (chr <= 0x1bf) return true;
    if (chr == 0x1c6) return true;
    if (chr == 0x1c9) return true;
    if (chr < 0x1cc) return false;
    if ((chr & 1) == 0 && chr <= 0x1dc) return true;
    if (chr < 0x1dd) return false;
    if ((chr & 1) == 1 && chr <= 0x1ef) return true;
    if (chr == 0x1f0) return true;
    if (chr < 0x1f3) return false;
    if ((chr & 1) == 1 && chr <= 0x1f5) return true;
    if (chr < 0x1f9) return false;
    if ((chr & 1) == 1 && chr <= 0x233) return true;
    if (chr < 0x234) return false;
    if (chr <= 0x239) return true;
    if (chr == 0x23c) return true;
    if (chr < 0x23f) return false;
    if (chr <= 0x240) return true;
    if (chr == 0x242) return true;
    if (chr < 0x247) return false;
    if ((chr & 1) == 1 && chr <= 0x24f) return true;
    if (chr < 0x250) return false;
    if (chr <= 0x293) return true;
    if (chr < 0x295) return false;
    if (chr <= 0x2af) return true;
    if (chr < 0x371) return false;
    if ((chr & 1) == 1 && chr <= 0x373) return true;
    if (chr == 0x377) return true;
    if (chr < 0x37b) return false;
    if (chr <= 0x37d) return true;
    if (chr == 0x390) return true;
    if (chr < 0x3ac) return false;
    if (chr <= 0x3ce) return true;
    if (chr < 0x3d0) return false;
    if (chr <= 0x3d1) return true;
    if (chr < 0x3d5) return false;
    if (chr <= 0x3d7) return true;
    if (chr < 0x3d9) return false;
    if ((chr & 1) == 1 && chr <= 0x3ef) return true;
    if (chr < 0x3f0) return false;
    if (chr <= 0x3f3) return true;
    if (chr == 0x3f5) return true;
    if (chr == 0x3f8) return true;
    if (chr < 0x3fb) return false;
    if (chr <= 0x3fc) return true;
    if (chr < 0x430) return false;
    if (chr <= 0x45f) return true;
    if (chr < 0x461) return false;
    if ((chr & 1) == 1 && chr <= 0x481) return true;
    if (chr < 0x48b) return false;
    if ((chr & 1) == 1 && chr <= 0x4bf) return true;
    if (chr < 0x4c2) return false;
    if ((chr & 1) == 0 && chr <= 0x4ce) return true;
    if (chr < 0x4cf) return false;
    if ((chr & 1) == 1 && chr <= 0x52f) return true;
    if (chr < 0x560) return false;
    if (chr <= 0x588) return true;
    if (chr < 0x10d0) return false;
    if (chr <= 0x10fa) return true;
    if (chr < 0x10fd) return false;
    if (chr <= 0x10ff) return true;
    if (chr < 0x13f8) return false;
    if (chr <= 0x13fd) return true;
    if (chr < 0x1c80) return false;
    if (chr <= 0x1c88) return true;
    if (chr < 0x1d00) return false;
    if (chr <= 0x1d2b) return true;
    if (chr < 0x1d6b) return false;
    if (chr <= 0x1d77) return true;
    if (chr < 0x1d79) return false;
    if (chr <= 0x1d9a) return true;
    if (chr < 0x1e01) return false;
    if ((chr & 1) == 1 && chr <= 0x1e95) return true;
    if (chr < 0x1e96) return false;
    if (chr <= 0x1e9d) return true;
    if (chr < 0x1e9f) return false;
    if ((chr & 1) == 1 && chr <= 0x1eff) return true;
    if (chr < 0x1f00) return false;
    if (chr <= 0x1f07) return true;
    if (chr < 0x1f10) return false;
    if (chr <= 0x1f15) return true;
    if (chr < 0x1f20) return false;
    if (chr <= 0x1f27) return true;
    if (chr < 0x1f30) return false;
    if (chr <= 0x1f37) return true;
    if (chr < 0x1f40) return false;
    if (chr <= 0x1f45) return true;
    if (chr < 0x1f50) return false;
    if (chr <= 0x1f57) return true;
    if (chr < 0x1f60) return false;
    if (chr <= 0x1f67) return true;
    if (chr < 0x1f70) return false;
    if (chr <= 0x1f7d) return true;
    if (chr < 0x1f80) return false;
    if (chr <= 0x1f87) return true;
    if (chr < 0x1f90) return false;
    if (chr <= 0x1f97) return true;
    if (chr < 0x1fa0) return false;
    if (chr <= 0x1fa7) return true;
    if (chr < 0x1fb0) return false;
    if (chr <= 0x1fb4) return true;
    if (chr < 0x1fb6) return false;
    if (chr <= 0x1fb7) return true;
    if (chr == 0x1fbe) return true;
    if (chr < 0x1fc2) return false;
    if (chr <= 0x1fc4) return true;
    if (chr < 0x1fc6) return false;
    if (chr <= 0x1fc7) return true;
    if (chr < 0x1fd0) return false;
    if (chr <= 0x1fd3) return true;
    if (chr < 0x1fd6) return false;
    if (chr <= 0x1fd7) return true;
    if (chr < 0x1fe0) return false;
    if (chr <= 0x1fe7) return true;
    if (chr < 0x1ff2) return false;
    if (chr <= 0x1ff4) return true;
    if (chr < 0x1ff6) return false;
    if (chr <= 0x1ff7) return true;
    if (chr == 0x210a) return true;
    if (chr < 0x210e) return false;
    if (chr <= 0x210f) return true;
    if (chr == 0x2113) return true;
    if (chr == 0x212f) return true;
    if (chr == 0x2134) return true;
    if (chr == 0x2139) return true;
    if (chr < 0x213c) return false;
    if (chr <= 0x213d) return true;
    if (chr < 0x2146) return false;
    if (chr <= 0x2149) return true;
    if (chr == 0x214e) return true;
    if (chr == 0x2184) return true;
    if (chr < 0x2c30) return false;
    if (chr <= 0x2c5f) return true;
    if (chr == 0x2c61) return true;
    if (chr < 0x2c65) return false;
    if (chr <= 0x2c66) return true;
    if (chr < 0x2c68) return false;
    if ((chr & 1) == 0 && chr <= 0x2c6c) return true;
    if (chr < 0x2c71) return false;
    if ((chr & 1) == 1 && chr <= 0x2c73) return true;
    if (chr < 0x2c74) return false;
    if ((chr & 1) == 0 && chr <= 0x2c76) return true;
    if (chr < 0x2c77) return false;
    if (chr <= 0x2c7b) return true;
    if (chr < 0x2c81) return false;
    if ((chr & 1) == 1 && chr <= 0x2ce3) return true;
    if (chr == 0x2ce4) return true;
    if (chr < 0x2cec) return false;
    if ((chr & 1) == 0 && chr <= 0x2cee) return true;
    if (chr == 0x2cf3) return true;
    if (chr < 0x2d00) return false;
    if (chr <= 0x2d25) return true;
    if (chr == 0x2d27) return true;
    if (chr == 0x2d2d) return true;
    if (chr < 0xa641) return false;
    if ((chr & 1) == 1 && chr <= 0xa66d) return true;
    if (chr < 0xa681) return false;
    if ((chr & 1) == 1 && chr <= 0xa69b) return true;
    if (chr < 0xa723) return false;
    if ((chr & 1) == 1 && chr <= 0xa72f) return true;
    if (chr < 0xa730) return false;
    if (chr <= 0xa731) return true;
    if (chr < 0xa733) return false;
    if ((chr & 1) == 1 && chr <= 0xa771) return true;
    if (chr < 0xa772) return false;
    if (chr <= 0xa778) return true;
    if (chr < 0xa77a) return false;
    if ((chr & 1) == 0 && chr <= 0xa77c) return true;
    if (chr < 0xa77f) return false;
    if ((chr & 1) == 1 && chr <= 0xa787) return true;
    if (chr < 0xa78c) return false;
    if ((chr & 1) == 0 && chr <= 0xa78e) return true;
    if (chr < 0xa791) return false;
    if ((chr & 1) == 1 && chr <= 0xa793) return true;
    if (chr < 0xa794) return false;
    if (chr <= 0xa795) return true;
    if (chr < 0xa797) return false;
    if ((chr & 1) == 1 && chr <= 0xa7a9) return true;
    if (chr == 0xa7af) return true;
    if (chr < 0xa7b5) return false;
    if ((chr & 1) == 1 && chr <= 0xa7c3) return true;
    if (chr < 0xa7c8) return false;
    if ((chr & 1) == 0 && chr <= 0xa7ca) return true;
    if (chr < 0xa7d1) return false;
    if ((chr & 1) == 1 && chr <= 0xa7d9) return true;
    if (chr == 0xa7f6) return true;
    if (chr == 0xa7fa) return true;
    if (chr < 0xab30) return false;
    if (chr <= 0xab5a) return true;
    if (chr < 0xab60) return false;
    if (chr <= 0xab68) return true;
    if (chr < 0xab70) return false;
    if (chr <= 0xabbf) return true;
    if (chr < 0xfb00) return false;
    if (chr <= 0xfb06) return true;
    if (chr < 0xfb13) return false;
    if (chr <= 0xfb17) return true;
    if (chr < 0xff41) return false;
    if (chr <= 0xff5a) return true;
    if (chr < 0x10428) return false;
    if (chr <= 0x1044f) return true;
    if (chr < 0x104d8) return false;
    if (chr <= 0x104fb) return true;
    if (chr < 0x10597) return false;
    if (chr <= 0x105a1) return true;
    if (chr < 0x105a3) return false;
    if (chr <= 0x105b1) return true;
    if (chr < 0x105b3) return false;
    if (chr <= 0x105b9) return true;
    if (chr < 0x105bb) return false;
    if (chr <= 0x105bc) return true;
    if (chr < 0x10cc0) return false;
    if (chr <= 0x10cf2) return true;
    if (chr < 0x118c0) return false;
    if (chr <= 0x118df) return true;
    if (chr < 0x16e60) return false;
    if (chr <= 0x16e7f) return true;
    if (chr < 0x1d41a) return false;
    if (chr <= 0x1d433) return true;
    if (chr < 0x1d44e) return false;
    if (chr <= 0x1d454) return true;
    if (chr < 0x1d456) return false;
    if (chr <= 0x1d467) return true;
    if (chr < 0x1d482) return false;
    if (chr <= 0x1d49b) return true;
    if (chr < 0x1d4b6) return false;
    if (chr <= 0x1d4b9) return true;
    if (chr < 0x1d4bb) return false;
    if ((chr & 1) == 1 && chr <= 0x1d4bd) return true;
    if (chr < 0x1d4be) return false;
    if (chr <= 0x1d4c3) return true;
    if (chr < 0x1d4c5) return false;
    if (chr <= 0x1d4cf) return true;
    if (chr < 0x1d4ea) return false;
    if (chr <= 0x1d503) return true;
    if (chr < 0x1d51e) return false;
    if (chr <= 0x1d537) return true;
    if (chr < 0x1d552) return false;
    if (chr <= 0x1d56b) return true;
    if (chr < 0x1d586) return false;
    if (chr <= 0x1d59f) return true;
    if (chr < 0x1d5ba) return false;
    if (chr <= 0x1d5d3) return true;
    if (chr < 0x1d5ee) return false;
    if (chr <= 0x1d607) return true;
    if (chr < 0x1d622) return false;
    if (chr <= 0x1d63b) return true;
    if (chr < 0x1d656) return false;
    if (chr <= 0x1d66f) return true;
    if (chr < 0x1d68a) return false;
    if (chr <= 0x1d6a5) return true;
    if (chr < 0x1d6c2) return false;
    if (chr <= 0x1d6da) return true;
    if (chr < 0x1d6dc) return false;
    if (chr <= 0x1d6e1) return true;
    if (chr < 0x1d6fc) return false;
    if (chr <= 0x1d714) return true;
    if (chr < 0x1d716) return false;
    if (chr <= 0x1d71b) return true;
    if (chr < 0x1d736) return false;
    if (chr <= 0x1d74e) return true;
    if (chr < 0x1d750) return false;
    if (chr <= 0x1d755) return true;
    if (chr < 0x1d770) return false;
    if (chr <= 0x1d788) return true;
    if (chr < 0x1d78a) return false;
    if (chr <= 0x1d78f) return true;
    if (chr < 0x1d7aa) return false;
    if (chr <= 0x1d7c2) return true;
    if (chr < 0x1d7c4) return false;
    if (chr <= 0x1d7c9) return true;
    if (chr == 0x1d7cb) return true;
    if (chr < 0x1df00) return false;
    if (chr <= 0x1df09) return true;
    if (chr < 0x1df0b) return false;
    if (chr <= 0x1df1e) return true;
    if (chr < 0x1df25) return false;
    if (chr <= 0x1df2a) return true;
    if (chr < 0x1e922) return false;
    if (chr <= 0x1e943) return true;
    return false;
  }

static uint32_t to_lower_case
  (
    uint32_t chr
  )
  {
    if (chr < 0x41) return chr;
    if (chr <= 0x5a) return chr+0x20;
    if (chr < 0xc0) return chr;
    if (chr <= 0xd6) return chr+0x20;
    if (chr < 0xd8) return chr;
    if (chr <= 0xde) return chr+0x20;
    if (chr < 0x100) return chr;
    if ((chr & 1) == 0 && chr <= 0x12e) return chr+1;
    if (chr == 0x130) return chr-0xc7;
    if (chr < 0x132) return chr;
    if ((chr & 1) == 0 && chr <= 0x136) return chr+1;
    if (chr < 0x139) return chr;
    if ((chr & 1) == 1 && chr <= 0x147) return chr+1;
    if (chr < 0x14a) return chr;
    if ((chr & 1) == 0 && chr <= 0x176) return chr+1;
    if (chr == 0x178) return chr-0x79;
    if (chr < 0x179) return chr;
    if ((chr & 1) == 1 && chr <= 0x17d) return chr+1;
    if (chr == 0x181) return chr+0xd2;
    if (chr < 0x182) return chr;
    if ((chr & 1) == 0 && chr <= 0x184) return chr+1;
    if (chr == 0x186) return chr+0xce;
    if (chr == 0x187) return chr+1;
    if (chr < 0x189) return chr;
    if (chr <= 0x18a) return chr+0xcd;
    if (chr == 0x18b) return chr+1;
    if (chr == 0x18e) return chr+0x4f;
    if (chr == 0x18f) return chr+0xca;
    if (chr == 0x190) return chr+0xcb;
    if (chr == 0x191) return chr+1;
    if (chr == 0x193) return chr+0xcd;
    if (chr == 0x194) return chr+0xcf;
    if (chr == 0x196) return chr+0xd3;
    if (chr == 0x197) return chr+0xd1;
    if (chr == 0x198) return chr+1;
    if (chr == 0x19c) return chr+0xd3;
    if (chr == 0x19d) return chr+0xd5;
    if (chr == 0x19f) return chr+0xd6;
    if (chr < 0x1a0) return chr;
    if ((chr & 1) == 0 && chr <= 0x1a4) return chr+1;
    if (chr == 0x1a6) return chr+0xda;
    if (chr == 0x1a7) return chr+1;
    if (chr == 0x1a9) return chr+0xda;
    if (chr == 0x1ac) return chr+1;
    if (chr == 0x1ae) return chr+0xda;
    if (chr == 0x1af) return chr+1;
    if (chr < 0x1b1) return chr;
    if (chr <= 0x1b2) return chr+0xd9;
    if (chr < 0x1b3) return chr;
    if ((chr & 1) == 1 && chr <= 0x1b5) return chr+1;
    if (chr == 0x1b7) return chr+0xdb;
    if (chr == 0x1b8) return chr+1;
    if (chr == 0x1bc) return chr+1;
    if (chr == 0x1c4) return chr+2;
    if (chr == 0x1c5) return chr+1;
    if (chr == 0x1c7) return chr+2;
    if (chr == 0x1c8) return chr+1;
    if (chr == 0x1ca) return chr+2;
    if (chr < 0x1cb) return chr;
    if ((chr & 1) == 1 && chr <= 0x1db) return chr+1;
    if (chr < 0x1de) return chr;
    if ((chr & 1) == 0 && chr <= 0x1ee) return chr+1;
    if (chr == 0x1f1) return chr+2;
    if (chr < 0x1f2) return chr;
    if ((chr & 1) == 0 && chr <= 0x1f4) return chr+1;
    if (chr == 0x1f6) return chr-0x61;
    if (chr == 0x1f7) return chr-0x38;
    if (chr < 0x1f8) return chr;
    if ((chr & 1) == 0 && chr <= 0x21e) return chr+1;
    if (chr == 0x220) return chr-0x82;
    if (chr < 0x222) return chr;
    if ((chr & 1) == 0 && chr <= 0x232) return chr+1;
    if (chr == 0x23a) return chr+0x2a2b;
    if (chr == 0x23b) return chr+1;
    if (chr == 0x23d) return chr-0xa3;
    if (chr == 0x23e) return chr+0x2a28;
    if (chr == 0x241) return chr+1;
    if (chr == 0x243) return chr-0xc3;
    if (chr == 0x244) return chr+0x45;
    if (chr == 0x245) return chr+0x47;
    if (chr < 0x246) return chr;
    if ((chr & 1) == 0 && chr <= 0x24e) return chr+1;
    if (chr < 0x370) return chr;
    if ((chr & 1) == 0 && chr <= 0x372) return chr+1;
    if (chr == 0x376) return chr+1;
    if (chr == 0x37f) return chr+0x74;
    if (chr == 0x386) return chr+0x26;
    if (chr < 0x388) return chr;
    if (chr <= 0x38a) return chr+0x25;
    if (chr == 0x38c) return chr+0x40;
    if (chr < 0x38e) return chr;
    if (chr <= 0x38f) return chr+0x3f;
    if (chr < 0x391) return chr;
    if (chr <= 0x3a1) return chr+0x20;
    if (chr < 0x3a3) return chr;
    if (chr <= 0x3ab) return chr+0x20;
    if (chr == 0x3cf) return chr+8;
    if (chr < 0x3d8) return chr;
    if ((chr & 1) == 0 && chr <= 0x3ee) return chr+1;
    if (chr == 0x3f4) return chr-0x3c;
    if (chr == 0x3f7) return chr+1;
    if (chr == 0x3f9) return chr-7;
    if (chr == 0x3fa) return chr+1;
    if (chr < 0x3fd) return chr;
    if (chr <= 0x3ff) return chr-0x82;
    if (chr < 0x400) return chr;
    if (chr <= 0x40f) return chr+0x50;
    if (chr < 0x410) return chr;
    if (chr <= 0x42f) return chr+0x20;
    if (chr < 0x460) return chr;
    if ((chr & 1) == 0 && chr <= 0x480) return chr+1;
    if (chr < 0x48a) return chr;
    if ((chr & 1) == 0 && chr <= 0x4be) return chr+1;
    if (chr == 0x4c0) return chr+0xf;
    if (chr < 0x4c1) return chr;
    if ((chr & 1) == 1 && chr <= 0x4cd) return chr+1;
    if (chr < 0x4d0) return chr;
    if ((chr & 1) == 0 && chr <= 0x52e) return chr+1;
    if (chr < 0x531) return chr;
    if (chr <= 0x556) return chr+0x30;
    if (chr < 0x10a0) return chr;
    if (chr <= 0x10c5) return chr+0x1c60;
    if (chr == 0x10c7) return chr+0x1c60;
    if (chr == 0x10cd) return chr+0x1c60;
    if (chr < 0x13a0) return chr;
    if (chr <= 0x13ef) return chr+0x97d0;
    if (chr < 0x13f0) return chr;
    if (chr <= 0x13f5) return chr+8;
    if (chr < 0x1c90) return chr;
    if (chr <= 0x1cba) return chr-0xbc0;
    if (chr < 0x1cbd) return chr;
    if (chr <= 0x1cbf) return chr-0xbc0;
    if (chr < 0x1e00) return chr;
    if ((chr & 1) == 0 && chr <= 0x1e94) return chr+1;
    if (chr == 0x1e9e) return chr-0x1dbf;
    if (chr < 0x1ea0) return chr;
    if ((chr & 1) == 0 && chr <= 0x1efe) return chr+1;
    if (chr < 0x1f08) return chr;
    if (chr <= 0x1f0f) return chr-8;
    if (chr < 0x1f18) return chr;
    if (chr <= 0x1f1d) return chr-8;
    if (chr < 0x1f28) return chr;
    if (chr <= 0x1f2f) return chr-8;
    if (chr < 0x1f38) return chr;
    if (chr <= 0x1f3f) return chr-8;
    if (chr < 0x1f48) return chr;
    if (chr <= 0x1f4d) return chr-8;
    if (chr < 0x1f59) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f5f) return chr-8;
    if (chr < 0x1f68) return chr;
    if (chr <= 0x1f6f) return chr-8;
    if (chr < 0x1f88) return chr;
    if (chr <= 0x1f8f) return chr-8;
    if (chr < 0x1f98) return chr;
    if (chr <= 0x1f9f) return chr-8;
    if (chr < 0x1fa8) return chr;
    if (chr <= 0x1faf) return chr-8;
    if (chr < 0x1fb8) return chr;
    if (chr <= 0x1fb9) return chr-8;
    if (chr < 0x1fba) return chr;
    if (chr <= 0x1fbb) return chr-0x4a;
    if (chr == 0x1fbc) return chr-9;
    if (chr < 0x1fc8) return chr;
    if (chr <= 0x1fcb) return chr-0x56;
    if (chr == 0x1fcc) return chr-9;
    if (chr < 0x1fd8) return chr;
    if (chr <= 0x1fd9) return chr-8;
    if (chr < 0x1fda) return chr;
    if (chr <= 0x1fdb) return chr-0x64;
    if (chr < 0x1fe8) return chr;
    if (chr <= 0x1fe9) return chr-8;
    if (chr < 0x1fea) return chr;
    if (chr <= 0x1feb) return chr-0x70;
    if (chr == 0x1fec) return chr-7;
    if (chr < 0x1ff8) return chr;
    if (chr <= 0x1ff9) return chr-0x80;
    if (chr < 0x1ffa) return chr;
    if (chr <= 0x1ffb) return chr-0x7e;
    if (chr == 0x1ffc) return chr-9;
    if (chr == 0x2126) return chr-0x1d5d;
    if (chr == 0x212a) return chr-0x20bf;
    if (chr == 0x212b) return chr-0x2046;
    if (chr == 0x2132) return chr+0x1c;
    if (chr < 0x2160) return chr;
    if (chr <= 0x216f) return chr+0x10;
    if (chr == 0x2183) return chr+1;
    if (chr < 0x24b6) return chr;
    if (chr <= 0x24cf) return chr+0x1a;
    if (chr < 0x2c00) return chr;
    if (chr <= 0x2c2f) return chr+0x30;
    if (chr == 0x2c60) return chr+1;
    if (chr == 0x2c62) return chr-0x29f7;
    if (chr == 0x2c63) return chr-0xee6;
    if (chr == 0x2c64) return chr-0x29e7;
    if (chr < 0x2c67) return chr;
    if ((chr & 1) == 1 && chr <= 0x2c6b) return chr+1;
    if (chr == 0x2c6d) return chr-0x2a1c;
    if (chr == 0x2c6e) return chr-0x29fd;
    if (chr == 0x2c6f) return chr-0x2a1f;
    if (chr == 0x2c70) return chr-0x2a1e;
    if (chr == 0x2c72) return chr+1;
    if (chr == 0x2c75) return chr+1;
    if (chr < 0x2c7e) return chr;
    if (chr <= 0x2c7f) return chr-0x2a3f;
    if (chr < 0x2c80) return chr;
    if ((chr & 1) == 0 && chr <= 0x2ce2) return chr+1;
    if (chr < 0x2ceb) return chr;
    if ((chr & 1) == 1 && chr <= 0x2ced) return chr+1;
    if (chr == 0x2cf2) return chr+1;
    if (chr < 0xa640) return chr;
    if ((chr & 1) == 0 && chr <= 0xa66c) return chr+1;
    if (chr < 0xa680) return chr;
    if ((chr & 1) == 0 && chr <= 0xa69a) return chr+1;
    if (chr < 0xa722) return chr;
    if ((chr & 1) == 0 && chr <= 0xa72e) return chr+1;
    if (chr < 0xa732) return chr;
    if ((chr & 1) == 0 && chr <= 0xa76e) return chr+1;
    if (chr < 0xa779) return chr;
    if ((chr & 1) == 1 && chr <= 0xa77b) return chr+1;
    if (chr == 0xa77d) return chr-0x8a04;
    if (chr < 0xa77e) return chr;
    if ((chr & 1) == 0 && chr <= 0xa786) return chr+1;
    if (chr == 0xa78b) return chr+1;
    if (chr == 0xa78d) return chr-0xa528;
    if (chr < 0xa790) return chr;
    if ((chr & 1) == 0 && chr <= 0xa792) return chr+1;
    if (chr < 0xa796) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7a8) return chr+1;
    if (chr == 0xa7aa) return chr-0xa544;
    if (chr == 0xa7ab) return chr-0xa54f;
    if (chr == 0xa7ac) return chr-0xa54b;
    if (chr == 0xa7ad) return chr-0xa541;
    if (chr == 0xa7ae) return chr-0xa544;
    if (chr == 0xa7b0) return chr-0xa512;
    if (chr == 0xa7b1) return chr-0xa52a;
    if (chr == 0xa7b2) return chr-0xa515;
    if (chr == 0xa7b3) return chr+0x3a0;
    if (chr < 0xa7b4) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7c2) return chr+1;
    if (chr == 0xa7c4) return chr-0x30;
    if (chr == 0xa7c5) return chr-0xa543;
    if (chr == 0xa7c6) return chr-0x8a38;
    if (chr < 0xa7c7) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7c9) return chr+1;
    if (chr == 0xa7d0) return chr+1;
    if (chr < 0xa7d6) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7d8) return chr+1;
    if (chr == 0xa7f5) return chr+1;
    if (chr < 0xff21) return chr;
    if (chr <= 0xff3a) return chr+0x20;
    if (chr < 0x10400) return chr;
    if (chr <= 0x10427) return chr+0x28;
    if (chr < 0x104b0) return chr;
    if (chr <= 0x104d3) return chr+0x28;
    if (chr < 0x10570) return chr;
    if (chr <= 0x1057a) return chr+0x27;
    if (chr < 0x1057c) return chr;
    if (chr <= 0x1058a) return chr+0x27;
    if (chr < 0x1058c) return chr;
    if (chr <= 0x10592) return chr+0x27;
    if (chr < 0x10594) return chr;
    if (chr <= 0x10595) return chr+0x27;
    if (chr < 0x10c80) return chr;
    if (chr <= 0x10cb2) return chr+0x40;
    if (chr < 0x118a0) return chr;
    if (chr <= 0x118bf) return chr+0x20;
    if (chr < 0x16e40) return chr;
    if (chr <= 0x16e5f) return chr+0x20;
    if (chr < 0x1e900) return chr;
    if (chr <= 0x1e921) return chr+0x22;
    return chr;
  }

int is_a_title_case_letter_character
  (
    uint32_t chr
  )
  {
    if (chr == 0x1c5) return true;
    if (chr == 0x1c8) return true;
    if (chr == 0x1cb) return true;
    if (chr == 0x1f2) return true;
    if (chr < 0x1f88) return false;
    if (chr <= 0x1f8f) return true;
    if (chr < 0x1f98) return false;
    if (chr <= 0x1f9f) return true;
    if (chr < 0x1fa8) return false;
    if (chr <= 0x1faf) return true;
    if (chr == 0x1fbc) return true;
    if (chr == 0x1fcc) return true;
    if (chr == 0x1ffc) return true;
    return false;
  }

static uint32_t to_title_case
  (
    uint32_t chr
  )
  {
    if (chr < 0x61) return chr;
    if (chr <= 0x7a) return chr-0x20;
    if (chr == 0xb5) return chr+0x2e7;
    if (chr < 0xe0) return chr;
    if (chr <= 0xf6) return chr-0x20;
    if (chr < 0xf8) return chr;
    if (chr <= 0xfe) return chr-0x20;
    if (chr == 0xff) return chr+0x79;
    if (chr < 0x101) return chr;
    if ((chr & 1) == 1 && chr <= 0x12f) return chr-1;
    if (chr == 0x131) return chr-0xe8;
    if (chr < 0x133) return chr;
    if ((chr & 1) == 1 && chr <= 0x137) return chr-1;
    if (chr < 0x13a) return chr;
    if ((chr & 1) == 0 && chr <= 0x148) return chr-1;
    if (chr < 0x14b) return chr;
    if ((chr & 1) == 1 && chr <= 0x177) return chr-1;
    if (chr < 0x17a) return chr;
    if ((chr & 1) == 0 && chr <= 0x17e) return chr-1;
    if (chr == 0x17f) return chr-0x12c;
    if (chr == 0x180) return chr+0xc3;
    if (chr < 0x183) return chr;
    if ((chr & 1) == 1 && chr <= 0x185) return chr-1;
    if (chr == 0x188) return chr-1;
    if (chr == 0x18c) return chr-1;
    if (chr == 0x192) return chr-1;
    if (chr == 0x195) return chr+0x61;
    if (chr == 0x199) return chr-1;
    if (chr == 0x19a) return chr+0xa3;
    if (chr == 0x19e) return chr+0x82;
    if (chr < 0x1a1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1a5) return chr-1;
    if (chr == 0x1a8) return chr-1;
    if (chr == 0x1ad) return chr-1;
    if (chr == 0x1b0) return chr-1;
    if (chr < 0x1b4) return chr;
    if ((chr & 1) == 0 && chr <= 0x1b6) return chr-1;
    if (chr == 0x1b9) return chr-1;
    if (chr == 0x1bd) return chr-1;
    if (chr == 0x1bf) return chr+0x38;
    if (chr == 0x1c4) return chr+1;
    if (chr == 0x1c6) return chr-1;
    if (chr == 0x1c7) return chr+1;
    if (chr == 0x1c9) return chr-1;
    if (chr == 0x1ca) return chr+1;
    if (chr < 0x1cc) return chr;
    if ((chr & 1) == 0 && chr <= 0x1dc) return chr-1;
    if (chr == 0x1dd) return chr-0x4f;
    if (chr < 0x1df) return chr;
    if ((chr & 1) == 1 && chr <= 0x1ef) return chr-1;
    if (chr == 0x1f1) return chr+1;
    if (chr < 0x1f3) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f5) return chr-1;
    if (chr < 0x1f9) return chr;
    if ((chr & 1) == 1 && chr <= 0x21f) return chr-1;
    if (chr < 0x223) return chr;
    if ((chr & 1) == 1 && chr <= 0x233) return chr-1;
    if (chr == 0x23c) return chr-1;
    if (chr < 0x23f) return chr;
    if (chr <= 0x240) return chr+0x2a3f;
    if (chr == 0x242) return chr-1;
    if (chr < 0x247) return chr;
    if ((chr & 1) == 1 && chr <= 0x24f) return chr-1;
    if (chr == 0x250) return chr+0x2a1f;
    if (chr == 0x251) return chr+0x2a1c;
    if (chr == 0x252) return chr+0x2a1e;
    if (chr == 0x253) return chr-0xd2;
    if (chr == 0x254) return chr-0xce;
    if (chr < 0x256) return chr;
    if (chr <= 0x257) return chr-0xcd;
    if (chr == 0x259) return chr-0xca;
    if (chr == 0x25b) return chr-0xcb;
    if (chr == 0x25c) return chr+0xa54f;
    if (chr == 0x260) return chr-0xcd;
    if (chr == 0x261) return chr+0xa54b;
    if (chr == 0x263) return chr-0xcf;
    if (chr == 0x265) return chr+0xa528;
    if (chr == 0x266) return chr+0xa544;
    if (chr == 0x268) return chr-0xd1;
    if (chr == 0x269) return chr-0xd3;
    if (chr == 0x26a) return chr+0xa544;
    if (chr == 0x26b) return chr+0x29f7;
    if (chr == 0x26c) return chr+0xa541;
    if (chr == 0x26f) return chr-0xd3;
    if (chr == 0x271) return chr+0x29fd;
    if (chr == 0x272) return chr-0xd5;
    if (chr == 0x275) return chr-0xd6;
    if (chr == 0x27d) return chr+0x29e7;
    if (chr == 0x280) return chr-0xda;
    if (chr == 0x282) return chr+0xa543;
    if (chr == 0x283) return chr-0xda;
    if (chr == 0x287) return chr+0xa52a;
    if (chr == 0x288) return chr-0xda;
    if (chr == 0x289) return chr-0x45;
    if (chr < 0x28a) return chr;
    if (chr <= 0x28b) return chr-0xd9;
    if (chr == 0x28c) return chr-0x47;
    if (chr == 0x292) return chr-0xdb;
    if (chr == 0x29d) return chr+0xa515;
    if (chr == 0x29e) return chr+0xa512;
    if (chr == 0x345) return chr+0x54;
    if (chr < 0x371) return chr;
    if ((chr & 1) == 1 && chr <= 0x373) return chr-1;
    if (chr == 0x377) return chr-1;
    if (chr < 0x37b) return chr;
    if (chr <= 0x37d) return chr+0x82;
    if (chr == 0x3ac) return chr-0x26;
    if (chr < 0x3ad) return chr;
    if (chr <= 0x3af) return chr-0x25;
    if (chr < 0x3b1) return chr;
    if (chr <= 0x3c1) return chr-0x20;
    if (chr == 0x3c2) return chr-0x1f;
    if (chr < 0x3c3) return chr;
    if (chr <= 0x3cb) return chr-0x20;
    if (chr == 0x3cc) return chr-0x40;
    if (chr < 0x3cd) return chr;
    if (chr <= 0x3ce) return chr-0x3f;
    if (chr == 0x3d0) return chr-0x3e;
    if (chr == 0x3d1) return chr-0x39;
    if (chr == 0x3d5) return chr-0x2f;
    if (chr == 0x3d6) return chr-0x36;
    if (chr == 0x3d7) return chr-8;
    if (chr < 0x3d9) return chr;
    if ((chr & 1) == 1 && chr <= 0x3ef) return chr-1;
    if (chr == 0x3f0) return chr-0x56;
    if (chr == 0x3f1) return chr-0x50;
    if (chr == 0x3f2) return chr+7;
    if (chr == 0x3f3) return chr-0x74;
    if (chr == 0x3f5) return chr-0x60;
    if (chr == 0x3f8) return chr-1;
    if (chr == 0x3fb) return chr-1;
    if (chr < 0x430) return chr;
    if (chr <= 0x44f) return chr-0x20;
    if (chr < 0x450) return chr;
    if (chr <= 0x45f) return chr-0x50;
    if (chr < 0x461) return chr;
    if ((chr & 1) == 1 && chr <= 0x481) return chr-1;
    if (chr < 0x48b) return chr;
    if ((chr & 1) == 1 && chr <= 0x4bf) return chr-1;
    if (chr < 0x4c2) return chr;
    if ((chr & 1) == 0 && chr <= 0x4ce) return chr-1;
    if (chr == 0x4cf) return chr-0xf;
    if (chr < 0x4d1) return chr;
    if ((chr & 1) == 1 && chr <= 0x52f) return chr-1;
    if (chr < 0x561) return chr;
    if (chr <= 0x586) return chr-0x30;
    if (chr < 0x13f8) return chr;
    if (chr <= 0x13fd) return chr-8;
    if (chr == 0x1c80) return chr-0x186e;
    if (chr == 0x1c81) return chr-0x186d;
    if (chr == 0x1c82) return chr-0x1864;
    if (chr < 0x1c83) return chr;
    if (chr <= 0x1c84) return chr-0x1862;
    if (chr == 0x1c85) return chr-0x1863;
    if (chr == 0x1c86) return chr-0x185c;
    if (chr == 0x1c87) return chr-0x1825;
    if (chr == 0x1c88) return chr+0x89c2;
    if (chr == 0x1d79) return chr+0x8a04;
    if (chr == 0x1d7d) return chr+0xee6;
    if (chr == 0x1d8e) return chr+0x8a38;
    if (chr < 0x1e01) return chr;
    if ((chr & 1) == 1 && chr <= 0x1e95) return chr-1;
    if (chr == 0x1e9b) return chr-0x3b;
    if (chr < 0x1ea1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1eff) return chr-1;
    if (chr < 0x1f00) return chr;
    if (chr <= 0x1f07) return chr+8;
    if (chr < 0x1f10) return chr;
    if (chr <= 0x1f15) return chr+8;
    if (chr < 0x1f20) return chr;
    if (chr <= 0x1f27) return chr+8;
    if (chr < 0x1f30) return chr;
    if (chr <= 0x1f37) return chr+8;
    if (chr < 0x1f40) return chr;
    if (chr <= 0x1f45) return chr+8;
    if (chr < 0x1f51) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f57) return chr+8;
    if (chr < 0x1f60) return chr;
    if (chr <= 0x1f67) return chr+8;
    if (chr < 0x1f70) return chr;
    if (chr <= 0x1f71) return chr+0x4a;
    if (chr < 0x1f72) return chr;
    if (chr <= 0x1f75) return chr+0x56;
    if (chr < 0x1f76) return chr;
    if (chr <= 0x1f77) return chr+0x64;
    if (chr < 0x1f78) return chr;
    if (chr <= 0x1f79) return chr+0x80;
    if (chr < 0x1f7a) return chr;
    if (chr <= 0x1f7b) return chr+0x70;
    if (chr < 0x1f7c) return chr;
    if (chr <= 0x1f7d) return chr+0x7e;
    if (chr < 0x1f80) return chr;
    if (chr <= 0x1f87) return chr+8;
    if (chr < 0x1f90) return chr;
    if (chr <= 0x1f97) return chr+8;
    if (chr < 0x1fa0) return chr;
    if (chr <= 0x1fa7) return chr+8;
    if (chr < 0x1fb0) return chr;
    if (chr <= 0x1fb1) return chr+8;
    if (chr == 0x1fb3) return chr+9;
    if (chr == 0x1fbe) return chr-0x1c25;
    if (chr == 0x1fc3) return chr+9;
    if (chr < 0x1fd0) return chr;
    if (chr <= 0x1fd1) return chr+8;
    if (chr < 0x1fe0) return chr;
    if (chr <= 0x1fe1) return chr+8;
    if (chr == 0x1fe5) return chr+7;
    if (chr == 0x1ff3) return chr+9;
    if (chr == 0x214e) return chr-0x1c;
    if (chr < 0x2170) return chr;
    if (chr <= 0x217f) return chr-0x10;
    if (chr == 0x2184) return chr-1;
    if (chr < 0x24d0) return chr;
    if (chr <= 0x24e9) return chr-0x1a;
    if (chr < 0x2c30) return chr;
    if (chr <= 0x2c5f) return chr-0x30;
    if (chr == 0x2c61) return chr-1;
    if (chr == 0x2c65) return chr-0x2a2b;
    if (chr == 0x2c66) return chr-0x2a28;
    if (chr < 0x2c68) return chr;
    if ((chr & 1) == 0 && chr <= 0x2c6c) return chr-1;
    if (chr == 0x2c73) return chr-1;
    if (chr == 0x2c76) return chr-1;
    if (chr < 0x2c81) return chr;
    if ((chr & 1) == 1 && chr <= 0x2ce3) return chr-1;
    if (chr < 0x2cec) return chr;
    if ((chr & 1) == 0 && chr <= 0x2cee) return chr-1;
    if (chr == 0x2cf3) return chr-1;
    if (chr < 0x2d00) return chr;
    if (chr <= 0x2d25) return chr-0x1c60;
    if (chr == 0x2d27) return chr-0x1c60;
    if (chr == 0x2d2d) return chr-0x1c60;
    if (chr < 0xa641) return chr;
    if ((chr & 1) == 1 && chr <= 0xa66d) return chr-1;
    if (chr < 0xa681) return chr;
    if ((chr & 1) == 1 && chr <= 0xa69b) return chr-1;
    if (chr < 0xa723) return chr;
    if ((chr & 1) == 1 && chr <= 0xa72f) return chr-1;
    if (chr < 0xa733) return chr;
    if ((chr & 1) == 1 && chr <= 0xa76f) return chr-1;
    if (chr < 0xa77a) return chr;
    if ((chr & 1) == 0 && chr <= 0xa77c) return chr-1;
    if (chr < 0xa77f) return chr;
    if ((chr & 1) == 1 && chr <= 0xa787) return chr-1;
    if (chr == 0xa78c) return chr-1;
    if (chr < 0xa791) return chr;
    if ((chr & 1) == 1 && chr <= 0xa793) return chr-1;
    if (chr == 0xa794) return chr+0x30;
    if (chr < 0xa797) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7a9) return chr-1;
    if (chr < 0xa7b5) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7c3) return chr-1;
    if (chr < 0xa7c8) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7ca) return chr-1;
    if (chr == 0xa7d1) return chr-1;
    if (chr < 0xa7d7) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7d9) return chr-1;
    if (chr == 0xa7f6) return chr-1;
    if (chr == 0xab53) return chr-0x3a0;
    if (chr < 0xab70) return chr;
    if (chr <= 0xabbf) return chr-0x97d0;
    if (chr < 0xff41) return chr;
    if (chr <= 0xff5a) return chr-0x20;
    if (chr < 0x10428) return chr;
    if (chr <= 0x1044f) return chr-0x28;
    if (chr < 0x104d8) return chr;
    if (chr <= 0x104fb) return chr-0x28;
    if (chr < 0x10597) return chr;
    if (chr <= 0x105a1) return chr-0x27;
    if (chr < 0x105a3) return chr;
    if (chr <= 0x105b1) return chr-0x27;
    if (chr < 0x105b3) return chr;
    if (chr <= 0x105b9) return chr-0x27;
    if (chr < 0x105bb) return chr;
    if (chr <= 0x105bc) return chr-0x27;
    if (chr < 0x10cc0) return chr;
    if (chr <= 0x10cf2) return chr-0x40;
    if (chr < 0x118c0) return chr;
    if (chr <= 0x118df) return chr-0x20;
    if (chr < 0x16e60) return chr;
    if (chr <= 0x16e7f) return chr-0x20;
    if (chr < 0x1e922) return chr;
    if (chr <= 0x1e943) return chr-0x22;
    return chr;
  }

int is_a_letter_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x41) return false;
    if (chr <= 0x5a) return true;
    if (chr < 0x61) return false;
    if (chr <= 0x7a) return true;
    if (chr == 0xb5) return true;
    if (chr < 0xc0) return false;
    if (chr <= 0xd6) return true;
    if (chr < 0xd8) return false;
    if (chr <= 0xf6) return true;
    if (chr < 0xf8) return false;
    if (chr <= 0x1ba) return true;
    if (chr < 0x1bc) return false;
    if (chr <= 0x1bf) return true;
    if (chr < 0x1c4) return false;
    if (chr <= 0x293) return true;
    if (chr < 0x295) return false;
    if (chr <= 0x2af) return true;
    if (chr < 0x370) return false;
    if (chr <= 0x373) return true;
    if (chr < 0x376) return false;
    if (chr <= 0x377) return true;
    if (chr < 0x37b) return false;
    if (chr <= 0x37d) return true;
    if (chr == 0x37f) return true;
    if (chr < 0x386) return false;
    if ((chr & 1) == 0 && chr <= 0x388) return true;
    if (chr < 0x389) return false;
    if (chr <= 0x38a) return true;
    if (chr < 0x38c) return false;
    if ((chr & 1) == 0 && chr <= 0x38e) return true;
    if (chr < 0x38f) return false;
    if (chr <= 0x3a1) return true;
    if (chr < 0x3a3) return false;
    if (chr <= 0x3f5) return true;
    if (chr < 0x3f7) return false;
    if (chr <= 0x481) return true;
    if (chr < 0x48a) return false;
    if (chr <= 0x52f) return true;
    if (chr < 0x531) return false;
    if (chr <= 0x556) return true;
    if (chr < 0x560) return false;
    if (chr <= 0x588) return true;
    if (chr < 0x10a0) return false;
    if (chr <= 0x10c5) return true;
    if (chr == 0x10c7) return true;
    if (chr == 0x10cd) return true;
    if (chr < 0x10d0) return false;
    if (chr <= 0x10fa) return true;
    if (chr < 0x10fd) return false;
    if (chr <= 0x10ff) return true;
    if (chr < 0x13a0) return false;
    if (chr <= 0x13f5) return true;
    if (chr < 0x13f8) return false;
    if (chr <= 0x13fd) return true;
    if (chr < 0x1c80) return false;
    if (chr <= 0x1c88) return true;
    if (chr < 0x1c90) return false;
    if (chr <= 0x1cba) return true;
    if (chr < 0x1cbd) return false;
    if (chr <= 0x1cbf) return true;
    if (chr < 0x1d00) return false;
    if (chr <= 0x1d2b) return true;
    if (chr < 0x1d6b) return false;
    if (chr <= 0x1d77) return true;
    if (chr < 0x1d79) return false;
    if (chr <= 0x1d9a) return true;
    if (chr < 0x1e00) return false;
    if (chr <= 0x1f15) return true;
    if (chr < 0x1f18) return false;
    if (chr <= 0x1f1d) return true;
    if (chr < 0x1f20) return false;
    if (chr <= 0x1f45) return true;
    if (chr < 0x1f48) return false;
    if (chr <= 0x1f4d) return true;
    if (chr < 0x1f50) return false;
    if (chr <= 0x1f57) return true;
    if (chr < 0x1f59) return false;
    if ((chr & 1) == 1 && chr <= 0x1f5f) return true;
    if (chr < 0x1f60) return false;
    if (chr <= 0x1f7d) return true;
    if (chr < 0x1f80) return false;
    if (chr <= 0x1fb4) return true;
    if (chr < 0x1fb6) return false;
    if (chr <= 0x1fbc) return true;
    if (chr == 0x1fbe) return true;
    if (chr < 0x1fc2) return false;
    if (chr <= 0x1fc4) return true;
    if (chr < 0x1fc6) return false;
    if (chr <= 0x1fcc) return true;
    if (chr < 0x1fd0) return false;
    if (chr <= 0x1fd3) return true;
    if (chr < 0x1fd6) return false;
    if (chr <= 0x1fdb) return true;
    if (chr < 0x1fe0) return false;
    if (chr <= 0x1fec) return true;
    if (chr < 0x1ff2) return false;
    if (chr <= 0x1ff4) return true;
    if (chr < 0x1ff6) return false;
    if (chr <= 0x1ffc) return true;
    if (chr == 0x2102) return true;
    if (chr == 0x2107) return true;
    if (chr < 0x210a) return false;
    if (chr <= 0x2113) return true;
    if (chr == 0x2115) return true;
    if (chr < 0x2119) return false;
    if (chr <= 0x211d) return true;
    if (chr < 0x2124) return false;
    if ((chr & 1) == 0 && chr <= 0x212a) return true;
    if (chr < 0x212b) return false;
    if (chr <= 0x212d) return true;
    if (chr < 0x212f) return false;
    if (chr <= 0x2134) return true;
    if (chr == 0x2139) return true;
    if (chr < 0x213c) return false;
    if (chr <= 0x213f) return true;
    if (chr < 0x2145) return false;
    if (chr <= 0x2149) return true;
    if (chr == 0x214e) return true;
    if (chr < 0x2183) return false;
    if (chr <= 0x2184) return true;
    if (chr < 0x2c00) return false;
    if (chr <= 0x2c7b) return true;
    if (chr < 0x2c7e) return false;
    if (chr <= 0x2ce4) return true;
    if (chr < 0x2ceb) return false;
    if (chr <= 0x2cee) return true;
    if (chr < 0x2cf2) return false;
    if (chr <= 0x2cf3) return true;
    if (chr < 0x2d00) return false;
    if (chr <= 0x2d25) return true;
    if (chr == 0x2d27) return true;
    if (chr == 0x2d2d) return true;
    if (chr < 0xa640) return false;
    if (chr <= 0xa66d) return true;
    if (chr < 0xa680) return false;
    if (chr <= 0xa69b) return true;
    if (chr < 0xa722) return false;
    if (chr <= 0xa76f) return true;
    if (chr < 0xa771) return false;
    if (chr <= 0xa787) return true;
    if (chr < 0xa78b) return false;
    if (chr <= 0xa78e) return true;
    if (chr < 0xa790) return false;
    if (chr <= 0xa7ca) return true;
    if (chr < 0xa7d0) return false;
    if (chr <= 0xa7d1) return true;
    if (chr < 0xa7d3) return false;
    if ((chr & 1) == 1 && chr <= 0xa7d5) return true;
    if (chr < 0xa7d6) return false;
    if (chr <= 0xa7d9) return true;
    if (chr < 0xa7f5) return false;
    if (chr <= 0xa7f6) return true;
    if (chr == 0xa7fa) return true;
    if (chr < 0xab30) return false;
    if (chr <= 0xab5a) return true;
    if (chr < 0xab60) return false;
    if (chr <= 0xab68) return true;
    if (chr < 0xab70) return false;
    if (chr <= 0xabbf) return true;
    if (chr < 0xfb00) return false;
    if (chr <= 0xfb06) return true;
    if (chr < 0xfb13) return false;
    if (chr <= 0xfb17) return true;
    if (chr < 0xff21) return false;
    if (chr <= 0xff3a) return true;
    if (chr < 0xff41) return false;
    if (chr <= 0xff5a) return true;
    if (chr < 0x10400) return false;
    if (chr <= 0x1044f) return true;
    if (chr < 0x104b0) return false;
    if (chr <= 0x104d3) return true;
    if (chr < 0x104d8) return false;
    if (chr <= 0x104fb) return true;
    if (chr < 0x10570) return false;
    if (chr <= 0x1057a) return true;
    if (chr < 0x1057c) return false;
    if (chr <= 0x1058a) return true;
    if (chr < 0x1058c) return false;
    if (chr <= 0x10592) return true;
    if (chr < 0x10594) return false;
    if (chr <= 0x10595) return true;
    if (chr < 0x10597) return false;
    if (chr <= 0x105a1) return true;
    if (chr < 0x105a3) return false;
    if (chr <= 0x105b1) return true;
    if (chr < 0x105b3) return false;
    if (chr <= 0x105b9) return true;
    if (chr < 0x105bb) return false;
    if (chr <= 0x105bc) return true;
    if (chr < 0x10c80) return false;
    if (chr <= 0x10cb2) return true;
    if (chr < 0x10cc0) return false;
    if (chr <= 0x10cf2) return true;
    if (chr < 0x118a0) return false;
    if (chr <= 0x118df) return true;
    if (chr < 0x16e40) return false;
    if (chr <= 0x16e7f) return true;
    if (chr < 0x1d400) return false;
    if (chr <= 0x1d454) return true;
    if (chr < 0x1d456) return false;
    if (chr <= 0x1d49c) return true;
    if (chr < 0x1d49e) return false;
    if (chr <= 0x1d49f) return true;
    if (chr == 0x1d4a2) return true;
    if (chr < 0x1d4a5) return false;
    if (chr <= 0x1d4a6) return true;
    if (chr < 0x1d4a9) return false;
    if (chr <= 0x1d4ac) return true;
    if (chr < 0x1d4ae) return false;
    if (chr <= 0x1d4b9) return true;
    if (chr < 0x1d4bb) return false;
    if ((chr & 1) == 1 && chr <= 0x1d4bd) return true;
    if (chr < 0x1d4be) return false;
    if (chr <= 0x1d4c3) return true;
    if (chr < 0x1d4c5) return false;
    if (chr <= 0x1d505) return true;
    if (chr < 0x1d507) return false;
    if (chr <= 0x1d50a) return true;
    if (chr < 0x1d50d) return false;
    if (chr <= 0x1d514) return true;
    if (chr < 0x1d516) return false;
    if (chr <= 0x1d51c) return true;
    if (chr < 0x1d51e) return false;
    if (chr <= 0x1d539) return true;
    if (chr < 0x1d53b) return false;
    if (chr <= 0x1d53e) return true;
    if (chr < 0x1d540) return false;
    if (chr <= 0x1d544) return true;
    if (chr == 0x1d546) return true;
    if (chr < 0x1d54a) return false;
    if (chr <= 0x1d550) return true;
    if (chr < 0x1d552) return false;
    if (chr <= 0x1d6a5) return true;
    if (chr < 0x1d6a8) return false;
    if (chr <= 0x1d6c0) return true;
    if (chr < 0x1d6c2) return false;
    if (chr <= 0x1d6da) return true;
    if (chr < 0x1d6dc) return false;
    if (chr <= 0x1d6fa) return true;
    if (chr < 0x1d6fc) return false;
    if (chr <= 0x1d714) return true;
    if (chr < 0x1d716) return false;
    if (chr <= 0x1d734) return true;
    if (chr < 0x1d736) return false;
    if (chr <= 0x1d74e) return true;
    if (chr < 0x1d750) return false;
    if (chr <= 0x1d76e) return true;
    if (chr < 0x1d770) return false;
    if (chr <= 0x1d788) return true;
    if (chr < 0x1d78a) return false;
    if (chr <= 0x1d7a8) return true;
    if (chr < 0x1d7aa) return false;
    if (chr <= 0x1d7c2) return true;
    if (chr < 0x1d7c4) return false;
    if (chr <= 0x1d7cb) return true;
    if (chr < 0x1df00) return false;
    if (chr <= 0x1df09) return true;
    if (chr < 0x1df0b) return false;
    if (chr <= 0x1df1e) return true;
    if (chr < 0x1df25) return false;
    if (chr <= 0x1df2a) return true;
    if (chr < 0x1e900) return false;
    if (chr <= 0x1e943) return true;
    return false;
  }

int is_a_whitespace_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x1) return false;
    if (chr <= 0x20) return true;
    if (chr < 0x7f) return false;
    if (chr <= 0xa0) return true;
    if (chr == 0x1680) return true;
    if (chr < 0x2000) return false;
    if (chr <= 0x200a) return true;
    if (chr < 0x2028) return false;
    if (chr <= 0x2029) return true;
    if (chr == 0x202f) return true;
    if (chr == 0x205f) return true;
    if (chr == 0x3000) return true;
    return false;
  }

int is_a_zero_width_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x300) return false;
    if (chr <= 0x36f) return true;
    if (chr < 0x483) return false;
    if (chr <= 0x487) return true;
    if (chr < 0x591) return false;
    if (chr <= 0x5bd) return true;
    if (chr < 0x5bf) return false;
    if ((chr & 1) == 1 && chr <= 0x5c1) return true;
    if (chr < 0x5c2) return false;
    if ((chr & 1) == 0 && chr <= 0x5c4) return true;
    if (chr < 0x5c5) return false;
    if ((chr & 1) == 1 && chr <= 0x5c7) return true;
    if (chr < 0x610) return false;
    if (chr <= 0x61a) return true;
    if (chr < 0x64b) return false;
    if (chr <= 0x65f) return true;
    if (chr == 0x670) return true;
    if (chr < 0x6d6) return false;
    if (chr <= 0x6dc) return true;
    if (chr < 0x6df) return false;
    if (chr <= 0x6e4) return true;
    if (chr < 0x6e7) return false;
    if (chr <= 0x6e8) return true;
    if (chr < 0x6ea) return false;
    if (chr <= 0x6ed) return true;
    if (chr == 0x711) return true;
    if (chr < 0x730) return false;
    if (chr <= 0x74a) return true;
    if (chr < 0x7a6) return false;
    if (chr <= 0x7b0) return true;
    if (chr < 0x7eb) return false;
    if (chr <= 0x7f3) return true;
    if (chr == 0x7fd) return true;
    if (chr < 0x816) return false;
    if (chr <= 0x819) return true;
    if (chr < 0x81b) return false;
    if (chr <= 0x823) return true;
    if (chr < 0x825) return false;
    if (chr <= 0x827) return true;
    if (chr < 0x829) return false;
    if (chr <= 0x82d) return true;
    if (chr < 0x859) return false;
    if (chr <= 0x85b) return true;
    if (chr < 0x898) return false;
    if (chr <= 0x89f) return true;
    if (chr < 0x8ca) return false;
    if (chr <= 0x8e1) return true;
    if (chr < 0x8e3) return false;
    if (chr <= 0x902) return true;
    if (chr < 0x93a) return false;
    if ((chr & 1) == 0 && chr <= 0x93c) return true;
    if (chr < 0x941) return false;
    if (chr <= 0x948) return true;
    if (chr == 0x94d) return true;
    if (chr < 0x951) return false;
    if (chr <= 0x957) return true;
    if (chr < 0x962) return false;
    if (chr <= 0x963) return true;
    if (chr == 0x981) return true;
    if (chr == 0x9bc) return true;
    if (chr < 0x9c1) return false;
    if (chr <= 0x9c4) return true;
    if (chr == 0x9cd) return true;
    if (chr < 0x9e2) return false;
    if (chr <= 0x9e3) return true;
    if (chr == 0x9fe) return true;
    if (chr < 0xa01) return false;
    if (chr <= 0xa02) return true;
    if (chr == 0xa3c) return true;
    if (chr < 0xa41) return false;
    if (chr <= 0xa42) return true;
    if (chr < 0xa47) return false;
    if (chr <= 0xa48) return true;
    if (chr < 0xa4b) return false;
    if (chr <= 0xa4d) return true;
    if (chr == 0xa51) return true;
    if (chr < 0xa70) return false;
    if (chr <= 0xa71) return true;
    if (chr == 0xa75) return true;
    if (chr < 0xa81) return false;
    if (chr <= 0xa82) return true;
    if (chr == 0xabc) return true;
    if (chr < 0xac1) return false;
    if (chr <= 0xac5) return true;
    if (chr < 0xac7) return false;
    if (chr <= 0xac8) return true;
    if (chr == 0xacd) return true;
    if (chr < 0xae2) return false;
    if (chr <= 0xae3) return true;
    if (chr < 0xafa) return false;
    if (chr <= 0xaff) return true;
    if (chr == 0xb01) return true;
    if (chr == 0xb3c) return true;
    if (chr < 0xb3f) return false;
    if ((chr & 1) == 1 && chr <= 0xb41) return true;
    if (chr < 0xb42) return false;
    if (chr <= 0xb44) return true;
    if (chr == 0xb4d) return true;
    if (chr < 0xb55) return false;
    if (chr <= 0xb56) return true;
    if (chr < 0xb62) return false;
    if (chr <= 0xb63) return true;
    if (chr == 0xb82) return true;
    if (chr == 0xbc0) return true;
    if (chr == 0xbcd) return true;
    if (chr == 0xc00) return true;
    if (chr == 0xc04) return true;
    if (chr < 0xc3c) return false;
    if ((chr & 1) == 0 && chr <= 0xc3e) return true;
    if (chr < 0xc3f) return false;
    if (chr <= 0xc40) return true;
    if (chr < 0xc46) return false;
    if (chr <= 0xc48) return true;
    if (chr < 0xc4a) return false;
    if (chr <= 0xc4d) return true;
    if (chr < 0xc55) return false;
    if (chr <= 0xc56) return true;
    if (chr < 0xc62) return false;
    if (chr <= 0xc63) return true;
    if (chr == 0xc81) return true;
    if (chr == 0xcbc) return true;
    if (chr == 0xcbf) return true;
    if (chr == 0xcc6) return true;
    if (chr < 0xccc) return false;
    if (chr <= 0xccd) return true;
    if (chr < 0xce2) return false;
    if (chr <= 0xce3) return true;
    if (chr < 0xd00) return false;
    if (chr <= 0xd01) return true;
    if (chr < 0xd3b) return false;
    if (chr <= 0xd3c) return true;
    if (chr < 0xd41) return false;
    if (chr <= 0xd44) return true;
    if (chr == 0xd4d) return true;
    if (chr < 0xd62) return false;
    if (chr <= 0xd63) return true;
    if (chr == 0xd81) return true;
    if (chr == 0xdca) return true;
    if (chr < 0xdd2) return false;
    if (chr <= 0xdd4) return true;
    if (chr == 0xdd6) return true;
    if (chr == 0xe31) return true;
    if (chr < 0xe34) return false;
    if (chr <= 0xe3a) return true;
    if (chr < 0xe47) return false;
    if (chr <= 0xe4e) return true;
    if (chr == 0xeb1) return true;
    if (chr < 0xeb4) return false;
    if (chr <= 0xebc) return true;
    if (chr < 0xec8) return false;
    if (chr <= 0xece) return true;
    if (chr < 0xf18) return false;
    if (chr <= 0xf19) return true;
    if (chr < 0xf35) return false;
    if ((chr & 1) == 1 && chr <= 0xf39) return true;
    if (chr < 0xf71) return false;
    if (chr <= 0xf7e) return true;
    if (chr < 0xf80) return false;
    if (chr <= 0xf84) return true;
    if (chr < 0xf86) return false;
    if (chr <= 0xf87) return true;
    if (chr < 0xf8d) return false;
    if (chr <= 0xf97) return true;
    if (chr < 0xf99) return false;
    if (chr <= 0xfbc) return true;
    if (chr == 0xfc6) return true;
    if (chr < 0x102d) return false;
    if (chr <= 0x1030) return true;
    if (chr < 0x1032) return false;
    if (chr <= 0x1037) return true;
    if (chr < 0x1039) return false;
    if (chr <= 0x103a) return true;
    if (chr < 0x103d) return false;
    if (chr <= 0x103e) return true;
    if (chr < 0x1058) return false;
    if (chr <= 0x1059) return true;
    if (chr < 0x105e) return false;
    if (chr <= 0x1060) return true;
    if (chr < 0x1071) return false;
    if (chr <= 0x1074) return true;
    if (chr == 0x1082) return true;
    if (chr < 0x1085) return false;
    if (chr <= 0x1086) return true;
    if (chr == 0x108d) return true;
    if (chr == 0x109d) return true;
    if (chr < 0x135d) return false;
    if (chr <= 0x135f) return true;
    if (chr < 0x1712) return false;
    if (chr <= 0x1714) return true;
    if (chr < 0x1732) return false;
    if (chr <= 0x1733) return true;
    if (chr < 0x1752) return false;
    if (chr <= 0x1753) return true;
    if (chr < 0x1772) return false;
    if (chr <= 0x1773) return true;
    if (chr < 0x17b4) return false;
    if (chr <= 0x17b5) return true;
    if (chr < 0x17b7) return false;
    if (chr <= 0x17bd) return true;
    if (chr == 0x17c6) return true;
    if (chr < 0x17c9) return false;
    if (chr <= 0x17d3) return true;
    if (chr == 0x17dd) return true;
    if (chr < 0x180b) return false;
    if (chr <= 0x180d) return true;
    if (chr == 0x180f) return true;
    if (chr < 0x1885) return false;
    if (chr <= 0x1886) return true;
    if (chr == 0x18a9) return true;
    if (chr < 0x1920) return false;
    if (chr <= 0x1922) return true;
    if (chr < 0x1927) return false;
    if (chr <= 0x1928) return true;
    if (chr == 0x1932) return true;
    if (chr < 0x1939) return false;
    if (chr <= 0x193b) return true;
    if (chr < 0x1a17) return false;
    if (chr <= 0x1a18) return true;
    if (chr == 0x1a1b) return true;
    if (chr < 0x1a56) return false;
    if ((chr & 1) == 0 && chr <= 0x1a58) return true;
    if (chr < 0x1a59) return false;
    if (chr <= 0x1a5e) return true;
    if (chr < 0x1a60) return false;
    if ((chr & 1) == 0 && chr <= 0x1a62) return true;
    if (chr < 0x1a65) return false;
    if (chr <= 0x1a6c) return true;
    if (chr < 0x1a73) return false;
    if (chr <= 0x1a7c) return true;
    if (chr == 0x1a7f) return true;
    if (chr < 0x1ab0) return false;
    if (chr <= 0x1abd) return true;
    if (chr < 0x1abf) return false;
    if (chr <= 0x1ace) return true;
    if (chr < 0x1b00) return false;
    if (chr <= 0x1b03) return true;
    if (chr < 0x1b34) return false;
    if ((chr & 1) == 0 && chr <= 0x1b36) return true;
    if (chr < 0x1b37) return false;
    if (chr <= 0x1b3a) return true;
    if (chr == 0x1b3c) return true;
    if (chr == 0x1b42) return true;
    if (chr < 0x1b6b) return false;
    if (chr <= 0x1b73) return true;
    if (chr < 0x1b80) return false;
    if (chr <= 0x1b81) return true;
    if (chr < 0x1ba2) return false;
    if (chr <= 0x1ba5) return true;
    if (chr < 0x1ba8) return false;
    if (chr <= 0x1ba9) return true;
    if (chr < 0x1bab) return false;
    if (chr <= 0x1bad) return true;
    if (chr < 0x1be6) return false;
    if ((chr & 1) == 0 && chr <= 0x1be8) return true;
    if (chr == 0x1be9) return true;
    if (chr < 0x1bed) return false;
    if ((chr & 1) == 1 && chr <= 0x1bef) return true;
    if (chr < 0x1bf0) return false;
    if (chr <= 0x1bf1) return true;
    if (chr < 0x1c2c) return false;
    if (chr <= 0x1c33) return true;
    if (chr < 0x1c36) return false;
    if (chr <= 0x1c37) return true;
    if (chr < 0x1cd0) return false;
    if (chr <= 0x1cd2) return true;
    if (chr < 0x1cd4) return false;
    if (chr <= 0x1ce0) return true;
    if (chr < 0x1ce2) return false;
    if (chr <= 0x1ce8) return true;
    if (chr == 0x1ced) return true;
    if (chr == 0x1cf4) return true;
    if (chr < 0x1cf8) return false;
    if (chr <= 0x1cf9) return true;
    if (chr < 0x1dc0) return false;
    if (chr <= 0x1dff) return true;
    if (chr < 0x20d0) return false;
    if (chr <= 0x20dc) return true;
    if (chr == 0x20e1) return true;
    if (chr < 0x20e5) return false;
    if (chr <= 0x20f0) return true;
    if (chr < 0x2cef) return false;
    if (chr <= 0x2cf1) return true;
    if (chr == 0x2d7f) return true;
    if (chr < 0x2de0) return false;
    if (chr <= 0x2dff) return true;
    if (chr < 0x302a) return false;
    if (chr <= 0x302d) return true;
    if (chr < 0x3099) return false;
    if (chr <= 0x309a) return true;
    if (chr == 0xa66f) return true;
    if (chr < 0xa674) return false;
    if (chr <= 0xa67d) return true;
    if (chr < 0xa69e) return false;
    if (chr <= 0xa69f) return true;
    if (chr < 0xa6f0) return false;
    if (chr <= 0xa6f1) return true;
    if (chr == 0xa802) return true;
    if (chr == 0xa806) return true;
    if (chr == 0xa80b) return true;
    if (chr < 0xa825) return false;
    if (chr <= 0xa826) return true;
    if (chr == 0xa82c) return true;
    if (chr < 0xa8c4) return false;
    if (chr <= 0xa8c5) return true;
    if (chr < 0xa8e0) return false;
    if (chr <= 0xa8f1) return true;
    if (chr == 0xa8ff) return true;
    if (chr < 0xa926) return false;
    if (chr <= 0xa92d) return true;
    if (chr < 0xa947) return false;
    if (chr <= 0xa951) return true;
    if (chr < 0xa980) return false;
    if (chr <= 0xa982) return true;
    if (chr == 0xa9b3) return true;
    if (chr < 0xa9b6) return false;
    if (chr <= 0xa9b9) return true;
    if (chr < 0xa9bc) return false;
    if (chr <= 0xa9bd) return true;
    if (chr == 0xa9e5) return true;
    if (chr < 0xaa29) return false;
    if (chr <= 0xaa2e) return true;
    if (chr < 0xaa31) return false;
    if (chr <= 0xaa32) return true;
    if (chr < 0xaa35) return false;
    if (chr <= 0xaa36) return true;
    if (chr == 0xaa43) return true;
    if (chr == 0xaa4c) return true;
    if (chr == 0xaa7c) return true;
    if (chr < 0xaab0) return false;
    if ((chr & 1) == 0 && chr <= 0xaab2) return true;
    if (chr < 0xaab3) return false;
    if (chr <= 0xaab4) return true;
    if (chr < 0xaab7) return false;
    if (chr <= 0xaab8) return true;
    if (chr < 0xaabe) return false;
    if (chr <= 0xaabf) return true;
    if (chr == 0xaac1) return true;
    if (chr < 0xaaec) return false;
    if (chr <= 0xaaed) return true;
    if (chr == 0xaaf6) return true;
    if (chr == 0xabe5) return true;
    if (chr == 0xabe8) return true;
    if (chr == 0xabed) return true;
    if (chr == 0xfb1e) return true;
    if (chr < 0xfe00) return false;
    if (chr <= 0xfe0f) return true;
    if (chr < 0xfe20) return false;
    if (chr <= 0xfe2f) return true;
    if (chr == 0x101fd) return true;
    if (chr == 0x102e0) return true;
    if (chr < 0x10376) return false;
    if (chr <= 0x1037a) return true;
    if (chr < 0x10a01) return false;
    if (chr <= 0x10a03) return true;
    if (chr < 0x10a05) return false;
    if (chr <= 0x10a06) return true;
    if (chr < 0x10a0c) return false;
    if (chr <= 0x10a0f) return true;
    if (chr < 0x10a38) return false;
    if (chr <= 0x10a3a) return true;
    if (chr == 0x10a3f) return true;
    if (chr < 0x10ae5) return false;
    if (chr <= 0x10ae6) return true;
    if (chr < 0x10d24) return false;
    if (chr <= 0x10d27) return true;
    if (chr < 0x10eab) return false;
    if (chr <= 0x10eac) return true;
    if (chr < 0x10efd) return false;
    if (chr <= 0x10eff) return true;
    if (chr < 0x10f46) return false;
    if (chr <= 0x10f50) return true;
    if (chr < 0x10f82) return false;
    if (chr <= 0x10f85) return true;
    if (chr == 0x11001) return true;
    if (chr < 0x11038) return false;
    if (chr <= 0x11046) return true;
    if (chr == 0x11070) return true;
    if (chr < 0x11073) return false;
    if (chr <= 0x11074) return true;
    if (chr < 0x1107f) return false;
    if (chr <= 0x11081) return true;
    if (chr < 0x110b3) return false;
    if (chr <= 0x110b6) return true;
    if (chr < 0x110b9) return false;
    if (chr <= 0x110ba) return true;
    if (chr == 0x110c2) return true;
    if (chr < 0x11100) return false;
    if (chr <= 0x11102) return true;
    if (chr < 0x11127) return false;
    if (chr <= 0x1112b) return true;
    if (chr < 0x1112d) return false;
    if (chr <= 0x11134) return true;
    if (chr == 0x11173) return true;
    if (chr < 0x11180) return false;
    if (chr <= 0x11181) return true;
    if (chr < 0x111b6) return false;
    if (chr <= 0x111be) return true;
    if (chr < 0x111c9) return false;
    if (chr <= 0x111cc) return true;
    if (chr == 0x111cf) return true;
    if (chr < 0x1122f) return false;
    if (chr <= 0x11231) return true;
    if (chr < 0x11234) return false;
    if ((chr & 1) == 0 && chr <= 0x11236) return true;
    if (chr == 0x11237) return true;
    if (chr == 0x1123e) return true;
    if (chr == 0x11241) return true;
    if (chr == 0x112df) return true;
    if (chr < 0x112e3) return false;
    if (chr <= 0x112ea) return true;
    if (chr < 0x11300) return false;
    if (chr <= 0x11301) return true;
    if (chr < 0x1133b) return false;
    if (chr <= 0x1133c) return true;
    if (chr == 0x11340) return true;
    if (chr < 0x11366) return false;
    if (chr <= 0x1136c) return true;
    if (chr < 0x11370) return false;
    if (chr <= 0x11374) return true;
    if (chr < 0x11438) return false;
    if (chr <= 0x1143f) return true;
    if (chr < 0x11442) return false;
    if (chr <= 0x11444) return true;
    if (chr == 0x11446) return true;
    if (chr == 0x1145e) return true;
    if (chr < 0x114b3) return false;
    if (chr <= 0x114b8) return true;
    if (chr == 0x114ba) return true;
    if (chr < 0x114bf) return false;
    if (chr <= 0x114c0) return true;
    if (chr < 0x114c2) return false;
    if (chr <= 0x114c3) return true;
    if (chr < 0x115b2) return false;
    if (chr <= 0x115b5) return true;
    if (chr < 0x115bc) return false;
    if (chr <= 0x115bd) return true;
    if (chr < 0x115bf) return false;
    if (chr <= 0x115c0) return true;
    if (chr < 0x115dc) return false;
    if (chr <= 0x115dd) return true;
    if (chr < 0x11633) return false;
    if (chr <= 0x1163a) return true;
    if (chr < 0x1163d) return false;
    if ((chr & 1) == 1 && chr <= 0x1163f) return true;
    if (chr == 0x11640) return true;
    if (chr < 0x116ab) return false;
    if ((chr & 1) == 1 && chr <= 0x116ad) return true;
    if (chr < 0x116b0) return false;
    if (chr <= 0x116b5) return true;
    if (chr == 0x116b7) return true;
    if (chr < 0x1171d) return false;
    if (chr <= 0x1171f) return true;
    if (chr < 0x11722) return false;
    if (chr <= 0x11725) return true;
    if (chr < 0x11727) return false;
    if (chr <= 0x1172b) return true;
    if (chr < 0x1182f) return false;
    if (chr <= 0x11837) return true;
    if (chr < 0x11839) return false;
    if (chr <= 0x1183a) return true;
    if (chr < 0x1193b) return false;
    if (chr <= 0x1193c) return true;
    if (chr == 0x1193e) return true;
    if (chr == 0x11943) return true;
    if (chr < 0x119d4) return false;
    if (chr <= 0x119d7) return true;
    if (chr < 0x119da) return false;
    if (chr <= 0x119db) return true;
    if (chr == 0x119e0) return true;
    if (chr < 0x11a01) return false;
    if (chr <= 0x11a0a) return true;
    if (chr < 0x11a33) return false;
    if (chr <= 0x11a38) return true;
    if (chr < 0x11a3b) return false;
    if (chr <= 0x11a3e) return true;
    if (chr == 0x11a47) return true;
    if (chr < 0x11a51) return false;
    if (chr <= 0x11a56) return true;
    if (chr < 0x11a59) return false;
    if (chr <= 0x11a5b) return true;
    if (chr < 0x11a8a) return false;
    if (chr <= 0x11a96) return true;
    if (chr < 0x11a98) return false;
    if (chr <= 0x11a99) return true;
    if (chr < 0x11c30) return false;
    if (chr <= 0x11c36) return true;
    if (chr < 0x11c38) return false;
    if (chr <= 0x11c3d) return true;
    if (chr == 0x11c3f) return true;
    if (chr < 0x11c92) return false;
    if (chr <= 0x11ca7) return true;
    if (chr < 0x11caa) return false;
    if (chr <= 0x11cb0) return true;
    if (chr < 0x11cb2) return false;
    if (chr <= 0x11cb3) return true;
    if (chr < 0x11cb5) return false;
    if (chr <= 0x11cb6) return true;
    if (chr < 0x11d31) return false;
    if (chr <= 0x11d36) return true;
    if (chr < 0x11d3a) return false;
    if ((chr & 1) == 0 && chr <= 0x11d3c) return true;
    if (chr < 0x11d3d) return false;
    if ((chr & 1) == 1 && chr <= 0x11d3f) return true;
    if (chr < 0x11d40) return false;
    if (chr <= 0x11d45) return true;
    if (chr == 0x11d47) return true;
    if (chr < 0x11d90) return false;
    if (chr <= 0x11d91) return true;
    if (chr < 0x11d95) return false;
    if ((chr & 1) == 1 && chr <= 0x11d97) return true;
    if (chr < 0x11ef3) return false;
    if (chr <= 0x11ef4) return true;
    if (chr < 0x11f00) return false;
    if (chr <= 0x11f01) return true;
    if (chr < 0x11f36) return false;
    if (chr <= 0x11f3a) return true;
    if (chr < 0x11f40) return false;
    if ((chr & 1) == 0 && chr <= 0x11f42) return true;
    if (chr == 0x13440) return true;
    if (chr < 0x13447) return false;
    if (chr <= 0x13455) return true;
    if (chr < 0x16af0) return false;
    if (chr <= 0x16af4) return true;
    if (chr < 0x16b30) return false;
    if (chr <= 0x16b36) return true;
    if (chr == 0x16f4f) return true;
    if (chr < 0x16f8f) return false;
    if (chr <= 0x16f92) return true;
    if (chr == 0x16fe4) return true;
    if (chr < 0x1bc9d) return false;
    if (chr <= 0x1bc9e) return true;
    if (chr < 0x1cf00) return false;
    if (chr <= 0x1cf2d) return true;
    if (chr < 0x1cf30) return false;
    if (chr <= 0x1cf46) return true;
    if (chr < 0x1d167) return false;
    if (chr <= 0x1d169) return true;
    if (chr < 0x1d17b) return false;
    if (chr <= 0x1d182) return true;
    if (chr < 0x1d185) return false;
    if (chr <= 0x1d18b) return true;
    if (chr < 0x1d1aa) return false;
    if (chr <= 0x1d1ad) return true;
    if (chr < 0x1d242) return false;
    if (chr <= 0x1d244) return true;
    if (chr < 0x1da00) return false;
    if (chr <= 0x1da36) return true;
    if (chr < 0x1da3b) return false;
    if (chr <= 0x1da6c) return true;
    if (chr == 0x1da75) return true;
    if (chr == 0x1da84) return true;
    if (chr < 0x1da9b) return false;
    if (chr <= 0x1da9f) return true;
    if (chr < 0x1daa1) return false;
    if (chr <= 0x1daaf) return true;
    if (chr < 0x1e000) return false;
    if (chr <= 0x1e006) return true;
    if (chr < 0x1e008) return false;
    if (chr <= 0x1e018) return true;
    if (chr < 0x1e01b) return false;
    if (chr <= 0x1e021) return true;
    if (chr < 0x1e023) return false;
    if (chr <= 0x1e024) return true;
    if (chr < 0x1e026) return false;
    if (chr <= 0x1e02a) return true;
    if (chr == 0x1e08f) return true;
    if (chr < 0x1e130) return false;
    if (chr <= 0x1e136) return true;
    if (chr == 0x1e2ae) return true;
    if (chr < 0x1e2ec) return false;
    if (chr <= 0x1e2ef) return true;
    if (chr < 0x1e4ec) return false;
    if (chr <= 0x1e4ef) return true;
    if (chr < 0x1e8d0) return false;
    if (chr <= 0x1e8d6) return true;
    if (chr < 0x1e944) return false;
    if (chr <= 0x1e94a) return true;
    if (chr < 0xe0100) return false;
    if (chr <= 0xe01ef) return true;
    return false;
  }

int is_a_wide_character
  (
    uint32_t chr
  )
  {
    if (chr <= 0x10ff) return false;
    if (chr >= 0x1100 && chr <= 0x115f) return true;
    if (chr >= 0x1160 && chr <= 0x2319) return false;
    if (chr >= 0x231a && chr <= 0x231b) return true;
    if (chr >= 0x231c && chr <= 0x2328) return false;
    if (chr >= 0x2329 && chr <= 0x232a) return true;
    if (chr >= 0x232b && chr <= 0x23e8) return false;
    if (chr >= 0x23e9 && chr <= 0x23ec) return true;
    if (chr >= 0x23ed && chr <= 0x23ef) return false;
    if (chr == 0x23f0) return true;
    if (chr >= 0x23f1 && chr <= 0x23f2) return false;
    if (chr == 0x23f3) return true;
    if (chr >= 0x23f4 && chr <= 0x25fc) return false;
    if (chr >= 0x25fd && chr <= 0x25fe) return true;
    if (chr >= 0x25ff && chr <= 0x2613) return false;
    if (chr >= 0x2614 && chr <= 0x2615) return true;
    if (chr >= 0x2616 && chr <= 0x2647) return false;
    if (chr >= 0x2648 && chr <= 0x2653) return true;
    if (chr >= 0x2654 && chr <= 0x267e) return false;
    if (chr == 0x267f) return true;
    if (chr >= 0x2680 && chr <= 0x2692) return false;
    if (chr == 0x2693) return true;
    if (chr >= 0x2694 && chr <= 0x26a0) return false;
    if (chr == 0x26a1) return true;
    if (chr >= 0x26a2 && chr <= 0x26a9) return false;
    if (chr >= 0x26aa && chr <= 0x26ab) return true;
    if (chr >= 0x26ac && chr <= 0x26bc) return false;
    if (chr >= 0x26bd && chr <= 0x26be) return true;
    if (chr >= 0x26bf && chr <= 0x26c3) return false;
    if (chr >= 0x26c4 && chr <= 0x26c5) return true;
    if (chr >= 0x26c6 && chr <= 0x26cd) return false;
    if (chr == 0x26ce) return true;
    if (chr >= 0x26cf && chr <= 0x26d3) return false;
    if (chr == 0x26d4) return true;
    if (chr >= 0x26d5 && chr <= 0x26e9) return false;
    if (chr == 0x26ea) return true;
    if (chr >= 0x26eb && chr <= 0x26f1) return false;
    if (chr >= 0x26f2 && chr <= 0x26f3) return true;
    if (chr == 0x26f4) return false;
    if (chr == 0x26f5) return true;
    if (chr >= 0x26f6 && chr <= 0x26f9) return false;
    if (chr == 0x26fa) return true;
    if (chr >= 0x26fb && chr <= 0x26fc) return false;
    if (chr == 0x26fd) return true;
    if (chr >= 0x26fe && chr <= 0x2704) return false;
    if (chr == 0x2705) return true;
    if (chr >= 0x2706 && chr <= 0x2709) return false;
    if (chr >= 0x270a && chr <= 0x270b) return true;
    if (chr >= 0x270c && chr <= 0x2727) return false;
    if (chr == 0x2728) return true;
    if (chr >= 0x2729 && chr <= 0x274b) return false;
    if (chr == 0x274c) return true;
    if (chr == 0x274d) return false;
    if (chr == 0x274e) return true;
    if (chr >= 0x274f && chr <= 0x2752) return false;
    if (chr >= 0x2753 && chr <= 0x2755) return true;
    if (chr == 0x2756) return false;
    if (chr == 0x2757) return true;
    if (chr >= 0x2758 && chr <= 0x2794) return false;
    if (chr >= 0x2795 && chr <= 0x2797) return true;
    if (chr >= 0x2798 && chr <= 0x27af) return false;
    if (chr == 0x27b0) return true;
    if (chr >= 0x27b1 && chr <= 0x27be) return false;
    if (chr == 0x27bf) return true;
    if (chr >= 0x27c0 && chr <= 0x2b1a) return false;
    if (chr >= 0x2b1b && chr <= 0x2b1c) return true;
    if (chr >= 0x2b1d && chr <= 0x2b4f) return false;
    if (chr == 0x2b50) return true;
    if (chr >= 0x2b51 && chr <= 0x2b54) return false;
    if (chr == 0x2b55) return true;
    if (chr >= 0x2b56 && chr <= 0x2e5d) return false;
    if (chr >= 0x2e80 && chr <= 0x2e99) return true;
    if (chr >= 0x2e9b && chr <= 0x2ef3) return true;
    if (chr >= 0x2f00 && chr <= 0x2fd5) return true;
    if (chr >= 0x2ff0 && chr <= 0x303e) return true;
    if (chr == 0x303f) return false;
    if (chr >= 0x3041 && chr <= 0x3096) return true;
    if (chr >= 0x3099 && chr <= 0x30ff) return true;
    if (chr >= 0x3105 && chr <= 0x312f) return true;
    if (chr >= 0x3131 && chr <= 0x318e) return true;
    if (chr >= 0x3190 && chr <= 0x31e3) return true;
    if (chr >= 0x31ef && chr <= 0x321e) return true;
    if (chr >= 0x3220 && chr <= 0x3247) return true;
    if (chr >= 0x3248 && chr <= 0x324f) return false;
    if (chr >= 0x3250 && chr <= 0x4dbf) return true;
    if (chr >= 0x4dc0 && chr <= 0x4dff) return false;
    if (chr >= 0x4e00 && chr <= 0xa48c) return true;
    if (chr >= 0xa490 && chr <= 0xa4c6) return true;
    if (chr >= 0xa4d0 && chr <= 0xa95f) return false;
    if (chr >= 0xa960 && chr <= 0xa97c) return true;
    if (chr >= 0xa980 && chr <= 0xabf9) return false;
    if (chr >= 0xac00 && chr <= 0xd7a3) return true;
    if (chr >= 0xd7b0 && chr <= 0xf8ff) return false;
    if (chr >= 0xf900 && chr <= 0xfaff) return true;
    if (chr >= 0xfb00 && chr <= 0xfe0f) return false;
    if (chr >= 0xfe10 && chr <= 0xfe19) return true;
    if (chr >= 0xfe20 && chr <= 0xfe2f) return false;
    if (chr >= 0xfe30 && chr <= 0xfe52) return true;
    if (chr >= 0xfe54 && chr <= 0xfe66) return true;
    if (chr >= 0xfe68 && chr <= 0xfe6b) return true;
    if (chr >= 0xfe70 && chr <= 0xfeff) return false;
    if (chr >= 0xff01 && chr <= 0xff60) return true;
    if (chr >= 0xff61 && chr <= 0xffdc) return false;
    if (chr >= 0xffe0 && chr <= 0xffe6) return true;
    if (chr >= 0xffe8 && chr <= 0x16f9f) return false;
    if (chr >= 0x16fe0 && chr <= 0x16fe4) return true;
    if (chr >= 0x16ff0 && chr <= 0x16ff1) return true;
    if (chr >= 0x17000 && chr <= 0x187f7) return true;
    if (chr >= 0x18800 && chr <= 0x18cd5) return true;
    if (chr >= 0x18d00 && chr <= 0x18d08) return true;
    if (chr >= 0x1aff0 && chr <= 0x1aff3) return true;
    if (chr >= 0x1aff5 && chr <= 0x1affb) return true;
    if (chr >= 0x1affd && chr <= 0x1affe) return true;
    if (chr >= 0x1b000 && chr <= 0x1b122) return true;
    if (chr == 0x1b132) return true;
    if (chr >= 0x1b150 && chr <= 0x1b152) return true;
    if (chr == 0x1b155) return true;
    if (chr >= 0x1b164 && chr <= 0x1b167) return true;
    if (chr >= 0x1b170 && chr <= 0x1b2fb) return true;
    if (chr >= 0x1bc00 && chr <= 0x1f003) return false;
    if (chr == 0x1f004) return true;
    if (chr >= 0x1f005 && chr <= 0x1f0ce) return false;
    if (chr == 0x1f0cf) return true;
    if (chr >= 0x1f0d1 && chr <= 0x1f18d) return false;
    if (chr == 0x1f18e) return true;
    if (chr >= 0x1f18f && chr <= 0x1f190) return false;
    if (chr >= 0x1f191 && chr <= 0x1f19a) return true;
    if (chr >= 0x1f19b && chr <= 0x1f1ff) return false;
    if (chr >= 0x1f200 && chr <= 0x1f202) return true;
    if (chr >= 0x1f210 && chr <= 0x1f23b) return true;
    if (chr >= 0x1f240 && chr <= 0x1f248) return true;
    if (chr >= 0x1f250 && chr <= 0x1f251) return true;
    if (chr >= 0x1f260 && chr <= 0x1f265) return true;
    if (chr >= 0x1f300 && chr <= 0x1f320) return true;
    if (chr >= 0x1f321 && chr <= 0x1f32c) return false;
    if (chr >= 0x1f32d && chr <= 0x1f335) return true;
    if (chr == 0x1f336) return false;
    if (chr >= 0x1f337 && chr <= 0x1f37c) return true;
    if (chr == 0x1f37d) return false;
    if (chr >= 0x1f37e && chr <= 0x1f393) return true;
    if (chr >= 0x1f394 && chr <= 0x1f39f) return false;
    if (chr >= 0x1f3a0 && chr <= 0x1f3ca) return true;
    if (chr >= 0x1f3cb && chr <= 0x1f3ce) return false;
    if (chr >= 0x1f3cf && chr <= 0x1f3d3) return true;
    if (chr >= 0x1f3d4 && chr <= 0x1f3df) return false;
    if (chr >= 0x1f3e0 && chr <= 0x1f3f0) return true;
    if (chr >= 0x1f3f1 && chr <= 0x1f3f3) return false;
    if (chr == 0x1f3f4) return true;
    if (chr >= 0x1f3f5 && chr <= 0x1f3f7) return false;
    if (chr >= 0x1f3f8 && chr <= 0x1f43e) return true;
    if (chr == 0x1f43f) return false;
    if (chr == 0x1f440) return true;
    if (chr == 0x1f441) return false;
    if (chr >= 0x1f442 && chr <= 0x1f4fc) return true;
    if (chr >= 0x1f4fd && chr <= 0x1f4fe) return false;
    if (chr >= 0x1f4ff && chr <= 0x1f53d) return true;
    if (chr >= 0x1f53e && chr <= 0x1f54a) return false;
    if (chr >= 0x1f54b && chr <= 0x1f54e) return true;
    if (chr == 0x1f54f) return false;
    if (chr >= 0x1f550 && chr <= 0x1f567) return true;
    if (chr >= 0x1f568 && chr <= 0x1f579) return false;
    if (chr == 0x1f57a) return true;
    if (chr >= 0x1f57b && chr <= 0x1f594) return false;
    if (chr >= 0x1f595 && chr <= 0x1f596) return true;
    if (chr >= 0x1f597 && chr <= 0x1f5a3) return false;
    if (chr == 0x1f5a4) return true;
    if (chr >= 0x1f5a5 && chr <= 0x1f5fa) return false;
    if (chr >= 0x1f5fb && chr <= 0x1f64f) return true;
    if (chr >= 0x1f650 && chr <= 0x1f67f) return false;
    if (chr >= 0x1f680 && chr <= 0x1f6c5) return true;
    if (chr >= 0x1f6c6 && chr <= 0x1f6cb) return false;
    if (chr == 0x1f6cc) return true;
    if (chr >= 0x1f6cd && chr <= 0x1f6cf) return false;
    if (chr >= 0x1f6d0 && chr <= 0x1f6d2) return true;
    if (chr >= 0x1f6d3 && chr <= 0x1f6d4) return false;
    if (chr >= 0x1f6d5 && chr <= 0x1f6d7) return true;
    if (chr >= 0x1f6dc && chr <= 0x1f6df) return true;
    if (chr >= 0x1f6e0 && chr <= 0x1f6ea) return false;
    if (chr >= 0x1f6eb && chr <= 0x1f6ec) return true;
    if (chr >= 0x1f6f0 && chr <= 0x1f6f3) return false;
    if (chr >= 0x1f6f4 && chr <= 0x1f6fc) return true;
    if (chr >= 0x1f700 && chr <= 0x1f7d9) return false;
    if (chr >= 0x1f7e0 && chr <= 0x1f7eb) return true;
    if (chr == 0x1f7f0) return true;
    if (chr >= 0x1f800 && chr <= 0x1f90b) return false;
    if (chr >= 0x1f90c && chr <= 0x1f93a) return true;
    if (chr == 0x1f93b) return false;
    if (chr >= 0x1f93c && chr <= 0x1f945) return true;
    if (chr == 0x1f946) return false;
    if (chr >= 0x1f947 && chr <= 0x1f9ff) return true;
    if (chr >= 0x1fa00 && chr <= 0x1fa6d) return false;
    if (chr >= 0x1fa70 && chr <= 0x1fa7c) return true;
    if (chr >= 0x1fa80 && chr <= 0x1fa88) return true;
    if (chr >= 0x1fa90 && chr <= 0x1fabd) return true;
    if (chr >= 0x1fabf && chr <= 0x1fac5) return true;
    if (chr >= 0x1face && chr <= 0x1fadb) return true;
    if (chr >= 0x1fae0 && chr <= 0x1fae8) return true;
    if (chr >= 0x1faf0 && chr <= 0x1faf8) return true;
    if (chr >= 0x1fb00 && chr <= 0x1fbf9) return false;
    if (chr >= 0x20000 && chr <= 0x2fffd) return true;
    if (chr >= 0x30000 && chr <= 0x3fffd) return true;
    return false;
  }

static long unique_idx = 1;
static const char **my_unique_item_names;

static void *std_types___unique_item____collect
  (
    UNIQUE_ITEM *node
  )
  {
    UNIQUE_ITEM *new_node;
    new_node = allocate(sizeof(UNIQUE_ITEM));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->id = node->id;
    return new_node;
  }

NODE *register_unique_item
  (
    const char *name
  )
  {
    if (unique_idx == 0) {
      my_unique_item_names = allocate_memory(sizeof(const char *));
    } else if (is_a_power_of_two(unique_idx)) {
      my_unique_item_names =
	reallocate_memory(
	  my_unique_item_names,
	  2*unique_idx*sizeof(const char *));
    }
    my_unique_item_names[unique_idx] = name;
    return create__std_types___unique_item(unique_idx++);
  }

static long std_types___unique_item____debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf,
      node->unique_item.id == 0 ? "<unique_item>" :
      my_unique_item_names[node->unique_item.id]);
  }

static int flags_to_int
(
  NODE *node,
  int *result_p
)
{
  char *flags_str = NULL;
  int flags = 0;
  if (!to_c_string(node, &flags_str)) return false;
  switch (flags_str[0]) {
    case 'R':
      flags = O_NONBLOCK;
    case 'r':
      if (flags_str[1] == '+') {
	if (flags_str[2] == 0) {
	  flags |= O_CLOEXEC|O_RDWR;
	  break;
	} else {
	  goto err;
	}
      } else if (flags_str[1] == 0) {
	flags |= O_CLOEXEC|O_RDONLY;
	break;
      } else {
	goto err;
	goto err;
      }
    case 'W':
      flags = O_NONBLOCK;
    case 'w':
      if (flags_str[1] == '+') {
	if (flags_str[2] == 0) {
	  flags |= O_CLOEXEC|O_RDWR|O_CREAT|O_TRUNC;
	  break;
	} else {
	  goto err;
	}
      } else if (flags_str[1] == 0) {
	flags |= O_CLOEXEC|O_WRONLY|O_CREAT|O_TRUNC;
	break;
      } else {
	goto err;
      }
    case 'A':
      flags = O_NONBLOCK;
    case 'a':
      if (flags_str[1] == '+') {
	if (flags_str[2] == 0) {
	  flags |= O_CLOEXEC|O_RDWR|O_CREAT|O_APPEND;
	  break;
	} else {
	  goto err;
	}
      } else if (flags_str[1] == 0) {
	flags |= O_CLOEXEC|O_WRONLY|O_CREAT|O_APPEND;
	break;
      } else {
	goto err;
      }
    default:
      goto err;
  }
  deallocate_memory(flags_str);
  *result_p = flags;
  return true;

  err:
  deallocate_memory(flags_str);
  create_error_message(
    module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
    "Conversion to open flags failed!", 0, 0, NULL);
  return false;
}

static int mode_to_int
(
  NODE *node,
  int *result_p
)
{
  char *mode_str = NULL;
  int mode = 0;
  if (!to_c_string(node, &mode_str)) return false;
  if (strlen(mode_str) != 9) goto err;
  switch (mode_str[0]) {
    case 'r':
      mode |= 0400;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[1]) {
    case 'w':
      mode |= 0200;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[2]) {
    case 'x':
      mode |= 0100;
      break;
    case 's':
      mode |= 0100|S_ISUID;
      break;
    case 'S':
      mode |= S_ISUID;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[3]) {
    case 'r':
      mode |= 040;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[4]) {
    case 'w':
      mode |= 020;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[5]) {
    case 'x':
      mode |= 010;
      break;
    case 's':
      mode |= 010|S_ISGID;
      break;
    case 'S':
      mode |= S_ISGID;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[6]) {
    case 'r':
      mode |= 04;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[7]) {
    case 'w':
      mode |= 02;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[8]) {
    case 'x':
      mode |= 01;
      break;
    case 't':
      mode |= 01|S_ISVTX;
      break;
    case 'T':
      mode |= S_ISVTX;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  deallocate_memory(mode_str);
  *result_p = mode;
  return true;

  err:
  deallocate_memory(mode_str);
  create_error_message(
    module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
    "Conversion to file mode failed!", 0, 0, NULL);
  return false;
}

static NODE *mode_from_int
(
  int value
)
{
  char mode[12];
  if (S_ISREG(value)) {
    mode[0] = '-';
  } else if (S_ISBLK(value)) {
    mode[0] = 'b';
  } else if (S_ISCHR(value)) {
    mode[0] = 'c';
  } else if (S_ISDIR(value)) {
    mode[0] = 'd';
  } else if (S_ISLNK(value)) {
    mode[0] = 'l';
  } else if (S_ISFIFO(value)) {
    mode[0] = 'p';
  } else {
    mode[0] = 0;
  }
  if (value & 0400) {
    mode[1] = 'r';
  } else {
    mode[1] = '-';
  }
  if (value & 0200) {
    mode[2] = 'w';
  } else {
    mode[2] = '-';
  }
  if (value & 0100) {
    if (value & S_ISUID) {
      mode[3] = 's';
    } else {
      mode[3] = 'x';
    }
  } else {
    if (value & S_ISUID) {
      mode[3] = 'S';
    } else {
      mode[3] = '-';
    }
  }
  if (value & 040) {
    mode[4] = 'r';
  } else {
    mode[4] = '-';
  }
  if (value & 020) {
    mode[5] = 'w';
  } else {
    mode[5] = '-';
  }
  if (value & 010) {
    if (value & S_ISGID) {
      mode[6] = 's';
    } else {
      mode[6] = 'x';
    }
  } else {
    if (value & S_ISGID) {
      mode[6] = 'S';
    } else {
      mode[6] = '-';
    }
  }
  if (value & 04) {
    mode[7] = 'r';
  } else {
    mode[7] = '-';
  }
  if (value & 02) {
    mode[8] = 'w';
  } else {
    mode[8] = '-';
  }
  if (value & 01) {
    if (value & S_ISVTX) {
      mode[9] = 't';
    } else {
      mode[9] = 'x';
    }
  } else {
    if (value & S_ISVTX) {
      mode[9] = 'T';
    } else {
      mode[9] = '-';
    }
  }
  mode[10] = 0;
  return from_c_string(mode[0] ? mode : mode+1);
}

static int initialize_fd_set
  (
    fd_set *set,
    NODE *descriptors,
    long *descriptor_count_p,
    int *last_fd_p
  )
  {
    long descriptor_count;
    if (!length_of(descriptors, &descriptor_count)) return false;
    FD_ZERO(set);
    int last_fd = *last_fd_p;
    long i;
    for (i = 0; i < descriptor_count; ++i) {
      NODE *descriptor;
      if (!get_item_of(descriptors, i, &descriptor)) return false;
      if ((descriptor)->type != std_types___file_descriptor.type) {
	create_error_message(
	  module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	  "Invalid arguments!", 0, 0, NULL);
	return false;
      }
      int fd = descriptor->file_descriptor.value;
      FD_SET(fd, set);
      if (fd > last_fd) last_fd = fd;
    }
    *descriptor_count_p = descriptor_count;
    *last_fd_p = last_fd;
    return true;
  }

static NODE *create_descriptor_list
  (
    fd_set *set,
    int fd_count,
    NODE *descriptors,
    long descriptor_count
  )
  {
    LIST_DATA *data =
      allocate_large(sizeof(LIST_DATA)+fd_count*sizeof(NODE *));
    data->size = fd_count;
    data->length = fd_count;
    int n = 0;
    long i;
    for (i = 0; i < descriptor_count; ++i) {
      NODE *descriptor;
      get_item_of(descriptors, i, &descriptor);
      int fd = descriptor->file_descriptor.value;
      if (FD_ISSET(fd, set)) {
	data->items[n++] = descriptor;
      }
    }
    return create__std_types___list(0, fd_count, data);
  }

static void std_types___generic_array____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the generic array prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___array____type (void)
  {
    ARRAY_DATA *data = TLS_myself->array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_array_updates((ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->array.view);
      if (offset < 0) return;
      NODE *value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(value);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->array.view);
      if (offset < 0) return;
      NODE *value;
      value = TLS_arguments[dimension_count];
      long length = TLS_myself->array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_ARRAY_DATA_SET_VALUE));
      UPDATE_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___boolean_array____type (void)
  {
    BOOLEAN_ARRAY_DATA *data = TLS_myself->boolean_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->boolean_array.view);
      if (offset < 0) return;
      int value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_bool(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->boolean_array.view);
      if (offset < 0) return;
      int value;
      if (!to_bool(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->boolean_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE));
      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->boolean_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___character_array____type (void)
  {
    CHARACTER_ARRAY_DATA *data = TLS_myself->character_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_character_array_updates((CHARACTER_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->character_array.view);
      if (offset < 0) return;
      uint32_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uchar32(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->character_array.view);
      if (offset < 0) return;
      uint32_t value;
      if (!to_uchar32(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->character_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE));
      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->character_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___int8_array____type (void)
  {
    INT8_ARRAY_DATA *data = TLS_myself->int8_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int8_array_updates((INT8_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int8_array.view);
      if (offset < 0) return;
      int8_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int8(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int8_array.view);
      if (offset < 0) return;
      int8_t value;
      if (!to_int8(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int8_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE));
      UPDATE_INT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT8_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___uint8_array____type (void)
  {
    UINT8_ARRAY_DATA *data = TLS_myself->uint8_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint8_array_updates((UINT8_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint8_array.view);
      if (offset < 0) return;
      uint8_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint8(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint8_array.view);
      if (offset < 0) return;
      uint8_t value;
      if (!to_uint8(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint8_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT8_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___int16_array____type (void)
  {
    INT16_ARRAY_DATA *data = TLS_myself->int16_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int16_array_updates((INT16_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int16_array.view);
      if (offset < 0) return;
      int16_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int16(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int16_array.view);
      if (offset < 0) return;
      int16_t value;
      if (!to_int16(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int16_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE));
      UPDATE_INT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT16_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___uint16_array____type (void)
  {
    UINT16_ARRAY_DATA *data = TLS_myself->uint16_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint16_array_updates((UINT16_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint16_array.view);
      if (offset < 0) return;
      uint16_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint16(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint16_array.view);
      if (offset < 0) return;
      uint16_t value;
      if (!to_uint16(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint16_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT16_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___int32_array____type (void)
  {
    INT32_ARRAY_DATA *data = TLS_myself->int32_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int32_array_updates((INT32_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int32_array.view);
      if (offset < 0) return;
      int32_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int32(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int32_array.view);
      if (offset < 0) return;
      int32_t value;
      if (!to_int32(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int32_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE));
      UPDATE_INT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT32_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___uint32_array____type (void)
  {
    UINT32_ARRAY_DATA *data = TLS_myself->uint32_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint32_array_updates((UINT32_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint32_array.view);
      if (offset < 0) return;
      uint32_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint32(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint32_array.view);
      if (offset < 0) return;
      uint32_t value;
      if (!to_uint32(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint32_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT32_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___int64_array____type (void)
  {
    INT64_ARRAY_DATA *data = TLS_myself->int64_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int64_array_updates((INT64_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int64_array.view);
      if (offset < 0) return;
      int64_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int64(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int64_array.view);
      if (offset < 0) return;
      int64_t value;
      if (!to_int64(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int64_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE));
      UPDATE_INT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT64_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___uint64_array____type (void)
  {
    UINT64_ARRAY_DATA *data = TLS_myself->uint64_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint64_array_updates((UINT64_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint64_array.view);
      if (offset < 0) return;
      uint64_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint64(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint64_array.view);
      if (offset < 0) return;
      uint64_t value;
      if (!to_uint64(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint64_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT64_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___float32_array____type (void)
  {
    FLOAT32_ARRAY_DATA *data = TLS_myself->float32_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->float32_array.view);
      if (offset < 0) return;
      float value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_float(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->float32_array.view);
      if (offset < 0) return;
      float value;
      if (!to_float(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->float32_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->float32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___float64_array____type (void)
  {
    FLOAT64_ARRAY_DATA *data = TLS_myself->float64_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->float64_array.view);
      if (offset < 0) return;
      double value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_double(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->float64_array.view);
      if (offset < 0) return;
      double value;
      if (!to_double(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->float64_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->float64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types___true____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the boolean value true as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___false____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the boolean value false as a function!", 0, 0, NULL);
      return;
    }
  }

static void c_function____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the C function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types___character____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a character value as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___date_and_time____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a date-and-time object as a function!", 0, 0, NULL);
      return;
    }
  }

void std_types___error____type (void)
  {
    if (TLS_result_count < 1) TLS_result_count = 1;
    TLS_argument_count = TLS_result_count;
    int i;
    for (i = 0; i < TLS_result_count; ++i) {
      TLS_arguments[i] = TLS_myself;
    }
    {
      return;
    }
  }

static void std_types___object____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call an object as a function!", 0, 0, NULL);
      return;
    }
  }

void std_types___undefined____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call an undefined object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___function____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void tabular_function____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the tabular function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types___generic_list____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the generic list prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

void std_types___list____type (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    long length = TLS_myself->list.length;
    long idx;
    if (!to_long(TLS_arguments[0], &idx)) return;
    if (idx < 0) idx = length+idx+1;
    if (idx < 1 || idx > length) {
      invalid_index(TLS_myself);
      return;
    };
    long offset = TLS_myself->list.offset;
    if (TLS_argument_count == 1)
      {
        NODE *result__node = (NODE *)(TLS_myself->list.data->items[offset+idx-1]);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    NODE *item = TLS_arguments[1];
    LIST_DATA *new_data = allocate_large(sizeof(LIST_DATA)+length*sizeof(NODE *));
    memcpy(
      new_data->items, TLS_myself->list.data->items+offset, length*sizeof(NODE *));
    new_data->items[idx-1] = item;
    new_data->size = length;
    new_data->length = length;
    NODE *node = create__std_types___list(0, length, new_data);
    node->type = TLS_myself->type;
    node->attributes = TLS_myself->attributes;
    {
      NODE *result__node = (NODE *)(node);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void std_types___number____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a numeric value as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___integer____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the integer protoype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___positive_integer____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a positive integer value as a function!", 0, 0, NULL);
      return;
    }
  }

void negative_integer____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a negative integer value as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___real____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a real number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___polymorphic_function____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the polymorphic-function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types___polymorphic_function_with_setter____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the polymorphic-function-with-setter protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types___file_type____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a file type as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___file_descriptor____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a file descriptor as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___shutdown_type____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a shutdown type as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___device_id____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a device id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___directory____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a directory as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___group_id____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a group id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___inode_number____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a inode number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___process_id____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a process id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___user_id____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a user id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___error_number____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a error number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___passwd____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a passwd as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___stat____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a stat as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___dirent____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a dirent as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___string____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the string prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types___octet_string____type (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long idx;
    if (!to_long(TLS_arguments[0], &idx)) return;
    long length = TLS_myself->octet_string.length;
    if (idx < 0) idx = length+idx+1;
    if (idx < 1 || idx > length) {
      invalid_index(TLS_myself);
      return;
    };
    long offset = TLS_myself->octet_string.offset;
    if (TLS_argument_count == 1)
      {
        NODE *result__node = (NODE *)(from_uchar32(TLS_myself->octet_string.data->buffer[offset+idx-1]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    uint32_t chr;
    if (!to_uchar32(TLS_arguments[1], &chr)) return;;
    OCTET_DATA *data = TLS_myself->octet_string.data;
    if (data->buffer[idx-1] == chr) {
      NODE *result__node = (NODE *)(TLS_myself);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (chr > 0xff) {
      long size = ALLOCATION_SIZE(4*length);
      QUAD_OCTET_DATA *new_data = allocate_large(sizeof(QUAD_OCTET_DATA)+size);
      long i;
      for (i = 0; i < length; ++i) {
	new_data->buffer[i] = data->buffer[offset+i];
      }
      new_data->size = size;
      new_data->length = length;
      new_data->buffer[idx-1] = chr;
      {
        NODE *result__node = (NODE *)(create__quad_octet_string(0, length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      long size = ALLOCATION_SIZE(length);
      OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+size);
      memcpy(new_data->buffer, data->buffer+offset, length);
      new_data->size = size;
      new_data->length = length;
      new_data->buffer[idx-1] = chr;
      {
        NODE *result__node = (NODE *)(create__std_types___octet_string(0, length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void quad_octet_string____type (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long idx;
    if (!to_long(TLS_arguments[0], &idx)) return;
    long length = TLS_myself->quad_octet_string.length;
    if (idx < 0) idx = length+idx+1;
    if (idx < 1 || idx > length) {
      invalid_index(TLS_myself);
      return;
    };
    long offset = TLS_myself->quad_octet_string.offset;
    if (TLS_argument_count == 1)
      {
        NODE *result__node = (NODE *)(from_uchar32(TLS_myself->quad_octet_string.data->buffer[offset+idx-1]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    uint32_t chr;
    if (!to_uchar32(TLS_arguments[1], &chr)) return;;
    QUAD_OCTET_DATA *data = TLS_myself->quad_octet_string.data;
    if (data->buffer[idx-1] == chr) {
      NODE *result__node = (NODE *)(TLS_myself);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (chr <= 0xff && data->buffer[offset+idx-1] > 0xff) {
      long i;
      for (i = 0; i < length; ++i) {
	if (i != idx-1 && data->buffer[offset+i] > 0xff) goto quad;
      }
      long size = ALLOCATION_SIZE(length);
      OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+size);
      for (i = 0; i < length; ++i) {
	new_data->buffer[i] = data->buffer[offset+i];
      }
      new_data->size = size;
      new_data->length = length;
      new_data->buffer[idx-1] = chr;
      {
        NODE *result__node = (NODE *)(create__std_types___octet_string(0, length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    quad:;
    long size = ALLOCATION_SIZE(4*length);
    QUAD_OCTET_DATA *new_data = allocate_large(sizeof(QUAD_OCTET_DATA)+size);
    memcpy(new_data->buffer, data->buffer+offset, 4*length);
    new_data->size = size;
    new_data->length = length;
    new_data->buffer[idx-1] = chr;
    {
      NODE *result__node = (NODE *)(create__quad_octet_string(0, length, new_data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void std_types___terminal_attributes____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call terminal attributes as a function!", 0, 0, NULL);
      return;
    };
  }

static void std_types___tuple____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call the tuple prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void builtin___tuple2____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 2) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 2: TLS_arguments[1] = TLS_myself->tuple2.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple2.node_0;
    }
    {
      return;
    }
  }

static void builtin___tuple3____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 3) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 3: TLS_arguments[2] = TLS_myself->tuple3.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple3.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple3.node_0;
    }
    {
      return;
    }
  }

static void builtin___tuple4____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 4) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 4: TLS_arguments[3] = TLS_myself->tuple4.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple4.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple4.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple4.node_0;
    }
    {
      return;
    }
  }

static void builtin___tuple5____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 5) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 5: TLS_arguments[4] = TLS_myself->tuple5.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple5.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple5.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple5.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple5.node_0;
    }
    {
      return;
    }
  }

static void builtin___tuple6____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 6) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 6: TLS_arguments[5] = TLS_myself->tuple6.node_5;
      case 5: TLS_arguments[4] = TLS_myself->tuple6.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple6.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple6.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple6.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple6.node_0;
    }
    {
      return;
    }
  }

static void builtin___tuple7____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 7) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 7: TLS_arguments[6] = TLS_myself->tuple7.node_6;
      case 6: TLS_arguments[5] = TLS_myself->tuple7.node_5;
      case 5: TLS_arguments[4] = TLS_myself->tuple7.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple7.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple7.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple7.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple7.node_0;
    }
    {
      return;
    }
  }

static void builtin___tuple8____type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = TLS_myself->tuple8.node_7;
      case 7: TLS_arguments[6] = TLS_myself->tuple8.node_6;
      case 6: TLS_arguments[5] = TLS_myself->tuple8.node_5;
      case 5: TLS_arguments[4] = TLS_myself->tuple8.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple8.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple8.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple8.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple8.node_0;
    }
    {
      return;
    }
  }

static void std_types___unique_item____type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to call a unique item as a function!", 0, 0, NULL);
      return;
    }
  }

SIMPLE_NODE std_types___generic_array = {
  std_types___generic_array____type, NULL
};

ARRAY std_types___array = {
  std_types___array____type, NULL
};

BOOLEAN_ARRAY std_types___boolean_array = {
  std_types___boolean_array____type, NULL
};

CHARACTER_ARRAY std_types___character_array = {
  std_types___character_array____type, NULL
};

INT8_ARRAY std_types___int8_array = {
  std_types___int8_array____type, NULL
};

UINT8_ARRAY std_types___uint8_array = {
  std_types___uint8_array____type, NULL
};

INT16_ARRAY std_types___int16_array = {
  std_types___int16_array____type, NULL
};

UINT16_ARRAY std_types___uint16_array = {
  std_types___uint16_array____type, NULL
};

INT32_ARRAY std_types___int32_array = {
  std_types___int32_array____type, NULL
};

UINT32_ARRAY std_types___uint32_array = {
  std_types___uint32_array____type, NULL
};

INT64_ARRAY std_types___int64_array = {
  std_types___int64_array____type, NULL
};

UINT64_ARRAY std_types___uint64_array = {
  std_types___uint64_array____type, NULL
};

FLOAT32_ARRAY std_types___float32_array = {
  std_types___float32_array____type, NULL
};

FLOAT64_ARRAY std_types___float64_array = {
  std_types___float64_array____type, NULL
};

SIMPLE_NODE std_types___true = {
  std_types___true____type, NULL
};

SIMPLE_NODE std_types___false = {
  std_types___false____type, NULL
};

C_FUNCTION c_function = {
  c_function____type, NULL
};

CHARACTER std_types___character = {
  std_types___character____type, NULL
};

DATE_AND_TIME std_types___date_and_time = {
  std_types___date_and_time____type, NULL
};

ERROR std_types___error = {
  std_types___error____type, NULL
};

SIMPLE_NODE std_types___object = {
  std_types___object____type, NULL
};

SIMPLE_NODE std_types___undefined = {
  std_types___undefined____type, NULL
};

SIMPLE_NODE std_types___function = {
  std_types___function____type, NULL
};

TABULAR_FUNCTION tabular_function = {
  tabular_function____type, NULL
};

SIMPLE_NODE std_types___generic_list = {
  std_types___generic_list____type, NULL
};

LIST std_types___list = {
  std_types___list____type, NULL
};

SIMPLE_NODE std_types___number = {
  std_types___number____type, NULL
};

INTEGER std_types___integer = {
  std_types___integer____type, NULL
};

POSITIVE_INTEGER std_types___positive_integer = {
  std_types___positive_integer____type, NULL
};

NEGATIVE_INTEGER negative_integer = {
  negative_integer____type, NULL
};

REAL std_types___real = {
  std_types___real____type, NULL
};

SIMPLE_NODE std_types___polymorphic_function = {
  std_types___polymorphic_function____type, NULL
};

SIMPLE_NODE std_types___polymorphic_function_with_setter = {
  std_types___polymorphic_function_with_setter____type, NULL
};

FILE_TYPE std_types___file_type = {
  std_types___file_type____type, NULL
};

FILE_DESCRIPTOR std_types___file_descriptor = {
  std_types___file_descriptor____type, NULL
};

SHUTDOWN_TYPE std_types___shutdown_type = {
  std_types___shutdown_type____type, NULL
};

DEVICE_ID std_types___device_id = {
  std_types___device_id____type, NULL
};

DIRECTORY std_types___directory = {
  std_types___directory____type, NULL
};

GROUP_ID std_types___group_id = {
  std_types___group_id____type, NULL
};

INODE_NUMBER std_types___inode_number = {
  std_types___inode_number____type, NULL
};

PROCESS_ID std_types___process_id = {
  std_types___process_id____type, NULL
};

USER_ID std_types___user_id = {
  std_types___user_id____type, NULL
};

ERROR_NUMBER std_types___error_number = {
  std_types___error_number____type, NULL
};

SIMPLE_NODE std_types___passwd = {
  std_types___passwd____type, NULL
};

SIMPLE_NODE std_types___stat = {
  std_types___stat____type, NULL
};

SIMPLE_NODE std_types___dirent = {
  std_types___dirent____type, NULL
};

SIMPLE_NODE std_types___string = {
  std_types___string____type, NULL
};

OCTET_STRING std_types___octet_string = {
  std_types___octet_string____type, NULL
};

QUAD_OCTET_STRING quad_octet_string = {
  quad_octet_string____type, NULL
};

TERMINAL_ATTRIBUTES std_types___terminal_attributes = {
  std_types___terminal_attributes____type, NULL
};

SIMPLE_NODE std_types___tuple = {
  std_types___tuple____type, NULL
};

TUPLE2 builtin___tuple2 = {
  builtin___tuple2____type, NULL
};

TUPLE3 builtin___tuple3 = {
  builtin___tuple3____type, NULL
};

TUPLE4 builtin___tuple4 = {
  builtin___tuple4____type, NULL
};

TUPLE5 builtin___tuple5 = {
  builtin___tuple5____type, NULL
};

TUPLE6 builtin___tuple6 = {
  builtin___tuple6____type, NULL
};

TUPLE7 builtin___tuple7 = {
  builtin___tuple7____type, NULL
};

TUPLE8 builtin___tuple8 = {
  builtin___tuple8____type, NULL
};

UNIQUE_ITEM std_types___unique_item = {
  std_types___unique_item____type, NULL
};

static POSITIVE_INTEGER std___EXIT_SUCCESS = {
  std_types___positive_integer____type, NULL, EXIT_SUCCESS
};

static POSITIVE_INTEGER std___EXIT_FAILURE = {
  std_types___positive_integer____type, NULL, EXIT_FAILURE
};

static OCTET_STRING std___program_name = {
  std_types___octet_string____type, NULL, 0, 0, NULL
};

static LIST std___command_line_arguments = {
  std_types___list____type, NULL, 0, 0, NULL
};

static LIST std___environment_variables = {
  std_types___list____type, NULL, 0, 0, NULL
};

TUPLE2 std_types___key_value_pair = {
  builtin___tuple2____type, NULL, (NODE *)&std_types___undefined, (NODE *)&std_types___undefined
};

LIST std___empty_list = {
  std_types___list____type, NULL, 0, 0, NULL
};

static FILE_TYPE std___BLOCK_DEVICE = {
  std_types___file_type____type, NULL, DT_BLK
};

static FILE_TYPE std___CHARACTER_DEVICE = {
  std_types___file_type____type, NULL, DT_CHR
};

static FILE_TYPE std___DIRECTORY = {
  std_types___file_type____type, NULL, DT_DIR
};

static FILE_TYPE std___NAMED_PIPE = {
  std_types___file_type____type, NULL, DT_FIFO
};

static FILE_TYPE std___SYMBOLIC_LINK = {
  std_types___file_type____type, NULL, DT_LNK
};

static FILE_TYPE std___REGULAR_FILE = {
  std_types___file_type____type, NULL, DT_REG
};

static FILE_TYPE std___SOCKET = {
  std_types___file_type____type, NULL, DT_SOCK
};

static FILE_TYPE std___UNKNOWN_FILE_TYPE = {
  std_types___file_type____type, NULL, DT_UNKNOWN
};

static FILE_DESCRIPTOR std___STDIN_FILENO = {
  std_types___file_descriptor____type, NULL, STDIN_FILENO
};

static FILE_DESCRIPTOR std___STDOUT_FILENO = {
  std_types___file_descriptor____type, NULL, STDOUT_FILENO
};

static FILE_DESCRIPTOR std___STDERR_FILENO = {
  std_types___file_descriptor____type, NULL, STDERR_FILENO
};

static SHUTDOWN_TYPE std___SHUT_RD = {
  std_types___shutdown_type____type, NULL, SHUT_RD
};

static SHUTDOWN_TYPE std___SHUT_WR = {
  std_types___shutdown_type____type, NULL, SHUT_WR
};

static SHUTDOWN_TYPE std___SHUT_RDWR = {
  std_types___shutdown_type____type, NULL, SHUT_RDWR
};

static ERROR_NUMBER std___ENOERR = {
  std_types___error_number____type, NULL, 0
};

static ERROR_NUMBER std___EPERM = {
  std_types___error_number____type, NULL, EPERM
};

static ERROR_NUMBER std___ENOENT = {
  std_types___error_number____type, NULL, ENOENT
};

static ERROR_NUMBER std___ESRCH = {
  std_types___error_number____type, NULL, ESRCH
};

static ERROR_NUMBER std___EINTR = {
  std_types___error_number____type, NULL, EINTR
};

static ERROR_NUMBER std___EIO = {
  std_types___error_number____type, NULL, EIO
};

static ERROR_NUMBER std___ENXIO = {
  std_types___error_number____type, NULL, ENXIO
};

static ERROR_NUMBER std___E2BIG = {
  std_types___error_number____type, NULL, E2BIG
};

static ERROR_NUMBER std___ENOEXEC = {
  std_types___error_number____type, NULL, ENOEXEC
};

static ERROR_NUMBER std___EBADF = {
  std_types___error_number____type, NULL, EBADF
};

static ERROR_NUMBER std___ECHILD = {
  std_types___error_number____type, NULL, ECHILD
};

static ERROR_NUMBER std___EAGAIN = {
  std_types___error_number____type, NULL, EAGAIN
};

static ERROR_NUMBER std___ENOMEM = {
  std_types___error_number____type, NULL, ENOMEM
};

static ERROR_NUMBER std___EACCES = {
  std_types___error_number____type, NULL, EACCES
};

static ERROR_NUMBER std___EFAULT = {
  std_types___error_number____type, NULL, EFAULT
};

static ERROR_NUMBER std___ENOTBLK = {
  std_types___error_number____type, NULL, ENOTBLK
};

static ERROR_NUMBER std___EBUSY = {
  std_types___error_number____type, NULL, EBUSY
};

static ERROR_NUMBER std___EEXIST = {
  std_types___error_number____type, NULL, EEXIST
};

static ERROR_NUMBER std___EXDEV = {
  std_types___error_number____type, NULL, EXDEV
};

static ERROR_NUMBER std___ENODEV = {
  std_types___error_number____type, NULL, ENODEV
};

static ERROR_NUMBER std___ENOTDIR = {
  std_types___error_number____type, NULL, ENOTDIR
};

static ERROR_NUMBER std___EISDIR = {
  std_types___error_number____type, NULL, EISDIR
};

static ERROR_NUMBER std___EINVAL = {
  std_types___error_number____type, NULL, EINVAL
};

static ERROR_NUMBER std___ENFILE = {
  std_types___error_number____type, NULL, ENFILE
};

static ERROR_NUMBER std___EMFILE = {
  std_types___error_number____type, NULL, EMFILE
};

static ERROR_NUMBER std___ENOTTY = {
  std_types___error_number____type, NULL, ENOTTY
};

static ERROR_NUMBER std___ETXTBSY = {
  std_types___error_number____type, NULL, ETXTBSY
};

static ERROR_NUMBER std___EFBIG = {
  std_types___error_number____type, NULL, EFBIG
};

static ERROR_NUMBER std___ENOSPC = {
  std_types___error_number____type, NULL, ENOSPC
};

static ERROR_NUMBER std___ESPIPE = {
  std_types___error_number____type, NULL, ESPIPE
};

static ERROR_NUMBER std___EROFS = {
  std_types___error_number____type, NULL, EROFS
};

static ERROR_NUMBER std___EMLINK = {
  std_types___error_number____type, NULL, EMLINK
};

static ERROR_NUMBER std___EPIPE = {
  std_types___error_number____type, NULL, EPIPE
};

static ERROR_NUMBER std___EDOM = {
  std_types___error_number____type, NULL, EDOM
};

static ERROR_NUMBER std___ERANGE = {
  std_types___error_number____type, NULL, ERANGE
};

static ERROR_NUMBER std___EDEADLK = {
  std_types___error_number____type, NULL, EDEADLK
};

static ERROR_NUMBER std___ENAMETOOLONG = {
  std_types___error_number____type, NULL, ENAMETOOLONG
};

static ERROR_NUMBER std___ENOLCK = {
  std_types___error_number____type, NULL, ENOLCK
};

static ERROR_NUMBER std___ENOSYS = {
  std_types___error_number____type, NULL, ENOSYS
};

static ERROR_NUMBER std___ENOTEMPTY = {
  std_types___error_number____type, NULL, ENOTEMPTY
};

static ERROR_NUMBER std___EILSEQ = {
  std_types___error_number____type, NULL, EILSEQ
};

static ERROR_NUMBER std___ELOOP = {
  std_types___error_number____type, NULL, ELOOP
};

static ERROR_NUMBER std___ENOMSG = {
  std_types___error_number____type, NULL, ENOMSG
};

static ERROR_NUMBER std___EIDRM = {
  std_types___error_number____type, NULL, EIDRM
};

static ERROR_NUMBER std___ECHRNG = {
  std_types___error_number____type, NULL, ECHRNG
};

static ERROR_NUMBER std___EL2NSYNC = {
  std_types___error_number____type, NULL, EL2NSYNC
};

static ERROR_NUMBER std___EL3HLT = {
  std_types___error_number____type, NULL, EL3HLT
};

static ERROR_NUMBER std___EL3RST = {
  std_types___error_number____type, NULL, EL3RST
};

static ERROR_NUMBER std___ELNRNG = {
  std_types___error_number____type, NULL, ELNRNG
};

static ERROR_NUMBER std___EUNATCH = {
  std_types___error_number____type, NULL, EUNATCH
};

static ERROR_NUMBER std___ENOCSI = {
  std_types___error_number____type, NULL, ENOCSI
};

static ERROR_NUMBER std___EL2HLT = {
  std_types___error_number____type, NULL, EL2HLT
};

static ERROR_NUMBER std___EBADE = {
  std_types___error_number____type, NULL, EBADE
};

static ERROR_NUMBER std___EBADR = {
  std_types___error_number____type, NULL, EBADR
};

static ERROR_NUMBER std___EXFULL = {
  std_types___error_number____type, NULL, EXFULL
};

static ERROR_NUMBER std___ENOANO = {
  std_types___error_number____type, NULL, ENOANO
};

static ERROR_NUMBER std___EBADRQC = {
  std_types___error_number____type, NULL, EBADRQC
};

static ERROR_NUMBER std___EBADSLT = {
  std_types___error_number____type, NULL, EBADSLT
};

static ERROR_NUMBER std___EBFONT = {
  std_types___error_number____type, NULL, EBFONT
};

static ERROR_NUMBER std___ENOSTR = {
  std_types___error_number____type, NULL, ENOSTR
};

static ERROR_NUMBER std___ENODATA = {
  std_types___error_number____type, NULL, ENODATA
};

static ERROR_NUMBER std___ETIME = {
  std_types___error_number____type, NULL, ETIME
};

static ERROR_NUMBER std___ENOSR = {
  std_types___error_number____type, NULL, ENOSR
};

static ERROR_NUMBER std___ENONET = {
  std_types___error_number____type, NULL, ENONET
};

static ERROR_NUMBER std___ENOPKG = {
  std_types___error_number____type, NULL, ENOPKG
};

static ERROR_NUMBER std___EREMOTE = {
  std_types___error_number____type, NULL, EREMOTE
};

static ERROR_NUMBER std___ENOLINK = {
  std_types___error_number____type, NULL, ENOLINK
};

static ERROR_NUMBER std___EADV = {
  std_types___error_number____type, NULL, EADV
};

static ERROR_NUMBER std___ESRMNT = {
  std_types___error_number____type, NULL, ESRMNT
};

static ERROR_NUMBER std___ECOMM = {
  std_types___error_number____type, NULL, ECOMM
};

static ERROR_NUMBER std___EPROTO = {
  std_types___error_number____type, NULL, EPROTO
};

static ERROR_NUMBER std___EMULTIHOP = {
  std_types___error_number____type, NULL, EMULTIHOP
};

static ERROR_NUMBER std___EDOTDOT = {
  std_types___error_number____type, NULL, EDOTDOT
};

static ERROR_NUMBER std___EBADMSG = {
  std_types___error_number____type, NULL, EBADMSG
};

static ERROR_NUMBER std___EOVERFLOW = {
  std_types___error_number____type, NULL, EOVERFLOW
};

static ERROR_NUMBER std___ENOTUNIQ = {
  std_types___error_number____type, NULL, ENOTUNIQ
};

static ERROR_NUMBER std___EBADFD = {
  std_types___error_number____type, NULL, EBADFD
};

static ERROR_NUMBER std___EREMCHG = {
  std_types___error_number____type, NULL, EREMCHG
};

static ERROR_NUMBER std___ELIBACC = {
  std_types___error_number____type, NULL, ELIBACC
};

static ERROR_NUMBER std___ELIBBAD = {
  std_types___error_number____type, NULL, ELIBBAD
};

static ERROR_NUMBER std___ELIBSCN = {
  std_types___error_number____type, NULL, ELIBSCN
};

static ERROR_NUMBER std___ELIBMAX = {
  std_types___error_number____type, NULL, ELIBMAX
};

static ERROR_NUMBER std___ELIBEXEC = {
  std_types___error_number____type, NULL, ELIBEXEC
};

static ERROR_NUMBER std___ESTRPIPE = {
  std_types___error_number____type, NULL, ESTRPIPE
};

static ERROR_NUMBER std___EUSERS = {
  std_types___error_number____type, NULL, EUSERS
};

static ERROR_NUMBER std___ENOTSOCK = {
  std_types___error_number____type, NULL, ENOTSOCK
};

static ERROR_NUMBER std___EDESTADDRREQ = {
  std_types___error_number____type, NULL, EDESTADDRREQ
};

static ERROR_NUMBER std___EMSGSIZE = {
  std_types___error_number____type, NULL, EMSGSIZE
};

static ERROR_NUMBER std___EPROTOTYPE = {
  std_types___error_number____type, NULL, EPROTOTYPE
};

static ERROR_NUMBER std___ENOPROTOOPT = {
  std_types___error_number____type, NULL, ENOPROTOOPT
};

static ERROR_NUMBER std___EPROTONOSUPPORT = {
  std_types___error_number____type, NULL, EPROTONOSUPPORT
};

static ERROR_NUMBER std___ESOCKTNOSUPPORT = {
  std_types___error_number____type, NULL, ESOCKTNOSUPPORT
};

static ERROR_NUMBER std___EOPNOTSUPP = {
  std_types___error_number____type, NULL, EOPNOTSUPP
};

static ERROR_NUMBER std___EPFNOSUPPORT = {
  std_types___error_number____type, NULL, EPFNOSUPPORT
};

static ERROR_NUMBER std___EAFNOSUPPORT = {
  std_types___error_number____type, NULL, EAFNOSUPPORT
};

static ERROR_NUMBER std___EADDRINUSE = {
  std_types___error_number____type, NULL, EADDRINUSE
};

static ERROR_NUMBER std___EADDRNOTAVAIL = {
  std_types___error_number____type, NULL, EADDRNOTAVAIL
};

static ERROR_NUMBER std___ENETDOWN = {
  std_types___error_number____type, NULL, ENETDOWN
};

static ERROR_NUMBER std___ENETUNREACH = {
  std_types___error_number____type, NULL, ENETUNREACH
};

static ERROR_NUMBER std___ENETRESET = {
  std_types___error_number____type, NULL, ENETRESET
};

static ERROR_NUMBER std___ECONNABORTED = {
  std_types___error_number____type, NULL, ECONNABORTED
};

static ERROR_NUMBER std___ECONNRESET = {
  std_types___error_number____type, NULL, ECONNRESET
};

static ERROR_NUMBER std___ENOBUFS = {
  std_types___error_number____type, NULL, ENOBUFS
};

static ERROR_NUMBER std___EISCONN = {
  std_types___error_number____type, NULL, EISCONN
};

static ERROR_NUMBER std___ENOTCONN = {
  std_types___error_number____type, NULL, ENOTCONN
};

static ERROR_NUMBER std___ESHUTDOWN = {
  std_types___error_number____type, NULL, ESHUTDOWN
};

static ERROR_NUMBER std___ETOOMANYREFS = {
  std_types___error_number____type, NULL, ETOOMANYREFS
};

static ERROR_NUMBER std___ETIMEDOUT = {
  std_types___error_number____type, NULL, ETIMEDOUT
};

static ERROR_NUMBER std___ECONNREFUSED = {
  std_types___error_number____type, NULL, ECONNREFUSED
};

static ERROR_NUMBER std___EHOSTDOWN = {
  std_types___error_number____type, NULL, EHOSTDOWN
};

static ERROR_NUMBER std___EHOSTUNREACH = {
  std_types___error_number____type, NULL, EHOSTUNREACH
};

static ERROR_NUMBER std___EALREADY = {
  std_types___error_number____type, NULL, EALREADY
};

static ERROR_NUMBER std___EINPROGRESS = {
  std_types___error_number____type, NULL, EINPROGRESS
};

static ERROR_NUMBER std___ESTALE = {
  std_types___error_number____type, NULL, ESTALE
};

static ERROR_NUMBER std___EDQUOT = {
  std_types___error_number____type, NULL, EDQUOT
};

static ERROR_NUMBER std___ENOMEDIUM = {
  std_types___error_number____type, NULL, ENOMEDIUM
};

static ERROR_NUMBER std___ECANCELED = {
  std_types___error_number____type, NULL, ECANCELED
};

static ERROR_NUMBER std___EOWNERDEAD = {
  std_types___error_number____type, NULL, EOWNERDEAD
};

static ERROR_NUMBER std___ENOTRECOVERABLE = {
  std_types___error_number____type, NULL, ENOTRECOVERABLE
};

LIST std_types___sequence = {
  std_types___list____type, NULL, 0, 0, NULL
};

static OCTET_STRING std___empty_string = {
  std_types___octet_string____type, NULL, 0, 0, NULL
};

TUPLE2 std_types___value_range = {
  builtin___tuple2____type, NULL, (NODE *)&std_types___undefined, (NODE *)&std_types___undefined
};

static void *create__std_types___array
  (
    long updates_length,
    ARRAY_VIEW *view,
    ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    ARRAY *node = allocate(sizeof(ARRAY));
    node->type = std_types___array____type;
    node->attributes = std_types___array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___boolean_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    BOOLEAN_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    BOOLEAN_ARRAY *node = allocate(sizeof(BOOLEAN_ARRAY));
    node->type = std_types___boolean_array____type;
    node->attributes = std_types___boolean_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___character_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    CHARACTER_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    CHARACTER_ARRAY *node = allocate(sizeof(CHARACTER_ARRAY));
    node->type = std_types___character_array____type;
    node->attributes = std_types___character_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___int8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT8_ARRAY *node = allocate(sizeof(INT8_ARRAY));
    node->type = std_types___int8_array____type;
    node->attributes = std_types___int8_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___uint8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT8_ARRAY *node = allocate(sizeof(UINT8_ARRAY));
    node->type = std_types___uint8_array____type;
    node->attributes = std_types___uint8_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___int16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT16_ARRAY *node = allocate(sizeof(INT16_ARRAY));
    node->type = std_types___int16_array____type;
    node->attributes = std_types___int16_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___uint16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT16_ARRAY *node = allocate(sizeof(UINT16_ARRAY));
    node->type = std_types___uint16_array____type;
    node->attributes = std_types___uint16_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___int32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT32_ARRAY *node = allocate(sizeof(INT32_ARRAY));
    node->type = std_types___int32_array____type;
    node->attributes = std_types___int32_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___uint32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT32_ARRAY *node = allocate(sizeof(UINT32_ARRAY));
    node->type = std_types___uint32_array____type;
    node->attributes = std_types___uint32_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___int64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT64_ARRAY *node = allocate(sizeof(INT64_ARRAY));
    node->type = std_types___int64_array____type;
    node->attributes = std_types___int64_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___uint64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT64_ARRAY *node = allocate(sizeof(UINT64_ARRAY));
    node->type = std_types___uint64_array____type;
    node->attributes = std_types___uint64_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___float32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    FLOAT32_ARRAY *node = allocate(sizeof(FLOAT32_ARRAY));
    node->type = std_types___float32_array____type;
    node->attributes = std_types___float32_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types___float64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    FLOAT64_ARRAY *node = allocate(sizeof(FLOAT64_ARRAY));
    node->type = std_types___float64_array____type;
    node->attributes = std_types___float64_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__c_function
  (
    int32_t parameter_count
  )
  {
    C_FUNCTION *node = allocate(sizeof(C_FUNCTION));
    node->type = c_function____type;
    node->attributes = c_function.attributes;
    node->parameter_count = parameter_count;
    return node;
  }

static void *create__std_types___character
  (
    uint32_t code
  )
  {
    CHARACTER *node = allocate(sizeof(CHARACTER));
    node->type = std_types___character____type;
    node->attributes = std_types___character.attributes;
    node->code = code;
    return node;
  }

static void *create__std_types___date_and_time
  (
    int64_t seconds,
    int32_t nanoseconds
  )
  {
    DATE_AND_TIME *node = allocate(sizeof(DATE_AND_TIME));
    node->type = std_types___date_and_time____type;
    node->attributes = std_types___date_and_time.attributes;
    node->seconds = seconds;
    node->nanoseconds = nanoseconds;
    return node;
  }

void *create__std_types___error
  (
    NODE *category,
    MESSAGE_TEXT *message,
    int err_no,
    int attr_idx,
    NODE *object,
    long instruction_counter,
    FUNC_DATA *data
  )
  {
    ERROR *node = allocate(sizeof(ERROR));
    node->type = std_types___error____type;
    node->attributes = std_types___error.attributes;
    node->category = category;
    node->message = message;
    node->err_no = err_no;
    node->attr_idx = attr_idx;
    node->object = object;
    node->instruction_counter = instruction_counter;
    node->data = data;
    return node;
  }

static void *create__tabular_function
  (

  )
  {
    TABULAR_FUNCTION *node = allocate(sizeof(TABULAR_FUNCTION));
    node->type = tabular_function____type;
    node->attributes = tabular_function.attributes;
    return node;
  }

void *create__std_types___list
  (
    long offset,
    long length,
    LIST_DATA *data
  )
  {
    LIST *node = allocate(sizeof(LIST));
    node->type = std_types___list____type;
    node->attributes = std_types___list.attributes;
    node->offset = offset;
    node->length = length;
    node->data = data;
    return node;
  }

static void *create__std_types___integer
  (
    uint64_t value
  )
  {
    INTEGER *node = allocate(sizeof(INTEGER));
    node->type = std_types___integer____type;
    node->attributes = std_types___integer.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___positive_integer
  (
    uint64_t value
  )
  {
    POSITIVE_INTEGER *node = allocate(sizeof(POSITIVE_INTEGER));
    node->type = std_types___positive_integer____type;
    node->attributes = std_types___positive_integer.attributes;
    node->value = value;
    return node;
  }

void *create__negative_integer
  (
    uint64_t value
  )
  {
    NEGATIVE_INTEGER *node = allocate(sizeof(NEGATIVE_INTEGER));
    node->type = negative_integer____type;
    node->attributes = negative_integer.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___real
  (
    double value
  )
  {
    REAL *node = allocate(sizeof(REAL));
    node->type = std_types___real____type;
    node->attributes = std_types___real.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___file_type
  (
    int value
  )
  {
    FILE_TYPE *node = allocate(sizeof(FILE_TYPE));
    node->type = std_types___file_type____type;
    node->attributes = std_types___file_type.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___file_descriptor
  (
    int value
  )
  {
    FILE_DESCRIPTOR *node = allocate(sizeof(FILE_DESCRIPTOR));
    node->type = std_types___file_descriptor____type;
    node->attributes = std_types___file_descriptor.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___shutdown_type
  (
    int value
  )
  {
    SHUTDOWN_TYPE *node = allocate(sizeof(SHUTDOWN_TYPE));
    node->type = std_types___shutdown_type____type;
    node->attributes = std_types___shutdown_type.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___device_id
  (
    unsigned long value
  )
  {
    DEVICE_ID *node = allocate(sizeof(DEVICE_ID));
    node->type = std_types___device_id____type;
    node->attributes = std_types___device_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___directory
  (
    void *value
  )
  {
    DIRECTORY *node = allocate(sizeof(DIRECTORY));
    node->type = std_types___directory____type;
    node->attributes = std_types___directory.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___group_id
  (
    int value
  )
  {
    GROUP_ID *node = allocate(sizeof(GROUP_ID));
    node->type = std_types___group_id____type;
    node->attributes = std_types___group_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___inode_number
  (
    unsigned long value
  )
  {
    INODE_NUMBER *node = allocate(sizeof(INODE_NUMBER));
    node->type = std_types___inode_number____type;
    node->attributes = std_types___inode_number.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___process_id
  (
    int value
  )
  {
    PROCESS_ID *node = allocate(sizeof(PROCESS_ID));
    node->type = std_types___process_id____type;
    node->attributes = std_types___process_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___user_id
  (
    int value
  )
  {
    USER_ID *node = allocate(sizeof(USER_ID));
    node->type = std_types___user_id____type;
    node->attributes = std_types___user_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___error_number
  (
    int value
  )
  {
    ERROR_NUMBER *node = allocate(sizeof(ERROR_NUMBER));
    node->type = std_types___error_number____type;
    node->attributes = std_types___error_number.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types___octet_string
  (
    long offset,
    long length,
    OCTET_DATA *data
  )
  {
    OCTET_STRING *node = allocate(sizeof(OCTET_STRING));
    node->type = std_types___octet_string____type;
    node->attributes = std_types___octet_string.attributes;
    node->offset = offset;
    node->length = length;
    node->data = data;
    return node;
  }

static void *create__quad_octet_string
  (
    long offset,
    long length,
    QUAD_OCTET_DATA *data
  )
  {
    QUAD_OCTET_STRING *node = allocate(sizeof(QUAD_OCTET_STRING));
    node->type = quad_octet_string____type;
    node->attributes = quad_octet_string.attributes;
    node->offset = offset;
    node->length = length;
    node->data = data;
    return node;
  }

static void *create__std_types___terminal_attributes
  (
    TERMIO_DATA *data
  )
  {
    TERMINAL_ATTRIBUTES *node = allocate(sizeof(TERMINAL_ATTRIBUTES));
    node->type = std_types___terminal_attributes____type;
    node->attributes = std_types___terminal_attributes.attributes;
    node->data = data;
    return node;
  }

static void *create__builtin___tuple2
  (
    NODE *node_0,
    NODE *node_1
  )
  {
    TUPLE2 *node = allocate(sizeof(TUPLE2));
    node->type = builtin___tuple2____type;
    node->attributes = builtin___tuple2.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    return node;
  }

static void *create__builtin___tuple3
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2
  )
  {
    TUPLE3 *node = allocate(sizeof(TUPLE3));
    node->type = builtin___tuple3____type;
    node->attributes = builtin___tuple3.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    return node;
  }

static void *create__builtin___tuple4
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3
  )
  {
    TUPLE4 *node = allocate(sizeof(TUPLE4));
    node->type = builtin___tuple4____type;
    node->attributes = builtin___tuple4.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    return node;
  }

static void *create__builtin___tuple5
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4
  )
  {
    TUPLE5 *node = allocate(sizeof(TUPLE5));
    node->type = builtin___tuple5____type;
    node->attributes = builtin___tuple5.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    return node;
  }

static void *create__builtin___tuple6
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5
  )
  {
    TUPLE6 *node = allocate(sizeof(TUPLE6));
    node->type = builtin___tuple6____type;
    node->attributes = builtin___tuple6.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    node->node_5 = node_5;
    return node;
  }

static void *create__builtin___tuple7
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6
  )
  {
    TUPLE7 *node = allocate(sizeof(TUPLE7));
    node->type = builtin___tuple7____type;
    node->attributes = builtin___tuple7.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    node->node_5 = node_5;
    node->node_6 = node_6;
    return node;
  }

static void *create__builtin___tuple8
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6,
    NODE *node_7
  )
  {
    TUPLE8 *node = allocate(sizeof(TUPLE8));
    node->type = builtin___tuple8____type;
    node->attributes = builtin___tuple8.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    node->node_5 = node_5;
    node->node_6 = node_6;
    node->node_7 = node_7;
    return node;
  }

static void *create__std_types___unique_item
  (
    long id
  )
  {
    UNIQUE_ITEM *node = allocate(sizeof(UNIQUE_ITEM));
    node->type = std_types___unique_item____type;
    node->attributes = std_types___unique_item.attributes;
    node->id = id;
    return node;
  }

static void entry__std_types___array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_DATA *data = TLS_arguments[0]->array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types___undefined;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    NODE *initial_value;
    initial_value = TLS_arguments[TLS_argument_count-1];
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->array.data->info,
	TLS_arguments[0]->array.data->size, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types___undefined;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___array(0, TLS_arguments[0]->array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___array___std___range (void)
  {
    ARRAY *array = (ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    ARRAY_DATA *data = apply_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->boolean_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    BOOLEAN_ARRAY_DATA *data = TLS_arguments[0]->boolean_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    BOOLEAN_ARRAY_DATA *left =
      apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right =
      apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___boolean_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_boolean_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int initial_value;
    if (!to_bool(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->boolean_array.data->info,
	TLS_arguments[0]->boolean_array.data->size, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___boolean_array___std___range (void)
  {
    BOOLEAN_ARRAY *array = (BOOLEAN_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = apply_boolean_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___boolean_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->character_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    CHARACTER_ARRAY_DATA *data = TLS_arguments[0]->character_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    CHARACTER_ARRAY_DATA *left = apply_character_array_updates((CHARACTER_ARRAY *)TLS_arguments[0]);
    CHARACTER_ARRAY_DATA *right = apply_character_array_updates((CHARACTER_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint32_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___character_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___character_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_character_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint32_t initial_value;
    if (!to_uchar32(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___character_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->character_array.data->info,
	TLS_arguments[0]->character_array.data->size, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___character_array(0, TLS_arguments[0]->character_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character_array___std___range (void)
  {
    CHARACTER_ARRAY *array = (CHARACTER_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = apply_character_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___character_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int8_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int8_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int8_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT8_ARRAY_DATA *data = TLS_arguments[0]->int8_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int8_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[0]);
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int8_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int8_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[0]);
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int8_array_scalar_product(
    	  TLS_arguments[0]->int8_array.view, left, 0,
    	  TLS_arguments[1]->int8_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___int8_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_int8_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int8_t initial_value;
    if (!to_int8(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int8_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int8_array.data->info,
	TLS_arguments[0]->int8_array.data->size, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int8_array(0, TLS_arguments[0]->int8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int8_array___std___range (void)
  {
    INT8_ARRAY *array = (INT8_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT8_ARRAY_DATA *data = apply_int8_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___int8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint8_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT8_ARRAY_DATA *data = TLS_arguments[0]->uint8_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint8_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left =
      apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right =
      apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint8_array_scalar_product(
    	  TLS_arguments[0]->uint8_array.view, left, 0,
    	  TLS_arguments[1]->uint8_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___uint8_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_uint8_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint8_t initial_value;
    if (!to_uint8(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint8_array.data->info,
	TLS_arguments[0]->uint8_array.data->size, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint8_array___std___range (void)
  {
    UINT8_ARRAY *array = (UINT8_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT8_ARRAY_DATA *data = apply_uint8_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___uint8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int16_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int16_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int16_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT16_ARRAY_DATA *data = TLS_arguments[0]->int16_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int16_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[0]);
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int16_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int16_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[0]);
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int16_array_scalar_product(
    	  TLS_arguments[0]->int16_array.view, left, 0,
    	  TLS_arguments[1]->int16_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___int16_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_int16_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int16_t initial_value;
    if (!to_int16(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int16_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int16_array.data->info,
	TLS_arguments[0]->int16_array.data->size, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int16_array(0, TLS_arguments[0]->int16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int16_array___std___range (void)
  {
    INT16_ARRAY *array = (INT16_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT16_ARRAY_DATA *data = apply_int16_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___int16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint16_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT16_ARRAY_DATA *data = TLS_arguments[0]->uint16_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint16_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left =
      apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right =
      apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint16_array_scalar_product(
    	  TLS_arguments[0]->uint16_array.view, left, 0,
    	  TLS_arguments[1]->uint16_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___uint16_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_uint16_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint16_t initial_value;
    if (!to_uint16(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint16_array.data->info,
	TLS_arguments[0]->uint16_array.data->size, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint16_array___std___range (void)
  {
    UINT16_ARRAY *array = (UINT16_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT16_ARRAY_DATA *data = apply_uint16_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___uint16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int32_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int32_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int32_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT32_ARRAY_DATA *data = TLS_arguments[0]->int32_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int32_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[0]);
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int32_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int32_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[0]);
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int32_array_scalar_product(
    	  TLS_arguments[0]->int32_array.view, left, 0,
    	  TLS_arguments[1]->int32_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___int32_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_int32_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int32_t initial_value;
    if (!to_int32(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int32_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int32_array.data->info,
	TLS_arguments[0]->int32_array.data->size, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int32_array(0, TLS_arguments[0]->int32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int32_array___std___range (void)
  {
    INT32_ARRAY *array = (INT32_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT32_ARRAY_DATA *data = apply_int32_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___int32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint32_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT32_ARRAY_DATA *data = TLS_arguments[0]->uint32_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint32_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left =
      apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right =
      apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint32_array_scalar_product(
    	  TLS_arguments[0]->uint32_array.view, left, 0,
    	  TLS_arguments[1]->uint32_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___uint32_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_uint32_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint32_t initial_value;
    if (!to_uint32(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint32_array.data->info,
	TLS_arguments[0]->uint32_array.data->size, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint32_array___std___range (void)
  {
    UINT32_ARRAY *array = (UINT32_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT32_ARRAY_DATA *data = apply_uint32_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___uint32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int64_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int64_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int64_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT64_ARRAY_DATA *data = TLS_arguments[0]->int64_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int64_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[0]);
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int64_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int64_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[0]);
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int64_array_scalar_product(
    	  TLS_arguments[0]->int64_array.view, left, 0,
    	  TLS_arguments[1]->int64_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___int64_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_int64_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int64_t initial_value;
    if (!to_int64(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int64_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int64_array.data->info,
	TLS_arguments[0]->int64_array.data->size, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___int64_array(0, TLS_arguments[0]->int64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___int64_array___std___range (void)
  {
    INT64_ARRAY *array = (INT64_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT64_ARRAY_DATA *data = apply_int64_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___int64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint64_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT64_ARRAY_DATA *data = TLS_arguments[0]->uint64_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint64_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left =
      apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right =
      apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint64_array_scalar_product(
    	  TLS_arguments[0]->uint64_array.view, left, 0,
    	  TLS_arguments[1]->uint64_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___uint64_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_uint64_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint64_t initial_value;
    if (!to_uint64(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint64_array.data->info,
	TLS_arguments[0]->uint64_array.data->size, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___uint64_array___std___range (void)
  {
    UINT64_ARRAY *array = (UINT64_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT64_ARRAY_DATA *data = apply_uint64_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___uint64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float32_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->float32_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float32_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT32_ARRAY_DATA *data = TLS_arguments[0]->float32_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float32_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[0]);
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(float)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float32_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[0]);
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_double(
    	float32_array_scalar_product(
    	  TLS_arguments[0]->float32_array.view, left, 0,
    	  TLS_arguments[1]->float32_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___float32_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___float32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_float32_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    float initial_value;
    if (!to_float(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___float32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float32_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->float32_array.data->info,
	TLS_arguments[0]->float32_array.data->size, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___float32_array(0, TLS_arguments[0]->float32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float32_array___std___range (void)
  {
    FLOAT32_ARRAY *array = (FLOAT32_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = apply_float32_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___float32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float64_array___std___length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->float64_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float64_array___std___dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT64_ARRAY_DATA *data = TLS_arguments[0]->float64_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float64_array___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[0]);
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(double)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float64_array___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[0]);
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_double(
    	float64_array_scalar_product(
    	  TLS_arguments[0]->float64_array.view, left, 0,
    	  TLS_arguments[1]->float64_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___float64_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___float64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___initialized_float64_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    double initial_value;
    if (!to_double(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___float64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float64_array___std___new (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->float64_array.data->info,
	TLS_arguments[0]->float64_array.data->size, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___float64_array(0, TLS_arguments[0]->float64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___float64_array___std___range (void)
  {
    FLOAT64_ARRAY *array = (FLOAT64_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = apply_float64_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types___float64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___pass (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 0) {
      result_count_mismatch();
      return;
    }
    {
      return;
    }
  }

static void entry__std___result_count (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_int(*TLS_frame->link->code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___true___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___true.type) {
      {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___false___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___false.type) {
      {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__c_function___std___parameter_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[0]->c_function.parameter_count < 0)
      {
        NODE *result__node = (NODE *)(&std_types___undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    else
      {
        NODE *result__node = (NODE *)(from_uint32(TLS_arguments[0]->c_function.parameter_count));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
  }

static void entry__std___character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t code;
    if (!to_uint32(TLS_arguments[0], &code)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___character(code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character___std___plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long offset;
    if (!to_long(TLS_arguments[1], &offset)) return;
    long code = (long)TLS_arguments[0]->character.code+offset;
    if (code >= 0x100000000LL || code < 0) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___character((uint32_t)code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character___std___minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___character.type) {
      {
        NODE *result__node = (NODE *)(from_long(
      	  (long)TLS_arguments[0]->character.code-(long)TLS_arguments[1]->character.code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      long offset;
      if (!to_long(TLS_arguments[1], &offset)) return;
      long code = (long)TLS_arguments[0]->character.code-offset;
      if (code >= 0x100000000LL || code < 0) {
        invalid_arguments();
        return;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___character((uint32_t)code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___character___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___character.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->character.code == TLS_arguments[1]->character.code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___character___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___character.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->character.code < TLS_arguments[1]->character.code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___character___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t hash = TLS_arguments[0]->character.code;
    hash *= 179234567;
    hash ^= hash >> 27 | hash << 5;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types___character___std___to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[0]->character.code <= 0xff) {
      char buf[1];
      buf[0] = TLS_arguments[0]->character.code;
      {
        NODE *result__node = (NODE *)(from_latin_1_string((const uint8_t *)buf, 1));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(from_uint32_string(&TLS_arguments[0]->character.code, 1));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___character___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_uint32(TLS_arguments[0]->character.code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character___std___width_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_uint32(is_a_wide_character(TLS_arguments[0]->character.code) ? 2 : 1));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___from_unix_time (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int64_t sec;
    if (!to_int64(TLS_arguments[0], &sec)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___date_and_time(sec, 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___date_and_time (void)
  {
    if (TLS_argument_count != 6) {
      invalid_arguments();
      return;
    }
    int year, month, day, hour, minute;
    double second;

    if (!to_int(TLS_arguments[0], &year)) return;
    if (!to_int(TLS_arguments[1], &month)) return;
    if (!to_int(TLS_arguments[2], &day)) return;
    if (!to_int(TLS_arguments[3], &hour)) return;
    if (!to_int(TLS_arguments[4], &minute)) return;
    if (!to_double(TLS_arguments[5], &second)) return;
    int64_t seconds = floor(second);
    int32_t nanoseconds = 1000000000*(second-seconds);
    if (
      year < 1970 ||
      month < 1 || month > 12 ||
      day < 1 ||
      hour < 0 || hour > 23 ||
      minute < 0 || minute > 59 ||
      seconds < 0 || seconds > 59
    ) {
      NODE *result__node = (NODE *)(&std_types___undefined);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    int64_t days = 0;
    year -= 1970;
    if (year >= 2) {
      days += 730;
      year -= 2;
      days += 1461*(year/4);
      year %= 4;
      days += 365*year;
      if (year > 0) ++days;
    } else {
      if (year == 1971) days += 365;
      year += 2;
    }
    int m;
    for (m = 1; m <= 12; ++m) {
      int d;
      switch (m) {
	case 2:
	  d = year == 0 ? 29 : 28;
	  break;
	case 4: case 6: case 9: case 11:
	  d = 30;
	  break;
	default:
	  d = 31;
      }
      if (month > m) days += d;
      if (month == m && day > d) {
        NODE *result__node = (NODE *)(&std_types___undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    days += day-1;
    seconds += 86400*(uint64_t)days+3600*hour+60*minute;
    {
      NODE *result__node = (NODE *)(create__std_types___date_and_time(seconds, nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___year_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int year;
    year_month_day(TLS_arguments[0], &year, NULL, NULL);
    {
      NODE *result__node = (NODE *)(from_int(year));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___month_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int month;
    year_month_day(TLS_arguments[0], NULL, &month, NULL);
    {
      NODE *result__node = (NODE *)(from_int(month));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___day_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int day;
    year_month_day(TLS_arguments[0], NULL, NULL, &day);
    {
      NODE *result__node = (NODE *)(from_int(day));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___day_of_week_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(
    	(3+TLS_arguments[0]->date_and_time.seconds/86400)%7+1));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___hour_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int seconds = TLS_arguments[0]->date_and_time.seconds%86400;
    {
      NODE *result__node = (NODE *)(from_int(seconds/3600));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___minute_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int seconds = TLS_arguments[0]->date_and_time.seconds%3600;
    {
      NODE *result__node = (NODE *)(from_int(seconds/60));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___second_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_double(
    	TLS_arguments[0]->date_and_time.seconds%60+
    	TLS_arguments[0]->date_and_time.nanoseconds/1000000000.0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___time_shift_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    // This insane looking sequence of calls correctly computes the time shift!!!
    struct tm tm;
    time_t t1 = TLS_arguments[0]->date_and_time.seconds;
    localtime_r(&t1, &tm);
    int isdst = tm.tm_isdst;
    gmtime_r(&t1, &tm);
    tm.tm_isdst = isdst;
    time_t t2 = mktime(&tm);
    {
      NODE *result__node = (NODE *)(from_uint64(t1-t2));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___seconds_since_epoch (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_uint64(TLS_arguments[0]->date_and_time.seconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    int64_t seconds = TLS_arguments[0]->date_and_time.seconds;
    int32_t nanoseconds = TLS_arguments[0]->date_and_time.nanoseconds;
    double delta;
    if (!to_double(TLS_arguments[1], &delta)) return;
    int64_t delta_seconds = round(delta);
    int32_t delta_nanoseconds = 1000000000*(delta-delta_seconds);
    seconds += delta_seconds;
    nanoseconds += delta_nanoseconds;
    if (nanoseconds >= 1000000000) {
      nanoseconds -= 1000000000;
      ++seconds;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___date_and_time(seconds, nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    int64_t seconds = TLS_arguments[0]->date_and_time.seconds;
    int32_t nanoseconds = TLS_arguments[0]->date_and_time.nanoseconds;
    if ((TLS_arguments[1])->type == std_types___date_and_time.type) {
      int64_t seconds_2 = TLS_arguments[1]->date_and_time.seconds;
      int32_t nanoseconds_2 = TLS_arguments[1]->date_and_time.nanoseconds;
      {
        NODE *result__node = (NODE *)(from_double(
      	seconds-seconds_2+(nanoseconds-nanoseconds_2)/1000000000.0));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      double delta;
      if (!to_double(TLS_arguments[1], &delta)) return;
      int64_t delta_seconds = round(delta);
      int32_t delta_nanoseconds = 1000000000*(delta-delta_seconds);
      seconds -= delta_seconds;
      nanoseconds -= delta_nanoseconds;
      if (nanoseconds < 00) {
	nanoseconds += 1000000000;
	--seconds;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___date_and_time(seconds, nanoseconds));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___date_and_time___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *left, *right;
    left = TLS_arguments[0];
    right = TLS_arguments[1];
    if ((TLS_arguments[1])->type != std_types___date_and_time.type) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(left->date_and_time.seconds == right->date_and_time.seconds &&
          left->date_and_time.nanoseconds == right->date_and_time.nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___date_and_time___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *left, *right;
    left = TLS_arguments[0];
    right = TLS_arguments[1];
    if ((TLS_arguments[1])->type != std_types___date_and_time.type) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(left->date_and_time.seconds < right->date_and_time.seconds ||
          left->date_and_time.seconds == right->date_and_time.seconds &&
          left->date_and_time.nanoseconds < right->date_and_time.nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___current_time (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    struct timespec timespec;
    clock_gettime(CLOCK_REALTIME, &timespec);
    {
      NODE *result__node = (NODE *)(create__std_types___date_and_time(timespec.tv_sec, timespec.tv_nsec));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__debug___string (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }

    NODE *node = TLS_arguments[0];
    int indent = 0;
    int depth = 1;
    if (TLS_argument_count >= 2) {
      if (!to_int(TLS_arguments[1], &indent)) return;
    }
    if (TLS_argument_count >= 3) {
      if (!to_int(TLS_arguments[2], &depth)) return;
    }
    long len = debug_string(node, indent, depth, NULL);
    char *buf = allocate_memory(len+1);
      // <sprintf> might be used and might add a null-byte;
      // therefor allocate 1 byte more
    len = debug_string(node, indent, depth, buf);
    NODE *result = from_latin_1_string((const uint8_t *)buf, len);
    deallocate_memory(buf);
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__debug___write (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *buf;
    long len;
    if (!to_octets(TLS_arguments[0], (const uint8_t **)&buf, &len)) return;
    char *p = buf;
    retry:;
    long bytes_written = write(STDERR_FILENO, p, len);
    if (bytes_written == -1) {
      if (errno == EINTR) goto retry;
    } else if (bytes_written < len) {
      p += bytes_written;
      len -= bytes_written;
      goto retry;
    }
    deallocate_memory(buf);
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__debug___dump_object (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    NODE *node = TLS_arguments[TLS_argument_count-1];
    int depth = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[0], &depth)) return;
    }
    long len = debug_string(node, 0, depth, NULL);
    char *buf = allocate_memory(len+1);
    char *p = buf;
    len = debug_string(node, 0, depth, buf);
    retry:;
    long bytes_written = write(STDERR_FILENO, p, len);
    if (bytes_written == -1) {
      if (errno == EINTR) goto retry;
    } else if (bytes_written < len) {
      p += bytes_written;
      len -= bytes_written;
      goto retry;
    }
    deallocate_memory(buf);
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__debug___exit (void)
  {
    // ignore all arguments
    exit(EXIT_FAILURE);
  }

static void entry__std___error_check (void)
  {
    int i;
    if (TLS_result_count != 0) {
      result_count_mismatch();
      return;
    }
    for (i = 0; i < TLS_argument_count; ++i) {
      if ((TLS_arguments[i])->type == std_types___error.type) {
	{
	  NODE *result__node = (NODE *)(TLS_arguments[i]);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    }
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__debug___total_garbage_collections (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(total_garbage_collections));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error___std___error_category_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(TLS_arguments[0]->error.category);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error___std___error_message_text_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_c_string(TLS_arguments[0]->error.message->text));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error___std___error_details_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *details = TLS_arguments[0]->error.object;
    if (!details) details = (NODE *)&std_types___undefined;
    {
      NODE *result__node = (NODE *)(details);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error___std___errno_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_arguments[0]->error.err_no) {
      {
        NODE *result__node = (NODE *)(error_number_from_int(TLS_arguments[0]->error.err_no));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___error___std___failed_attribute_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_arguments[0]->error.attr_idx) {
      {
        NODE *result__node = (NODE *)(from_c_string(poly_name(TLS_arguments[0]->error.attr_idx)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std___error (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    char *msg;
    NODE *obj;
    NODE *category =
      TLS_argument_count >= 2 ? TLS_arguments[0] :
      module__builtin.constants_base[unique__std___APPLICATION_ERROR-1];
    if (!to_c_string(TLS_arguments[TLS_argument_count >= 2 ? 1 : 0], &msg)) return;
    obj = TLS_argument_count == 3 ? TLS_arguments[2] : NULL;
    create_error_message(category, msg, 0, 0, obj);
    deallocate_memory(msg);
  }

static void entry__std___exec (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type != std_types___list.type) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int i;
    sigset_t set;
    int ret = sigpending(&set);
    if (ret != -1) {
      // cancel all pending signals
      for (i = 1; i <= 31; ++i) {
	if (sigismember(&set, i)) {
	  signal(i, SIG_IGN);
	}
      }
    }

    NODE *arguments = TLS_arguments[1];
    char **args = allocate_memory((arguments->list.length+2)*sizeof(char *));
    for (i = 0; i < arguments->list.length+1; ++i) {
      args[i] = NULL;
    }
    // convert the command and all arguments into C-strings
    if (!to_c_string(TLS_arguments[0], &args[0])) goto cleanup;
    long offset = arguments->list.offset;
    for (i = 0; i < arguments->list.length; ++i) {
      if (!to_c_string(arguments->list.data->items[offset+i], &args[i+1]))
	goto cleanup;
    }
    args[arguments->list.length+1] = NULL;

    int err = execvp(args[0], args); // This call should not return!
    create_error_message(
      module__builtin.constants_base[unique__std___IO_ERROR-1],
      "EXEC FAILED", errno, 0, NULL);

    cleanup:

    if (args) {
      for (i = 0; i < arguments->list.length+1; ++i) {
	deallocate_memory(args[i]);
      }
      deallocate_memory(args);
    }
  }

static void entry__std___create_process (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 6) {
      too_many_arguments();
      return;
    }
    if ((TLS_arguments[1])->type != std_types___list.type) {
      invalid_arguments();
      return;
    }
    NODE *environment = (NODE *)&std_types___undefined;
    if (TLS_argument_count >= 3) {
      environment = TLS_arguments[2];
      if (
	(environment)->type != std_types___undefined.type &&
	(environment)->type != std_types___list.type
      ) {
        invalid_arguments();
        return;
      }
    }
    if (
      TLS_argument_count >= 4 &&
      (TLS_arguments[3])->type != std_types___file_descriptor.type
    ) {
      invalid_arguments();
      return;
    }
    if (
      TLS_argument_count >= 5 &&
      (TLS_arguments[4])->type != std_types___file_descriptor.type
    ) {
      invalid_arguments();
      return;
    }
    if (
      TLS_argument_count >= 6 &&
      (TLS_arguments[5])->type != std_types___file_descriptor.type
    ) {
      invalid_arguments();
      return;
    }

    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    char **envp = NULL;

    // initialize all pipe handles to invalid file descriptors
    struct {
      int read_fd;
      int write_fd;
    } in_pipe = {-1, -1}, out_pipe = {-1, -1}, err_pipe = {-1, -1};

    NODE *arguments = TLS_arguments[1];
    char **args = allocate_memory((arguments->list.length+2)*sizeof(char *));
    int i;
    for (i = 0; i < arguments->list.length+1; ++i) {
      args[i] = NULL;
    }
    // convert the command and all arguments into C-strings
    if (!to_c_string(TLS_arguments[0], &args[0])) goto cleanup;
    long offset = arguments->list.offset;
    for (i = 0; i < arguments->list.length; ++i) {
      if (!to_c_string(arguments->list.data->items[offset+i], &args[i+1]))
	goto cleanup;
    }
    args[arguments->list.length+1] = NULL;

    if (TLS_argument_count < 4) {
      if (pipe((int *)&in_pipe) != 0) {
	pipe_creation_failed:
	create_error_message(
	  module__builtin.constants_base[unique__std___IO_ERROR-1],
	  "PIPE_CREATION FAILED", errno, 0, NULL);
	goto cleanup;
      }
    }
    if (TLS_argument_count < 5) {
      if (pipe((int *)&out_pipe) != 0) goto pipe_creation_failed;
    }
    if (TLS_argument_count < 6) {
      if (pipe((int *)&err_pipe) != 0) goto pipe_creation_failed;
    }

    pid_t pid = fork();
    if (pid == 0) {
      // child process
      if (TLS_argument_count >= 4) {
	dup2_fd(TLS_arguments[3]->file_descriptor.value, STDIN_FILENO);
	close(TLS_arguments[3]->file_descriptor.value);
      } else {
	close(in_pipe.write_fd);
	dup2_fd(in_pipe.read_fd, STDIN_FILENO);
	close(in_pipe.read_fd);
      }
      if (TLS_argument_count >= 5) {
	dup2_fd(TLS_arguments[4]->file_descriptor.value, STDOUT_FILENO);
      }
      if (TLS_argument_count >= 6) {
	dup2_fd(TLS_arguments[5]->file_descriptor.value, STDERR_FILENO);
      }
      if (TLS_argument_count >= 5) {
	close(TLS_arguments[4]->file_descriptor.value);
      } else {
	close(out_pipe.read_fd);
	dup2_fd(out_pipe.write_fd, STDOUT_FILENO);
	close(out_pipe.write_fd);
      }
      if (TLS_argument_count >= 6) {
	close(TLS_arguments[5]->file_descriptor.value);
      } else {
	close(err_pipe.read_fd);
	dup2_fd(err_pipe.write_fd, STDERR_FILENO);
	close(err_pipe.write_fd);
      }

      if ((environment)->type == std_types___list.type) {
	envp = allocate_memory((environment->list.length+1)*sizeof(char *));
	int i;
	for (i = 0; i < environment->list.length; ++i) {
	  envp[i] = NULL;
	}
	// convert the environment into C-strings
	long offset = environment->list.offset;
	for (i = 0; i < environment->list.length; ++i) {
	  if (!to_c_string(environment->list.data->items[offset+i], &envp[i]))
	    goto cleanup;
	}
	envp[environment->list.length] = NULL;
	execvpe(args[0], args, envp);
      } else {
	execvp(args[0], args);
      }
      fprintf(stderr, "EXEC \"%s\" FAILED - %s\n", args[0], strerror(errno));
      exit(EXIT_FAILURE);
    }

    // parent process

    if (pid == -1) {
      create_error_message(
	      module__builtin.constants_base[unique__std___IO_ERROR-1],
	"FORK FAILED", errno, 0, NULL);
      goto cleanup;
    }

    NODE *child_pid, *child_stdin, *child_stdout, *child_stderr;

    child_pid = process_id_from_int(pid);
    if (TLS_argument_count < 4) {
      child_stdin = file_descriptor_from_int(in_pipe.write_fd);
    }
    child_stdout = file_descriptor_from_int(out_pipe.read_fd);
    child_stderr = file_descriptor_from_int(err_pipe.read_fd);


    if (TLS_argument_count == 4) {
      // we got *stdin* from the caller
      TLS_argument_count = 3;
      TLS_arguments[0] = child_pid;
      TLS_arguments[1] = child_stdout;
      TLS_arguments[2] = child_stderr;
      goto cleanup_2;
    } else if (TLS_argument_count == 5) {
      // we got *stdin* and *stdout* from the caller
      TLS_argument_count = 2;
      TLS_arguments[0] = child_pid;
      TLS_arguments[1] = child_stderr;
      goto cleanup_2;
    } else if (TLS_argument_count == 6) {
      // we got *stdin*, *stdout* and *stderr* from the caller
      TLS_argument_count = 1;
      TLS_arguments[0] = child_pid;
      goto cleanup_2;
    } else {
      TLS_argument_count = 4;
      TLS_arguments[0] = child_pid;
      TLS_arguments[1] = child_stdin;
      TLS_arguments[2] = child_stdout;
      TLS_arguments[3] = child_stderr;
      goto cleanup_2;
    }

    cleanup:

    close_fd(&in_pipe.write_fd);
    close_fd(&out_pipe.read_fd);
    close_fd(&err_pipe.read_fd);

    cleanup_2:

    close_fd(&in_pipe.read_fd);
    close_fd(&out_pipe.write_fd);
    close_fd(&err_pipe.write_fd);

    if (args) {
      for (i = 0; i < arguments->list.length+1; ++i) {
	deallocate_memory(args[i]);
      }
      deallocate_memory(args);
    }
    if (envp) {
      for (i = 0; i < environment->list.length; ++i) {
	deallocate_memory(envp[i]);
      }
      deallocate_memory(envp);
    }
  }

static void entry__std_types___function___std___parameter_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    int par_count =
      ((const TAB_NUM *)((unsigned long)TLS_arguments[0]->type & -4L))[1];
    if (par_count < 0)
      {
        NODE *result__node = (NODE *)(&std_types___undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    else
      {
        NODE *result__node = (NODE *)(from_uint32(par_count));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
  }

static void entry__std_types___list___std___new (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type != std_types___list.type) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__std_types___list(TLS_arguments[1]->list.offset, TLS_arguments[1]->list.length, TLS_arguments[1]->list.data);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___list (void)
  {
    if (TLS_argument_count < 0) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count == 0) {
      NODE *result__node = (NODE *)((NODE *)&std___empty_list);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    LIST_DATA *data =
      allocate_large(sizeof(LIST_DATA)+TLS_argument_count*sizeof(NODE *));
    data->size = TLS_argument_count;
    data->length = TLS_argument_count;
    int i = 0;
    for (i = 0; i < TLS_argument_count; ++i) {
      data->items[i] = TLS_arguments[i];
    }
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, TLS_argument_count, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___list___std___length_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->list.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___list___std___is_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->list.length == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___list___std___is_not_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->list.length > 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___list___std___push (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    NODE *value = TLS_arguments[1];
    long start_offset = self->list.offset;
    long left_length = self->list.length;
    long end_offset = start_offset+left_length;
    long new_length = left_length+1;
    LIST_DATA *data = self->list.data;
    if (!data || data->size < end_offset+1 || data->length != end_offset) {
      long new_size = ALLOCATION_SIZE(2*new_length);
      LIST_DATA *new_data = allocate_large(sizeof(LIST_DATA)+new_size*sizeof(NODE *));
      if (data) memcpy(new_data->items, data->items+start_offset, left_length*sizeof(NODE *));
      start_offset = 0;
      end_offset = left_length;
      new_data->size = new_size;
      data = new_data;
    }
    data->items[end_offset] = value;
    data->length = end_offset+1;
    NODE *result = create__std_types___list(start_offset, new_length, data);
    result->attributes = self->attributes; // maintain attributes
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types___list___std___drop (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *list = TLS_arguments[0];
    long length = list->list.length;
    if (length == 0) {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to drop an element from an empty list!", 0, 0, NULL);
      return;
    }
    NODE *result =
      create__std_types___list(list->list.offset, length-1, list->list.data);
    result->attributes = list->attributes; // maintain attributes
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types___list___std___pop (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 2) {
      result_count_mismatch();
      return;
    }
    if (TLS_result_count != 2) {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Invalid number of expected results!", 0, 0, NULL);
      return;
    }
    NODE *list = TLS_arguments[0];
    long offset = list->list.offset;
    long length = list->list.length;
    if (length == 0) {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to pop an element from an empty list!", 0, 0, NULL);
      return;
    }
    NODE *new_list = create__std_types___list(offset, length-1, list->list.data);
    new_list->attributes = list->attributes; // maintain attributes
    TLS_argument_count = 2;
    TLS_arguments[0] = new_list;
    TLS_arguments[1] = list->list.data->items[offset+length-1];
    {
      return;
    }
  }

static void entry__std_types___list___std___peek (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *list = TLS_arguments[0];
    long length = list->list.length;
    if (length == 0) {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to peek an element of an empty list!", 0, 0, NULL);
      return;
    }
    {
      NODE *result__node = (NODE *)(list->list.data->items[list->list.offset+length-1]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___list___std___append (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    long left_length = left->list.length;
    long new_length = left_length;
    int i;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      if ((right)->type != std_types___list.type) {
        invalid_arguments();
        return;
      }
      new_length += right->list.length;
    }
    if (new_length == left_length) {
      NODE *result__node = (NODE *)(left);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_length == 0 && TLS_argument_count == 2) {
      NODE *right = TLS_arguments[1];
      NODE *result =
	create__std_types___list(right->list.offset, right->list.length, right->list.data);
      result->attributes = left->attributes; // maintain attributes
      {
        NODE *result__node = (NODE *)(result);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    }
    long left_offset = left->list.offset;
    LIST_DATA *data = left->list.data;
    if (
      !data || data->size < left_offset+new_length ||
      data->length != left_offset+left_length
    ) {
      long new_size = 2*new_length;
      LIST_DATA *new_data =
	allocate_large(sizeof(LIST_DATA)+new_size*sizeof(NODE *));
      if (data) {
	memcpy(
	  new_data->items, data->items+left_offset, left_length*sizeof(NODE *));
      }
      left_offset = 0;
      new_data->size = new_size;
      data = new_data;
    }
    long offset = left_offset+left_length;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      long right_offset = right->list.offset;
      long right_length = right->list.length;
      if (right_length > 0) {
	memcpy(
	  data->items+offset,
	  right->list.data->items+right_offset,
	  right_length*sizeof(NODE *));
	offset += right_length;
      }
    }
    data->length = left_offset+new_length;
    NODE *result = create__std_types___list(left_offset, new_length, data);
    result->attributes = left->attributes; // maintain attributes
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types___list___std___range (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    long first_idx, last_idx;
    if (!to_long(TLS_arguments[1], &first_idx)) return;
    if (!to_long(TLS_arguments[2], &last_idx)) return;
    long length = self->list.length;
    if (first_idx < 0) first_idx = length+first_idx+1;
    if (last_idx < 0) last_idx = length+last_idx+1;
    if (first_idx < 1 || first_idx > length+1) {
      invalid_index(self);
      return;
    };
    if (last_idx < 0 || last_idx > length) {
      invalid_index(self);
      return;
    };
    if (first_idx > last_idx+1) {
      invalid_arguments();
      return;
    }
    if (first_idx == 1 && last_idx == length) {
      NODE *result__node = (NODE *)(self);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long new_len = last_idx-first_idx+1;
    if (new_len == 0) {
      NODE *result__node = (NODE *)((NODE *)&std___empty_list);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___list(self->list.offset+first_idx-1, new_len, self->list.data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___list___std___spread (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long length = self->list.length;
    if (TLS_result_count != length) {
      result_count_mismatch();
      return;
    }
    TLS_argument_count = length;
    int i;
    for (i = 0; i < length; ++i) {
      TLS_arguments[i] = self->list.data->items[i];
    }
    {
      return;
    }
  }

static void entry__std_types___positive_integer___std___negate (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[0]->integer.value == 0) {
      return;
    }
    {
      NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__negative_integer___std___negate (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___negate (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(-TLS_arguments[0]->real.value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___positive_integer___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint64_t low, high;
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->integer.value*TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint64_t low, high;
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(-(TLS_arguments[0]->integer.value*TLS_arguments[1]->real.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__negative_integer___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    long val = floor(TLS_arguments[0]->real.value);
    {
      NODE *result__node = (NODE *)(from_long(val));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___floor (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(floor(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___ceil (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(ceil(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___round (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(round(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__negative_integer___std___to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    char buf[24];
    sprintf(buf, "-%" PRIu64, TLS_arguments[0]->integer.value);
    {
      NODE *result__node = (NODE *)(from_c_string(buf));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___positive_integer___std___to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    char buf[24];
    sprintf(buf, "%" PRIu64, TLS_arguments[0]->integer.value);
    {
      NODE *result__node = (NODE *)(from_c_string(buf));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    char buf[24];
    sprintf(buf, "%.15g", TLS_arguments[0]->real.value);
    {
      NODE *result__node = (NODE *)(from_c_string(buf));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___positive_integer___std___over (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[1]->integer.value == 0) goto invalid_arguments;
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types___real((double)TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types___real(-((double)TLS_arguments[0]->integer.value /
	  	    TLS_arguments[1]->integer.value)));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->integer.value/TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    invalid_arguments:
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___over (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == negative_integer.type) {
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types___real((double)TLS_arguments[0]->integer.value /
	  	    TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[1]->integer.value == 0) goto invalid_arguments;
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types___real(-((double)TLS_arguments[0]->integer.value /
	  	    TLS_arguments[1]->integer.value)));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(-(TLS_arguments[0]->integer.value/TLS_arguments[1]->real.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    invalid_arguments:
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___div (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__negative_integer((TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value-1) /
        	  TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___div (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer((TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value-1) /
	  	    TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___mod (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      long result = TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value;
      {
        NODE *result__node = (NODE *)(create__negative_integer(result ? TLS_arguments[1]->integer.value-result : 0));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___mod (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	long result = TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value;
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(result ? TLS_arguments[1]->integer.value-result : 0));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash =
      (uint32_t)TLS_arguments[0]->integer.value ^ (TLS_arguments[0]->integer.value >> 32);
    hash *= 179234567;
    hash ^= hash >> 27 | hash << 5;
    //hash *= 257913241;
    //hash ^= hash >> 21 | hash << 11;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__negative_integer___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash =
      (uint32_t)TLS_arguments[0]->integer.value ^ (TLS_arguments[0]->integer.value >> 32);
    hash *= 179234567;
    hash ^= hash >> 27 | hash << 5;
    //hash *= 326987239;
    //hash ^= hash >> 21 | hash << 11;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash =
      (uint32_t)TLS_arguments[0]->integer.value ^ (TLS_arguments[0]->integer.value >> 32);
    hash ^= hash >> 23 | hash << 9;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___positive_integer___std___ln (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(log(TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__negative_integer___std___ln (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(log(-TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___ln (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(log(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___positive_integer___std___exp (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(exp(TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__negative_integer___std___exp (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(exp(-TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___real___std___exp (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___real(exp(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___real (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *str;
    if (!to_c_string(TLS_arguments[0], &str)) return;
    NODE *result = from_double(atof(str));
    deallocate_memory(str);
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *buf;
    if (!to_c_string(TLS_arguments[0], &buf)) return;
    int sign = 1;
    unsigned long value = 0;
    char *str = buf;
    if (*str == '-') {
      sign = -1;
      ++str;
    } else if (*str == '+') {
      ++str;
    }
    if (*str < '0' || *str > '9') {
      invalid_arguments();
      goto cleanup;
    }
    char c;
    next:
    c = *str++;
    if (c < '0' || c > '9') {
      NODE *result;
      if (sign < 0 && value != 0) {
	result = create__negative_integer(value);
      } else {
	result = create__std_types___positive_integer(value);
      }
      {
        NODE *result__node = (NODE *)(result);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
      goto cleanup;
    } else {
      unsigned long old_value = value;
      value <<= 1;
      if (value < old_value) goto overflow;
      unsigned long intermediate_value = value;
      value <<= 1;
      if (value < intermediate_value) goto overflow;
      intermediate_value = value;
      value += old_value;
      if (value < intermediate_value) goto overflow;
      intermediate_value = value;
      value <<= 1;
      if (value < intermediate_value) goto overflow;
      intermediate_value = value;
      value += c-'0';
      if (value < intermediate_value) goto overflow;
      goto next;
    }

    overflow:

    create_error_message(
      module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
      "std::integer OVERFLOW", 0, 0, NULL);

    cleanup:

    deallocate_memory(buf);
    return;
  }

static void entry__std___sqrt (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(sqrt(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___pow (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    double base;
    if (!to_double(TLS_arguments[0], &base)) return;
    double exponent;
    if (!to_double(TLS_arguments[1], &exponent)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(pow(base, exponent)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___positive_integer___std___exit (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int status;
    if (!to_int(TLS_arguments[0], &status)) return;
    exit(status);
  }

static void entry__std_types___positive_integer___std___plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >= TLS_arguments[0]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      if (TLS_arguments[0]->integer.value >= TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->integer.value+TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == negative_integer.type) {
      if (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >= TLS_arguments[0]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[0]->integer.value > TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[1]->real.value-TLS_arguments[0]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___real___std___plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value+TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value+TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value-TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[0]->integer.value >= TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      if (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >= TLS_arguments[0]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->integer.value-TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == negative_integer.type) {
      if (TLS_arguments[0]->integer.value > TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      if (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >= TLS_arguments[0]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__negative_integer(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(-(TLS_arguments[0]->integer.value+TLS_arguments[1]->real.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___real___std___minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value-TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value-TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value+TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___real___std___times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value*TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value*TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(-(TLS_arguments[0]->real.value*TLS_arguments[1]->integer.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___real___std___over (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value/TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(TLS_arguments[0]->real.value/TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___real(-(TLS_arguments[0]->real.value/TLS_arguments[1]->integer.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__negative_integer___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == -TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___real___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value == TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(-TLS_arguments[0]->real.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___positive_integer___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value < TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value < TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__negative_integer___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value > TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value > -TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___real___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value < TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value < TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(-TLS_arguments[0]->real.value > TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___shift_left (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value << TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___shift_right (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value >> TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value & TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value | TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types___positive_integer___std___bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types___positive_integer(TLS_arguments[0]->integer.value ^ TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std___sin (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(sin(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___cos (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(cos(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___tan (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(tan(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___asin (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(asin(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___acos (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(acos(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___atan (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types___real(atan(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_type___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___file_type.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->file_type.value ==
      	  TLS_arguments[1]->file_type.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_type___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->file_type.value;
    hash += 4243007357u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___file_type (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___file_type(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_type___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->file_type.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_descriptor___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___file_descriptor.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->file_descriptor.value ==
      	  TLS_arguments[1]->file_descriptor.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_descriptor___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->file_descriptor.value;
    hash += 1659535014u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___file_descriptor (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___file_descriptor(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_descriptor___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->file_descriptor.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___shutdown_type___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___shutdown_type.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->shutdown_type.value ==
      	  TLS_arguments[1]->shutdown_type.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___shutdown_type___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->shutdown_type.value;
    hash += 1037657925u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___shutdown_type (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___shutdown_type(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___shutdown_type___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->shutdown_type.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___device_id___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___device_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->device_id.value ==
      	  TLS_arguments[1]->device_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___device_id___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->device_id.value;
    hash += 1532833290u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___device_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value;
    if (!(to_ulong(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___device_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___device_id___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value = TLS_arguments[0]->device_id.value;
    {
      NODE *result__node = (NODE *)(from_ulong(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___directory___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___directory.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->directory.value ==
      	  TLS_arguments[1]->directory.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___directory___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = (uint32_t)(long)TLS_arguments[0]->directory.value;
    hash += 835235593u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types___group_id___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___group_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->group_id.value ==
      	  TLS_arguments[1]->group_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___group_id___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->group_id.value;
    hash += 1390477003u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___group_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___group_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___group_id___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->group_id.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___inode_number___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___inode_number.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->inode_number.value ==
      	  TLS_arguments[1]->inode_number.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___inode_number___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->inode_number.value;
    hash += 524255112u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___inode_number (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value;
    if (!(to_ulong(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___inode_number(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___inode_number___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value = TLS_arguments[0]->inode_number.value;
    {
      NODE *result__node = (NODE *)(from_ulong(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___process_id___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___process_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->process_id.value ==
      	  TLS_arguments[1]->process_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___process_id___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->process_id.value;
    hash += 3109630881u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___process_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___process_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___process_id___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->process_id.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___user_id___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___user_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->user_id.value ==
      	  TLS_arguments[1]->user_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___user_id___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->user_id.value;
    hash += 4053581900u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___user_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___user_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___user_id___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->user_id.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error_number___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types___error_number.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->error_number.value ==
      	  TLS_arguments[1]->error_number.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error_number___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->error_number.value;
    hash += 1056763753u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___error_number (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types___error_number(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___error_number___std___to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->error_number.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___access (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    char *mode_str;
    int mode;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!to_c_string(TLS_arguments[1], &mode_str)) goto cleanup;
    mode = 0;
    for(int i = 0; mode_str[i]; i++) {
      switch(mode_str[i]) {
	case 'r':
	  mode |= R_OK;
	  break;
	case 'w':
	  mode |= W_OK;
	  break;
	case 'x':
	  mode |= X_OK;
	  break;
	default:
	  create_error_message(
	    module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	    "ACCESS: INVALID MODE", 0, 0, NULL);
	  goto cleanup;
      }
    }
    if (event__mode != EM__REPLAY) {
      result = access(filename, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("access");
          } else {
            failed__action("access");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("access")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("access");
          print__c_string(filename);
          print__c_string(mode_str);
          print__integer(result);
    }
    if (result == 0) {
      {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    } else {
      if (errno == EACCES) {
	{
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	}
      } else {
	create_error_message(
	  module__builtin.constants_base[unique__std___IO_ERROR-1],
	  "ACCESS FAILED", errno, 0, NULL);
      }
    }
    cleanup:
    deallocate_memory(filename);
    deallocate_memory(mode_str);
  }

static void entry__std___chdir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *pathname = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &pathname)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chdir(pathname);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("chdir");
          } else {
            failed__action("chdir");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("chdir")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("chdir");
          print__c_string(pathname);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHDIR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(pathname);
  }

static void entry__std___chmod (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int mode;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!mode_to_int(TLS_arguments[1], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chmod(filename, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("chmod");
          } else {
            failed__action("chmod");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("chmod")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("chmod");
          print__c_string(filename);
          print__integer(mode);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHMOD FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std___chown (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int owner;
    int group;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!user_id_to_int(TLS_arguments[1], &owner)) goto cleanup;
    if (!group_id_to_int(TLS_arguments[2], &group)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chown(filename, owner, group);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("chown");
          } else {
            failed__action("chown");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("chown")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("chown");
          print__c_string(filename);
          print__integer(owner);
          print__integer(group);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHOWN FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std___chroot (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *pathname = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &pathname)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chroot(pathname);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("chroot");
          } else {
            failed__action("chroot");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("chroot")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("chroot");
          print__c_string(pathname);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHROOT FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(pathname);
  }

static void entry__std_types___file_descriptor___std___close (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd = TLS_arguments[0]->file_descriptor.value;
    int result;
    if (event__mode != EM__REPLAY) {
      do {
	result = close(fd);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("close");
          } else {
            failed__action("close");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("close")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("close");
          print__integer(fd);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CLOSE FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std___closedir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    void *dir = NULL;
    int result;
    if (!directory_to_ptr(TLS_arguments[0], &dir)) return;
    if (event__mode != EM__REPLAY) {
      result = closedir(dir);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("closedir");
          } else {
            failed__action("closedir");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("closedir")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("closedir");
          print__pointer(dir);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CLOSEDIR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std___dup2 (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int old_fd;
    int new_fd;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &old_fd)) return;
    if (!file_descriptor_to_int(TLS_arguments[1], &new_fd)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = dup2(old_fd, new_fd);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("dup2");
          } else {
            failed__action("dup2");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("dup2")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("dup2");
          print__integer(old_fd);
          print__integer(new_fd);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"DUP2 FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std___fstat (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    struct stat statbuf;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (event__mode != EM__REPLAY) {
      result = fstat(fd, &statbuf);
      if (event__mode == EM__RECORD) {
        record__event("fstat");
        store__integer(result);
        store__memory(&statbuf, sizeof(statbuf));
      }
    } else {
      replay__event("fstat");
      retrieve__integer(&result);
      retrieve__fixed_memory((uint8_t *)&statbuf, sizeof(statbuf));
      report__event("fstat");
      print__integer(fd);
      print__integer(result);
      print__memory(&statbuf, sizeof(statbuf));
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"FSTAT FAILED", errno, 0, NULL);
    } else {
      NODE *node__device_of = device_id_from_ulong(statbuf.st_dev);
      NODE *node__inode_number_of = inode_number_from_ulong(statbuf.st_ino);
      NODE *node__type_of = file_type_from_int(statbuf.st_mode >> 12);
      NODE *node__mode_of = mode_from_int(statbuf.st_mode);
      NODE *node__link_count_of = from_int(statbuf.st_nlink);
      NODE *node__user_id_of = user_id_from_int(statbuf.st_uid);
      NODE *node__group_id_of = group_id_from_int(statbuf.st_gid);
      NODE *node__root_device_of = device_id_from_ulong(statbuf.st_rdev);
      NODE *node__size_of = from_long(statbuf.st_size);
      NODE *node__block_size_of = from_long(statbuf.st_blksize);
      NODE *node__block_count_of = from_long(statbuf.st_blocks);
      NODE *node__access_time_seconds_of = from_long(statbuf.st_atim.tv_sec);
      NODE *node__access_time_nanoseconds_of =
	from_long(statbuf.st_atim.tv_nsec);
      NODE *node__modification_time_seconds_of =
	from_long(statbuf.st_mtim.tv_sec);
      NODE *node__modification_time_nanoseconds_of =
	from_long(statbuf.st_mtim.tv_nsec);
      NODE *node__status_change_time_seconds_of =
	from_long(statbuf.st_ctim.tv_sec);
      NODE *node__status_change_time_nanoseconds_of =
	from_long(statbuf.st_ctim.tv_nsec);
      NODE *node = clone_object_and_attributes((NODE *)&std_types___stat);
      update_start_p = node_p;
      set_attribute(
	node->attributes,
	variables_table[var_no__std___device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__device_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___mode_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__mode_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___link_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__link_count_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___root_device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__root_device_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__size_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___block_size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_size_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___access_time_seconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__access_time_seconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___access_time_nanoseconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__access_time_nanoseconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___modification_time_seconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__modification_time_seconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___modification_time_nanoseconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__modification_time_nanoseconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___status_change_time_seconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__status_change_time_seconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___status_change_time_nanoseconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__status_change_time_nanoseconds_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___fsync (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (event__mode != EM__REPLAY) {
      result = fsync(fd);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("fsync");
          } else {
            failed__action("fsync");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("fsync")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("fsync");
          print__integer(fd);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"FSYNC FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std___getcwd (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    uint8_t static_buf[1024];
    uint8_t *buf = NULL;
    size_t size;
    char *result = NULL;
    if (event__mode != EM__REPLAY) {
      buf = static_buf;
      size = 1024;
      retry:
      result = getcwd((char *)buf, size);
      if (buf == static_buf) buf = NULL;
      if (errno == ERANGE) {
	size += size;
	buf = reallocate_memory(buf, size);
	goto retry;
      }
      if (event__mode == EM__RECORD) {
        record__event("getcwd");
        store__c_string(result);
      }
    } else {
      replay__event("getcwd");
      retrieve__c_string(&result);
      report__event("getcwd");
      print__c_string(result);
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETCWD FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    deallocate_memory(buf);
  }

static void entry__std___getenv (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *var_name = NULL;
    char *result = NULL;
    if (!to_c_string(TLS_arguments[0], &var_name)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = getenv(var_name);
      if (event__mode == EM__RECORD) {
        record__event("getenv");
        store__c_string(result);
      }
    } else {
      replay__event("getenv");
      retrieve__c_string(&result);
      report__event("getenv");
      print__c_string(var_name);
      print__c_string(result);
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETENV FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(var_name);
  }

static void entry__std___getegid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getegid();
      if (event__mode == EM__RECORD) {
        record__event("getegid");
        store__integer(result);
      }
    } else {
      replay__event("getegid");
      retrieve__integer(&result);
      report__event("getegid");
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(group_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___geteuid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = geteuid();
      if (event__mode == EM__RECORD) {
        record__event("geteuid");
        store__integer(result);
      }
    } else {
      replay__event("geteuid");
      retrieve__integer(&result);
      report__event("geteuid");
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(user_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___getgid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getgid();
      if (event__mode == EM__RECORD) {
        record__event("getgid");
        store__integer(result);
      }
    } else {
      replay__event("getgid");
      retrieve__integer(&result);
      report__event("getgid");
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(group_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___gethostname (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char buf[HOST_NAME_MAX+1];
    int result;
    if (event__mode != EM__REPLAY) {
      result = gethostname(buf, sizeof(buf));
      if (event__mode == EM__RECORD) {
        record__event("gethostname");
        store__memory(buf, result);
      }
    } else {
      replay__event("gethostname");
      result = retrieve__memory((uint8_t **)&buf);
      report__event("gethostname");
      print__memory(buf, result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETHOSTNAME FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(buf));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___getlogin (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *result = NULL;
    if (event__mode != EM__REPLAY) {
      result = getlogin();
      if (event__mode == EM__RECORD) {
        record__event("getlogin");
        store__c_string(result);
      }
    } else {
      replay__event("getlogin");
      retrieve__c_string(&result);
      report__event("getlogin");
      print__c_string(result);
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETLOGIN FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___getpid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getpid();
      if (event__mode == EM__RECORD) {
        record__event("getpid");
        store__integer(result);
      }
    } else {
      replay__event("getpid");
      retrieve__integer(&result);
      report__event("getpid");
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(process_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___getppid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getppid();
      if (event__mode == EM__RECORD) {
        record__event("getppid");
        store__integer(result);
      }
    } else {
      replay__event("getppid");
      retrieve__integer(&result);
      report__event("getppid");
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(process_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___getpwuid (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int uid;
    struct passwd *result = NULL;
    if (!user_id_to_int(TLS_arguments[0], &uid)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = getpwuid(uid);
      } while (result == NULL && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("getpwuid");
        store__memory(&result, sizeof(result));
      }
    } else {
      replay__event("getpwuid");
      retrieve__fixed_memory((uint8_t *)&result, sizeof(result));
      report__event("getpwuid");
      print__integer(uid);
      print__memory(&result, sizeof(result));
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETPWUID FAILED", errno, 0, NULL);
    } else {
      NODE *node__username_of = from_c_string(result->pw_name);
      NODE *node__password_of = from_c_string(result->pw_passwd);
      NODE *node__user_id_of = user_id_from_int(result->pw_uid);
      NODE *node__group_id_of = group_id_from_int(result->pw_gid);
      NODE *node__user_information_of = from_c_string(result->pw_gecos);
      NODE *node__home_directory_of = from_c_string(result->pw_dir);
      NODE *node__shell_of = from_c_string(result->pw_shell);
      NODE *node = clone_object_and_attributes((NODE *)&std_types___passwd);
      update_start_p = node_p;
      set_attribute(
	node->attributes,
	variables_table[var_no__std___username_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__username_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___password_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__password_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___user_information_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_information_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___home_directory_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__home_directory_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___shell_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__shell_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___getsid (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int pid;
    int result;
    if (!process_id_to_int(TLS_arguments[0], &pid)) return;
    if (event__mode != EM__REPLAY) {
      result = getsid(pid);
      if (event__mode == EM__RECORD) {
        record__event("getsid");
        store__integer(result);
      }
    } else {
      replay__event("getsid");
      retrieve__integer(&result);
      report__event("getsid");
      print__integer(pid);
      print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETSID FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(process_id_from_int(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___getuid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getuid();
      if (event__mode == EM__RECORD) {
        record__event("getuid");
        store__integer(result);
      }
    } else {
      replay__event("getuid");
      retrieve__integer(&result);
      report__event("getuid");
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(user_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___isatty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    int result;
    if (event__mode != EM__REPLAY) {
      result = isatty(fd);
      if (event__mode == EM__RECORD) {
        record__event("isatty");
        store__integer(result);
      }
    } else {
      replay__event("isatty");
      retrieve__integer(&result);
      report__event("isatty");
      print__integer(fd);
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(from_bool(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___mkdir (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *pathname = NULL;
    int mode = 0755;
    int result;
    if (!to_c_string(TLS_arguments[0], &pathname)) goto cleanup;
    if (TLS_argument_count >= 2 && !mode_to_int(TLS_arguments[1], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = mkdir(pathname, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("mkdir");
          } else {
            failed__action("mkdir");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("mkdir")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("mkdir");
          print__c_string(pathname);
          print__integer(mode);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"MKDIR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(pathname);
  }

static void entry__std___mkfifo (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int mode = 0644;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (TLS_argument_count >= 2 && !mode_to_int(TLS_arguments[1], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = mkfifo(filename, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("mkfifo");
          } else {
            failed__action("mkfifo");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("mkfifo")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("mkfifo");
          print__c_string(filename);
          print__integer(mode);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"MKFIFO FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std___open (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int flags;
    int mode = 0644;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!flags_to_int(TLS_arguments[1], &flags)) goto cleanup;
    if (TLS_argument_count >= 3 && !mode_to_int(TLS_arguments[2], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      do {
	result = open(filename, flags, mode);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("open");
        store__integer(result);
      }
    } else {
      replay__event("open");
      retrieve__integer(&result);
      report__event("open");
      print__c_string(filename);
      print__integer(flags);
      print__integer(mode);
      print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"OPEN FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std___opendir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *name = NULL;
    void *result = NULL;
    if (!to_c_string(TLS_arguments[0], &name)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = opendir(name);
      if (event__mode == EM__RECORD) {
        record__event("opendir");
        store__pointer(result);
      }
    } else {
      replay__event("opendir");
      retrieve__pointer((const void **)&result);
      report__event("opendir");
      print__c_string(name);
      print__pointer(result);
    }
    if (!result) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"OPENDIR FAILED", errno, 0, TLS_arguments[0]);
    } else {
      {
        NODE *result__node = (NODE *)(directory_from_ptr(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(name);
  }

static void entry__std_types___file_descriptor___std___read (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd = TLS_arguments[0]->file_descriptor.value;
    uint8_t *buf = NULL;
    size_t size;
    ssize_t result;
    if (!to_ulong(TLS_arguments[1], &size)) goto cleanup;
    buf = allocate_memory(size);
    if (event__mode != EM__REPLAY) {
      do {
	result = read(fd, (char *)buf, size);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("read");
        store__memory(buf, result);
      }
    } else {
      replay__event("read");
      result = retrieve__memory((uint8_t **)&buf);
      report__event("read");
      print__integer(fd);
      print__unsigned_long_integer(size);
      print__memory(buf, result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"READ FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_latin_1_string(buf, result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(buf);
  }

static void entry__std___readdir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    void *dir = NULL;
    struct dirent *result = NULL;
    if (!directory_to_ptr(TLS_arguments[0], &dir)) return;
    if (event__mode != EM__REPLAY) {
      result = readdir(dir);
      if (event__mode == EM__RECORD) {
        record__event("readdir");
        store__memory(&result, sizeof(result));
      }
    } else {
      replay__event("readdir");
      retrieve__fixed_memory((uint8_t *)&result, sizeof(result));
      report__event("readdir");
      print__pointer(dir);
      print__memory(&result, sizeof(result));
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"READDIR FAILED", errno, 0, NULL);
    } else {
      NODE *node__inode_number_of = inode_number_from_ulong(result->d_ino);
      NODE *node__type_of = file_type_from_int(result->d_type);
      NODE *node__name_of = from_c_string(result->d_name);
      NODE *node = clone_object_and_attributes((NODE *)&std_types___dirent);
      update_start_p = node_p;
      set_attribute(
	node->attributes,
	variables_table[var_no__std___inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___name_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__name_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___realpath (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    char *resolved_name = NULL;
    char *result = NULL;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = realpath(filename, resolved_name);
      if (event__mode == EM__RECORD) {
        record__event("realpath");
        store__c_string(result);
      }
    } else {
      replay__event("realpath");
      retrieve__c_string(&result);
      report__event("realpath");
      print__c_string(filename);
      print__c_string(result);
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"REALPATH FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
    deallocate_memory(resolved_name);
    free(result);
  }

static void entry__std___rename (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *old_filename = NULL;
    char *new_filename = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &old_filename)) goto cleanup;
    if (!to_c_string(TLS_arguments[1], &new_filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = rename(old_filename, new_filename);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("rename");
          } else {
            failed__action("rename");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("rename")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("rename");
          print__c_string(old_filename);
          print__c_string(new_filename);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"RENAME FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(old_filename);
    deallocate_memory(new_filename);
  }

static void entry__std___sethostname (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    uint8_t *buf = NULL;
    size_t size;
    int result;
    if (
      !to_octets(TLS_arguments[1],
      (const uint8_t **)&buf, (long *)&size)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      do {
	result = sethostname((char *)buf, size);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("sethostname");
          } else {
            failed__action("sethostname");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("sethostname")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("sethostname");
          print__memory(buf, size);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SETHOSTNAME FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(buf);
  }

static void entry__std___shutdown (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    int how;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (!shutdown_type_to_int(TLS_arguments[1], &how)) return;
    if (event__mode != EM__REPLAY) {
      result = shutdown(fd, how);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("shutdown");
          } else {
            failed__action("shutdown");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("shutdown")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("shutdown");
          print__integer(fd);
          print__integer(how);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SHUTDOWN FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std___stat (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    struct stat statbuf;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = stat(filename, &statbuf);
      if (event__mode == EM__RECORD) {
        record__event("stat");
        store__integer(result);
        store__memory(&statbuf, sizeof(statbuf));
      }
    } else {
      replay__event("stat");
      retrieve__integer(&result);
      retrieve__fixed_memory((uint8_t *)&statbuf, sizeof(statbuf));
      report__event("stat");
      print__c_string(filename);
      print__integer(result);
      print__memory(&statbuf, sizeof(statbuf));
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"STAT FAILED", errno, 0, TLS_arguments[0]);
    } else {
      NODE *node__device_of = device_id_from_ulong(statbuf.st_dev);
      NODE *node__inode_number_of = inode_number_from_ulong(statbuf.st_ino);
      NODE *node__type_of = file_type_from_int(statbuf.st_mode >> 12);
      NODE *node__mode_of = mode_from_int(statbuf.st_mode);
      NODE *node__link_count_of = from_int(statbuf.st_nlink);
      NODE *node__user_id_of = user_id_from_int(statbuf.st_uid);
      NODE *node__group_id_of = group_id_from_int(statbuf.st_gid);
      NODE *node__root_device_of = device_id_from_ulong(statbuf.st_rdev);
      NODE *node__size_of = from_long(statbuf.st_size);
      NODE *node__block_size_of = from_long(statbuf.st_blksize);
      NODE *node__block_count_of = from_long(statbuf.st_blocks);
      NODE *node__access_time_seconds_of = from_long(statbuf.st_atim.tv_sec);
      NODE *node__access_time_nanoseconds_of =
	from_long(statbuf.st_atim.tv_nsec);
      NODE *node__modification_time_seconds_of =
	from_long(statbuf.st_mtim.tv_sec);
      NODE *node__modification_time_nanoseconds_of =
	from_long(statbuf.st_mtim.tv_nsec);
      NODE *node__status_change_time_seconds_of =
	from_long(statbuf.st_ctim.tv_sec);
      NODE *node__status_change_time_nanoseconds_of =
	from_long(statbuf.st_ctim.tv_nsec);
      NODE *node = clone_object_and_attributes((NODE *)&std_types___stat);
      update_start_p = node_p;
      set_attribute(
	node->attributes,
	variables_table[var_no__std___device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__device_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___mode_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__mode_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___link_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__link_count_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___root_device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__root_device_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__size_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___block_size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_size_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___access_time_seconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__access_time_seconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___access_time_nanoseconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__access_time_nanoseconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___modification_time_seconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__modification_time_seconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___modification_time_nanoseconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__modification_time_nanoseconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___status_change_time_seconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__status_change_time_seconds_of));
      set_attribute(
	node->attributes,
	variables_table[var_no__std___status_change_time_nanoseconds_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__status_change_time_nanoseconds_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std___strerror (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int errnum;
    char *result = NULL;
    if (!error_number_to_int(TLS_arguments[0], &errnum)) return;
    if (event__mode != EM__REPLAY) {
      result = strerror(errnum);
      if (event__mode == EM__RECORD) {
        record__event("strerror");
        store__c_string(result);
      }
    } else {
      replay__event("strerror");
      retrieve__c_string(&result);
      report__event("strerror");
      print__integer(errnum);
      print__c_string(result);
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"STRERROR FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___wait (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int status;
    int result;
    if (event__mode != EM__REPLAY) {
      do {
	result = wait(&status);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("wait");
        store__integer(result);
        store__integer(status);
      }
    } else {
      replay__event("wait");
      retrieve__integer(&result);
      retrieve__integer(&status);
      report__event("wait");
      print__integer(result);
      print__integer(status);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"WAIT FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 2;
      TLS_arguments[0] = process_id_from_int(result);
      TLS_arguments[1] = from_int(status);
    }
  }

static void entry__std_types___file_descriptor___std___write (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd = TLS_arguments[0]->file_descriptor.value;
    uint8_t *buf = NULL;
    size_t size;
    ssize_t result;
    if (
      !to_octets(TLS_arguments[1],
      (const uint8_t **)&buf, (long *)&size)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      do {
	result = write(fd, (char *)buf, size);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("write");
        store__long_integer(result);
      }
    } else {
      replay__event("write");
      retrieve__long_integer(&result);
      report__event("write");
      print__integer(fd);
      print__memory(buf, size);
      print__long_integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"WRITE FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_long(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(buf);
  }

static void entry__std___umask (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int mask;
    int result;
    if (!mode_to_int(TLS_arguments[0], &mask)) return;
    if (event__mode != EM__REPLAY) {
      result = umask(mask);
      if (event__mode == EM__RECORD) {
        record__event("umask");
        store__integer(result);
      }
    } else {
      replay__event("umask");
      retrieve__integer(&result);
      report__event("umask");
      print__integer(mask);
      print__integer(result);
    }
    {
      NODE *result__node = (NODE *)(mode_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___unlink (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = unlink(filename);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("unlink");
          } else {
            failed__action("unlink");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("unlink")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("unlink");
          print__c_string(filename);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"UNLINK FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std___usleep (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    unsigned int microseconds;
    int result;
    if (!to_uint(TLS_arguments[0], &microseconds)) return;
    if (event__mode != EM__REPLAY) {
      result = usleep(microseconds);
      if (event__mode == EM__RECORD) {
        record__event("usleep");
        store__integer(result);
      }
    } else {
      replay__event("usleep");
      retrieve__integer(&result);
      report__event("usleep");
      print__unsigned_integer(microseconds);
      print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SLEEP FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std_types___octet_string___std___length_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->octet_string.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___length_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->quad_octet_string.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___is_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->octet_string.length == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___is_not_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->octet_string.length > 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___is_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->quad_octet_string.length == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___is_not_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->quad_octet_string.length > 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___push (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[1], &chr_code)) return;;
    NODE *self = TLS_arguments[0];
    long left_start_offset = self->octet_string.offset;
    long length = self->octet_string.length;
    long end_offset = left_start_offset+length;
    long new_length = length+1;
    OCTET_DATA *data = self->octet_string.data;
    if (chr_code <= 0xff) {
      if (!data || data->size < end_offset+1 || data->length != end_offset) {
	long new_size = ALLOCATION_SIZE(2*new_length);
	OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+new_size);
	if (data) {
	  memcpy(
	    new_data->buffer,
	    data->buffer+left_start_offset,
	    length);
	}
	left_start_offset = 0;
	end_offset = length;
	new_data->size = new_size;
	data = new_data;
      }
      data->buffer[end_offset] = (uint8_t)chr_code;
      data->length = end_offset+1;
      {
        NODE *result__node = (NODE *)(create__std_types___octet_string(left_start_offset, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      QUAD_OCTET_DATA *new_data = allocate_large(sizeof(QUAD_OCTET_DATA)+new_size);
      new_data->size = new_size;
      new_data->length = new_length;
      if (data) {
	long idx;
	for (idx = 0; idx < length; ++idx) {
	  new_data->buffer[idx] = data->buffer[left_start_offset+idx];
	}
      }
      new_data->buffer[length] = chr_code;
      {
        NODE *result__node = (NODE *)(create__quad_octet_string(0, new_length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__quad_octet_string___std___push (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[1], &chr_code)) return;;
    NODE *self = TLS_arguments[0];
    long start_offset = self->quad_octet_string.offset;
    long length = self->quad_octet_string.length;
    long end_offset = start_offset+length;
    long new_length = length+1;
    QUAD_OCTET_DATA *data = self->quad_octet_string.data;
    if (!data || data->size < 4*(end_offset+1) || data->length != end_offset) {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      QUAD_OCTET_DATA *new_data = allocate_large(sizeof(QUAD_OCTET_DATA)+new_size);
      if (data) {
	memcpy(
	  new_data->buffer,
	  data->buffer+start_offset,
	  4*length);
      }
      start_offset = 0;
      end_offset = length;
      new_data->size = new_size;
      data = new_data;
    }
    data->buffer[end_offset] = chr_code;
    data->length = end_offset+1;
    {
      NODE *result__node = (NODE *)(create__quad_octet_string(start_offset, new_length, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___append (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    long left_length = left->octet_string.length;
    long new_length = left_length;
    int is_a_quad_octet_string = false;
    int i;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      if ((right)->type == quad_octet_string.type) {
	is_a_quad_octet_string = true;
      } else if ((right)->type != std_types___octet_string.type) {
	{
	  invalid_arguments();
	  return;
	}
      }
      new_length += right->octet_string.length;
    }
    if (new_length == left_length) {
      NODE *result__node = (NODE *)(left);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_length == 0 && TLS_argument_count == 2) {
      {
        NODE *result__node = (NODE *)(TLS_arguments[1]);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    long left_offset = left->octet_string.offset;
    OCTET_DATA *data = left->octet_string.data;
    if (is_a_quad_octet_string) {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      QUAD_OCTET_DATA *new_data =
	allocate_large(sizeof(QUAD_OCTET_DATA)+new_size);
      new_data->size = new_size;
      new_data->length = new_length;
      long idx;
      for (idx = 0; idx < left_length; ++idx) {
	new_data->buffer[idx] = data->buffer[left_offset+idx];
      }
      long offset = left_length;
      for (i = 1; i < TLS_argument_count; ++i) {
	NODE *right = TLS_arguments[i];
	long right_offset = right->octet_string.offset;
	long right_length = right->octet_string.length;
	if ((right)->type == quad_octet_string.type) {
	  memcpy(
	    new_data->buffer+offset,
	    right->quad_octet_string.data->buffer+right_offset,
	    4*right_length);
	} else {
	  for (idx = 0; idx < right_length; ++idx) {
	    new_data->buffer[offset+idx] =
	      right->octet_string.data->buffer[right_offset+idx];
	  }
	}
	offset += right_length;
      }
      {
        NODE *result__node = (NODE *)(create__quad_octet_string(0, new_length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      if (
	!data || data->size < left_offset+new_length ||
	data->length != left_offset+left_length
      ) {
	long new_size = ALLOCATION_SIZE(2*new_length);
	OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+new_size);
	if (data) {
	  memcpy(new_data->buffer, data->buffer+left_offset, left_length);
	}
	left_offset = 0;
	new_data->size = new_size;
	data = new_data;
      }
      long offset = left_offset+left_length;
      for (i = 1; i < TLS_argument_count; ++i) {
	NODE *right = TLS_arguments[i];
	long right_length = right->octet_string.length;
	memcpy(
	  data->buffer+offset,
	  right->octet_string.data->buffer+right->octet_string.offset,
	  right_length);
	offset += right_length;
      }
      data->length = left_offset+new_length;
      {
        NODE *result__node = (NODE *)(create__std_types___octet_string(left_offset, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__quad_octet_string___std___append (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    long left_length = left->quad_octet_string.length;
    long new_length = left_length;
    int i;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      if (
	(right)->type == std_types___octet_string.type ||
	(right)->type == quad_octet_string.type
      ) {
	new_length += right->octet_string.length;
      } else {
	{
	  invalid_arguments();
	  return;
	}
      }
    }
    if (new_length == left_length) {
      NODE *result__node = (NODE *)(left);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_length == 0 && TLS_argument_count == 2) {
      {
        NODE *result__node = (NODE *)(TLS_arguments[1]);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    long left_offset = left->quad_octet_string.offset;
    QUAD_OCTET_DATA *data = left->quad_octet_string.data;
    if (
      data->size < 4*(left_offset+new_length) ||
      data->length != left_offset+left_length
    ) {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      QUAD_OCTET_DATA *new_data =
	allocate_large(sizeof(QUAD_OCTET_DATA)+new_size);
      memcpy(new_data->buffer, data->buffer+left_offset, 4*left_length);
      left_offset = 0;
      new_data->size = new_size;
      data = new_data;
    }
    long offset = left_offset+left_length;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      long right_offset = right->octet_string.offset;
      long right_length = right->octet_string.length;
      if ((right)->type == quad_octet_string.type) {
	memcpy(
	  data->buffer+offset,
	  right->quad_octet_string.data->buffer+right_offset,
	  4*right_length);
      } else {
	long idx;
	for (idx = 0; idx < right_length; ++idx) {
	  data->buffer[offset+idx] =
	    right->octet_string.data->buffer[right_offset+idx];
	}
      }
      offset += right_length;
    }
    data->length = left_offset+new_length;
    {
      NODE *result__node = (NODE *)(create__quad_octet_string(left_offset, new_length, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___range (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    long first_idx, last_idx;
    if (!to_long(TLS_arguments[1], &first_idx)) return;
    if (!to_long(TLS_arguments[2], &last_idx)) return;
    long length = self->octet_string.length;
    if (first_idx < 0) first_idx = length+first_idx+1;
    if (last_idx < 0) last_idx = length+last_idx+1;
    if (first_idx < 1 || first_idx > length+1) {
      invalid_index(self);
      return;
    };
    if (last_idx < 0 || last_idx > length) {
      invalid_index(self);
      return;
    };
    if (first_idx > last_idx+1) {
      invalid_arguments();
      return;
    }
    if (first_idx == 1 && last_idx == length) {
      NODE *result__node = (NODE *)(self);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long new_len = last_idx-first_idx+1;
    if (new_len == 0) {
      NODE *result__node = (NODE *)((NODE *)&std___empty_string);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types___octet_string(self->octet_string.offset+first_idx-1, new_len, self->octet_string.data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___range (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    long first_idx, last_idx;
    if (!to_long(TLS_arguments[1], &first_idx)) return;;
    if (!to_long(TLS_arguments[2], &last_idx)) return;;
    long length = self->octet_string.length;
    if (first_idx < 0) first_idx = length+first_idx+1;
    if (last_idx < 0) last_idx = length+last_idx+1;
    if (first_idx < 1 || first_idx > length+1) {
      invalid_index(self);
      return;
    };
    if (last_idx < 0 || last_idx > length) {
      invalid_index(self);
      return;
    };
    if (first_idx > last_idx+1) {
      invalid_arguments();
      return;
    }
    if (first_idx == 1 && last_idx == length) {
      NODE *result__node = (NODE *)(self);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long new_len = last_idx-first_idx+1;
    if (new_len == 0) {
      NODE *result__node = (NODE *)((NODE *)&std___empty_string);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long idx;
    long offset = self->quad_octet_string.offset;
    QUAD_OCTET_DATA *data = self->quad_octet_string.data;
    for (idx = first_idx-1; idx < last_idx; ++idx) {
      if (data->buffer[offset+idx] > 0xff) {
	{
	  NODE *result__node = (NODE *)(create__quad_octet_string(offset+first_idx-1, new_len, data));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    }
    long new_size = ALLOCATION_SIZE(new_len);
    OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+new_size);
    new_data->size = new_size;
    new_data->length = new_len;
    offset += first_idx-1;
    for (idx = 0; idx < new_len; ++idx) {
      new_data->buffer[idx] = data->buffer[idx+offset];
    }
    {
      NODE *result__node = (NODE *)(create__std_types___octet_string(0, new_len, new_data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    uint8_t *buf = self->octet_string.data->buffer+self->octet_string.offset;
    long length = self->octet_string.length;
    uint32_t hash = 0x7890abcd;
    long i;
    if (length > 16) {
      for (i = length-8; i < length; ++i) {
	hash = (hash << 7) | (hash >> 25);
	hash ^= buf[i];
      }
      length = 8;
    }
    for (i = 0; i < length; ++i) {
      hash = (hash << 7) | (hash >> 25);
      hash ^= buf[i];
    }
    hash *= 234256597;
    hash ^= hash >> 26 | hash << 6;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    uint32_t *buf =
      self->quad_octet_string.data->buffer+self->quad_octet_string.offset;
    long length = self->quad_octet_string.length;
    uint32_t hash = 0x3456789a;
    long i;
    if (length > 16) {
      for (i = length-8; i < length; ++i) {
	hash = (hash << 13) | (hash >> 19);
	hash ^= buf[i];
      }
      length = 8;
    }
    for (i = 0; i < length; ++i) {
      hash = (hash << 13) | (hash >> 19);
      hash ^= buf[i];
    }
    hash *= 234256597;
    hash ^= hash >> 22 | hash << 10;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type != std_types___octet_string.type) {
      if ((TLS_arguments[1])->type == std_types___error.type) {
	{
	  invalid_arguments();
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    }
    OCTET_DATA *left_data = left->octet_string.data;
    OCTET_DATA *right_data = right->octet_string.data;
    long left_offset = left->octet_string.offset;
    long right_offset = right->octet_string.offset;
    long length = left->octet_string.length;
    if (length != right->octet_string.length) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_offset == right_offset && left_data == right_data) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long i;
    for (i = 0; i < length; ++i) {
      if (left_data->buffer[left_offset+i] != right_data->buffer[right_offset+i]) {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    if (left_offset == right_offset) {
      // join the two versions of the string data to simplify future comparisons
      join_nodes(&left->octet_string.data, &right->octet_string.data);
    }
    {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type != quad_octet_string.type) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    QUAD_OCTET_DATA *left_data = left->quad_octet_string.data;
    QUAD_OCTET_DATA *right_data = right->quad_octet_string.data;
    long left_offset = left->quad_octet_string.offset;
    long right_offset = right->quad_octet_string.offset;
    long length = left->quad_octet_string.length;
    if (length != right->quad_octet_string.length) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_offset == right_offset && left_data == right_data) {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long i;
    for (i = 0; i < length; ++i) {
      if (left_data->buffer[left_offset+i] != right_data->buffer[right_offset+i]) {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    if (left_offset == right_offset) {
      // join the two versions of the string data to simplify future comparisons
      join_nodes(&left->quad_octet_string.data, &right->quad_octet_string.data);
    }
    {
      NODE *result__node = (NODE *)(&std_types___true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type == std_types___octet_string.type) {
      OCTET_DATA *left_data = left->octet_string.data;
      OCTET_DATA *right_data = right->octet_string.data;
      long left_offset = left->octet_string.offset;
      long right_offset = right->octet_string.offset;
      long left_length = left->octet_string.length;
      long right_length = right->octet_string.length;
      if (left_offset == right_offset && left_length == right_length && left_data == right_data)
	{
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint8_t left_chr = left_data->buffer[left_offset+i];
	uint8_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types___true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      if (left_offset == right_offset && left_length == right_length) { // both strings are equal!
	// join the two versions of the string data to simplify future comparisons
	join_nodes(&left->octet_string.data, &right->octet_string.data);
      }
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((right)->type == quad_octet_string.type) {
      OCTET_DATA *left_data = left->octet_string.data;
      QUAD_OCTET_DATA *right_data = right->quad_octet_string.data;
      long left_offset = left->octet_string.offset;
      long right_offset = right->quad_octet_string.offset;
      long left_length = left->octet_string.length;
      long right_length = right->quad_octet_string.length;
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint32_t left_chr = left_data->buffer[left_offset+i];
	uint32_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types___true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        invalid_arguments();
        return;
      }
    }
  }

static void entry__quad_octet_string___std___less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types___false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type == std_types___octet_string.type) {
      QUAD_OCTET_DATA *left_data = left->quad_octet_string.data;
      OCTET_DATA *right_data = right->octet_string.data;
      long left_offset = left->quad_octet_string.offset;
      long right_offset = right->octet_string.offset;
      long left_length = left->quad_octet_string.length;
      long right_length = right->octet_string.length;
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint32_t left_chr = left_data->buffer[left_offset+i];
	uint32_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types___true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((right)->type == quad_octet_string.type) {
      QUAD_OCTET_DATA *left_data = left->quad_octet_string.data;
      QUAD_OCTET_DATA *right_data = right->quad_octet_string.data;
      long left_offset = left->quad_octet_string.offset;
      long right_offset = right->quad_octet_string.offset;
      long left_length = left->quad_octet_string.length;
      long right_length = right->quad_octet_string.length;
      if (left_offset == right_offset && left_length == right_length && left_data == right_data)
	{
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint32_t left_chr = left_data->buffer[left_offset+i];
	uint32_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types___true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types___false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      if (left_offset == right_offset && left_length == right_length) { // both strings are equal!
	// join the two versions of the string data to simplify future comparisons
	join_nodes(&left->octet_string.data, &right->octet_string.data);
      }
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        invalid_arguments();
        return;
      }
    }
  }

static void entry__std_types___octet_string___std___width_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->octet_string.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___width_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long width = 0;
    NODE *string = TLS_arguments[0];
    QUAD_OCTET_DATA *data = string->quad_octet_string.data;
    long offset = string->quad_octet_string.offset;
    long length = string->quad_octet_string.length;
    for (long i = 0; i < length; ++i) {
      uint32_t chr = data->buffer[offset+i];
      if (is_a_wide_character(chr)) {
	width += 2;
      } else {
	++width;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___octet_string___std___from_utf8 (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long offset = self->octet_string.offset;
    long length = self->octet_string.length;
    uint8_t *buf = self->octet_string.data->buffer+offset;
    int is_latin_1 = true;
    uint8_t chr;
    long src_idx, dest_idx;
    // check vor valid utf-8 encoding
    // the allowed maximum size is 32 bits instead of 21 bits!
    long new_length = 0;
    src_idx = 0;
    while (src_idx < length) {
      int n; // number of continuation octets
      chr = buf[src_idx++];
      if (chr >= 0x80) {
	if ((chr & 0xe0) == 0xc0) { // 2 byte code
	  if (chr & 0x3c) is_latin_1 = false; // more than 8 bits
	  n = 1;
	} else if ((chr & 0xf0) == 0xe0) { // 3 byte code
	  is_latin_1 = false;
	  n = 2;
	} else if ((chr & 0xf8) == 0xf0) { // 4 byte code
	  is_latin_1 = false;
	  n = 3;
	} else if ((chr & 0xfc) == 0xf8) { // 5 byte code
	  is_latin_1 = false;
	  n = 4;
	} else if ((chr & 0xfe) == 0xfc) { // 6 byte code
	  is_latin_1 = false;
	  n = 5;
	} else if (chr == 0xfe) { // 7 byte code
	  if (buf[src_idx] & 0x3e) {
	    invalid_arguments();
	    return;
	  } // more than 32 bits
	  is_latin_1 = false;
	  n = 6;
	} else {
	  invalid_arguments();
	  return;
	}
	if (src_idx+n > length) {
	  invalid_arguments();
	  return;
	}
	while (--n >= 0) {
	  chr = buf[src_idx++];
	  if ((chr & 0xc0) != 0x80) {
	    invalid_arguments();
	    return;
	  }
	}
      }
      ++new_length;
    }
    if (is_latin_1) {
      long new_size = ALLOCATION_SIZE(new_length);
      OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+new_size);
      data->size = new_size;
      data->length = new_length;
      src_idx = 0;
      for (dest_idx = 0; dest_idx < new_length; ++dest_idx) {
	uint8_t chr;
	chr = buf[src_idx++];
	if (chr >= 0x80) {
	  chr = ((chr & 0x1f) << 6) | (buf[src_idx++] & 0x3f);
	}
	data->buffer[dest_idx] = chr;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___octet_string(0, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      long new_size = ALLOCATION_SIZE(4*new_length);
      QUAD_OCTET_DATA *data = allocate_large(sizeof(QUAD_OCTET_DATA)+new_size);
      data->size = new_size;
      data->length = new_length;
      src_idx = 0;
      for (dest_idx = 0; dest_idx < new_length; ++dest_idx) {
	uint32_t chr;
	chr = buf[src_idx++];
	if (chr >= 0x80) {
	  int n; // number of continuation octets
	  if ((chr & 0xe0) == 0xc0) { // 2 byte code
	    chr &= 0x1f;
	    n = 1;
	  } else if ((chr & 0xf0) == 0xe0) { // 3 byte code
	    chr &= 0x0f;
	    n = 2;
	  } else if ((chr & 0xf8) == 0xf0) { // 4 byte code
	    chr &= 0x07;
	    n = 3;
	  } else if ((chr & 0xfc) == 0xf8) { // 5 byte code
	    chr &= 0x03;
	    n = 4;
	  } else if ((chr & 0xfe) == 0xfc) { // 6 byte code
	    chr &= 0x01;
	    n = 5;
	  } else { // 7 byte code
	    chr = 0;
	    n = 6;
	  }
	  while (--n >= 0) {
	    chr = (chr << 6) | (buf[src_idx++] & 0x3f);
	  }
	}
	data->buffer[dest_idx] = chr;
      }
      {
        NODE *result__node = (NODE *)(create__quad_octet_string(0, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___octet_string___std___to_utf8 (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long offset = self->octet_string.offset;
    long length = self->octet_string.length;
    long new_len = length;
    uint8_t *src = self->octet_string.data->buffer+offset;
    long i;
    for(i = 0; i < length; ++i) {
      uint8_t chr = src[i];
      if (chr >= 0x80) {
	++new_len;
      }
    }
    long size = ALLOCATION_SIZE(new_len);
    OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+size);
    data->size = size;
    data->length = new_len;
    uint8_t *dst = data->buffer;
    for(i = 0; i < length; ++i) {
      uint8_t chr = src[i];
      if (chr >= 0x80) {
	*dst++ = chr >> 6 | 0xc0;
	*dst++ = chr & 0x3f | 0x80;
      } else {
	*dst++ = chr;
      }
    }
    {
      NODE *result__node = (NODE *)(create__std_types___octet_string(0, new_len, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__quad_octet_string___std___to_utf8 (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long offset = self->quad_octet_string.offset;
    long length = self->quad_octet_string.length;
    long new_len = length;
    uint32_t *src = self->quad_octet_string.data->buffer+offset;
    long i;
    for(i = 0; i < length; ++i) {
      uint32_t chr = src[i];
      if (chr >= 0x80) {
	if (chr >= 0x800) {
	  if (chr >= 0x10000) {
	    if (chr >= 0x200000) {
	      if (chr >= 0x4000000) {
		if (chr >= 0x80000000) {
		  new_len += 6;
		} else {
		  new_len += 5;
		}
	      } else {
		new_len += 4;
	      }
	    } else {
	      new_len += 3;
	    }
	  } else {
	    new_len += 2;
	  }
	} else {
	  ++new_len;
	}
      }
    }
    long size = ALLOCATION_SIZE(new_len);
    OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+size);
    data->size = size;
    data->length = new_len;
    uint8_t *dst = data->buffer;
    for(i = 0; i < length; ++i) {
      uint32_t chr = src[i];
      if (chr >= 0x80) {
	if (chr >= 0x800) {
	  if (chr >= 0x10000) {
	    if (chr >= 0x200000) {
	      if (chr >= 0x4000000) {
		if (chr >= 0x80000000) {
		  *dst++ = 0xfe;
		  *dst++ = (chr >> 30) & 0x3f | 0x80;
		  *dst++ = (chr >> 24) & 0x3f | 0x80;
		  *dst++ = (chr >> 18) & 0x3f | 0x80;
		  *dst++ = (chr >> 12) & 0x3f | 0x80;
		  *dst++ = (chr >> 6) & 0x3f | 0x80;
		  *dst++ = chr & 0x3f | 0x80;
		} else {
		  *dst++ = chr >> 30 | 0xfc0;
		  *dst++ = (chr >> 24) & 0x3f | 0x80;
		  *dst++ = (chr >> 18) & 0x3f | 0x80;
		  *dst++ = (chr >> 12) & 0x3f | 0x80;
		  *dst++ = (chr >> 6) & 0x3f | 0x80;
		  *dst++ = chr & 0x3f | 0x80;
		}
	      } else {
		*dst++ = chr >> 24 | 0xf8;
		*dst++ = (chr >> 18) & 0x3f | 0x80;
		*dst++ = (chr >> 12) & 0x3f | 0x80;
		*dst++ = (chr >> 6) & 0x3f | 0x80;
		*dst++ = chr & 0x3f | 0x80;
	      }
	    } else {
	      *dst++ = chr >> 18 | 0xf0;
	      *dst++ = (chr >> 12) & 0x3f | 0x80;
	      *dst++ = (chr >> 6) & 0x3f | 0x80;
	      *dst++ = chr & 0x3f | 0x80;
	    }
	  } else {
	    *dst++ = chr >> 12 | 0xe0;
	    *dst++ = (chr >> 6) & 0x3f | 0x80;
	    *dst++ = chr & 0x3f | 0x80;
	  }
	} else {
	  *dst++ = chr >> 6 | 0xc0;
	  *dst++ = chr & 0x3f | 0x80;
	}
      } else {
	*dst++ = chr;
      }
    }
    {
      NODE *result__node = (NODE *)(create__std_types___octet_string(0, new_len, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___file_descriptor___std___get_terminal_attributes (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    int fd = TLS_arguments[0]->file_descriptor.value;
    TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
    if (tcgetattr(fd, &data->termios) == 0) {
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___file_descriptor___std___set_terminal_attributes (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    int fd = TLS_arguments[0]->file_descriptor.value;
    NODE *attributes = TLS_arguments[1];
    if ((attributes)->type != ((NODE *)&std_types___terminal_attributes)->type)
      {
        invalid_arguments();
        return;
      }
    if (tcsetattr(fd, TCSANOW, &attributes->terminal_attributes.data->termios) == 0) {
      {
        NODE *result__node = (NODE *)(&std_types___true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___backspace_character_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    {
      NODE *result__node = (NODE *)(from_uchar32(termios->c_cc[VERASE]));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___terminal_attributes___std___use_canonical_mode (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ICANON));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ICANON;
      } else {
	data->termios.c_lflag &= ~ICANON;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___echo_characters (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ECHO));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ECHO;
      } else {
	data->termios.c_lflag &= ~ECHO;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___echo_new_lines (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ECHONL));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ECHONL;
      } else {
	data->termios.c_lflag &= ~ECHONL;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___enable_xon_xoff_for_input (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IXOFF));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IXOFF;
      } else {
	data->termios.c_iflag &= ~IXOFF;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___enable_xon_xoff_for_output (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IXON));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IXON;
      } else {
	data->termios.c_iflag &= ~IXON;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___restart_output_on_any_character (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IXANY));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IXANY;
      } else {
	data->termios.c_iflag &= ~IXANY;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___ignore_cr_on_input (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IGNCR));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IGNCR;
      } else {
	data->termios.c_iflag &= ~IGNCR;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___generate_signals (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ISIG));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ISIG;
      } else {
	data->termios.c_lflag &= ~ISIG;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___map_cr_to_lf_on_input (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & ICRNL));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= ICRNL;
      } else {
	data->termios.c_iflag &= ~ICRNL;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___hangup_on_close (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_oflag & HUPCL));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_oflag |= HUPCL;
      } else {
	data->termios.c_oflag &= ~HUPCL;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___map_lf_to_crlf_on_output (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_oflag & ONLCR));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_oflag |= ONLCR;
      } else {
	data->termios.c_oflag &= ~ONLCR;
      }
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___minimum_characters_for_canoncial_read (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_int(termios->c_cc[VMIN]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int value;
      if (!to_int(TLS_arguments[1], &value)) return;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      data->termios.c_cc[VMIN] = value;
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___timeout_for_reads (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_double((double)termios->c_cc[VTIME]/10));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      double value;
      if (!to_double(TLS_arguments[1], &value)) return;
      value *= 10;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      data->termios.c_cc[VTIME] = value;
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___input_speed (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      int speed = cfgetispeed(termios);
      switch (speed) {
	case B0:
	  speed = 0;
	  break;
	case B50:
	  speed = 50;
	  break;
	case B75:
	  speed = 75;
	  break;
	case B110:
	  speed = 110;
	  break;
	case B134:
	  speed = 134;
	  break;
	case B150:
	  speed = 150;
	  break;
	case B200:
	  speed = 200;
	  break;
	case B300:
	  speed = 300;
	  break;
	case B600:
	  speed = 600;
	  break;
	case B1200:
	  speed = 1200;
	  break;
	case B1800:
	  speed = 1800;
	  break;
	case B2400:
	  speed = 2400;
	  break;
	case B4800:
	  speed = 4800;
	  break;
	case B9600:
	  speed = 9600;
	  break;
	case B19200:
	  speed = 19200;
	  break;
	case B38400:
	  speed = 38400;
	  break;
	case B57600:
	  speed = 57600;
	  break;
	case B115200:
	  speed = 115200;
	  break;
	case B230400:
	  speed = 230400;
	  break;
	default:
	  speed = -1;
      }
      if (speed < 0) {
	{
	  NODE *result__node = (NODE *)(&std_types___undefined);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(from_int(speed));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else {
      int speed;
      if (!to_int(TLS_arguments[1], &speed)) return;;
      switch (speed) {
	case 0:
	  speed = B0;
	  break;
	case 50:
	  speed = B50;
	  break;
	case 75:
	  speed = B75;
	  break;
	case 110:
	  speed = B110;
	  break;
	case 134:
	  speed = B134;
	  break;
	case 150:
	  speed = B150;
	  break;
	case 200:
	  speed = B200;
	  break;
	case 300:
	  speed = B300;
	  break;
	case 600:
	  speed = B600;
	  break;
	case 1200:
	  speed = B1200;
	  break;
	case 1800:
	  speed = B1800;
	  break;
	case 2400:
	  speed = B2400;
	  break;
	case 4800:
	  speed = B4800;
	  break;
	case 9600:
	  speed = B9600;
	  break;
	case 19200:
	  speed = B19200;
	  break;
	case 38400:
	  speed = B38400;
	  break;
	case 57600:
	  speed = B57600;
	  break;
	case 115200:
	  speed = B115200;
	  break;
	case 230400:
	  speed = B230400;
	  break;
	default:
	  {
	    invalid_arguments();
	    return;
	  }
      }
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      cfsetispeed(&data->termios, speed);
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___terminal_attributes___std___output_speed (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      int speed = cfgetospeed(termios);
      switch (speed) {
	case B0:
	  speed = 0;
	  break;
	case B50:
	  speed = 50;
	  break;
	case B75:
	  speed = 75;
	  break;
	case B110:
	  speed = 110;
	  break;
	case B134:
	  speed = 134;
	  break;
	case B150:
	  speed = 150;
	  break;
	case B200:
	  speed = 200;
	  break;
	case B300:
	  speed = 300;
	  break;
	case B600:
	  speed = 600;
	  break;
	case B1200:
	  speed = 1200;
	  break;
	case B1800:
	  speed = 1800;
	  break;
	case B2400:
	  speed = 2400;
	  break;
	case B4800:
	  speed = 4800;
	  break;
	case B9600:
	  speed = 9600;
	  break;
	case B19200:
	  speed = 19200;
	  break;
	case B38400:
	  speed = 38400;
	  break;
	case B57600:
	  speed = 57600;
	  break;
	case B115200:
	  speed = 115200;
	  break;
	case B230400:
	  speed = 230400;
	  break;
	default:
	  speed = -1;
      }
      if (speed < 0) {
	{
	  NODE *result__node = (NODE *)(&std_types___undefined);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(from_int(speed));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else {
      int speed;
      if (!to_int(TLS_arguments[1], &speed)) return;;
      switch (speed) {
	case 0:
	  speed = B0;
	  break;
	case 50:
	  speed = B50;
	  break;
	case 75:
	  speed = B75;
	  break;
	case 110:
	  speed = B110;
	  break;
	case 134:
	  speed = B134;
	  break;
	case 150:
	  speed = B150;
	  break;
	case 200:
	  speed = B200;
	  break;
	case 300:
	  speed = B300;
	  break;
	case 600:
	  speed = B600;
	  break;
	case 1200:
	  speed = B1200;
	  break;
	case 1800:
	  speed = B1800;
	  break;
	case 2400:
	  speed = B2400;
	  break;
	case 4800:
	  speed = B4800;
	  break;
	case 9600:
	  speed = B9600;
	  break;
	case 19200:
	  speed = B19200;
	  break;
	case 38400:
	  speed = B38400;
	  break;
	case 57600:
	  speed = B57600;
	  break;
	case 115200:
	  speed = B115200;
	  break;
	case 230400:
	  speed = B230400;
	  break;
	default:
	  {
	    invalid_arguments();
	    return;
	  }
      }
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      cfsetospeed(&data->termios, speed);
      {
        NODE *result__node = (NODE *)(create__std_types___terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___tuple___std___new (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "Attempt to clone the tuple prototype object!", 0, 0, NULL);
      return;
    }
  }

static void entry__builtin___tuple2___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+2*sizeof(NODE *));
    data->size = 2;
    data->length = 2;
    data->items[0] = self->tuple2.node_0;
    data->items[1] = self->tuple2.node_1;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 2, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple2___std___new (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple2(TLS_arguments[1], TLS_arguments[2]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple3___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+3*sizeof(NODE *));
    data->size = 3;
    data->length = 3;
    data->items[0] = self->tuple3.node_0;
    data->items[1] = self->tuple3.node_1;
    data->items[2] = self->tuple3.node_2;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 3, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple3___std___new (void)
  {
    if (TLS_argument_count != 4) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple3(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple4___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+4*sizeof(NODE *));
    data->size = 4;
    data->length = 4;
    data->items[0] = self->tuple4.node_0;
    data->items[1] = self->tuple4.node_1;
    data->items[2] = self->tuple4.node_2;
    data->items[3] = self->tuple4.node_3;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 4, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple4___std___new (void)
  {
    if (TLS_argument_count != 5) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple4(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple5___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+5*sizeof(NODE *));
    data->size = 5;
    data->length = 5;
    data->items[0] = self->tuple5.node_0;
    data->items[1] = self->tuple5.node_1;
    data->items[2] = self->tuple5.node_2;
    data->items[3] = self->tuple5.node_3;
    data->items[4] = self->tuple5.node_4;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 5, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple5___std___new (void)
  {
    if (TLS_argument_count != 6) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple5(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple6___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+6*sizeof(NODE *));
    data->size = 6;
    data->length = 6;
    data->items[0] = self->tuple6.node_0;
    data->items[1] = self->tuple6.node_1;
    data->items[2] = self->tuple6.node_2;
    data->items[3] = self->tuple6.node_3;
    data->items[4] = self->tuple6.node_4;
    data->items[5] = self->tuple6.node_5;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 6, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple6___std___new (void)
  {
    if (TLS_argument_count != 7) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple6(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple7___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+7*sizeof(NODE *));
    data->size = 7;
    data->length = 7;
    data->items[0] = self->tuple7.node_0;
    data->items[1] = self->tuple7.node_1;
    data->items[2] = self->tuple7.node_2;
    data->items[3] = self->tuple7.node_3;
    data->items[4] = self->tuple7.node_4;
    data->items[5] = self->tuple7.node_5;
    data->items[6] = self->tuple7.node_6;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 7, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple7___std___new (void)
  {
    if (TLS_argument_count != 8) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple7(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple8___std___to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+8*sizeof(NODE *));
    data->size = 8;
    data->length = 8;
    data->items[0] = self->tuple8.node_0;
    data->items[1] = self->tuple8.node_1;
    data->items[2] = self->tuple8.node_2;
    data->items[3] = self->tuple8.node_3;
    data->items[4] = self->tuple8.node_4;
    data->items[5] = self->tuple8.node_5;
    data->items[6] = self->tuple8.node_6;
    data->items[7] = self->tuple8.node_7;
    {
      NODE *result__node = (NODE *)(create__std_types___list(0, 8, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin___tuple8___std___new (void)
  {
    if (TLS_argument_count != 9) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin___tuple8(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7], TLS_arguments[8]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___tuple (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 8) {
      too_many_arguments();
      return;
    }
    switch (TLS_argument_count) {
      case 2:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple2(TLS_arguments[0], TLS_arguments[1]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 3:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple3(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 4:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple4(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 5:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple5(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 6:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple6(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 7:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple7(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 8:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple8(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
    }
  }

static void entry__std___tuple_or_error (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 8) {
      too_many_arguments();
      return;
    }
    int i;
    for (i = 0; i < TLS_argument_count; ++i) {
      if ((TLS_arguments[i])->type == std_types___error.type)
        {
	  NODE *result__node = (NODE *)(TLS_arguments[i]);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
    }
    switch (TLS_argument_count) {
      case 2:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple2(TLS_arguments[0], TLS_arguments[1]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 3:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple3(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 4:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple4(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 5:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple5(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 6:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple6(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 7:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple7(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 8:
        {
	  NODE *result__node = (NODE *)(create__builtin___tuple8(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
    }
  }

static void entry__std___new_tuple (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *list = TLS_arguments[1];
    if ((list)->type != std_types___list.type) {
      invalid_arguments();
      return;
    }
    long offset = list->list.offset;
    long length = list->list.length;
    if (length < 2) {
      {
        create_error_message(
          module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
          "tuple_from_list - TOO FEW ITEMS", 0, 0, NULL);
        return;
      }
      return;
    } else if (length > 8) {
      {
        create_error_message(
          module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
          "tuple_from_list - TOO MANY ITEMS", 0, 0, NULL);
        return;
      }
      return;
    }
    LIST_DATA *data = list->list.data;
    NODE *tuple;
    switch (length) {
      case 2:
        tuple =
          create__builtin___tuple2(data->items[offset+0], data->items[offset+1]);
        break;
      case 3:
        tuple =
          create__builtin___tuple3(data->items[offset+0], data->items[offset+1], data->items[offset+2]);
        break;
      case 4:
        tuple =
          create__builtin___tuple4(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3]);
        break;
      case 5:
        tuple =
          create__builtin___tuple5(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4]);
        break;
      case 6:
        tuple =
          create__builtin___tuple6(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4], data->items[offset+5]);
        break;
      case 7:
        tuple =
          create__builtin___tuple7(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4], data->items[offset+5], data->items[offset+6]);
        break;
      case 8:
        tuple =
          create__builtin___tuple8(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4], data->items[offset+5], data->items[offset+6], data->items[offset+7]);
        break;
    }
    if ((prototype)->type != std_types___tuple.type) {
      // std_types___tuple is generic and cannot be used!
      tuple->attributes = prototype->attributes;
    }
    {
      NODE *result__node = (NODE *)(tuple);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character___std___to_upper_case (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(create__std_types___character(to_upper_case(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_an_upper_case_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_an_upper_case_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character___std___to_lower_case (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(create__std_types___character(to_lower_case(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_a_lower_case_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_lower_case_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___character___std___to_title_case (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(create__std_types___character(to_title_case(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_a_title_case_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_title_case_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_a_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_a_whitespace_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_whitespace_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_a_zero_width_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_zero_width_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std___is_a_wide_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_wide_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___unique_item___std___to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_c_string(my_unique_item_names[TLS_arguments[0]->unique_item.id]));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types___unique_item___std___equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *right = TLS_arguments[1];
    if ((right)->type == std_types___unique_item.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->unique_item.id == right->unique_item.id));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((right)->type == std_types___error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types___false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types___unique_item___std___hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->unique_item.id;
    hash *= 1893456841;
    hash ^= hash >> 25 | hash << 7;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std___unique_item (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *name;
    if (!to_c_string(TLS_arguments[0], &name)) return;
    long i;
    for (i = 1; i < unique_idx; ++i) {
      if (strcmp(name, my_unique_item_names[i]) == 0) {
	{
	  NODE *result__node = (NODE *)(create__std_types___unique_item(i));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	}
	goto cleanup;
      }
    }
    {
      create_error_message(
        module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
        "NO SUCH UNIQUE ITEM", 0, 0, NULL);
      return;
    }

    cleanup:

    deallocate_memory(name);
  }

static void entry__std_types___file_descriptor___std___get_terminal_size (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    int fd = TLS_arguments[0]->file_descriptor.value;
    int width, height;
    struct winsize winsize;

    if (event__mode != EM__REPLAY) {
      ioctl(fd, TIOCGWINSZ, &winsize);
      width = winsize.ws_col;
      height = winsize.ws_row;
      if (event__mode == EM__RECORD) {
        record__event("get_terminal_size");
        store__integer(width);
        store__integer(height);
      }
    } else {
      replay__event("get_terminal_size");
      retrieve__integer(&width);
      retrieve__integer(&height);
    }
    NODE *width_node = from_int(width);
    NODE *height_node = from_int(height);
    TLS_argument_count = 2;;
    TLS_arguments[0] = width_node;
    TLS_arguments[1] = height_node;
    {
      return;
    }
  }

static void entry__std___exitstatus (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int status;
    if (!to_int(TLS_arguments[0], &status)) return;
    {
      NODE *result__node = (NODE *)(from_int(WEXITSTATUS(status)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std___pselect (void)
  {
    if (TLS_argument_count < 3) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 4) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 4) {
      result_count_mismatch();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    NODE *read_descriptors = TLS_arguments[0];
    NODE *write_descriptors = TLS_arguments[1];
    NODE *except_descriptors = TLS_arguments[2];
    double timeout = 0.0;
    struct timespec timeout_data;
    struct timespec *timeout_ptr = NULL;

    if (
      TLS_argument_count > 3 &&
      (TLS_arguments[3])->type != std_types___undefined.type
    ) {
      if (!to_double(TLS_arguments[3], &timeout)) return;
      if (timeout < 0.0) timeout = 0.0;
      timeout_data.tv_sec = timeout;
      timeout_data.tv_nsec = 1000000000*(timeout-floor(timeout));
      timeout_ptr = &timeout_data;
    }
    long read_descriptor_count, write_descriptor_count, except_descriptor_count;
    fd_set read_set, write_set, except_set;
    int last_fd = 0;
    if (!initialize_fd_set(
    	&read_set, read_descriptors, &read_descriptor_count, &last_fd)) return;
    if (!initialize_fd_set(
    	&write_set, write_descriptors, &write_descriptor_count, &last_fd)) return;
    if (!initialize_fd_set(
    	&except_set, except_descriptors, &except_descriptor_count, &last_fd)) return;
    int ret;
    int caught_hup = false;
    int caught_kill = false;
    int caught_usr1 = false;
    int caught_usr2 = false;
    int chld_changed_state = false;
    int win_changed_size = false;
    if (event__mode != EM__REPLAY) {
      sigset_t set;
      sigprocmask(0, NULL, &set);
      sigdelset(&set, SIGHUP);
      sigdelset(&set, SIGUSR1);
      sigdelset(&set, SIGUSR2);
      sigdelset(&set, SIGCHLD);
      sigdelset(&set, SIGWINCH);
      retry:;
      ret = pselect(last_fd+1, &read_set, &write_set, &except_set, timeout_ptr, &set);
      if (ret < 0 && errno == EINTR) {
	if (caught_sighup) {
	  caught_sighup = false;
	  caught_hup = true;
	} else if (caught_sigusr1) {
	  caught_sigusr1 = false;
	  caught_usr1 = true;
	} else if (caught_sigusr2) {
	  caught_sigusr2 = false;
	  caught_usr2 = true;
	} else if (child_changed_state) {
	  child_changed_state = false;
	  chld_changed_state = true;
	} else if (window_changed_size) {
	  window_changed_size = false;
	  win_changed_size = true;
	} else {
	  goto retry;
	}
      }
      if (event__mode == EM__RECORD) {
        record__event("pselect");
        store__integer(ret);
        store__integer(caught_hup);
        store__integer(caught_kill);
        store__integer(caught_usr1);
        store__integer(caught_usr2);
        store__integer(chld_changed_state);
        store__integer(win_changed_size);
      }
    } else {
      replay__event("pselect");
      retrieve__integer(&ret);
      retrieve__integer(&caught_hup);
      retrieve__integer(&caught_kill);
      retrieve__integer(&caught_usr1);
      retrieve__integer(&caught_usr2);
      retrieve__integer(&chld_changed_state);
      retrieve__integer(&win_changed_size);
    }
    //   store__integer(read_count);
    //   store__integer(write_count);
    //   store__integer(except_count);
    //   store__int_array(descriptors, descriptor_count);
    if (ret == -1 && errno != EINTR) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"PSELECT FAILED", errno, 0, NULL);
      return;
    }
    NODE *signals = (NODE *)&std___empty_list;
    int read_count = 0;
    int write_count = 0;
    int except_count = 0;
    if (ret > 0) { // success
      int fd;
      for (fd = 0; fd <= last_fd; ++fd) {
	if (FD_ISSET(fd, &read_set)) ++read_count;
	if (FD_ISSET(fd, &write_set)) ++write_count;
	if (FD_ISSET(fd, &except_set)) ++except_count;
      }
      if (read_count != read_descriptor_count) {
	if (read_count == 0) {
	  read_descriptors = (NODE *)&std___empty_list;
	} else {
	  read_descriptors =
	    create_descriptor_list(
	      &read_set, read_count,
	      read_descriptors, read_descriptor_count);
	}
      }
      if (write_count != write_descriptor_count) {
	if (write_count == 0) {
	  write_descriptors = (NODE *)&std___empty_list;
	} else {
	  write_descriptors =
	    create_descriptor_list(
	      &write_set, write_count,
	      write_descriptors, write_descriptor_count);
	}
      }
      if (except_count != except_descriptor_count) {
	if (except_count == 0) {
	  except_descriptors = (NODE *)&std___empty_list;
	} else {
	  except_descriptors =
	    create_descriptor_list(
	      &except_set, except_count,
	      except_descriptors, except_descriptor_count);
	}
      }
    } else {
      read_descriptors = (NODE *)&std___empty_list;
      write_descriptors = (NODE *)&std___empty_list;
      except_descriptors = (NODE *)&std___empty_list;
    }
    int signal_count =
      caught_hup+caught_kill+caught_usr1+caught_usr2+
      chld_changed_state+win_changed_size;
    if (signal_count > 0) {
      LIST_DATA *data =
	allocate_large(sizeof(LIST_DATA)+signal_count*sizeof(NODE *));
      data->size = signal_count;
      data->length = signal_count;
      int n = 0;
      if (caught_hup) {
	data->items[n++] =
	  module__builtin.constants_base[unique__std___SIGHUP-1];
      }
      if (caught_usr1) {
	data->items[n++] =
	  module__builtin.constants_base[unique__std___SIGUSR1-1];
      }
      signals = create__std_types___list(0, signal_count, data);
      if (caught_usr2) {
	data->items[n++] =
	  module__builtin.constants_base[unique__std___SIGUSR2-1];
      }
      if (chld_changed_state) {
	data->items[n++] =
	  module__builtin.constants_base[unique__std___CHILD_CHANGED_STATE-1];
      }
      if (win_changed_size) {
	data->items[n++] =
	  module__builtin.constants_base[unique__std___WINDOW_CHANGED_SIZE-1];
      }
      signals = create__std_types___list(0, signal_count, data);
    }
    TLS_argument_count = 4;;
    TLS_arguments[0] = signals;
    TLS_arguments[1] = read_descriptors;
    TLS_arguments[2] = write_descriptors;
    TLS_arguments[3] = except_descriptors;
    {
      return;
    }
  }

static void entry__std___do_not_close (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = fcntl(fd, F_GETFD);
      } while (result == -1 && errno == EINTR);
      if (result != -1) {
	int flags = result&~FD_CLOEXEC;
	do {
	  result = fcntl(fd, F_SETFD, flags);
	} while (result == -1 && errno == EINTR);
      }
      if (event__mode == EM__RECORD) {
        if (result == 0) {
            successful__action("do_not_close");
          } else {
            failed__action("do_not_close");
            store__integer(result);
          }
        }
      } else {
        if (replay__action("do_not_close")) {
          retrieve__integer(&result);
      } else {
          result = 0;
      }
        report__event("do_not_close");
          print__integer(fd);
          print__integer(result);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"DO_NO_CLOSE FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std___waitpid (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int status;
    int result;
    int pid;
    if (!process_id_to_int(TLS_arguments[0], &pid)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = waitpid(pid, &status, WNOHANG);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("waitpid");
        store__integer(result);
        store__integer(status);
      }
    } else {
      replay__event("waitpid");
      retrieve__integer(&result);
      retrieve__integer(&status);
      report__event("waitpid");
      print__integer(result);
      print__integer(status);
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
      "WAIT FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 2;
      TLS_arguments[0] = process_id_from_int(result);
      TLS_arguments[1] = from_int(status);
    }
  }

static void entry__std___open_tcp_client_socket (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *uri = NULL;
    int port_no;
    int result;
    int sock;
    struct hostent *server;
    struct sockaddr_in addr;
    if (!to_c_string(TLS_arguments[0], &uri)) goto cleanup;
    if (!to_int(TLS_arguments[1], &port_no)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock == -1) goto error;
      server = gethostbyname(uri);
      if (!server) goto error;
      memset(&addr, 0, sizeof(addr));
      addr.sin_family = AF_INET;
      addr.sin_port = htons(port_no);
      memcpy(&addr.sin_addr.s_addr,server->h_addr,server->h_length);
      do {
	result = connect(sock, (const struct sockaddr *)&addr, sizeof(addr));
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("open_tcp_client_socket");
        store__integer(sock);
      }
    } else {
      replay__event("open_tcp_client_socket");
      retrieve__integer(&sock);
      report__event("open_tcp_client_socket");
      print__c_string(uri);
      print__integer(port_no);
      print__integer(sock);
    }
    if (result == -1) {
      error:
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"OPEN_TCP_CLIENT_SOCKET FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(sock));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(uri);
  }

static void entry__std___open_tcp_server_socket (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int port_no;
    int backlog_count;
    int do_reuse = false;
    int sock;
    int result;
    struct sockaddr_in addr;
    if (!to_int(TLS_arguments[0], &port_no)) return;
    if (!to_int(TLS_arguments[1], &backlog_count)) return;
    if (TLS_argument_count == 3) {
      if (!to_bool(TLS_arguments[2], &do_reuse)) return;
    }
    if (event__mode != EM__REPLAY) {
      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock == -1) goto error;
      if (do_reuse) {
	int opt = 1;
	if (
	  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1
	) {
	  goto error;
	}
      }
      addr.sin_family = AF_INET;
      addr.sin_addr.s_addr = htonl(INADDR_ANY);
      addr.sin_port = htons(port_no);
      if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) goto error;
      if (listen(sock, backlog_count) == -1) goto error;
      if (event__mode == EM__RECORD) {
        record__event("open_tcp_server_socket");
        store__integer(sock);
      }
    } else {
      replay__event("open_tcp_server_socket");
      retrieve__integer(&sock);
      report__event("open_tcp_server_socket");
      print__integer(port_no);
      print__integer(backlog_count);
      print__integer(sock);
    }
    if (result == -1) {
      error:
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"OPEN_TCP_SERVER_SOCKET FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(sock));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___accept (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int sock;
    int result;
    int conn;
    if (!file_descriptor_to_int(TLS_arguments[0], &sock)) return;
    if (event__mode != EM__REPLAY) {
      do {
	conn = accept(sock, NULL, 0);
      } while (conn == -1 && errno == EINTR);
      if (conn == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std___IO_ERROR-1],
	  "ACCEPT FAILED", errno, 0, NULL);
      }
      if (event__mode == EM__RECORD) {
        record__event("accept");
        store__integer(conn);
      }
    } else {
      replay__event("accept");
      retrieve__integer(&conn);
      report__event("accept");
      print__integer(sock);
      print__integer(conn);
    }
    if (conn != -1) {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(conn));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std___is_listening (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int sock;
    if (!file_descriptor_to_int(TLS_arguments[0], &sock)) return;
    int result;
    int does_listen;
    socklen_t len = sizeof(does_listen);
    result = getsockopt(sock, SOL_SOCKET, SO_ACCEPTCONN, &does_listen, &len);
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETSOCKOPT FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_bool(does_listen ? true : false));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std___get_first_mac_address (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    #ifndef __CYGWIN__
      struct ifaddrs *addrs, *ifa;
      getifaddrs(&addrs);
      for (ifa = addrs; ifa != NULL; ifa = ifa->ifa_next) {
	if (ifa->ifa_addr == NULL) continue;
	if (ifa->ifa_addr->sa_family != AF_PACKET) continue;
	if (ifa->ifa_name[0] == 'l' && ifa->ifa_name[1] == 'o') continue;
	struct sockaddr_ll *sdl = (struct sockaddr_ll *)ifa->ifa_addr;
	NODE *result = from_latin_1_string(
	  ((struct sockaddr_ll *)ifa->ifa_addr)->sll_addr, 6);
	freeifaddrs(addrs);
	{
	  NODE *result__node = (NODE *)(result);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      freeifaddrs(addrs);
    #endif
    {
      NODE *result__node = (NODE *)(&std_types___undefined);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static FUNKY_NAMESPACE defined_namespaces[] = {
  {"builtin", 1, 0},
  {"debug", 1, 0},
  {"std", 1, 0},
  {"std_types", 1, 0}
};

static FUNKY_CONSTANT constants_table[] = {
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___array___std___dimension_count_of}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___boolean_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___boolean_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___boolean_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___boolean_array___std___bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___boolean_array___std___bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___boolean_array___std___bit_xor}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___boolean_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_boolean_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___boolean_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___boolean_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___character_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___character_array___std___equal}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___character_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_character_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___character_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int8_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int8_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int8_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int8_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___int8_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_int8_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int8_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int8_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint8_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint8_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint8_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint8_array___std___bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint8_array___std___bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint8_array___std___bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint8_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___uint8_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_uint8_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint8_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint8_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int16_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int16_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int16_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int16_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___int16_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_int16_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int16_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int16_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint16_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint16_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint16_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint16_array___std___bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint16_array___std___bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint16_array___std___bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint16_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___uint16_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_uint16_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint16_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint16_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int32_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int32_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int32_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int32_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___int32_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_int32_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int32_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int32_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint32_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint32_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint32_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint32_array___std___bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint32_array___std___bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint32_array___std___bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint32_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___uint32_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_uint32_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint32_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint32_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int64_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int64_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int64_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___int64_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___int64_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_int64_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___int64_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___int64_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint64_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint64_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint64_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint64_array___std___bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint64_array___std___bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint64_array___std___bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___uint64_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___uint64_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_uint64_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___uint64_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___uint64_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___float32_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___float32_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___float32_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___float32_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___float32_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_float32_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___float32_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___float32_array___std___range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___float64_array___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___float64_array___std___dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___float64_array___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___float64_array___std___times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___float64_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___initialized_float64_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___float64_array___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___float64_array___std___range}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___pass}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___result_count}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___true___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___false___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__c_function___std___parameter_count_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___character}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___character___std___plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___character___std___minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___character___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___character___std___less}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___to_string}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___width_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___from_unix_time}},
  {FLT_C_FUNCTION, 6, {.func = entry__std___date_and_time}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___year_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___month_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___day_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___day_of_week_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___hour_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___minute_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___second_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___time_shift_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___date_and_time___std___seconds_since_epoch}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___date_and_time___std___plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___date_and_time___std___minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___date_and_time___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___date_and_time___std___less}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___current_time}},
  {FLT_C_FUNCTION, -1, {.func = entry__debug___string}},
  {FLT_C_FUNCTION, 1, {.func = entry__debug___write}},
  {FLT_C_FUNCTION, -1, {.func = entry__debug___dump_object}},
  {FLT_C_FUNCTION, -1, {.func = entry__debug___exit}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___error_check}},
  {FLT_C_FUNCTION, 0, {.func = entry__debug___total_garbage_collections}},
  {FLT_UNIQUE, 0, {.str_8 = "std::IO_ERROR"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::RUNTIME_ERROR"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::APPLICATION_ERROR"}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error___std___error_category_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error___std___error_message_text_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error___std___error_details_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error___std___errno_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error___std___failed_attribute_of}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___error}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___exec}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___create_process}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___function___std___parameter_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___list___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___list}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___is_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___is_not_empty}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___list___std___push}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___drop}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___pop}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___peek}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___list___std___append}},
  {FLT_C_FUNCTION, 3, {.func = entry__std_types___list___std___range}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___list___std___spread}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___negate}},
  {FLT_C_FUNCTION, 1, {.func = entry__negative_integer___std___negate}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___negate}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___times}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___times}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__negative_integer___std___to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___floor}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___ceil}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___round}},
  {FLT_C_FUNCTION, 1, {.func = entry__negative_integer___std___to_string}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___to_string}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___to_string}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___over}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___over}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___div}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___div}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___mod}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___mod}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__negative_integer___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___ln}},
  {FLT_C_FUNCTION, 1, {.func = entry__negative_integer___std___ln}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___ln}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___exp}},
  {FLT_C_FUNCTION, 1, {.func = entry__negative_integer___std___exp}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___real___std___exp}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___real}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___sqrt}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___pow}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___positive_integer___std___exit}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___real___std___plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___real___std___minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___real___std___times}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___real___std___over}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___real___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___less}},
  {FLT_C_FUNCTION, 2, {.func = entry__negative_integer___std___less}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___real___std___less}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___shift_left}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___shift_right}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___positive_integer___std___bit_xor}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___sin}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___cos}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___tan}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___asin}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___acos}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___atan}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___file_type___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_type___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___file_type}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_type___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___file_descriptor___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_descriptor___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___file_descriptor}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_descriptor___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___shutdown_type___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___shutdown_type___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___shutdown_type}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___shutdown_type___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___device_id___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___device_id___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___device_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___device_id___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___directory___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___directory___std___hash}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___group_id___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___group_id___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___group_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___group_id___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___inode_number___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___inode_number___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___inode_number}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___inode_number___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___process_id___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___process_id___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___process_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___process_id___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___user_id___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___user_id___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___user_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___user_id___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___error_number___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error_number___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___error_number}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___error_number___std___to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___access}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___chdir}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___chmod}},
  {FLT_C_FUNCTION, 3, {.func = entry__std___chown}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___chroot}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_descriptor___std___close}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___closedir}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___dup2}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___fstat}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___fsync}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getcwd}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___getenv}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getegid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___geteuid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getgid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___gethostname}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getlogin}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getpid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getppid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___getpwuid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___getsid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___getuid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___isatty}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___mkdir}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___mkfifo}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___open}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___opendir}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___file_descriptor___std___read}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___readdir}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___realpath}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___rename}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___sethostname}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___shutdown}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___stat}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___strerror}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___wait}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___file_descriptor___std___write}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___umask}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___unlink}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___usleep}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__quad_octet_string___std___length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___is_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___is_not_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__quad_octet_string___std___is_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__quad_octet_string___std___is_not_empty}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___octet_string___std___push}},
  {FLT_C_FUNCTION, 2, {.func = entry__quad_octet_string___std___push}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___octet_string___std___append}},
  {FLT_C_FUNCTION, -1, {.func = entry__quad_octet_string___std___append}},
  {FLT_C_FUNCTION, 3, {.func = entry__std_types___octet_string___std___range}},
  {FLT_C_FUNCTION, 3, {.func = entry__quad_octet_string___std___range}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__quad_octet_string___std___hash}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___octet_string___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__quad_octet_string___std___equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___octet_string___std___less}},
  {FLT_C_FUNCTION, 2, {.func = entry__quad_octet_string___std___less}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___width_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__quad_octet_string___std___width_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___from_utf8}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___octet_string___std___to_utf8}},
  {FLT_C_FUNCTION, 1, {.func = entry__quad_octet_string___std___to_utf8}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_descriptor___std___get_terminal_attributes}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___file_descriptor___std___set_terminal_attributes}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___terminal_attributes___std___backspace_character_of}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___use_canonical_mode}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___echo_characters}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___echo_new_lines}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___enable_xon_xoff_for_input}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___enable_xon_xoff_for_output}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___restart_output_on_any_character}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___ignore_cr_on_input}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___generate_signals}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___map_cr_to_lf_on_input}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___hangup_on_close}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___map_lf_to_crlf_on_output}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___minimum_characters_for_canoncial_read}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___timeout_for_reads}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___input_speed}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___terminal_attributes___std___output_speed}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types___tuple___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple2___std___to_list}},
  {FLT_C_FUNCTION, 3, {.func = entry__builtin___tuple2___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple3___std___to_list}},
  {FLT_C_FUNCTION, 4, {.func = entry__builtin___tuple3___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple4___std___to_list}},
  {FLT_C_FUNCTION, 5, {.func = entry__builtin___tuple4___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple5___std___to_list}},
  {FLT_C_FUNCTION, 6, {.func = entry__builtin___tuple5___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple6___std___to_list}},
  {FLT_C_FUNCTION, 7, {.func = entry__builtin___tuple6___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple7___std___to_list}},
  {FLT_C_FUNCTION, 8, {.func = entry__builtin___tuple7___std___new}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin___tuple8___std___to_list}},
  {FLT_C_FUNCTION, 9, {.func = entry__builtin___tuple8___std___new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___tuple}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___tuple_or_error}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___new_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___to_upper_case}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_an_upper_case_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___to_lower_case}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_a_lower_case_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___character___std___to_title_case}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_a_title_case_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_a_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_a_whitespace_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_a_zero_width_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_a_wide_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___unique_item___std___to_string}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types___unique_item___std___equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___unique_item___std___hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___unique_item}},
  {FLT_UNIQUE, 0, {.str_8 = "std::SIGHUP"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::SIGUSR1"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::SIGUSR2"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::CHILD_CHANGED_STATE"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::WINDOW_CHANGED_SIZE"}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types___file_descriptor___std___get_terminal_size}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___exitstatus}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___pselect}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___do_not_close}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___waitpid}},
  {FLT_C_FUNCTION, 2, {.func = entry__std___open_tcp_client_socket}},
  {FLT_C_FUNCTION, -1, {.func = entry__std___open_tcp_server_socket}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___accept}},
  {FLT_C_FUNCTION, 1, {.func = entry__std___is_listening}},
  {FLT_C_FUNCTION, 0, {.func = entry__std___get_first_mac_address}}
};

static INTERNAL_METHOD std_types___array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(ARRAY)}},
  {FIM_COLLECT, {std_types___array____collect}},
  {FIM_DEBUG_STRING, {std_types___array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___array___std___dimension_count_of},
  {var_no__std___length_of, func__std_types___array___std___length_of},
  {var_no__std___new, func__std_types___array___std___new},
  {var_no__std___range, func__std_types___array___std___range}
};

static INTERNAL_METHOD std_types___boolean_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(BOOLEAN_ARRAY)}},
  {FIM_COLLECT, {std_types___boolean_array____collect}},
  {FIM_DEBUG_STRING, {std_types___boolean_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___boolean_array__attributes[] = {
  {var_no__std___bit_and, func__std_types___boolean_array___std___bit_and},
  {var_no__std___bit_or, func__std_types___boolean_array___std___bit_or},
  {var_no__std___bit_xor, func__std_types___boolean_array___std___bit_xor},
  {var_no__std___dimension_count_of, func__std_types___boolean_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___boolean_array___std___equal},
  {var_no__std___length_of, func__std_types___boolean_array___std___length_of},
  {var_no__std___new, func__std_types___boolean_array___std___new},
  {var_no__std___range, func__std_types___boolean_array___std___range}
};

static INTERNAL_METHOD std_types___character_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(CHARACTER_ARRAY)}},
  {FIM_COLLECT, {std_types___character_array____collect}},
  {FIM_DEBUG_STRING, {std_types___character_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___character_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___character_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___character_array___std___equal},
  {var_no__std___length_of, func__std_types___character_array___std___length_of},
  {var_no__std___new, func__std_types___character_array___std___new},
  {var_no__std___range, func__std_types___character_array___std___range}
};

static INTERNAL_METHOD std_types___int8_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT8_ARRAY)}},
  {FIM_COLLECT, {std_types___int8_array____collect}},
  {FIM_DEBUG_STRING, {std_types___int8_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___int8_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___int8_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___int8_array___std___equal},
  {var_no__std___length_of, func__std_types___int8_array___std___length_of},
  {var_no__std___new, func__std_types___int8_array___std___new},
  {var_no__std___range, func__std_types___int8_array___std___range},
  {var_no__std___times, func__std_types___int8_array___std___times}
};

static INTERNAL_METHOD std_types___uint8_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT8_ARRAY)}},
  {FIM_COLLECT, {std_types___uint8_array____collect}},
  {FIM_DEBUG_STRING, {std_types___uint8_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___uint8_array__attributes[] = {
  {var_no__std___bit_and, func__std_types___uint8_array___std___bit_and},
  {var_no__std___bit_or, func__std_types___uint8_array___std___bit_or},
  {var_no__std___bit_xor, func__std_types___uint8_array___std___bit_xor},
  {var_no__std___dimension_count_of, func__std_types___uint8_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___uint8_array___std___equal},
  {var_no__std___length_of, func__std_types___uint8_array___std___length_of},
  {var_no__std___new, func__std_types___uint8_array___std___new},
  {var_no__std___range, func__std_types___uint8_array___std___range},
  {var_no__std___times, func__std_types___uint8_array___std___times}
};

static INTERNAL_METHOD std_types___int16_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT16_ARRAY)}},
  {FIM_COLLECT, {std_types___int16_array____collect}},
  {FIM_DEBUG_STRING, {std_types___int16_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___int16_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___int16_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___int16_array___std___equal},
  {var_no__std___length_of, func__std_types___int16_array___std___length_of},
  {var_no__std___new, func__std_types___int16_array___std___new},
  {var_no__std___range, func__std_types___int16_array___std___range},
  {var_no__std___times, func__std_types___int16_array___std___times}
};

static INTERNAL_METHOD std_types___uint16_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT16_ARRAY)}},
  {FIM_COLLECT, {std_types___uint16_array____collect}},
  {FIM_DEBUG_STRING, {std_types___uint16_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___uint16_array__attributes[] = {
  {var_no__std___bit_and, func__std_types___uint16_array___std___bit_and},
  {var_no__std___bit_or, func__std_types___uint16_array___std___bit_or},
  {var_no__std___bit_xor, func__std_types___uint16_array___std___bit_xor},
  {var_no__std___dimension_count_of, func__std_types___uint16_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___uint16_array___std___equal},
  {var_no__std___length_of, func__std_types___uint16_array___std___length_of},
  {var_no__std___new, func__std_types___uint16_array___std___new},
  {var_no__std___range, func__std_types___uint16_array___std___range},
  {var_no__std___times, func__std_types___uint16_array___std___times}
};

static INTERNAL_METHOD std_types___int32_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT32_ARRAY)}},
  {FIM_COLLECT, {std_types___int32_array____collect}},
  {FIM_DEBUG_STRING, {std_types___int32_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___int32_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___int32_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___int32_array___std___equal},
  {var_no__std___length_of, func__std_types___int32_array___std___length_of},
  {var_no__std___new, func__std_types___int32_array___std___new},
  {var_no__std___range, func__std_types___int32_array___std___range},
  {var_no__std___times, func__std_types___int32_array___std___times}
};

static INTERNAL_METHOD std_types___uint32_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT32_ARRAY)}},
  {FIM_COLLECT, {std_types___uint32_array____collect}},
  {FIM_DEBUG_STRING, {std_types___uint32_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___uint32_array__attributes[] = {
  {var_no__std___bit_and, func__std_types___uint32_array___std___bit_and},
  {var_no__std___bit_or, func__std_types___uint32_array___std___bit_or},
  {var_no__std___bit_xor, func__std_types___uint32_array___std___bit_xor},
  {var_no__std___dimension_count_of, func__std_types___uint32_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___uint32_array___std___equal},
  {var_no__std___length_of, func__std_types___uint32_array___std___length_of},
  {var_no__std___new, func__std_types___uint32_array___std___new},
  {var_no__std___range, func__std_types___uint32_array___std___range},
  {var_no__std___times, func__std_types___uint32_array___std___times}
};

static INTERNAL_METHOD std_types___int64_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT64_ARRAY)}},
  {FIM_COLLECT, {std_types___int64_array____collect}},
  {FIM_DEBUG_STRING, {std_types___int64_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___int64_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___int64_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___int64_array___std___equal},
  {var_no__std___length_of, func__std_types___int64_array___std___length_of},
  {var_no__std___new, func__std_types___int64_array___std___new},
  {var_no__std___range, func__std_types___int64_array___std___range},
  {var_no__std___times, func__std_types___int64_array___std___times}
};

static INTERNAL_METHOD std_types___uint64_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT64_ARRAY)}},
  {FIM_COLLECT, {std_types___uint64_array____collect}},
  {FIM_DEBUG_STRING, {std_types___uint64_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___uint64_array__attributes[] = {
  {var_no__std___bit_and, func__std_types___uint64_array___std___bit_and},
  {var_no__std___bit_or, func__std_types___uint64_array___std___bit_or},
  {var_no__std___bit_xor, func__std_types___uint64_array___std___bit_xor},
  {var_no__std___dimension_count_of, func__std_types___uint64_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___uint64_array___std___equal},
  {var_no__std___length_of, func__std_types___uint64_array___std___length_of},
  {var_no__std___new, func__std_types___uint64_array___std___new},
  {var_no__std___range, func__std_types___uint64_array___std___range},
  {var_no__std___times, func__std_types___uint64_array___std___times}
};

static INTERNAL_METHOD std_types___float32_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FLOAT32_ARRAY)}},
  {FIM_COLLECT, {std_types___float32_array____collect}},
  {FIM_DEBUG_STRING, {std_types___float32_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___float32_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___float32_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___float32_array___std___equal},
  {var_no__std___length_of, func__std_types___float32_array___std___length_of},
  {var_no__std___new, func__std_types___float32_array___std___new},
  {var_no__std___range, func__std_types___float32_array___std___range},
  {var_no__std___times, func__std_types___float32_array___std___times}
};

static INTERNAL_METHOD std_types___float64_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FLOAT64_ARRAY)}},
  {FIM_COLLECT, {std_types___float64_array____collect}},
  {FIM_DEBUG_STRING, {std_types___float64_array____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___float64_array__attributes[] = {
  {var_no__std___dimension_count_of, func__std_types___float64_array___std___dimension_count_of},
  {var_no__std___equal, func__std_types___float64_array___std___equal},
  {var_no__std___length_of, func__std_types___float64_array___std___length_of},
  {var_no__std___new, func__std_types___float64_array___std___new},
  {var_no__std___range, func__std_types___float64_array___std___range},
  {var_no__std___times, func__std_types___float64_array___std___times}
};

static INTERNAL_METHOD std_types___true__internal_methods[] = {
  {FIM_TO_BOOL, {std_types___true____to_bool}},
  {FIM_DEBUG_STRING, {std_types___true____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___true__attributes[] = {
  {var_no__std___equal, func__std_types___true___std___equal}
};

static INTERNAL_METHOD std_types___false__internal_methods[] = {
  {FIM_TO_BOOL, {std_types___false____to_bool}},
  {FIM_DEBUG_STRING, {std_types___false____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___false__attributes[] = {
  {var_no__std___equal, func__std_types___false___std___equal}
};

static INTERNAL_METHOD c_function__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(C_FUNCTION)}},
  {FIM_COLLECT, {c_function____collect}},
  {FIM_DEBUG_STRING, {c_function____debug_string}}
};

static ATTRIBUTE_DEFINITION c_function__attributes[] = {
  {var_no__std___parameter_count_of, func__c_function___std___parameter_count_of}
};

static INTERNAL_METHOD std_types___character__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(CHARACTER)}},
  {FIM_COLLECT, {std_types___character____collect}},
  {FIM_TO_UCHAR32, {std_types___character____to_uchar32}},
  {FIM_DEBUG_STRING, {std_types___character____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___character__attributes[] = {
  {var_no__std___equal, func__std_types___character___std___equal},
  {var_no__std___hash, func__std_types___character___std___hash},
  {var_no__std___less, func__std_types___character___std___less},
  {var_no__std___minus, func__std_types___character___std___minus},
  {var_no__std___plus, func__std_types___character___std___plus},
  {var_no__std___to_integer, func__std_types___character___std___to_integer},
  {var_no__std___to_lower_case, func__std_types___character___std___to_lower_case},
  {var_no__std___to_string, func__std_types___character___std___to_string},
  {var_no__std___to_title_case, func__std_types___character___std___to_title_case},
  {var_no__std___to_upper_case, func__std_types___character___std___to_upper_case},
  {var_no__std___width_of, func__std_types___character___std___width_of}
};

static INTERNAL_METHOD std_types___date_and_time__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(DATE_AND_TIME)}},
  {FIM_COLLECT, {std_types___date_and_time____collect}},
  {FIM_DEBUG_STRING, {std_types___date_and_time____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___date_and_time__attributes[] = {
  {var_no__std___day_of, func__std_types___date_and_time___std___day_of},
  {var_no__std___day_of_week_of, func__std_types___date_and_time___std___day_of_week_of},
  {var_no__std___equal, func__std_types___date_and_time___std___equal},
  {var_no__std___hour_of, func__std_types___date_and_time___std___hour_of},
  {var_no__std___less, func__std_types___date_and_time___std___less},
  {var_no__std___minus, func__std_types___date_and_time___std___minus},
  {var_no__std___minute_of, func__std_types___date_and_time___std___minute_of},
  {var_no__std___month_of, func__std_types___date_and_time___std___month_of},
  {var_no__std___plus, func__std_types___date_and_time___std___plus},
  {var_no__std___second_of, func__std_types___date_and_time___std___second_of},
  {var_no__std___seconds_since_epoch, func__std_types___date_and_time___std___seconds_since_epoch},
  {var_no__std___time_shift_of, func__std_types___date_and_time___std___time_shift_of},
  {var_no__std___year_of, func__std_types___date_and_time___std___year_of}
};

static INTERNAL_METHOD std_types___error__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(ERROR)}},
  {FIM_COLLECT, {std_types___error____collect}},
  {FIM_DEBUG_STRING, {std_types___error____debug_string}},
  {FIM_TO_INT8, {propagate_error}},
  {FIM_TO_INT16, {propagate_error}},
  {FIM_TO_INT32, {propagate_error}},
  {FIM_TO_INT64, {propagate_error}},
  {FIM_TO_UINT8, {propagate_error}},
  {FIM_TO_UINT16, {propagate_error}},
  {FIM_TO_UINT32, {propagate_error}},
  {FIM_TO_UINT64, {propagate_error}},
  {FIM_TO_UCHAR32, {propagate_error}},
  {FIM_TO_BOOL, {propagate_error}},
  {FIM_TO_INT, {propagate_error}},
  {FIM_TO_UINT, {propagate_error}},
  {FIM_TO_LONG, {propagate_error}},
  {FIM_TO_ULONG, {propagate_error}},
  {FIM_TO_DOUBLE, {propagate_error}},
  {FIM_TO_C_STRING, {propagate_error}},
  {FIM_TO_OCTETS, {propagate_error}},
  {FIM_GET_ITEM_OF, {propagate_error}},
  {FIM_LENGTH_OF, {propagate_error}},
  {FIM_UNFOLD, {propagate_error}}
};

static ATTRIBUTE_DEFINITION std_types___error__attributes[] = {
  {var_no__std___errno_of, func__std_types___error___std___errno_of},
  {var_no__std___error_category_of, func__std_types___error___std___error_category_of},
  {var_no__std___error_details_of, func__std_types___error___std___error_details_of},
  {var_no__std___error_message_text_of, func__std_types___error___std___error_message_text_of},
  {var_no__std___failed_attribute_of, func__std_types___error___std___failed_attribute_of}
};

static INTERNAL_METHOD std_types___object__internal_methods[] = {
  {FIM_TO_INT8, {std_types___object____to_int8}},
  {FIM_TO_INT16, {std_types___object____to_int16}},
  {FIM_TO_INT32, {std_types___object____to_int32}},
  {FIM_TO_INT64, {std_types___object____to_int64}},
  {FIM_TO_UINT8, {std_types___object____to_uint8}},
  {FIM_TO_UINT16, {std_types___object____to_uint16}},
  {FIM_TO_UINT32, {std_types___object____to_uint32}},
  {FIM_TO_UINT64, {std_types___object____to_uint64}},
  {FIM_TO_UCHAR32, {std_types___object____to_uchar32}},
  {FIM_TO_BOOL, {std_types___object____to_bool}},
  {FIM_TO_INT, {std_types___object____to_int}},
  {FIM_TO_UINT, {std_types___object____to_uint}},
  {FIM_TO_LONG, {std_types___object____to_long}},
  {FIM_TO_ULONG, {std_types___object____to_ulong}},
  {FIM_TO_DOUBLE, {std_types___object____to_double}},
  {FIM_TO_C_STRING, {std_types___object____to_c_string}},
  {FIM_TO_OCTETS, {std_types___object____to_octets}},
  {FIM_GET_ITEM_OF, {std_types___object____get_item_of}},
  {FIM_LENGTH_OF, {std_types___object____length_of}},
  {FIM_UNFOLD, {std_types___object____unfold}},
  {FIM_COLLECT, {std_types___object____collect}},
  {FIM_DEBUG_STRING, {std_types___object____debug_string}}
};

static INTERNAL_METHOD std_types___undefined__internal_methods[] = {
  {FIM_TO_INT8, {std_types___undefined____to_int8}},
  {FIM_TO_INT16, {std_types___undefined____to_int16}},
  {FIM_TO_INT32, {std_types___undefined____to_int32}},
  {FIM_TO_INT64, {std_types___undefined____to_int64}},
  {FIM_TO_UINT8, {std_types___undefined____to_uint8}},
  {FIM_TO_UINT16, {std_types___undefined____to_uint16}},
  {FIM_TO_UINT32, {std_types___undefined____to_uint32}},
  {FIM_TO_UINT64, {std_types___undefined____to_uint64}},
  {FIM_TO_UCHAR32, {std_types___undefined____to_uchar32}},
  {FIM_TO_BOOL, {std_types___undefined____to_bool}},
  {FIM_TO_INT, {std_types___undefined____to_int}},
  {FIM_TO_UINT, {std_types___undefined____to_uint}},
  {FIM_TO_LONG, {std_types___undefined____to_long}},
  {FIM_TO_ULONG, {std_types___undefined____to_ulong}},
  {FIM_TO_DOUBLE, {std_types___undefined____to_double}},
  {FIM_TO_C_STRING, {std_types___undefined____to_c_string}},
  {FIM_TO_OCTETS, {std_types___undefined____to_octets}},
  {FIM_GET_ITEM_OF, {std_types___undefined____get_item_of}},
  {FIM_LENGTH_OF, {std_types___undefined____length_of}},
  {FIM_UNFOLD, {std_types___undefined____unfold}},
  {FIM_COLLECT, {std_types___undefined____collect}},
  {FIM_DEBUG_STRING, {std_types___undefined____debug_string}}
};

static INTERNAL_METHOD std_types___function__internal_methods[] = {
  {FIM_DEBUG_STRING, {std_types___function____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___function__attributes[] = {
  {var_no__std___parameter_count_of, func__std_types___function___std___parameter_count_of}
};

static INTERNAL_METHOD std_types___list__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(LIST)}},
  {FIM_COLLECT, {std_types___list____collect}},
  {FIM_DEBUG_STRING, {std_types___list____debug_string}},
  {FIM_GET_ITEM_OF, {std_types___list____get_item_of}},
  {FIM_UNFOLD, {std_types___list____unfold}},
  {FIM_LENGTH_OF, {std_types___list____length_of}}
};

static ATTRIBUTE_DEFINITION std_types___list__attributes[] = {
  {var_no__std___append, func__std_types___list___std___append},
  {var_no__std___drop, func__std_types___list___std___drop},
  {var_no__std___is_empty, func__std_types___list___std___is_empty},
  {var_no__std___is_not_empty, func__std_types___list___std___is_not_empty},
  {var_no__std___length_of, func__std_types___list___std___length_of},
  {var_no__std___new, func__std_types___list___std___new},
  {var_no__std___peek, func__std_types___list___std___peek},
  {var_no__std___pop, func__std_types___list___std___pop},
  {var_no__std___push, func__std_types___list___std___push},
  {var_no__std___range, func__std_types___list___std___range},
  {var_no__std___spread, func__std_types___list___std___spread}
};

static INTERNAL_METHOD std_types___integer__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INTEGER)}},
  {FIM_COLLECT, {std_types___integer____collect}}
};

static INTERNAL_METHOD std_types___positive_integer__internal_methods[] = {
  {FIM_DEBUG_STRING, {std_types___positive_integer____debug_string}},
  {FIM_TO_DOUBLE, {std_types___positive_integer____to_double}},
  {FIM_TO_FLOAT, {std_types___positive_integer____to_float}},
  {FIM_TO_INT, {std_types___positive_integer____to_int}},
  {FIM_TO_LONG, {std_types___positive_integer____to_long}},
  {FIM_TO_UINT, {std_types___positive_integer____to_uint}},
  {FIM_TO_ULONG, {std_types___positive_integer____to_ulong}},
  {FIM_TO_INT8, {std_types___positive_integer____to_int8}},
  {FIM_TO_INT16, {std_types___positive_integer____to_int16}},
  {FIM_TO_INT32, {std_types___positive_integer____to_int32}},
  {FIM_TO_INT64, {std_types___positive_integer____to_int64}},
  {FIM_TO_UINT8, {std_types___positive_integer____to_uint8}},
  {FIM_TO_UINT16, {std_types___positive_integer____to_uint16}},
  {FIM_TO_UINT32, {std_types___positive_integer____to_uint32}},
  {FIM_TO_UINT64, {std_types___positive_integer____to_uint64}}
};

static ATTRIBUTE_DEFINITION std_types___positive_integer__attributes[] = {
  {var_no__std___bit_and, func__std_types___positive_integer___std___bit_and},
  {var_no__std___bit_or, func__std_types___positive_integer___std___bit_or},
  {var_no__std___bit_xor, func__std_types___positive_integer___std___bit_xor},
  {var_no__std___div, func__std_types___positive_integer___std___div},
  {var_no__std___equal, func__std_types___positive_integer___std___equal},
  {var_no__std___exit, func__std_types___positive_integer___std___exit},
  {var_no__std___exp, func__std_types___positive_integer___std___exp},
  {var_no__std___hash, func__std_types___positive_integer___std___hash},
  {var_no__std___less, func__std_types___positive_integer___std___less},
  {var_no__std___ln, func__std_types___positive_integer___std___ln},
  {var_no__std___minus, func__std_types___positive_integer___std___minus},
  {var_no__std___mod, func__std_types___positive_integer___std___mod},
  {var_no__std___negate, func__std_types___positive_integer___std___negate},
  {var_no__std___over, func__std_types___positive_integer___std___over},
  {var_no__std___plus, func__std_types___positive_integer___std___plus},
  {var_no__std___shift_left, func__std_types___positive_integer___std___shift_left},
  {var_no__std___shift_right, func__std_types___positive_integer___std___shift_right},
  {var_no__std___times, func__std_types___positive_integer___std___times},
  {var_no__std___to_integer, func__std_types___positive_integer___std___to_integer},
  {var_no__std___to_string, func__std_types___positive_integer___std___to_string}
};

static INTERNAL_METHOD negative_integer__internal_methods[] = {
  {FIM_DEBUG_STRING, {negative_integer____debug_string}},
  {FIM_TO_DOUBLE, {negative_integer____to_double}},
  {FIM_TO_FLOAT, {negative_integer____to_float}},
  {FIM_TO_INT, {negative_integer____to_int}},
  {FIM_TO_LONG, {negative_integer____to_long}},
  {FIM_TO_INT8, {negative_integer____to_int8}},
  {FIM_TO_INT16, {negative_integer____to_int16}},
  {FIM_TO_INT32, {negative_integer____to_int32}},
  {FIM_TO_INT64, {negative_integer____to_int64}}
};

static ATTRIBUTE_DEFINITION negative_integer__attributes[] = {
  {var_no__std___div, func__negative_integer___std___div},
  {var_no__std___equal, func__negative_integer___std___equal},
  {var_no__std___exp, func__negative_integer___std___exp},
  {var_no__std___hash, func__negative_integer___std___hash},
  {var_no__std___less, func__negative_integer___std___less},
  {var_no__std___ln, func__negative_integer___std___ln},
  {var_no__std___minus, func__negative_integer___std___minus},
  {var_no__std___mod, func__negative_integer___std___mod},
  {var_no__std___negate, func__negative_integer___std___negate},
  {var_no__std___over, func__negative_integer___std___over},
  {var_no__std___plus, func__negative_integer___std___plus},
  {var_no__std___times, func__negative_integer___std___times},
  {var_no__std___to_integer, func__negative_integer___std___to_integer},
  {var_no__std___to_string, func__negative_integer___std___to_string}
};

static INTERNAL_METHOD std_types___real__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(REAL)}},
  {FIM_COLLECT, {std_types___real____collect}},
  {FIM_DEBUG_STRING, {std_types___real____debug_string}},
  {FIM_TO_DOUBLE, {std_types___real____to_double}},
  {FIM_TO_FLOAT, {std_types___real____to_float}}
};

static ATTRIBUTE_DEFINITION std_types___real__attributes[] = {
  {var_no__std___ceil, func__std_types___real___std___ceil},
  {var_no__std___equal, func__std_types___real___std___equal},
  {var_no__std___exp, func__std_types___real___std___exp},
  {var_no__std___floor, func__std_types___real___std___floor},
  {var_no__std___hash, func__std_types___real___std___hash},
  {var_no__std___less, func__std_types___real___std___less},
  {var_no__std___ln, func__std_types___real___std___ln},
  {var_no__std___minus, func__std_types___real___std___minus},
  {var_no__std___negate, func__std_types___real___std___negate},
  {var_no__std___over, func__std_types___real___std___over},
  {var_no__std___plus, func__std_types___real___std___plus},
  {var_no__std___round, func__std_types___real___std___round},
  {var_no__std___times, func__std_types___real___std___times},
  {var_no__std___to_integer, func__std_types___real___std___to_integer},
  {var_no__std___to_string, func__std_types___real___std___to_string}
};

static INTERNAL_METHOD std_types___file_type__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FILE_TYPE)}},
  {FIM_COLLECT, {std_types___file_type____collect}},
  {FIM_DEBUG_STRING, {std_types___file_type____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___file_type__attributes[] = {
  {var_no__std___equal, func__std_types___file_type___std___equal},
  {var_no__std___hash, func__std_types___file_type___std___hash},
  {var_no__std___to_integer, func__std_types___file_type___std___to_integer}
};

static INTERNAL_METHOD std_types___file_descriptor__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FILE_DESCRIPTOR)}},
  {FIM_COLLECT, {std_types___file_descriptor____collect}},
  {FIM_DEBUG_STRING, {std_types___file_descriptor____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___file_descriptor__attributes[] = {
  {var_no__std___close, func__std_types___file_descriptor___std___close},
  {var_no__std___equal, func__std_types___file_descriptor___std___equal},
  {var_no__std___get_terminal_attributes, func__std_types___file_descriptor___std___get_terminal_attributes},
  {var_no__std___get_terminal_size, func__std_types___file_descriptor___std___get_terminal_size},
  {var_no__std___hash, func__std_types___file_descriptor___std___hash},
  {var_no__std___read, func__std_types___file_descriptor___std___read},
  {var_no__std___set_terminal_attributes, func__std_types___file_descriptor___std___set_terminal_attributes},
  {var_no__std___to_integer, func__std_types___file_descriptor___std___to_integer},
  {var_no__std___write, func__std_types___file_descriptor___std___write}
};

static INTERNAL_METHOD std_types___shutdown_type__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(SHUTDOWN_TYPE)}},
  {FIM_COLLECT, {std_types___shutdown_type____collect}},
  {FIM_DEBUG_STRING, {std_types___shutdown_type____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___shutdown_type__attributes[] = {
  {var_no__std___equal, func__std_types___shutdown_type___std___equal},
  {var_no__std___hash, func__std_types___shutdown_type___std___hash},
  {var_no__std___to_integer, func__std_types___shutdown_type___std___to_integer}
};

static INTERNAL_METHOD std_types___device_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(DEVICE_ID)}},
  {FIM_COLLECT, {std_types___device_id____collect}},
  {FIM_DEBUG_STRING, {std_types___device_id____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___device_id__attributes[] = {
  {var_no__std___equal, func__std_types___device_id___std___equal},
  {var_no__std___hash, func__std_types___device_id___std___hash},
  {var_no__std___to_integer, func__std_types___device_id___std___to_integer}
};

static INTERNAL_METHOD std_types___directory__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(DIRECTORY)}},
  {FIM_COLLECT, {std_types___directory____collect}},
  {FIM_DEBUG_STRING, {std_types___directory____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___directory__attributes[] = {
  {var_no__std___equal, func__std_types___directory___std___equal},
  {var_no__std___hash, func__std_types___directory___std___hash}
};

static INTERNAL_METHOD std_types___group_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(GROUP_ID)}},
  {FIM_COLLECT, {std_types___group_id____collect}},
  {FIM_DEBUG_STRING, {std_types___group_id____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___group_id__attributes[] = {
  {var_no__std___equal, func__std_types___group_id___std___equal},
  {var_no__std___hash, func__std_types___group_id___std___hash},
  {var_no__std___to_integer, func__std_types___group_id___std___to_integer}
};

static INTERNAL_METHOD std_types___inode_number__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INODE_NUMBER)}},
  {FIM_COLLECT, {std_types___inode_number____collect}},
  {FIM_DEBUG_STRING, {std_types___inode_number____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___inode_number__attributes[] = {
  {var_no__std___equal, func__std_types___inode_number___std___equal},
  {var_no__std___hash, func__std_types___inode_number___std___hash},
  {var_no__std___to_integer, func__std_types___inode_number___std___to_integer}
};

static INTERNAL_METHOD std_types___process_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(PROCESS_ID)}},
  {FIM_COLLECT, {std_types___process_id____collect}},
  {FIM_DEBUG_STRING, {std_types___process_id____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___process_id__attributes[] = {
  {var_no__std___equal, func__std_types___process_id___std___equal},
  {var_no__std___hash, func__std_types___process_id___std___hash},
  {var_no__std___to_integer, func__std_types___process_id___std___to_integer}
};

static INTERNAL_METHOD std_types___user_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(USER_ID)}},
  {FIM_COLLECT, {std_types___user_id____collect}},
  {FIM_DEBUG_STRING, {std_types___user_id____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___user_id__attributes[] = {
  {var_no__std___equal, func__std_types___user_id___std___equal},
  {var_no__std___hash, func__std_types___user_id___std___hash},
  {var_no__std___to_integer, func__std_types___user_id___std___to_integer}
};

static INTERNAL_METHOD std_types___error_number__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(ERROR_NUMBER)}},
  {FIM_COLLECT, {std_types___error_number____collect}},
  {FIM_DEBUG_STRING, {std_types___error_number____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___error_number__attributes[] = {
  {var_no__std___equal, func__std_types___error_number___std___equal},
  {var_no__std___hash, func__std_types___error_number___std___hash},
  {var_no__std___to_integer, func__std_types___error_number___std___to_integer}
};

static INTERNAL_METHOD std_types___octet_string__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(OCTET_STRING)}},
  {FIM_COLLECT, {std_types___octet_string____collect}},
  {FIM_DEBUG_STRING, {std_types___octet_string____debug_string}},
  {FIM_GET_ITEM_OF, {std_types___octet_string____get_item_of}},
  {FIM_TO_C_STRING, {std_types___octet_string____to_c_string}},
  {FIM_TO_OCTETS, {std_types___octet_string____to_octets}},
  {FIM_LENGTH_OF, {std_types___octet_string____length_of}}
};

static ATTRIBUTE_DEFINITION std_types___octet_string__attributes[] = {
  {var_no__std___append, func__std_types___octet_string___std___append},
  {var_no__std___equal, func__std_types___octet_string___std___equal},
  {var_no__std___from_utf8, func__std_types___octet_string___std___from_utf8},
  {var_no__std___hash, func__std_types___octet_string___std___hash},
  {var_no__std___is_empty, func__std_types___octet_string___std___is_empty},
  {var_no__std___is_not_empty, func__std_types___octet_string___std___is_not_empty},
  {var_no__std___length_of, func__std_types___octet_string___std___length_of},
  {var_no__std___less, func__std_types___octet_string___std___less},
  {var_no__std___push, func__std_types___octet_string___std___push},
  {var_no__std___range, func__std_types___octet_string___std___range},
  {var_no__std___to_utf8, func__std_types___octet_string___std___to_utf8},
  {var_no__std___width_of, func__std_types___octet_string___std___width_of}
};

static INTERNAL_METHOD quad_octet_string__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(QUAD_OCTET_STRING)}},
  {FIM_COLLECT, {quad_octet_string____collect}},
  {FIM_DEBUG_STRING, {quad_octet_string____debug_string}},
  {FIM_GET_ITEM_OF, {quad_octet_string____get_item_of}},
  {FIM_LENGTH_OF, {quad_octet_string____length_of}}
};

static ATTRIBUTE_DEFINITION quad_octet_string__attributes[] = {
  {var_no__std___append, func__quad_octet_string___std___append},
  {var_no__std___equal, func__quad_octet_string___std___equal},
  {var_no__std___hash, func__quad_octet_string___std___hash},
  {var_no__std___is_empty, func__quad_octet_string___std___is_empty},
  {var_no__std___is_not_empty, func__quad_octet_string___std___is_not_empty},
  {var_no__std___length_of, func__quad_octet_string___std___length_of},
  {var_no__std___less, func__quad_octet_string___std___less},
  {var_no__std___push, func__quad_octet_string___std___push},
  {var_no__std___range, func__quad_octet_string___std___range},
  {var_no__std___to_utf8, func__quad_octet_string___std___to_utf8},
  {var_no__std___width_of, func__quad_octet_string___std___width_of}
};

static INTERNAL_METHOD std_types___terminal_attributes__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TERMINAL_ATTRIBUTES)}},
  {FIM_COLLECT, {std_types___terminal_attributes____collect}},
  {FIM_DEBUG_STRING, {std_types___terminal_attributes____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___terminal_attributes__attributes[] = {
  {var_no__std___backspace_character_of, func__std_types___terminal_attributes___std___backspace_character_of},
  {var_no__std___echo_characters, func__std_types___terminal_attributes___std___echo_characters},
  {var_no__std___echo_new_lines, func__std_types___terminal_attributes___std___echo_new_lines},
  {var_no__std___enable_xon_xoff_for_input, func__std_types___terminal_attributes___std___enable_xon_xoff_for_input},
  {var_no__std___enable_xon_xoff_for_output, func__std_types___terminal_attributes___std___enable_xon_xoff_for_output},
  {var_no__std___generate_signals, func__std_types___terminal_attributes___std___generate_signals},
  {var_no__std___hangup_on_close, func__std_types___terminal_attributes___std___hangup_on_close},
  {var_no__std___ignore_cr_on_input, func__std_types___terminal_attributes___std___ignore_cr_on_input},
  {var_no__std___input_speed, func__std_types___terminal_attributes___std___input_speed},
  {var_no__std___map_cr_to_lf_on_input, func__std_types___terminal_attributes___std___map_cr_to_lf_on_input},
  {var_no__std___map_lf_to_crlf_on_output, func__std_types___terminal_attributes___std___map_lf_to_crlf_on_output},
  {var_no__std___minimum_characters_for_canoncial_read, func__std_types___terminal_attributes___std___minimum_characters_for_canoncial_read},
  {var_no__std___output_speed, func__std_types___terminal_attributes___std___output_speed},
  {var_no__std___restart_output_on_any_character, func__std_types___terminal_attributes___std___restart_output_on_any_character},
  {var_no__std___timeout_for_reads, func__std_types___terminal_attributes___std___timeout_for_reads},
  {var_no__std___use_canonical_mode, func__std_types___terminal_attributes___std___use_canonical_mode}
};

static ATTRIBUTE_DEFINITION std_types___tuple__attributes[] = {
  {var_no__std___new, func__std_types___tuple___std___new}
};

static INTERNAL_METHOD builtin___tuple2__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE2)}},
  {FIM_COLLECT, {builtin___tuple2____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple2____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple2__attributes[] = {
  {var_no__std___new, func__builtin___tuple2___std___new},
  {var_no__std___to_list, func__builtin___tuple2___std___to_list}
};

static INTERNAL_METHOD builtin___tuple3__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE3)}},
  {FIM_COLLECT, {builtin___tuple3____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple3____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple3__attributes[] = {
  {var_no__std___new, func__builtin___tuple3___std___new},
  {var_no__std___to_list, func__builtin___tuple3___std___to_list}
};

static INTERNAL_METHOD builtin___tuple4__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE4)}},
  {FIM_COLLECT, {builtin___tuple4____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple4____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple4__attributes[] = {
  {var_no__std___new, func__builtin___tuple4___std___new},
  {var_no__std___to_list, func__builtin___tuple4___std___to_list}
};

static INTERNAL_METHOD builtin___tuple5__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE5)}},
  {FIM_COLLECT, {builtin___tuple5____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple5____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple5__attributes[] = {
  {var_no__std___new, func__builtin___tuple5___std___new},
  {var_no__std___to_list, func__builtin___tuple5___std___to_list}
};

static INTERNAL_METHOD builtin___tuple6__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE6)}},
  {FIM_COLLECT, {builtin___tuple6____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple6____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple6__attributes[] = {
  {var_no__std___new, func__builtin___tuple6___std___new},
  {var_no__std___to_list, func__builtin___tuple6___std___to_list}
};

static INTERNAL_METHOD builtin___tuple7__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE7)}},
  {FIM_COLLECT, {builtin___tuple7____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple7____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple7__attributes[] = {
  {var_no__std___new, func__builtin___tuple7___std___new},
  {var_no__std___to_list, func__builtin___tuple7___std___to_list}
};

static INTERNAL_METHOD builtin___tuple8__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE8)}},
  {FIM_COLLECT, {builtin___tuple8____collect}},
  {FIM_DEBUG_STRING, {builtin___tuple8____debug_string}}
};

static ATTRIBUTE_DEFINITION builtin___tuple8__attributes[] = {
  {var_no__std___new, func__builtin___tuple8___std___new},
  {var_no__std___to_list, func__builtin___tuple8___std___to_list}
};

static INTERNAL_METHOD std_types___unique_item__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UNIQUE_ITEM)}},
  {FIM_COLLECT, {std_types___unique_item____collect}},
  {FIM_DEBUG_STRING, {std_types___unique_item____debug_string}}
};

static ATTRIBUTE_DEFINITION std_types___unique_item__attributes[] = {
  {var_no__std___equal, func__std_types___unique_item___std___equal},
  {var_no__std___hash, func__std_types___unique_item___std___hash},
  {var_no__std___to_string, func__std_types___unique_item___std___to_string}
};

static FUNKY_VARIABLE variables_table[] = {
  {
    FOT_POLYMORPHIC, 0, 0,
    "new\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "plus\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "minus\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "times\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "over\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "div\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "mod\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "negate\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "floor\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "ceil\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "round\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "ln\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "exp\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "equal\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "less\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "shift_left\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "shift_right\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "bit_and\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "bit_or\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "bit_xor\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "parameter_count_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_string\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_integer\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_real\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_number\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_lower_case\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_upper_case\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_title_case\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "is_empty\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "is_not_empty\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "length_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "dimension_count_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "width_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "height_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "hash\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "push\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "pop\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "peek\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "drop\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "put\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "get\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "append\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "range\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "spread\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_list\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "exit\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "from_utf8\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "read\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "write\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "close\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "flush\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 0,
    "generic_array\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___generic_array}
  },
  {
    FOT_TYPE, 0, 4,
    "array\000std_types", std_types___array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___array__internal_methods,
    {(NODE *)&std_types___array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "array\000std", NULL,
    {.const_idx = func__std___array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_array\000std", NULL,
    {.const_idx = func__std___initialized_array}
  },
  {
    FOT_TYPE, 0, 8,
    "boolean_array\000std_types", std_types___boolean_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___boolean_array__internal_methods,
    {(NODE *)&std_types___boolean_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "boolean_array\000std", NULL,
    {.const_idx = func__std___boolean_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_boolean_array\000std", NULL,
    {.const_idx = func__std___initialized_boolean_array}
  },
  {
    FOT_TYPE, 0, 5,
    "character_array\000std_types", std_types___character_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___character_array__internal_methods,
    {(NODE *)&std_types___character_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "character_array\000std", NULL,
    {.const_idx = func__std___character_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_character_array\000std", NULL,
    {.const_idx = func__std___initialized_character_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int8_array\000std_types", std_types___int8_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___int8_array__internal_methods,
    {(NODE *)&std_types___int8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int8_array\000std", NULL,
    {.const_idx = func__std___int8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int8_array\000std", NULL,
    {.const_idx = func__std___initialized_int8_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint8_array\000std_types", std_types___uint8_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___uint8_array__internal_methods,
    {(NODE *)&std_types___uint8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint8_array\000std", NULL,
    {.const_idx = func__std___uint8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint8_array\000std", NULL,
    {.const_idx = func__std___initialized_uint8_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int16_array\000std_types", std_types___int16_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___int16_array__internal_methods,
    {(NODE *)&std_types___int16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int16_array\000std", NULL,
    {.const_idx = func__std___int16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int16_array\000std", NULL,
    {.const_idx = func__std___initialized_int16_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint16_array\000std_types", std_types___uint16_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___uint16_array__internal_methods,
    {(NODE *)&std_types___uint16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint16_array\000std", NULL,
    {.const_idx = func__std___uint16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint16_array\000std", NULL,
    {.const_idx = func__std___initialized_uint16_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int32_array\000std_types", std_types___int32_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___int32_array__internal_methods,
    {(NODE *)&std_types___int32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int32_array\000std", NULL,
    {.const_idx = func__std___int32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int32_array\000std", NULL,
    {.const_idx = func__std___initialized_int32_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint32_array\000std_types", std_types___uint32_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___uint32_array__internal_methods,
    {(NODE *)&std_types___uint32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint32_array\000std", NULL,
    {.const_idx = func__std___uint32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint32_array\000std", NULL,
    {.const_idx = func__std___initialized_uint32_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int64_array\000std_types", std_types___int64_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___int64_array__internal_methods,
    {(NODE *)&std_types___int64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int64_array\000std", NULL,
    {.const_idx = func__std___int64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int64_array\000std", NULL,
    {.const_idx = func__std___initialized_int64_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint64_array\000std_types", std_types___uint64_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___uint64_array__internal_methods,
    {(NODE *)&std_types___uint64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint64_array\000std", NULL,
    {.const_idx = func__std___uint64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint64_array\000std", NULL,
    {.const_idx = func__std___initialized_uint64_array}
  },
  {
    FOT_TYPE, 0, 6,
    "float32_array\000std_types", std_types___float32_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___float32_array__internal_methods,
    {(NODE *)&std_types___float32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "float32_array\000std", NULL,
    {.const_idx = func__std___float32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_float32_array\000std", NULL,
    {.const_idx = func__std___initialized_float32_array}
  },
  {
    FOT_TYPE, 0, 6,
    "float64_array\000std_types", std_types___float64_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types___float64_array__internal_methods,
    {(NODE *)&std_types___float64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "float64_array\000std", NULL,
    {.const_idx = func__std___float64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_float64_array\000std", NULL,
    {.const_idx = func__std___initialized_float64_array}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXIT_SUCCESS\000std", NULL,
    {"positive_integer\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EXIT_SUCCESS}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXIT_FAILURE\000std", NULL,
    {"positive_integer\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EXIT_FAILURE}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "pass\000std", NULL,
    {.const_idx = func__std___pass}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "result_count\000std", NULL,
    {.const_idx = func__std___result_count}
  },
  {
    FOT_TYPE, 0, 1,
    "true\000std_types", std_types___true__attributes,
    {"object\000std_types"},
    {.methods_count = 2}, 0,
    std_types___true__internal_methods,
    {(NODE *)&std_types___true}
  },
  {
    FOT_TYPE, 0, 1,
    "false\000std_types", std_types___false__attributes,
    {"object\000std_types"},
    {.methods_count = 2}, 0,
    std_types___false__internal_methods,
    {(NODE *)&std_types___false}
  },
  {
    FOT_TYPE, 0, 1,
    "c_function\000", c_function__attributes,
    {"function\000std_types"},
    {.methods_count = 3}, 0,
    c_function__internal_methods,
    {(NODE *)&c_function}
  },
  {
    FOT_TYPE, 0, 11,
    "character\000std_types", std_types___character__attributes,
    {"object\000std_types"},
    {.methods_count = 4}, 0,
    std_types___character__internal_methods,
    {(NODE *)&std_types___character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "character\000std", NULL,
    {.const_idx = func__std___character}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "year_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "month_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "day_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "day_of_week_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "hour_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "minute_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "second_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "time_shift_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "seconds_since_epoch\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 13,
    "date_and_time\000std_types", std_types___date_and_time__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___date_and_time__internal_methods,
    {(NODE *)&std_types___date_and_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "from_unix_time\000std", NULL,
    {.const_idx = func__std___from_unix_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "date_and_time\000std", NULL,
    {.const_idx = func__std___date_and_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "current_time\000std", NULL,
    {.const_idx = func__std___current_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "string\000debug", NULL,
    {.const_idx = func__debug___string}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "write\000debug", NULL,
    {.const_idx = func__debug___write}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "dump_object\000debug", NULL,
    {.const_idx = func__debug___dump_object}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "exit\000debug", NULL,
    {.const_idx = func__debug___exit}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "error_check\000std", NULL,
    {.const_idx = func__std___error_check}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "total_garbage_collections\000debug", NULL,
    {.const_idx = func__debug___total_garbage_collections}
  },
  {
    FOT_OBJECT, 0, 0,
    "program_name\000std", NULL,
    {"octet_string\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___program_name}
  },
  {
    FOT_OBJECT, 0, 0,
    "command_line_arguments\000std", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___command_line_arguments}
  },
  {
    FOT_OBJECT, 0, 0,
    "environment_variables\000std", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___environment_variables}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "IO_ERROR\000std", NULL,
    {.const_idx = unique__std___IO_ERROR}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "RUNTIME_ERROR\000std", NULL,
    {.const_idx = unique__std___RUNTIME_ERROR}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "APPLICATION_ERROR\000std", NULL,
    {.const_idx = unique__std___APPLICATION_ERROR}
  },
  {
    FOT_TYPE, 0, 5,
    "error\000std_types", std_types___error__attributes,
    {NULL},
    {.methods_count = 23}, 0,
    std_types___error__internal_methods,
    {(NODE *)&std_types___error}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "error_category_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "error_message_text_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "error_details_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "errno_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "failed_attribute_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "error\000std", NULL,
    {.const_idx = func__std___error}
  },
  {
    FOT_TYPE, 0, 0,
    "object\000std_types", NULL,
    {NULL},
    {.methods_count = 22}, 0,
    std_types___object__internal_methods,
    {(NODE *)&std_types___object}
  },
  {
    FOT_TYPE, 0, 0,
    "undefined\000std_types", NULL,
    {NULL},
    {.methods_count = 22}, 0,
    std_types___undefined__internal_methods,
    {(NODE *)&std_types___undefined}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "exec\000std", NULL,
    {.const_idx = func__std___exec}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "create_process\000std", NULL,
    {.const_idx = func__std___create_process}
  },
  {
    FOT_TYPE, 0, 1,
    "function\000std_types", std_types___function__attributes,
    {"object\000std_types"},
    {.methods_count = 1}, 0,
    std_types___function__internal_methods,
    {(NODE *)&std_types___function}
  },
  {
    FOT_TYPE, 0, 0,
    "tabular_function\000", NULL,
    {"function\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&tabular_function}
  },
  {
    FOT_OBJECT, 0, 0,
    "key_value_pair\000std_types", NULL,
    {"tuple2\000builtin"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___key_value_pair}
  },
  {
    FOT_TYPE, 0, 0,
    "generic_list\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___generic_list}
  },
  {
    FOT_TYPE, 0, 11,
    "list\000std_types", std_types___list__attributes,
    {"generic_list\000std_types"},
    {.methods_count = 6}, 0,
    std_types___list__internal_methods,
    {(NODE *)&std_types___list}
  },
  {
    FOT_OBJECT, 0, 0,
    "empty_list\000std", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___empty_list}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "list\000std", NULL,
    {.const_idx = func__std___list}
  },
  {
    FOT_TYPE, 0, 0,
    "number\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___number}
  },
  {
    FOT_TYPE, 0, 0,
    "integer\000std_types", NULL,
    {"number\000std_types"},
    {.methods_count = 2}, 0,
    std_types___integer__internal_methods,
    {(NODE *)&std_types___integer}
  },
  {
    FOT_TYPE, 0, 20,
    "positive_integer\000std_types", std_types___positive_integer__attributes,
    {"integer\000std_types"},
    {.methods_count = 15}, 0,
    std_types___positive_integer__internal_methods,
    {(NODE *)&std_types___positive_integer}
  },
  {
    FOT_TYPE, 0, 14,
    "negative_integer\000", negative_integer__attributes,
    {"integer\000std_types"},
    {.methods_count = 9}, 0,
    negative_integer__internal_methods,
    {(NODE *)&negative_integer}
  },
  {
    FOT_TYPE, 0, 15,
    "real\000std_types", std_types___real__attributes,
    {"number\000std_types"},
    {.methods_count = 5}, 0,
    std_types___real__internal_methods,
    {(NODE *)&std_types___real}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "real\000std", NULL,
    {.const_idx = func__std___real}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "integer\000std", NULL,
    {.const_idx = func__std___integer}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "sqrt\000std", NULL,
    {.const_idx = func__std___sqrt}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "pow\000std", NULL,
    {.const_idx = func__std___pow}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "sin\000std", NULL,
    {.const_idx = func__std___sin}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "cos\000std", NULL,
    {.const_idx = func__std___cos}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "tan\000std", NULL,
    {.const_idx = func__std___tan}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "asin\000std", NULL,
    {.const_idx = func__std___asin}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "acos\000std", NULL,
    {.const_idx = func__std___acos}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "atan\000std", NULL,
    {.const_idx = func__std___atan}
  },
  {
    FOT_TYPE, 0, 0,
    "polymorphic_function\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___polymorphic_function}
  },
  {
    FOT_TYPE, 0, 0,
    "polymorphic_function_with_setter\000std_types", NULL,
    {"polymorphic_function\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___polymorphic_function_with_setter}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "subtype_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_OBJECT, 0, 0,
    "BLOCK_DEVICE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___BLOCK_DEVICE}
  },
  {
    FOT_OBJECT, 0, 0,
    "CHARACTER_DEVICE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___CHARACTER_DEVICE}
  },
  {
    FOT_OBJECT, 0, 0,
    "DIRECTORY\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___DIRECTORY}
  },
  {
    FOT_OBJECT, 0, 0,
    "NAMED_PIPE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___NAMED_PIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SYMBOLIC_LINK\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___SYMBOLIC_LINK}
  },
  {
    FOT_OBJECT, 0, 0,
    "REGULAR_FILE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___REGULAR_FILE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SOCKET\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___SOCKET}
  },
  {
    FOT_OBJECT, 0, 0,
    "UNKNOWN_FILE_TYPE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___UNKNOWN_FILE_TYPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "STDIN_FILENO\000std", NULL,
    {"file_descriptor\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___STDIN_FILENO}
  },
  {
    FOT_OBJECT, 0, 0,
    "STDOUT_FILENO\000std", NULL,
    {"file_descriptor\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___STDOUT_FILENO}
  },
  {
    FOT_OBJECT, 0, 0,
    "STDERR_FILENO\000std", NULL,
    {"file_descriptor\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___STDERR_FILENO}
  },
  {
    FOT_OBJECT, 0, 0,
    "SHUT_RD\000std", NULL,
    {"shutdown_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___SHUT_RD}
  },
  {
    FOT_OBJECT, 0, 0,
    "SHUT_WR\000std", NULL,
    {"shutdown_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___SHUT_WR}
  },
  {
    FOT_OBJECT, 0, 0,
    "SHUT_RDWR\000std", NULL,
    {"shutdown_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___SHUT_RDWR}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOERR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOERR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPERM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EPERM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOENT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOENT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESRCH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESRCH}
  },
  {
    FOT_OBJECT, 0, 0,
    "EINTR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EINTR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EIO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EIO}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENXIO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENXIO}
  },
  {
    FOT_OBJECT, 0, 0,
    "E2BIG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___E2BIG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOEXEC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOEXEC}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADF\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADF}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECHILD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECHILD}
  },
  {
    FOT_OBJECT, 0, 0,
    "EAGAIN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EAGAIN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOMEM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOMEM}
  },
  {
    FOT_OBJECT, 0, 0,
    "EACCES\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EACCES}
  },
  {
    FOT_OBJECT, 0, 0,
    "EFAULT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EFAULT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTBLK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTBLK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBUSY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBUSY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EEXIST\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EEXIST}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXDEV\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EXDEV}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENODEV\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENODEV}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTDIR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTDIR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EISDIR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EISDIR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EINVAL\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EINVAL}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENFILE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENFILE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMFILE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EMFILE}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTTY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTTY}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETXTBSY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ETXTBSY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EFBIG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EFBIG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSPC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOSPC}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESPIPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EROFS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EROFS}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMLINK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EMLINK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPIPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDOM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EDOM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ERANGE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ERANGE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDEADLK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EDEADLK}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENAMETOOLONG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENAMETOOLONG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOLCK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOLCK}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSYS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOSYS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTEMPTY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTEMPTY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EILSEQ\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EILSEQ}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELOOP\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELOOP}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOMSG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOMSG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EIDRM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EIDRM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECHRNG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECHRNG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL2NSYNC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EL2NSYNC}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL3HLT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EL3HLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL3RST\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EL3RST}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELNRNG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELNRNG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EUNATCH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EUNATCH}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOCSI\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOCSI}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL2HLT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EL2HLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXFULL\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EXFULL}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOANO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOANO}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADRQC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADRQC}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADSLT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADSLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBFONT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBFONT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSTR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOSTR}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENODATA\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENODATA}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETIME\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ETIME}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOSR}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENONET\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENONET}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOPKG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOPKG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EREMOTE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EREMOTE}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOLINK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOLINK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EADV\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EADV}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESRMNT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESRMNT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECOMM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECOMM}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPROTO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EPROTO}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMULTIHOP\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EMULTIHOP}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDOTDOT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EDOTDOT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADMSG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADMSG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EOVERFLOW\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EOVERFLOW}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTUNIQ\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTUNIQ}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADFD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EBADFD}
  },
  {
    FOT_OBJECT, 0, 0,
    "EREMCHG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EREMCHG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBACC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELIBACC}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBBAD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELIBBAD}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBSCN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELIBSCN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBMAX\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELIBMAX}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBEXEC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ELIBEXEC}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESTRPIPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESTRPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EUSERS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EUSERS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTSOCK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTSOCK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDESTADDRREQ\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EDESTADDRREQ}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMSGSIZE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EMSGSIZE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPROTOTYPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EPROTOTYPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOPROTOOPT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOPROTOOPT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPROTONOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EPROTONOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESOCKTNOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESOCKTNOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EOPNOTSUPP\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EOPNOTSUPP}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPFNOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EPFNOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EAFNOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EAFNOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EADDRINUSE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EADDRINUSE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EADDRNOTAVAIL\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EADDRNOTAVAIL}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENETDOWN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENETDOWN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENETUNREACH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENETUNREACH}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENETRESET\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENETRESET}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECONNABORTED\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECONNABORTED}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECONNRESET\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECONNRESET}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOBUFS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOBUFS}
  },
  {
    FOT_OBJECT, 0, 0,
    "EISCONN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EISCONN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTCONN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTCONN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESHUTDOWN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESHUTDOWN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETOOMANYREFS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ETOOMANYREFS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETIMEDOUT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ETIMEDOUT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECONNREFUSED\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECONNREFUSED}
  },
  {
    FOT_OBJECT, 0, 0,
    "EHOSTDOWN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EHOSTDOWN}
  },
  {
    FOT_OBJECT, 0, 0,
    "EHOSTUNREACH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EHOSTUNREACH}
  },
  {
    FOT_OBJECT, 0, 0,
    "EALREADY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EALREADY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EINPROGRESS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EINPROGRESS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESTALE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ESTALE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDQUOT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EDQUOT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOMEDIUM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOMEDIUM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECANCELED\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ECANCELED}
  },
  {
    FOT_OBJECT, 0, 0,
    "EOWNERDEAD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___EOWNERDEAD}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTRECOVERABLE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___ENOTRECOVERABLE}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "access_time_nanoseconds_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "access_time_seconds_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "block_count_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "block_size_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "device_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "group_id_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "home_directory_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "inode_number_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "link_count_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "mode_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "modification_time_nanoseconds_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "modification_time_seconds_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "password_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "root_device_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "shell_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "size_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "status_change_time_nanoseconds_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "status_change_time_seconds_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "type_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "user_id_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "user_information_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "username_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "name_of\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_TYPE, 0, 3,
    "file_type\000std_types", std_types___file_type__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___file_type__internal_methods,
    {(NODE *)&std_types___file_type}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "file_type\000std", NULL,
    {.const_idx = func__std___file_type}
  },
  {
    FOT_TYPE, 0, 9,
    "file_descriptor\000std_types", std_types___file_descriptor__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___file_descriptor__internal_methods,
    {(NODE *)&std_types___file_descriptor}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "file_descriptor\000std", NULL,
    {.const_idx = func__std___file_descriptor}
  },
  {
    FOT_TYPE, 0, 3,
    "shutdown_type\000std_types", std_types___shutdown_type__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___shutdown_type__internal_methods,
    {(NODE *)&std_types___shutdown_type}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "shutdown_type\000std", NULL,
    {.const_idx = func__std___shutdown_type}
  },
  {
    FOT_TYPE, 0, 3,
    "device_id\000std_types", std_types___device_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___device_id__internal_methods,
    {(NODE *)&std_types___device_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "device_id\000std", NULL,
    {.const_idx = func__std___device_id}
  },
  {
    FOT_TYPE, 0, 2,
    "directory\000std_types", std_types___directory__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___directory__internal_methods,
    {(NODE *)&std_types___directory}
  },
  {
    FOT_TYPE, 0, 3,
    "group_id\000std_types", std_types___group_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___group_id__internal_methods,
    {(NODE *)&std_types___group_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "group_id\000std", NULL,
    {.const_idx = func__std___group_id}
  },
  {
    FOT_TYPE, 0, 3,
    "inode_number\000std_types", std_types___inode_number__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___inode_number__internal_methods,
    {(NODE *)&std_types___inode_number}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "inode_number\000std", NULL,
    {.const_idx = func__std___inode_number}
  },
  {
    FOT_TYPE, 0, 3,
    "process_id\000std_types", std_types___process_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___process_id__internal_methods,
    {(NODE *)&std_types___process_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "process_id\000std", NULL,
    {.const_idx = func__std___process_id}
  },
  {
    FOT_TYPE, 0, 3,
    "user_id\000std_types", std_types___user_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___user_id__internal_methods,
    {(NODE *)&std_types___user_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "user_id\000std", NULL,
    {.const_idx = func__std___user_id}
  },
  {
    FOT_TYPE, 0, 3,
    "error_number\000std_types", std_types___error_number__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___error_number__internal_methods,
    {(NODE *)&std_types___error_number}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "error_number\000std", NULL,
    {.const_idx = func__std___error_number}
  },
  {
    FOT_TYPE, 0, 0,
    "passwd\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___passwd}
  },
  {
    FOT_TYPE, 0, 0,
    "stat\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___stat}
  },
  {
    FOT_TYPE, 0, 0,
    "dirent\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___dirent}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "access\000std", NULL,
    {.const_idx = func__std___access}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chdir\000std", NULL,
    {.const_idx = func__std___chdir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chmod\000std", NULL,
    {.const_idx = func__std___chmod}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chown\000std", NULL,
    {.const_idx = func__std___chown}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chroot\000std", NULL,
    {.const_idx = func__std___chroot}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "closedir\000std", NULL,
    {.const_idx = func__std___closedir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "dup2\000std", NULL,
    {.const_idx = func__std___dup2}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "fstat\000std", NULL,
    {.const_idx = func__std___fstat}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "fsync\000std", NULL,
    {.const_idx = func__std___fsync}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getcwd\000std", NULL,
    {.const_idx = func__std___getcwd}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getenv\000std", NULL,
    {.const_idx = func__std___getenv}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getegid\000std", NULL,
    {.const_idx = func__std___getegid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "geteuid\000std", NULL,
    {.const_idx = func__std___geteuid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getgid\000std", NULL,
    {.const_idx = func__std___getgid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "gethostname\000std", NULL,
    {.const_idx = func__std___gethostname}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getlogin\000std", NULL,
    {.const_idx = func__std___getlogin}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getpid\000std", NULL,
    {.const_idx = func__std___getpid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getppid\000std", NULL,
    {.const_idx = func__std___getppid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getpwuid\000std", NULL,
    {.const_idx = func__std___getpwuid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getsid\000std", NULL,
    {.const_idx = func__std___getsid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getuid\000std", NULL,
    {.const_idx = func__std___getuid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "isatty\000std", NULL,
    {.const_idx = func__std___isatty}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "mkdir\000std", NULL,
    {.const_idx = func__std___mkdir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "mkfifo\000std", NULL,
    {.const_idx = func__std___mkfifo}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open\000std", NULL,
    {.const_idx = func__std___open}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "opendir\000std", NULL,
    {.const_idx = func__std___opendir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "readdir\000std", NULL,
    {.const_idx = func__std___readdir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "realpath\000std", NULL,
    {.const_idx = func__std___realpath}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "rename\000std", NULL,
    {.const_idx = func__std___rename}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "sethostname\000std", NULL,
    {.const_idx = func__std___sethostname}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "shutdown\000std", NULL,
    {.const_idx = func__std___shutdown}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "stat\000std", NULL,
    {.const_idx = func__std___stat}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "strerror\000std", NULL,
    {.const_idx = func__std___strerror}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "wait\000std", NULL,
    {.const_idx = func__std___wait}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "umask\000std", NULL,
    {.const_idx = func__std___umask}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "unlink\000std", NULL,
    {.const_idx = func__std___unlink}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "usleep\000std", NULL,
    {.const_idx = func__std___usleep}
  },
  {
    FOT_OBJECT, 0, 0,
    "sequence\000std_types", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___sequence}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_utf8\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 0,
    "string\000std_types", NULL,
    {"generic_list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___string}
  },
  {
    FOT_TYPE, 0, 12,
    "octet_string\000std_types", std_types___octet_string__attributes,
    {"string\000std_types"},
    {.methods_count = 7}, 0,
    std_types___octet_string__internal_methods,
    {(NODE *)&std_types___octet_string}
  },
  {
    FOT_TYPE, 0, 11,
    "quad_octet_string\000", quad_octet_string__attributes,
    {"string\000std_types"},
    {.methods_count = 5}, 0,
    quad_octet_string__internal_methods,
    {(NODE *)&quad_octet_string}
  },
  {
    FOT_OBJECT, 0, 0,
    "empty_string\000std", NULL,
    {"octet_string\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std___empty_string}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "get_terminal_attributes\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "set_terminal_attributes\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "backspace_character_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "use_canonical_mode\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "echo_characters\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "echo_new_lines\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "enable_xon_xoff_for_input\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "enable_xon_xoff_for_output\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "restart_output_on_any_character\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "ignore_cr_on_input\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "generate_signals\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "map_cr_to_lf_on_input\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "hangup_on_close\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "map_lf_to_crlf_on_output\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "minimum_characters_for_canoncial_read\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "timeout_for_reads\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "input_speed\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "output_speed\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 16,
    "terminal_attributes\000std_types", std_types___terminal_attributes__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___terminal_attributes__internal_methods,
    {(NODE *)&std_types___terminal_attributes}
  },
  {
    FOT_TYPE, 0, 1,
    "tuple\000std_types", std_types___tuple__attributes,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___tuple}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple2\000builtin", builtin___tuple2__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple2__internal_methods,
    {(NODE *)&builtin___tuple2}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple3\000builtin", builtin___tuple3__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple3__internal_methods,
    {(NODE *)&builtin___tuple3}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple4\000builtin", builtin___tuple4__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple4__internal_methods,
    {(NODE *)&builtin___tuple4}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple5\000builtin", builtin___tuple5__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple5__internal_methods,
    {(NODE *)&builtin___tuple5}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple6\000builtin", builtin___tuple6__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple6__internal_methods,
    {(NODE *)&builtin___tuple6}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple7\000builtin", builtin___tuple7__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple7__internal_methods,
    {(NODE *)&builtin___tuple7}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple8\000builtin", builtin___tuple8__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin___tuple8__internal_methods,
    {(NODE *)&builtin___tuple8}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "tuple\000std", NULL,
    {.const_idx = func__std___tuple}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "tuple_or_error\000std", NULL,
    {.const_idx = func__std___tuple_or_error}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "new_tuple\000std", NULL,
    {.const_idx = func__std___new_tuple}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_an_upper_case_letter_character\000std", NULL,
    {.const_idx = func__std___is_an_upper_case_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_lower_case_letter_character\000std", NULL,
    {.const_idx = func__std___is_a_lower_case_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_title_case_letter_character\000std", NULL,
    {.const_idx = func__std___is_a_title_case_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_letter_character\000std", NULL,
    {.const_idx = func__std___is_a_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_whitespace_character\000std", NULL,
    {.const_idx = func__std___is_a_whitespace_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_zero_width_character\000std", NULL,
    {.const_idx = func__std___is_a_zero_width_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_wide_character\000std", NULL,
    {.const_idx = func__std___is_a_wide_character}
  },
  {
    FOT_TYPE, 0, 3,
    "unique_item\000std_types", std_types___unique_item__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types___unique_item__internal_methods,
    {(NODE *)&std_types___unique_item}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "unique_item\000std", NULL,
    {.const_idx = func__std___unique_item}
  },
  {
    FOT_OBJECT, 0, 0,
    "value_range\000std_types", NULL,
    {"tuple2\000builtin"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types___value_range}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "SIGHUP\000std", NULL,
    {.const_idx = unique__std___SIGHUP}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "SIGUSR1\000std", NULL,
    {.const_idx = unique__std___SIGUSR1}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "SIGUSR2\000std", NULL,
    {.const_idx = unique__std___SIGUSR2}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "CHILD_CHANGED_STATE\000std", NULL,
    {.const_idx = unique__std___CHILD_CHANGED_STATE}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "WINDOW_CHANGED_SIZE\000std", NULL,
    {.const_idx = unique__std___WINDOW_CHANGED_SIZE}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "get_terminal_size\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "exitstatus\000std", NULL,
    {.const_idx = func__std___exitstatus}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "pselect\000std", NULL,
    {.const_idx = func__std___pselect}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "do_not_close\000std", NULL,
    {.const_idx = func__std___do_not_close}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "waitpid\000std", NULL,
    {.const_idx = func__std___waitpid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open_tcp_client_socket\000std", NULL,
    {.const_idx = func__std___open_tcp_client_socket}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open_tcp_server_socket\000std", NULL,
    {.const_idx = func__std___open_tcp_server_socket}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "accept\000std", NULL,
    {.const_idx = func__std___accept}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_listening\000std", NULL,
    {.const_idx = func__std___is_listening}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "get_first_mac_address\000std", NULL,
    {.const_idx = func__std___get_first_mac_address}
  }
};

FUNKY_MODULE module__builtin = {
  "_builtin",
  NULL,
  0, 0,
  4, 0,
  400, 437,
  NULL,
  defined_namespaces, NULL,
  constants_table, variables_table
};

BUILTIN_FUNCTION_NAME builtin_function_names[451] = {
  {std_types___generic_array____type, "std_types::generic_array/_type"},
  {std_types___array____type, "std_types::array/_type"},
  {entry__std_types___array___std___length_of, "std_types::array/length_of"},
  {entry__std_types___array___std___dimension_count_of, "std_types::array/dimension_count_of"},
  {entry__std___array, "std::array"},
  {entry__std___initialized_array, "std::initialized_array"},
  {entry__std_types___array___std___new, "std_types::array/new"},
  {entry__std_types___array___std___range, "std_types::array/range"},
  {std_types___boolean_array____type, "std_types::boolean_array/_type"},
  {entry__std_types___boolean_array___std___length_of, "std_types::boolean_array/length_of"},
  {entry__std_types___boolean_array___std___dimension_count_of, "std_types::boolean_array/dimension_count_of"},
  {entry__std_types___boolean_array___std___equal, "std_types::boolean_array/equal"},
  {entry__std_types___boolean_array___std___bit_and, "std_types::boolean_array/bit_and"},
  {entry__std_types___boolean_array___std___bit_or, "std_types::boolean_array/bit_or"},
  {entry__std_types___boolean_array___std___bit_xor, "std_types::boolean_array/bit_xor"},
  {entry__std___boolean_array, "std::boolean_array"},
  {entry__std___initialized_boolean_array, "std::initialized_boolean_array"},
  {entry__std_types___boolean_array___std___new, "std_types::boolean_array/new"},
  {entry__std_types___boolean_array___std___range, "std_types::boolean_array/range"},
  {std_types___character_array____type, "std_types::character_array/_type"},
  {entry__std_types___character_array___std___length_of, "std_types::character_array/length_of"},
  {entry__std_types___character_array___std___dimension_count_of, "std_types::character_array/dimension_count_of"},
  {entry__std_types___character_array___std___equal, "std_types::character_array/equal"},
  {entry__std___character_array, "std::character_array"},
  {entry__std___initialized_character_array, "std::initialized_character_array"},
  {entry__std_types___character_array___std___new, "std_types::character_array/new"},
  {entry__std_types___character_array___std___range, "std_types::character_array/range"},
  {std_types___int8_array____type, "std_types::int8_array/_type"},
  {entry__std_types___int8_array___std___length_of, "std_types::int8_array/length_of"},
  {entry__std_types___int8_array___std___dimension_count_of, "std_types::int8_array/dimension_count_of"},
  {entry__std_types___int8_array___std___equal, "std_types::int8_array/equal"},
  {entry__std_types___int8_array___std___times, "std_types::int8_array/times"},
  {entry__std___int8_array, "std::int8_array"},
  {entry__std___initialized_int8_array, "std::initialized_int8_array"},
  {entry__std_types___int8_array___std___new, "std_types::int8_array/new"},
  {entry__std_types___int8_array___std___range, "std_types::int8_array/range"},
  {std_types___uint8_array____type, "std_types::uint8_array/_type"},
  {entry__std_types___uint8_array___std___length_of, "std_types::uint8_array/length_of"},
  {entry__std_types___uint8_array___std___dimension_count_of, "std_types::uint8_array/dimension_count_of"},
  {entry__std_types___uint8_array___std___equal, "std_types::uint8_array/equal"},
  {entry__std_types___uint8_array___std___bit_and, "std_types::uint8_array/bit_and"},
  {entry__std_types___uint8_array___std___bit_or, "std_types::uint8_array/bit_or"},
  {entry__std_types___uint8_array___std___bit_xor, "std_types::uint8_array/bit_xor"},
  {entry__std_types___uint8_array___std___times, "std_types::uint8_array/times"},
  {entry__std___uint8_array, "std::uint8_array"},
  {entry__std___initialized_uint8_array, "std::initialized_uint8_array"},
  {entry__std_types___uint8_array___std___new, "std_types::uint8_array/new"},
  {entry__std_types___uint8_array___std___range, "std_types::uint8_array/range"},
  {std_types___int16_array____type, "std_types::int16_array/_type"},
  {entry__std_types___int16_array___std___length_of, "std_types::int16_array/length_of"},
  {entry__std_types___int16_array___std___dimension_count_of, "std_types::int16_array/dimension_count_of"},
  {entry__std_types___int16_array___std___equal, "std_types::int16_array/equal"},
  {entry__std_types___int16_array___std___times, "std_types::int16_array/times"},
  {entry__std___int16_array, "std::int16_array"},
  {entry__std___initialized_int16_array, "std::initialized_int16_array"},
  {entry__std_types___int16_array___std___new, "std_types::int16_array/new"},
  {entry__std_types___int16_array___std___range, "std_types::int16_array/range"},
  {std_types___uint16_array____type, "std_types::uint16_array/_type"},
  {entry__std_types___uint16_array___std___length_of, "std_types::uint16_array/length_of"},
  {entry__std_types___uint16_array___std___dimension_count_of, "std_types::uint16_array/dimension_count_of"},
  {entry__std_types___uint16_array___std___equal, "std_types::uint16_array/equal"},
  {entry__std_types___uint16_array___std___bit_and, "std_types::uint16_array/bit_and"},
  {entry__std_types___uint16_array___std___bit_or, "std_types::uint16_array/bit_or"},
  {entry__std_types___uint16_array___std___bit_xor, "std_types::uint16_array/bit_xor"},
  {entry__std_types___uint16_array___std___times, "std_types::uint16_array/times"},
  {entry__std___uint16_array, "std::uint16_array"},
  {entry__std___initialized_uint16_array, "std::initialized_uint16_array"},
  {entry__std_types___uint16_array___std___new, "std_types::uint16_array/new"},
  {entry__std_types___uint16_array___std___range, "std_types::uint16_array/range"},
  {std_types___int32_array____type, "std_types::int32_array/_type"},
  {entry__std_types___int32_array___std___length_of, "std_types::int32_array/length_of"},
  {entry__std_types___int32_array___std___dimension_count_of, "std_types::int32_array/dimension_count_of"},
  {entry__std_types___int32_array___std___equal, "std_types::int32_array/equal"},
  {entry__std_types___int32_array___std___times, "std_types::int32_array/times"},
  {entry__std___int32_array, "std::int32_array"},
  {entry__std___initialized_int32_array, "std::initialized_int32_array"},
  {entry__std_types___int32_array___std___new, "std_types::int32_array/new"},
  {entry__std_types___int32_array___std___range, "std_types::int32_array/range"},
  {std_types___uint32_array____type, "std_types::uint32_array/_type"},
  {entry__std_types___uint32_array___std___length_of, "std_types::uint32_array/length_of"},
  {entry__std_types___uint32_array___std___dimension_count_of, "std_types::uint32_array/dimension_count_of"},
  {entry__std_types___uint32_array___std___equal, "std_types::uint32_array/equal"},
  {entry__std_types___uint32_array___std___bit_and, "std_types::uint32_array/bit_and"},
  {entry__std_types___uint32_array___std___bit_or, "std_types::uint32_array/bit_or"},
  {entry__std_types___uint32_array___std___bit_xor, "std_types::uint32_array/bit_xor"},
  {entry__std_types___uint32_array___std___times, "std_types::uint32_array/times"},
  {entry__std___uint32_array, "std::uint32_array"},
  {entry__std___initialized_uint32_array, "std::initialized_uint32_array"},
  {entry__std_types___uint32_array___std___new, "std_types::uint32_array/new"},
  {entry__std_types___uint32_array___std___range, "std_types::uint32_array/range"},
  {std_types___int64_array____type, "std_types::int64_array/_type"},
  {entry__std_types___int64_array___std___length_of, "std_types::int64_array/length_of"},
  {entry__std_types___int64_array___std___dimension_count_of, "std_types::int64_array/dimension_count_of"},
  {entry__std_types___int64_array___std___equal, "std_types::int64_array/equal"},
  {entry__std_types___int64_array___std___times, "std_types::int64_array/times"},
  {entry__std___int64_array, "std::int64_array"},
  {entry__std___initialized_int64_array, "std::initialized_int64_array"},
  {entry__std_types___int64_array___std___new, "std_types::int64_array/new"},
  {entry__std_types___int64_array___std___range, "std_types::int64_array/range"},
  {std_types___uint64_array____type, "std_types::uint64_array/_type"},
  {entry__std_types___uint64_array___std___length_of, "std_types::uint64_array/length_of"},
  {entry__std_types___uint64_array___std___dimension_count_of, "std_types::uint64_array/dimension_count_of"},
  {entry__std_types___uint64_array___std___equal, "std_types::uint64_array/equal"},
  {entry__std_types___uint64_array___std___bit_and, "std_types::uint64_array/bit_and"},
  {entry__std_types___uint64_array___std___bit_or, "std_types::uint64_array/bit_or"},
  {entry__std_types___uint64_array___std___bit_xor, "std_types::uint64_array/bit_xor"},
  {entry__std_types___uint64_array___std___times, "std_types::uint64_array/times"},
  {entry__std___uint64_array, "std::uint64_array"},
  {entry__std___initialized_uint64_array, "std::initialized_uint64_array"},
  {entry__std_types___uint64_array___std___new, "std_types::uint64_array/new"},
  {entry__std_types___uint64_array___std___range, "std_types::uint64_array/range"},
  {std_types___float32_array____type, "std_types::float32_array/_type"},
  {entry__std_types___float32_array___std___length_of, "std_types::float32_array/length_of"},
  {entry__std_types___float32_array___std___dimension_count_of, "std_types::float32_array/dimension_count_of"},
  {entry__std_types___float32_array___std___equal, "std_types::float32_array/equal"},
  {entry__std_types___float32_array___std___times, "std_types::float32_array/times"},
  {entry__std___float32_array, "std::float32_array"},
  {entry__std___initialized_float32_array, "std::initialized_float32_array"},
  {entry__std_types___float32_array___std___new, "std_types::float32_array/new"},
  {entry__std_types___float32_array___std___range, "std_types::float32_array/range"},
  {std_types___float64_array____type, "std_types::float64_array/_type"},
  {entry__std_types___float64_array___std___length_of, "std_types::float64_array/length_of"},
  {entry__std_types___float64_array___std___dimension_count_of, "std_types::float64_array/dimension_count_of"},
  {entry__std_types___float64_array___std___equal, "std_types::float64_array/equal"},
  {entry__std_types___float64_array___std___times, "std_types::float64_array/times"},
  {entry__std___float64_array, "std::float64_array"},
  {entry__std___initialized_float64_array, "std::initialized_float64_array"},
  {entry__std_types___float64_array___std___new, "std_types::float64_array/new"},
  {entry__std_types___float64_array___std___range, "std_types::float64_array/range"},
  {entry__std___pass, "std::pass"},
  {entry__std___result_count, "std::result_count"},
  {std_types___true____type, "std_types::true/_type"},
  {entry__std_types___true___std___equal, "std_types::true/equal"},
  {std_types___false____type, "std_types::false/_type"},
  {entry__std_types___false___std___equal, "std_types::false/equal"},
  {c_function____type, "c_function/_type"},
  {entry__c_function___std___parameter_count_of, "c_function/parameter_count_of"},
  {std_types___character____type, "std_types::character/_type"},
  {entry__std___character, "std::character"},
  {entry__std_types___character___std___plus, "std_types::character/plus"},
  {entry__std_types___character___std___minus, "std_types::character/minus"},
  {entry__std_types___character___std___equal, "std_types::character/equal"},
  {entry__std_types___character___std___less, "std_types::character/less"},
  {entry__std_types___character___std___hash, "std_types::character/hash"},
  {entry__std_types___character___std___to_string, "std_types::character/to_string"},
  {entry__std_types___character___std___to_integer, "std_types::character/to_integer"},
  {entry__std_types___character___std___width_of, "std_types::character/width_of"},
  {std_types___date_and_time____type, "std_types::date_and_time/_type"},
  {entry__std___from_unix_time, "std::from_unix_time"},
  {entry__std___date_and_time, "std::date_and_time"},
  {entry__std_types___date_and_time___std___year_of, "std_types::date_and_time/year_of"},
  {entry__std_types___date_and_time___std___month_of, "std_types::date_and_time/month_of"},
  {entry__std_types___date_and_time___std___day_of, "std_types::date_and_time/day_of"},
  {entry__std_types___date_and_time___std___day_of_week_of, "std_types::date_and_time/day_of_week_of"},
  {entry__std_types___date_and_time___std___hour_of, "std_types::date_and_time/hour_of"},
  {entry__std_types___date_and_time___std___minute_of, "std_types::date_and_time/minute_of"},
  {entry__std_types___date_and_time___std___second_of, "std_types::date_and_time/second_of"},
  {entry__std_types___date_and_time___std___time_shift_of, "std_types::date_and_time/time_shift_of"},
  {entry__std_types___date_and_time___std___seconds_since_epoch, "std_types::date_and_time/seconds_since_epoch"},
  {entry__std_types___date_and_time___std___plus, "std_types::date_and_time/plus"},
  {entry__std_types___date_and_time___std___minus, "std_types::date_and_time/minus"},
  {entry__std_types___date_and_time___std___equal, "std_types::date_and_time/equal"},
  {entry__std_types___date_and_time___std___less, "std_types::date_and_time/less"},
  {entry__std___current_time, "std::current_time"},
  {entry__debug___string, "debug::string"},
  {entry__debug___write, "debug::write"},
  {entry__debug___dump_object, "debug::dump_object"},
  {entry__debug___exit, "debug::exit"},
  {entry__std___error_check, "std::error_check"},
  {entry__debug___total_garbage_collections, "debug::total_garbage_collections"},
  {std_types___error____type, "std_types::error/_type"},
  {entry__std_types___error___std___error_category_of, "std_types::error/error_category_of"},
  {entry__std_types___error___std___error_message_text_of, "std_types::error/error_message_text_of"},
  {entry__std_types___error___std___error_details_of, "std_types::error/error_details_of"},
  {entry__std_types___error___std___errno_of, "std_types::error/errno_of"},
  {entry__std_types___error___std___failed_attribute_of, "std_types::error/failed_attribute_of"},
  {entry__std___error, "std::error"},
  {entry__std___exec, "std::exec"},
  {entry__std___create_process, "std::create_process"},
  {std_types___function____type, "std_types::function/_type"},
  {tabular_function____type, "tabular_function/_type"},
  {entry__std_types___function___std___parameter_count_of, "std_types::function/parameter_count_of"},
  {std_types___generic_list____type, "std_types::generic_list/_type"},
  {std_types___list____type, "std_types::list/_type"},
  {entry__std_types___list___std___new, "std_types::list/new"},
  {entry__std___list, "std::list"},
  {entry__std_types___list___std___length_of, "std_types::list/length_of"},
  {entry__std_types___list___std___is_empty, "std_types::list/is_empty"},
  {entry__std_types___list___std___is_not_empty, "std_types::list/is_not_empty"},
  {entry__std_types___list___std___push, "std_types::list/push"},
  {entry__std_types___list___std___drop, "std_types::list/drop"},
  {entry__std_types___list___std___pop, "std_types::list/pop"},
  {entry__std_types___list___std___peek, "std_types::list/peek"},
  {entry__std_types___list___std___append, "std_types::list/append"},
  {entry__std_types___list___std___range, "std_types::list/range"},
  {entry__std_types___list___std___spread, "std_types::list/spread"},
  {std_types___number____type, "std_types::number/_type"},
  {std_types___integer____type, "std_types::integer/_type"},
  {std_types___positive_integer____type, "std_types::positive_integer/_type"},
  {negative_integer____type, "negative_integer/_type"},
  {std_types___real____type, "std_types::real/_type"},
  {entry__std_types___positive_integer___std___negate, "std_types::positive_integer/negate"},
  {entry__negative_integer___std___negate, "negative_integer/negate"},
  {entry__std_types___real___std___negate, "std_types::real/negate"},
  {entry__std_types___positive_integer___std___times, "std_types::positive_integer/times"},
  {entry__negative_integer___std___times, "negative_integer/times"},
  {entry__std_types___positive_integer___std___to_integer, "std_types::positive_integer/to_integer"},
  {entry__negative_integer___std___to_integer, "negative_integer/to_integer"},
  {entry__std_types___real___std___to_integer, "std_types::real/to_integer"},
  {entry__std_types___real___std___floor, "std_types::real/floor"},
  {entry__std_types___real___std___ceil, "std_types::real/ceil"},
  {entry__std_types___real___std___round, "std_types::real/round"},
  {entry__negative_integer___std___to_string, "negative_integer/to_string"},
  {entry__std_types___positive_integer___std___to_string, "std_types::positive_integer/to_string"},
  {entry__std_types___real___std___to_string, "std_types::real/to_string"},
  {entry__std_types___positive_integer___std___over, "std_types::positive_integer/over"},
  {entry__negative_integer___std___over, "negative_integer/over"},
  {entry__std_types___positive_integer___std___div, "std_types::positive_integer/div"},
  {entry__negative_integer___std___div, "negative_integer/div"},
  {entry__std_types___positive_integer___std___mod, "std_types::positive_integer/mod"},
  {entry__negative_integer___std___mod, "negative_integer/mod"},
  {entry__std_types___positive_integer___std___hash, "std_types::positive_integer/hash"},
  {entry__negative_integer___std___hash, "negative_integer/hash"},
  {entry__std_types___real___std___hash, "std_types::real/hash"},
  {entry__std_types___positive_integer___std___ln, "std_types::positive_integer/ln"},
  {entry__negative_integer___std___ln, "negative_integer/ln"},
  {entry__std_types___real___std___ln, "std_types::real/ln"},
  {entry__std_types___positive_integer___std___exp, "std_types::positive_integer/exp"},
  {entry__negative_integer___std___exp, "negative_integer/exp"},
  {entry__std_types___real___std___exp, "std_types::real/exp"},
  {entry__std___real, "std::real"},
  {entry__std___integer, "std::integer"},
  {entry__std___sqrt, "std::sqrt"},
  {entry__std___pow, "std::pow"},
  {entry__std_types___positive_integer___std___exit, "std_types::positive_integer/exit"},
  {entry__std_types___positive_integer___std___plus, "std_types::positive_integer/plus"},
  {entry__negative_integer___std___plus, "negative_integer/plus"},
  {entry__std_types___real___std___plus, "std_types::real/plus"},
  {entry__std_types___positive_integer___std___minus, "std_types::positive_integer/minus"},
  {entry__negative_integer___std___minus, "negative_integer/minus"},
  {entry__std_types___real___std___minus, "std_types::real/minus"},
  {entry__std_types___real___std___times, "std_types::real/times"},
  {entry__std_types___real___std___over, "std_types::real/over"},
  {entry__std_types___positive_integer___std___equal, "std_types::positive_integer/equal"},
  {entry__negative_integer___std___equal, "negative_integer/equal"},
  {entry__std_types___real___std___equal, "std_types::real/equal"},
  {entry__std_types___positive_integer___std___less, "std_types::positive_integer/less"},
  {entry__negative_integer___std___less, "negative_integer/less"},
  {entry__std_types___real___std___less, "std_types::real/less"},
  {entry__std_types___positive_integer___std___shift_left, "std_types::positive_integer/shift_left"},
  {entry__std_types___positive_integer___std___shift_right, "std_types::positive_integer/shift_right"},
  {entry__std_types___positive_integer___std___bit_and, "std_types::positive_integer/bit_and"},
  {entry__std_types___positive_integer___std___bit_or, "std_types::positive_integer/bit_or"},
  {entry__std_types___positive_integer___std___bit_xor, "std_types::positive_integer/bit_xor"},
  {entry__std___sin, "std::sin"},
  {entry__std___cos, "std::cos"},
  {entry__std___tan, "std::tan"},
  {entry__std___asin, "std::asin"},
  {entry__std___acos, "std::acos"},
  {entry__std___atan, "std::atan"},
  {std_types___object____type, "std_types::object/_type"},
  {std_types___polymorphic_function____type, "std_types::polymorphic_function/_type"},
  {std_types___polymorphic_function_with_setter____type, "std_types::polymorphic_function_with_setter/_type"},
  {std_types___file_type____type, "std_types::file_type/_type"},
  {entry__std_types___file_type___std___equal, "std_types::file_type/equal"},
  {entry__std_types___file_type___std___hash, "std_types::file_type/hash"},
  {entry__std___file_type, "std::file_type"},
  {entry__std_types___file_type___std___to_integer, "std_types::file_type/to_integer"},
  {std_types___file_descriptor____type, "std_types::file_descriptor/_type"},
  {entry__std_types___file_descriptor___std___equal, "std_types::file_descriptor/equal"},
  {entry__std_types___file_descriptor___std___hash, "std_types::file_descriptor/hash"},
  {entry__std___file_descriptor, "std::file_descriptor"},
  {entry__std_types___file_descriptor___std___to_integer, "std_types::file_descriptor/to_integer"},
  {std_types___shutdown_type____type, "std_types::shutdown_type/_type"},
  {entry__std_types___shutdown_type___std___equal, "std_types::shutdown_type/equal"},
  {entry__std_types___shutdown_type___std___hash, "std_types::shutdown_type/hash"},
  {entry__std___shutdown_type, "std::shutdown_type"},
  {entry__std_types___shutdown_type___std___to_integer, "std_types::shutdown_type/to_integer"},
  {std_types___device_id____type, "std_types::device_id/_type"},
  {entry__std_types___device_id___std___equal, "std_types::device_id/equal"},
  {entry__std_types___device_id___std___hash, "std_types::device_id/hash"},
  {entry__std___device_id, "std::device_id"},
  {entry__std_types___device_id___std___to_integer, "std_types::device_id/to_integer"},
  {std_types___directory____type, "std_types::directory/_type"},
  {entry__std_types___directory___std___equal, "std_types::directory/equal"},
  {entry__std_types___directory___std___hash, "std_types::directory/hash"},
  {std_types___group_id____type, "std_types::group_id/_type"},
  {entry__std_types___group_id___std___equal, "std_types::group_id/equal"},
  {entry__std_types___group_id___std___hash, "std_types::group_id/hash"},
  {entry__std___group_id, "std::group_id"},
  {entry__std_types___group_id___std___to_integer, "std_types::group_id/to_integer"},
  {std_types___inode_number____type, "std_types::inode_number/_type"},
  {entry__std_types___inode_number___std___equal, "std_types::inode_number/equal"},
  {entry__std_types___inode_number___std___hash, "std_types::inode_number/hash"},
  {entry__std___inode_number, "std::inode_number"},
  {entry__std_types___inode_number___std___to_integer, "std_types::inode_number/to_integer"},
  {std_types___process_id____type, "std_types::process_id/_type"},
  {entry__std_types___process_id___std___equal, "std_types::process_id/equal"},
  {entry__std_types___process_id___std___hash, "std_types::process_id/hash"},
  {entry__std___process_id, "std::process_id"},
  {entry__std_types___process_id___std___to_integer, "std_types::process_id/to_integer"},
  {std_types___user_id____type, "std_types::user_id/_type"},
  {entry__std_types___user_id___std___equal, "std_types::user_id/equal"},
  {entry__std_types___user_id___std___hash, "std_types::user_id/hash"},
  {entry__std___user_id, "std::user_id"},
  {entry__std_types___user_id___std___to_integer, "std_types::user_id/to_integer"},
  {std_types___error_number____type, "std_types::error_number/_type"},
  {entry__std_types___error_number___std___equal, "std_types::error_number/equal"},
  {entry__std_types___error_number___std___hash, "std_types::error_number/hash"},
  {entry__std___error_number, "std::error_number"},
  {entry__std_types___error_number___std___to_integer, "std_types::error_number/to_integer"},
  {std_types___passwd____type, "std_types::passwd/_type"},
  {std_types___stat____type, "std_types::stat/_type"},
  {std_types___dirent____type, "std_types::dirent/_type"},
  {entry__std___access, "std::access"},
  {entry__std___chdir, "std::chdir"},
  {entry__std___chmod, "std::chmod"},
  {entry__std___chown, "std::chown"},
  {entry__std___chroot, "std::chroot"},
  {entry__std_types___file_descriptor___std___close, "std_types::file_descriptor/close"},
  {entry__std___closedir, "std::closedir"},
  {entry__std___dup2, "std::dup2"},
  {entry__std___fstat, "std::fstat"},
  {entry__std___fsync, "std::fsync"},
  {entry__std___getcwd, "std::getcwd"},
  {entry__std___getenv, "std::getenv"},
  {entry__std___getegid, "std::getegid"},
  {entry__std___geteuid, "std::geteuid"},
  {entry__std___getgid, "std::getgid"},
  {entry__std___gethostname, "std::gethostname"},
  {entry__std___getlogin, "std::getlogin"},
  {entry__std___getpid, "std::getpid"},
  {entry__std___getppid, "std::getppid"},
  {entry__std___getpwuid, "std::getpwuid"},
  {entry__std___getsid, "std::getsid"},
  {entry__std___getuid, "std::getuid"},
  {entry__std___isatty, "std::isatty"},
  {entry__std___mkdir, "std::mkdir"},
  {entry__std___mkfifo, "std::mkfifo"},
  {entry__std___open, "std::open"},
  {entry__std___opendir, "std::opendir"},
  {entry__std_types___file_descriptor___std___read, "std_types::file_descriptor/read"},
  {entry__std___readdir, "std::readdir"},
  {entry__std___realpath, "std::realpath"},
  {entry__std___rename, "std::rename"},
  {entry__std___sethostname, "std::sethostname"},
  {entry__std___shutdown, "std::shutdown"},
  {entry__std___stat, "std::stat"},
  {entry__std___strerror, "std::strerror"},
  {entry__std___wait, "std::wait"},
  {entry__std_types___file_descriptor___std___write, "std_types::file_descriptor/write"},
  {entry__std___umask, "std::umask"},
  {entry__std___unlink, "std::unlink"},
  {entry__std___usleep, "std::usleep"},
  {std_types___string____type, "std_types::string/_type"},
  {std_types___octet_string____type, "std_types::octet_string/_type"},
  {quad_octet_string____type, "quad_octet_string/_type"},
  {entry__std_types___octet_string___std___length_of, "std_types::octet_string/length_of"},
  {entry__quad_octet_string___std___length_of, "quad_octet_string/length_of"},
  {entry__std_types___octet_string___std___is_empty, "std_types::octet_string/is_empty"},
  {entry__std_types___octet_string___std___is_not_empty, "std_types::octet_string/is_not_empty"},
  {entry__quad_octet_string___std___is_empty, "quad_octet_string/is_empty"},
  {entry__quad_octet_string___std___is_not_empty, "quad_octet_string/is_not_empty"},
  {entry__std_types___octet_string___std___push, "std_types::octet_string/push"},
  {entry__quad_octet_string___std___push, "quad_octet_string/push"},
  {entry__std_types___octet_string___std___append, "std_types::octet_string/append"},
  {entry__quad_octet_string___std___append, "quad_octet_string/append"},
  {entry__std_types___octet_string___std___range, "std_types::octet_string/range"},
  {entry__quad_octet_string___std___range, "quad_octet_string/range"},
  {entry__std_types___octet_string___std___hash, "std_types::octet_string/hash"},
  {entry__quad_octet_string___std___hash, "quad_octet_string/hash"},
  {entry__std_types___octet_string___std___equal, "std_types::octet_string/equal"},
  {entry__quad_octet_string___std___equal, "quad_octet_string/equal"},
  {entry__std_types___octet_string___std___less, "std_types::octet_string/less"},
  {entry__quad_octet_string___std___less, "quad_octet_string/less"},
  {entry__std_types___octet_string___std___width_of, "std_types::octet_string/width_of"},
  {entry__quad_octet_string___std___width_of, "quad_octet_string/width_of"},
  {entry__std_types___octet_string___std___from_utf8, "std_types::octet_string/from_utf8"},
  {entry__std_types___octet_string___std___to_utf8, "std_types::octet_string/to_utf8"},
  {entry__quad_octet_string___std___to_utf8, "quad_octet_string/to_utf8"},
  {std_types___terminal_attributes____type, "std_types::terminal_attributes/_type"},
  {entry__std_types___file_descriptor___std___get_terminal_attributes, "std_types::file_descriptor/get_terminal_attributes"},
  {entry__std_types___file_descriptor___std___set_terminal_attributes, "std_types::file_descriptor/set_terminal_attributes"},
  {entry__std_types___terminal_attributes___std___backspace_character_of, "std_types::terminal_attributes/backspace_character_of"},
  {entry__std_types___terminal_attributes___std___use_canonical_mode, "std_types::terminal_attributes/use_canonical_mode"},
  {entry__std_types___terminal_attributes___std___echo_characters, "std_types::terminal_attributes/echo_characters"},
  {entry__std_types___terminal_attributes___std___echo_new_lines, "std_types::terminal_attributes/echo_new_lines"},
  {entry__std_types___terminal_attributes___std___enable_xon_xoff_for_input, "std_types::terminal_attributes/enable_xon_xoff_for_input"},
  {entry__std_types___terminal_attributes___std___enable_xon_xoff_for_output, "std_types::terminal_attributes/enable_xon_xoff_for_output"},
  {entry__std_types___terminal_attributes___std___restart_output_on_any_character, "std_types::terminal_attributes/restart_output_on_any_character"},
  {entry__std_types___terminal_attributes___std___ignore_cr_on_input, "std_types::terminal_attributes/ignore_cr_on_input"},
  {entry__std_types___terminal_attributes___std___generate_signals, "std_types::terminal_attributes/generate_signals"},
  {entry__std_types___terminal_attributes___std___map_cr_to_lf_on_input, "std_types::terminal_attributes/map_cr_to_lf_on_input"},
  {entry__std_types___terminal_attributes___std___hangup_on_close, "std_types::terminal_attributes/hangup_on_close"},
  {entry__std_types___terminal_attributes___std___map_lf_to_crlf_on_output, "std_types::terminal_attributes/map_lf_to_crlf_on_output"},
  {entry__std_types___terminal_attributes___std___minimum_characters_for_canoncial_read, "std_types::terminal_attributes/minimum_characters_for_canoncial_read"},
  {entry__std_types___terminal_attributes___std___timeout_for_reads, "std_types::terminal_attributes/timeout_for_reads"},
  {entry__std_types___terminal_attributes___std___input_speed, "std_types::terminal_attributes/input_speed"},
  {entry__std_types___terminal_attributes___std___output_speed, "std_types::terminal_attributes/output_speed"},
  {std_types___tuple____type, "std_types::tuple/_type"},
  {entry__std_types___tuple___std___new, "std_types::tuple/new"},
  {builtin___tuple2____type, "builtin::tuple2/_type"},
  {entry__builtin___tuple2___std___to_list, "builtin::tuple2/to_list"},
  {entry__builtin___tuple2___std___new, "builtin::tuple2/new"},
  {builtin___tuple3____type, "builtin::tuple3/_type"},
  {entry__builtin___tuple3___std___to_list, "builtin::tuple3/to_list"},
  {entry__builtin___tuple3___std___new, "builtin::tuple3/new"},
  {builtin___tuple4____type, "builtin::tuple4/_type"},
  {entry__builtin___tuple4___std___to_list, "builtin::tuple4/to_list"},
  {entry__builtin___tuple4___std___new, "builtin::tuple4/new"},
  {builtin___tuple5____type, "builtin::tuple5/_type"},
  {entry__builtin___tuple5___std___to_list, "builtin::tuple5/to_list"},
  {entry__builtin___tuple5___std___new, "builtin::tuple5/new"},
  {builtin___tuple6____type, "builtin::tuple6/_type"},
  {entry__builtin___tuple6___std___to_list, "builtin::tuple6/to_list"},
  {entry__builtin___tuple6___std___new, "builtin::tuple6/new"},
  {builtin___tuple7____type, "builtin::tuple7/_type"},
  {entry__builtin___tuple7___std___to_list, "builtin::tuple7/to_list"},
  {entry__builtin___tuple7___std___new, "builtin::tuple7/new"},
  {builtin___tuple8____type, "builtin::tuple8/_type"},
  {entry__builtin___tuple8___std___to_list, "builtin::tuple8/to_list"},
  {entry__builtin___tuple8___std___new, "builtin::tuple8/new"},
  {entry__std___tuple, "std::tuple"},
  {entry__std___tuple_or_error, "std::tuple_or_error"},
  {entry__std___new_tuple, "std::new_tuple"},
  {std_types___undefined____type, "std_types::undefined/_type"},
  {entry__std_types___character___std___to_upper_case, "std_types::character/to_upper_case"},
  {entry__std___is_an_upper_case_letter_character, "std::is_an_upper_case_letter_character"},
  {entry__std_types___character___std___to_lower_case, "std_types::character/to_lower_case"},
  {entry__std___is_a_lower_case_letter_character, "std::is_a_lower_case_letter_character"},
  {entry__std_types___character___std___to_title_case, "std_types::character/to_title_case"},
  {entry__std___is_a_title_case_letter_character, "std::is_a_title_case_letter_character"},
  {entry__std___is_a_letter_character, "std::is_a_letter_character"},
  {entry__std___is_a_whitespace_character, "std::is_a_whitespace_character"},
  {entry__std___is_a_zero_width_character, "std::is_a_zero_width_character"},
  {entry__std___is_a_wide_character, "std::is_a_wide_character"},
  {std_types___unique_item____type, "std_types::unique_item/_type"},
  {entry__std_types___unique_item___std___to_string, "std_types::unique_item/to_string"},
  {entry__std_types___unique_item___std___equal, "std_types::unique_item/equal"},
  {entry__std_types___unique_item___std___hash, "std_types::unique_item/hash"},
  {entry__std___unique_item, "std::unique_item"},
  {entry__std_types___file_descriptor___std___get_terminal_size, "std_types::file_descriptor/std::get_terminal_size"},
  {entry__std___exitstatus, "std::exitstatus"},
  {entry__std___pselect, "std::pselect"},
  {entry__std___do_not_close, "std::do_not_close"},
  {entry__std___waitpid, "std::waitpid"},
  {entry__std___open_tcp_client_socket, "std::open_tcp_client_socket"},
  {entry__std___open_tcp_server_socket, "std::open_tcp_server_socket"},
  {entry__std___accept, "std::accept"},
  {entry__std___is_listening, "std::is_listening"},
  {entry__std___get_first_mac_address, "std::get_first_mac_address"}
};

const char *internal_method_names[] = {
  "size",
  "collect",
  "to_int8",
  "to_int16",
  "to_int32",
  "to_int64",
  "to_uint8",
  "to_uint16",
  "to_uint32",
  "to_uint64",
  "to_uchar32",
  "to_bool",
  "to_int",
  "to_uint",
  "to_long",
  "to_ulong",
  "to_float",
  "to_double",
  "to_c_string",
  "to_octets",
  "get_item_of",
  "length_of",
  "unfold",
  "debug_string"
};
