// This file is automatically generated by "builtins.sim"; do not edit manually!

#define _GNU_SOURCE
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <inttypes.h>
#include <limits.h>
#include <unistd.h>
#include <math.h>
#include <pwd.h>
#include <time.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#ifndef __CYGWIN__
  #include <ifaddrs.h>
  #include <arpa/inet.h>
  #include <netpacket/packet.h>
#endif
#include <netdb.h>
#include <dirent.h>

#include "platform.h"
#include "common.h"
#include "builtins.h"
#include "fko.h"
#include "linker.h"
#include "memory.h"
#include "interpreter.h"
#include "debugger.h"

enum {
  func__std_types__array__std__length_of = 1,
  func__std_types__array__std__dimension_count_of,
  func__std__array,
  func__std__initialized_array,
  func__std_types__array__std__create_empty_array,
  func__std_types__array__std__range,
  func__std_types__boolean_array__std__length_of,
  func__std_types__boolean_array__std__dimension_count_of,
  func__std_types__boolean_array__std__equal,
  func__std_types__boolean_array__std__bit_and,
  func__std_types__boolean_array__std__bit_or,
  func__std_types__boolean_array__std__bit_xor,
  func__std__boolean_array,
  func__std__initialized_boolean_array,
  func__std_types__boolean_array__std__create_empty_array,
  func__std_types__boolean_array__std__range,
  func__std_types__character_array__std__length_of,
  func__std_types__character_array__std__dimension_count_of,
  func__std_types__character_array__std__equal,
  func__std__character_array,
  func__std__initialized_character_array,
  func__std_types__character_array__std__create_empty_array,
  func__std_types__character_array__std__range,
  func__std_types__int8_array__std__length_of,
  func__std_types__int8_array__std__dimension_count_of,
  func__std_types__int8_array__std__equal,
  func__std_types__int8_array__std__times,
  func__std__int8_array,
  func__std__initialized_int8_array,
  func__std_types__int8_array__std__create_empty_array,
  func__std_types__int8_array__std__range,
  func__std_types__uint8_array__std__length_of,
  func__std_types__uint8_array__std__dimension_count_of,
  func__std_types__uint8_array__std__equal,
  func__std_types__uint8_array__std__bit_and,
  func__std_types__uint8_array__std__bit_or,
  func__std_types__uint8_array__std__bit_xor,
  func__std_types__uint8_array__std__times,
  func__std__uint8_array,
  func__std__initialized_uint8_array,
  func__std_types__uint8_array__std__create_empty_array,
  func__std_types__uint8_array__std__range,
  func__std_types__int16_array__std__length_of,
  func__std_types__int16_array__std__dimension_count_of,
  func__std_types__int16_array__std__equal,
  func__std_types__int16_array__std__times,
  func__std__int16_array,
  func__std__initialized_int16_array,
  func__std_types__int16_array__std__create_empty_array,
  func__std_types__int16_array__std__range,
  func__std_types__uint16_array__std__length_of,
  func__std_types__uint16_array__std__dimension_count_of,
  func__std_types__uint16_array__std__equal,
  func__std_types__uint16_array__std__bit_and,
  func__std_types__uint16_array__std__bit_or,
  func__std_types__uint16_array__std__bit_xor,
  func__std_types__uint16_array__std__times,
  func__std__uint16_array,
  func__std__initialized_uint16_array,
  func__std_types__uint16_array__std__create_empty_array,
  func__std_types__uint16_array__std__range,
  func__std_types__int32_array__std__length_of,
  func__std_types__int32_array__std__dimension_count_of,
  func__std_types__int32_array__std__equal,
  func__std_types__int32_array__std__times,
  func__std__int32_array,
  func__std__initialized_int32_array,
  func__std_types__int32_array__std__create_empty_array,
  func__std_types__int32_array__std__range,
  func__std_types__uint32_array__std__length_of,
  func__std_types__uint32_array__std__dimension_count_of,
  func__std_types__uint32_array__std__equal,
  func__std_types__uint32_array__std__bit_and,
  func__std_types__uint32_array__std__bit_or,
  func__std_types__uint32_array__std__bit_xor,
  func__std_types__uint32_array__std__times,
  func__std__uint32_array,
  func__std__initialized_uint32_array,
  func__std_types__uint32_array__std__create_empty_array,
  func__std_types__uint32_array__std__range,
  func__std_types__int64_array__std__length_of,
  func__std_types__int64_array__std__dimension_count_of,
  func__std_types__int64_array__std__equal,
  func__std_types__int64_array__std__times,
  func__std__int64_array,
  func__std__initialized_int64_array,
  func__std_types__int64_array__std__create_empty_array,
  func__std_types__int64_array__std__range,
  func__std_types__uint64_array__std__length_of,
  func__std_types__uint64_array__std__dimension_count_of,
  func__std_types__uint64_array__std__equal,
  func__std_types__uint64_array__std__bit_and,
  func__std_types__uint64_array__std__bit_or,
  func__std_types__uint64_array__std__bit_xor,
  func__std_types__uint64_array__std__times,
  func__std__uint64_array,
  func__std__initialized_uint64_array,
  func__std_types__uint64_array__std__create_empty_array,
  func__std_types__uint64_array__std__range,
  func__std_types__float32_array__std__length_of,
  func__std_types__float32_array__std__dimension_count_of,
  func__std_types__float32_array__std__equal,
  func__std_types__float32_array__std__times,
  func__std__float32_array,
  func__std__initialized_float32_array,
  func__std_types__float32_array__std__create_empty_array,
  func__std_types__float32_array__std__range,
  func__std_types__float64_array__std__length_of,
  func__std_types__float64_array__std__dimension_count_of,
  func__std_types__float64_array__std__equal,
  func__std_types__float64_array__std__times,
  func__std__float64_array,
  func__std__initialized_float64_array,
  func__std_types__float64_array__std__create_empty_array,
  func__std_types__float64_array__std__range,
  func__std__pass,
  func__std__result_count,
  func__std_types__true__std__equal,
  func__std_types__false__std__equal,
  func__c_function__std__parameter_count_of,
  func__std__character,
  func__std_types__character__std__plus,
  func__std_types__character__std__minus,
  func__std_types__character__std__equal,
  func__std_types__character__std__less,
  func__std_types__character__std__hash,
  func__std_types__character__std__to_string,
  func__std_types__character__std__to_integer,
  func__std_types__character__std__width_of,
  func__std__from_unix_time,
  func__std__date_and_time,
  func__std_types__date_and_time__std__year_of,
  func__std_types__date_and_time__std__month_of,
  func__std_types__date_and_time__std__day_of,
  func__std_types__date_and_time__std__day_of_week_of,
  func__std_types__date_and_time__std__hour_of,
  func__std_types__date_and_time__std__minute_of,
  func__std_types__date_and_time__std__second_of,
  func__std_types__date_and_time__std__time_shift_of,
  func__std_types__date_and_time__std__seconds_since_epoch,
  func__std_types__date_and_time__std__plus,
  func__std_types__date_and_time__std__minus,
  func__std_types__date_and_time__std__equal,
  func__std_types__date_and_time__std__less,
  func__std__current_time,
  func__debug__current_time,
  func__debug__string,
  func__debug__write,
  func__debug__dump_object,
  func__debug__has_io_access_rights,
  func__debug__exit,
  func__std__error_check,
  func__debug__total_garbage_collections,
  func__std__installation_prefix,
  func__std__package_version,
  unique__std__IO_ERROR,
  unique__std__RUNTIME_ERROR,
  unique__std__APPLICATION_ERROR,
  func__std_types__error__std__error_category_of,
  func__std_types__error__std__error_message_text_of,
  func__std_types__error__std__error_details_of,
  func__std_types__error__std__errno_of,
  func__std_types__error__std__failed_attribute_of,
  func__std__error,
  func__std__exec,
  func__std__create_process,
  func__std_types__function__std__parameter_count_of,
  func__std_types__function__std__new,
  func__std__list,
  func__std_types__list__std__length_of,
  func__std_types__list__std__is_empty,
  func__std_types__list__std__is_not_empty,
  func__std_types__list__std__push,
  func__std_types__list__std__drop,
  func__std_types__list__std__pop,
  func__std_types__list__std__peek,
  func__std_types__list__std__append,
  func__std_types__list__std__range,
  func__std_types__list__std__spread,
  func__builtin_types__positive_integer__std__negate,
  func__builtin_types__negative_integer__std__negate,
  func__std_types__real__std__negate,
  func__builtin_types__positive_integer__std__times,
  func__builtin_types__negative_integer__std__times,
  func__builtin_types__positive_integer__std__to_integer,
  func__builtin_types__negative_integer__std__to_integer,
  func__std_types__real__std__to_integer,
  func__std_types__real__std__floor,
  func__std_types__real__std__ceil,
  func__std_types__real__std__round,
  func__builtin_types__negative_integer__std__to_string,
  func__builtin_types__positive_integer__std__to_string,
  func__std_types__real__std__to_string,
  func__builtin_types__positive_integer__std__over,
  func__builtin_types__negative_integer__std__over,
  func__builtin_types__positive_integer__std__div,
  func__builtin_types__negative_integer__std__div,
  func__builtin_types__positive_integer__std__mod,
  func__builtin_types__negative_integer__std__mod,
  func__builtin_types__positive_integer__std__hash,
  func__builtin_types__negative_integer__std__hash,
  func__std_types__real__std__hash,
  func__builtin_types__positive_integer__std__ln,
  func__builtin_types__negative_integer__std__ln,
  func__std_types__real__std__ln,
  func__builtin_types__positive_integer__std__exp,
  func__builtin_types__negative_integer__std__exp,
  func__std_types__real__std__exp,
  func__std__real,
  func__std__integer,
  func__std__sqrt,
  func__std__pow,
  func__builtin_types__positive_integer__std__exit,
  func__builtin_types__positive_integer__std__plus,
  func__builtin_types__negative_integer__std__plus,
  func__std_types__real__std__plus,
  func__builtin_types__positive_integer__std__minus,
  func__builtin_types__negative_integer__std__minus,
  func__std_types__real__std__minus,
  func__std_types__real__std__times,
  func__std_types__real__std__over,
  func__builtin_types__positive_integer__std__equal,
  func__builtin_types__negative_integer__std__equal,
  func__std_types__real__std__equal,
  func__builtin_types__positive_integer__std__less,
  func__builtin_types__negative_integer__std__less,
  func__std_types__real__std__less,
  func__builtin_types__positive_integer__std__shift_left,
  func__builtin_types__positive_integer__std__shift_right,
  func__builtin_types__positive_integer__std__bit_and,
  func__builtin_types__positive_integer__std__bit_or,
  func__builtin_types__positive_integer__std__bit_xor,
  func__std__sin,
  func__std__cos,
  func__std__tan,
  func__std__asin,
  func__std__acos,
  func__std__atan,
  func__debug__object_type,
  func__debug__object_attributes,
  func__std_types__object__std__new,
  func__std_types__file_type__std__equal,
  func__std_types__file_type__std__hash,
  func__std__file_type,
  func__std_types__file_type__std__to_integer,
  func__std_types__file_descriptor__std__equal,
  func__std_types__file_descriptor__std__hash,
  func__std__file_descriptor,
  func__std_types__file_descriptor__std__to_integer,
  func__std_types__signal_number__std__equal,
  func__std_types__signal_number__std__hash,
  func__std__signal_number,
  func__std_types__signal_number__std__to_integer,
  func__std_types__shutdown_type__std__equal,
  func__std_types__shutdown_type__std__hash,
  func__std__shutdown_type,
  func__std_types__shutdown_type__std__to_integer,
  func__std_types__seek_type__std__equal,
  func__std_types__seek_type__std__hash,
  func__std__seek_type,
  func__std_types__seek_type__std__to_integer,
  func__std_types__device_id__std__equal,
  func__std_types__device_id__std__hash,
  func__std__device_id,
  func__std_types__device_id__std__to_integer,
  func__std_types__directory__std__equal,
  func__std_types__directory__std__hash,
  func__std_types__group_id__std__equal,
  func__std_types__group_id__std__hash,
  func__std__group_id,
  func__std_types__group_id__std__to_integer,
  func__std_types__inode_number__std__equal,
  func__std_types__inode_number__std__hash,
  func__std__inode_number,
  func__std_types__inode_number__std__to_integer,
  func__std_types__process_id__std__equal,
  func__std_types__process_id__std__hash,
  func__std__process_id,
  func__std_types__process_id__std__to_integer,
  func__std_types__user_id__std__equal,
  func__std_types__user_id__std__hash,
  func__std__user_id,
  func__std_types__user_id__std__to_integer,
  func__std_types__error_number__std__equal,
  func__std_types__error_number__std__hash,
  func__std__error_number,
  func__std_types__error_number__std__to_integer,
  func__std__access,
  func__std__chdir,
  func__std__chmod,
  func__std__chown,
  func__std__chroot,
  func__std_types__file_descriptor__std__close,
  func__std__closedir,
  func__std__dup2,
  func__std__fstat,
  func__std__fsync,
  func__std__getcwd,
  func__std__getenv,
  func__std__getegid,
  func__std__geteuid,
  func__std__getgid,
  func__std__gethostname,
  func__std__getlogin,
  func__std__getpid,
  func__std__getppid,
  func__std__getpwuid,
  func__std__getsid,
  func__std__getuid,
  func__std__isatty,
  func__std__kill,
  func__std__link,
  func__std__lseek,
  func__std__mkdir,
  func__std__mkfifo,
  func__std__open,
  func__std__opendir,
  func__std_types__file_descriptor__std__read,
  func__std__readdir,
  func__std__realpath,
  func__std__rename,
  func__std__sethostname,
  func__std__shutdown,
  func__std__stat,
  func__std__strerror,
  func__std__wait,
  func__std_types__file_descriptor__std__write,
  func__std__umask,
  func__std__unlink,
  func__std__shm_unlink,
  func__std__usleep,
  func__std_types__octet_string__std__length_of,
  func__std_types__wide_string__std__length_of,
  func__std_types__octet_string__std__is_empty,
  func__std_types__octet_string__std__is_not_empty,
  func__std_types__wide_string__std__is_empty,
  func__std_types__wide_string__std__is_not_empty,
  func__std_types__octet_string__std__push,
  func__std_types__wide_string__std__push,
  func__std_types__octet_string__std__append,
  func__std_types__wide_string__std__append,
  func__std_types__octet_string__std__range,
  func__std_types__wide_string__std__range,
  func__std_types__octet_string__std__hash,
  func__std_types__wide_string__std__hash,
  func__std_types__octet_string__std__equal,
  func__std_types__wide_string__std__equal,
  func__std_types__octet_string__std__less,
  func__std_types__wide_string__std__less,
  func__std_types__octet_string__std__width_of,
  func__std_types__wide_string__std__width_of,
  func__std_types__octet_string__std__from_utf8,
  func__std_types__octet_string__std__to_utf8,
  func__std_types__wide_string__std__to_utf8,
  func__std_types__file_descriptor__std__get_terminal_attributes,
  func__std_types__file_descriptor__std__set_terminal_attributes,
  func__std_types__terminal_attributes__std__backspace_character_of,
  func__std_types__terminal_attributes__std__use_canonical_mode,
  func__std_types__terminal_attributes__std__echo_characters,
  func__std_types__terminal_attributes__std__echo_new_lines,
  func__std_types__terminal_attributes__std__enable_xon_xoff_for_input,
  func__std_types__terminal_attributes__std__enable_xon_xoff_for_output,
  func__std_types__terminal_attributes__std__restart_output_on_any_character,
  func__std_types__terminal_attributes__std__ignore_cr_on_input,
  func__std_types__terminal_attributes__std__generate_signals,
  func__std_types__terminal_attributes__std__map_cr_to_lf_on_input,
  func__std_types__terminal_attributes__std__hangup_on_close,
  func__std_types__terminal_attributes__std__map_lf_to_crlf_on_output,
  func__std_types__terminal_attributes__std__minimum_characters_for_canoncial_read,
  func__std_types__terminal_attributes__std__timeout_for_reads,
  func__std_types__terminal_attributes__std__input_speed,
  func__std_types__terminal_attributes__std__output_speed,
  func__std_types__tuple__std__typed_tuple,
  func__builtin_types__tuple2__std__to_list,
  func__builtin_types__tuple2__std__typed_tuple,
  func__builtin_types__tuple3__std__to_list,
  func__builtin_types__tuple3__std__typed_tuple,
  func__builtin_types__tuple4__std__to_list,
  func__builtin_types__tuple4__std__typed_tuple,
  func__builtin_types__tuple5__std__to_list,
  func__builtin_types__tuple5__std__typed_tuple,
  func__builtin_types__tuple6__std__to_list,
  func__builtin_types__tuple6__std__typed_tuple,
  func__builtin_types__tuple7__std__to_list,
  func__builtin_types__tuple7__std__typed_tuple,
  func__builtin_types__tuple8__std__to_list,
  func__builtin_types__tuple8__std__typed_tuple,
  func__std__tuple,
  func__std__tuple_or_error,
  func__std__new_tuple,
  func__std_types__character__std__to_upper_case,
  func__std__is_an_upper_case_letter_character,
  func__std_types__character__std__to_lower_case,
  func__std__is_a_lower_case_letter_character,
  func__std_types__character__std__to_title_case,
  func__std__is_a_title_case_letter_character,
  func__std__is_a_letter_character,
  func__std__is_a_whitespace_character,
  func__std__is_a_zero_width_character,
  func__std__is_a_wide_character,
  func__std_types__unique_item__std__to_string,
  func__std_types__unique_item__std__equal,
  func__std_types__unique_item__std__hash,
  func__std__unique_item,
  func__std_types__file_descriptor__std__get_terminal_size,
  func__std__exitstatus,
  func__std__pselect,
  func__std__do_not_close,
  func__std__waitpid,
  func__std__open_unix_socket,
  func__std__send_file_descriptor,
  func__std__open_tcp_client_socket,
  func__std__open_tcp_server_socket,
  func__std__accept,
  func__std__is_listening,
  func__std__get_first_mac_address,
  func__std_types__shared_memory__std__size_of,
  func__std_types__shared_memory__std__file_descriptor_of,
  func__std_types__shared_memory__std__write_at,
  func__std__create_shared_memory
};

enum {
  var_std__new = FIRST_VAR+0,
  var_std__plus,
  var_std__minus,
  var_std__times,
  var_std__over,
  var_std__div,
  var_std__mod,
  var_std__negate,
  var_std__floor,
  var_std__ceil,
  var_std__round,
  var_std__ln,
  var_std__exp,
  var_std__equal,
  var_std__less,
  var_std__shift_left,
  var_std__shift_right,
  var_std__bit_and,
  var_std__bit_or,
  var_std__bit_xor,
  var_std__parameter_count_of,
  var_std__to_string,
  var_std__to_integer,
  var_std__to_real,
  var_std__to_number,
  var_std__to_lower_case,
  var_std__to_upper_case,
  var_std__to_title_case,
  var_std__is_empty,
  var_std__is_not_empty,
  var_std__length_of,
  var_std__dimension_count_of,
  var_std__width_of,
  var_std__height_of,
  var_std__hash,
  var_std__push,
  var_std__pop,
  var_std__peek,
  var_std__drop,
  var_std__put,
  var_std__get,
  var_std__append,
  var_std__range,
  var_std__spread,
  var_std__to_list,
  var_std__exit,
  var_std__from_utf8,
  var_std__read,
  var_std__write,
  var_std__close,
  var_std__flush,
  var_std_types__generic_array,
  var_std__create_empty_array,
  var_std_types__array,
  var_std__array,
  var_std__initialized_array,
  var_std_types__boolean_array,
  var_std__boolean_array,
  var_std__initialized_boolean_array,
  var_std_types__character_array,
  var_std__character_array,
  var_std__initialized_character_array,
  var_std_types__int8_array,
  var_std__int8_array,
  var_std__initialized_int8_array,
  var_std_types__uint8_array,
  var_std__uint8_array,
  var_std__initialized_uint8_array,
  var_std_types__int16_array,
  var_std__int16_array,
  var_std__initialized_int16_array,
  var_std_types__uint16_array,
  var_std__uint16_array,
  var_std__initialized_uint16_array,
  var_std_types__int32_array,
  var_std__int32_array,
  var_std__initialized_int32_array,
  var_std_types__uint32_array,
  var_std__uint32_array,
  var_std__initialized_uint32_array,
  var_std_types__int64_array,
  var_std__int64_array,
  var_std__initialized_int64_array,
  var_std_types__uint64_array,
  var_std__uint64_array,
  var_std__initialized_uint64_array,
  var_std_types__float32_array,
  var_std__float32_array,
  var_std__initialized_float32_array,
  var_std_types__float64_array,
  var_std__float64_array,
  var_std__initialized_float64_array,
  var_std__EXIT_SUCCESS,
  var_std__EXIT_FAILURE,
  var_std__pass,
  var_std__result_count,
  var_std_types__true,
  var_std_types__false,
  var_c_function,
  var_std_types__character,
  var_std__character,
  var_std__year_of,
  var_std__month_of,
  var_std__day_of,
  var_std__day_of_week_of,
  var_std__hour_of,
  var_std__minute_of,
  var_std__second_of,
  var_std__time_shift_of,
  var_std__seconds_since_epoch,
  var_std_types__date_and_time,
  var_std__from_unix_time,
  var_std__date_and_time,
  var_std__current_time,
  var_debug__current_time,
  var_debug__string,
  var_debug__write,
  var_debug__dump_object,
  var_debug__has_io_access_rights,
  var_debug__exit,
  var_std__error_check,
  var_debug__total_garbage_collections,
  var_std__program_name,
  var_std__command_line_arguments,
  var_std__environment_variables,
  var_std__installation_prefix,
  var_std__package_version,
  var_std__IO_ERROR,
  var_std__RUNTIME_ERROR,
  var_std__APPLICATION_ERROR,
  var_std_types__error,
  var_std__error_category_of,
  var_std__error_message_text_of,
  var_std__error_details_of,
  var_std__errno_of,
  var_std__failed_attribute_of,
  var_std__error,
  var_std_types__object,
  var_std_types__undefined,
  var_std__exec,
  var_std__create_process,
  var_std_types__function,
  var_tabular_function,
  var_std_types__key_value_pair,
  var_std_types__generic_list,
  var_std_types__list,
  var_std__empty_list,
  var_std__list,
  var_std_types__number,
  var_std_types__integer,
  var_builtin_types__positive_integer,
  var_builtin_types__negative_integer,
  var_std_types__real,
  var_std__real,
  var_std__integer,
  var_std__sqrt,
  var_std__pow,
  var_std__sin,
  var_std__cos,
  var_std__tan,
  var_std__asin,
  var_std__acos,
  var_std__atan,
  var_debug__object_type,
  var_debug__object_attributes,
  var_std_types__polymorphic_function,
  var_std_types__polymorphic_function_with_setter,
  var_std__subtype_of,
  var_std__BLOCK_DEVICE,
  var_std__CHARACTER_DEVICE,
  var_std__DIRECTORY,
  var_std__NAMED_PIPE,
  var_std__SYMBOLIC_LINK,
  var_std__REGULAR_FILE,
  var_std__SOCKET,
  var_std__UNKNOWN_FILE_TYPE,
  var_std__STDIN_FILENO,
  var_std__STDOUT_FILENO,
  var_std__STDERR_FILENO,
  var_std__SHUT_RD,
  var_std__SHUT_WR,
  var_std__SHUT_RDWR,
  var_std__SEEK_SET,
  var_std__SEEK_CUR,
  var_std__SEEK_END,
  var_std__ENOERR,
  var_std__EPERM,
  var_std__ENOENT,
  var_std__ESRCH,
  var_std__EINTR,
  var_std__EIO,
  var_std__ENXIO,
  var_std__E2BIG,
  var_std__ENOEXEC,
  var_std__EBADF,
  var_std__ECHILD,
  var_std__EAGAIN,
  var_std__ENOMEM,
  var_std__EACCES,
  var_std__EFAULT,
  var_std__ENOTBLK,
  var_std__EBUSY,
  var_std__EEXIST,
  var_std__EXDEV,
  var_std__ENODEV,
  var_std__ENOTDIR,
  var_std__EISDIR,
  var_std__EINVAL,
  var_std__ENFILE,
  var_std__EMFILE,
  var_std__ENOTTY,
  var_std__ETXTBSY,
  var_std__EFBIG,
  var_std__ENOSPC,
  var_std__ESPIPE,
  var_std__EROFS,
  var_std__EMLINK,
  var_std__EPIPE,
  var_std__EDOM,
  var_std__ERANGE,
  var_std__EDEADLK,
  var_std__ENAMETOOLONG,
  var_std__ENOLCK,
  var_std__ENOSYS,
  var_std__ENOTEMPTY,
  var_std__EILSEQ,
  var_std__ELOOP,
  var_std__ENOMSG,
  var_std__EIDRM,
  var_std__ECHRNG,
  var_std__EL2NSYNC,
  var_std__EL3HLT,
  var_std__EL3RST,
  var_std__ELNRNG,
  var_std__EUNATCH,
  var_std__ENOCSI,
  var_std__EL2HLT,
  var_std__EBADE,
  var_std__EBADR,
  var_std__EXFULL,
  var_std__ENOANO,
  var_std__EBADRQC,
  var_std__EBADSLT,
  var_std__EBFONT,
  var_std__ENOSTR,
  var_std__ENODATA,
  var_std__ETIME,
  var_std__ENOSR,
  var_std__ENONET,
  var_std__ENOPKG,
  var_std__EREMOTE,
  var_std__ENOLINK,
  var_std__EADV,
  var_std__ESRMNT,
  var_std__ECOMM,
  var_std__EPROTO,
  var_std__EMULTIHOP,
  var_std__EDOTDOT,
  var_std__EBADMSG,
  var_std__EOVERFLOW,
  var_std__ENOTUNIQ,
  var_std__EBADFD,
  var_std__EREMCHG,
  var_std__ELIBACC,
  var_std__ELIBBAD,
  var_std__ELIBSCN,
  var_std__ELIBMAX,
  var_std__ELIBEXEC,
  var_std__ESTRPIPE,
  var_std__EUSERS,
  var_std__ENOTSOCK,
  var_std__EDESTADDRREQ,
  var_std__EMSGSIZE,
  var_std__EPROTOTYPE,
  var_std__ENOPROTOOPT,
  var_std__EPROTONOSUPPORT,
  var_std__ESOCKTNOSUPPORT,
  var_std__EOPNOTSUPP,
  var_std__EPFNOSUPPORT,
  var_std__EAFNOSUPPORT,
  var_std__EADDRINUSE,
  var_std__EADDRNOTAVAIL,
  var_std__ENETDOWN,
  var_std__ENETUNREACH,
  var_std__ENETRESET,
  var_std__ECONNABORTED,
  var_std__ECONNRESET,
  var_std__ENOBUFS,
  var_std__EISCONN,
  var_std__ENOTCONN,
  var_std__ESHUTDOWN,
  var_std__ETOOMANYREFS,
  var_std__ETIMEDOUT,
  var_std__ECONNREFUSED,
  var_std__EHOSTDOWN,
  var_std__EHOSTUNREACH,
  var_std__EALREADY,
  var_std__EINPROGRESS,
  var_std__ESTALE,
  var_std__EDQUOT,
  var_std__ENOMEDIUM,
  var_std__ECANCELED,
  var_std__EOWNERDEAD,
  var_std__ENOTRECOVERABLE,
  var_std__SIGHUP,
  var_std__SIGINT,
  var_std__SIGQUIT,
  var_std__SIGILL,
  var_std__SIGTRAP,
  var_std__SIGABRT,
  var_std__SIGIOT,
  var_std__SIGBUS,
  var_std__SIGFPE,
  var_std__SIGKILL,
  var_std__SIGUSR1,
  var_std__SIGSEGV,
  var_std__SIGUSR2,
  var_std__SIGPIPE,
  var_std__SIGALRM,
  var_std__SIGTERM,
  var_std__SIGSTKFLT,
  var_std__SIGCHLD,
  var_std__SIGCONT,
  var_std__SIGSTOP,
  var_std__SIGTSTP,
  var_std__SIGTTIN,
  var_std__SIGTTOU,
  var_std__SIGURG,
  var_std__SIGXCPU,
  var_std__SIGXFSZ,
  var_std__SIGVTALRM,
  var_std__SIGPROF,
  var_std__SIGWINCH,
  var_std__SIGIO,
  var_std__SIGPWR,
  var_std__SIGSYS,
  var_std__access_time_of,
  var_std__block_count_of,
  var_std__block_size_of,
  var_std__device_of,
  var_std__group_id_of,
  var_std__home_directory_of,
  var_std__inode_number_of,
  var_std__link_count_of,
  var_std__mode_of,
  var_std__modification_time_of,
  var_std__name_of,
  var_std__password_of,
  var_std__root_device_of,
  var_std__shell_of,
  var_std__size_of,
  var_std__status_change_time_of,
  var_std__type_of,
  var_std__user_id_of,
  var_std__user_information_of,
  var_std__username_of,
  var_std_types__file_type,
  var_std__file_type,
  var_std_types__file_descriptor,
  var_std__file_descriptor,
  var_std_types__signal_number,
  var_std__signal_number,
  var_std_types__shutdown_type,
  var_std__shutdown_type,
  var_std_types__seek_type,
  var_std__seek_type,
  var_std_types__device_id,
  var_std__device_id,
  var_std_types__directory,
  var_std_types__group_id,
  var_std__group_id,
  var_std_types__inode_number,
  var_std__inode_number,
  var_std_types__process_id,
  var_std__process_id,
  var_std_types__user_id,
  var_std__user_id,
  var_std_types__error_number,
  var_std__error_number,
  var_std_types__passwd,
  var_std_types__stat,
  var_std_types__dirent,
  var_std__access,
  var_std__chdir,
  var_std__chmod,
  var_std__chown,
  var_std__chroot,
  var_std__closedir,
  var_std__dup2,
  var_std__fstat,
  var_std__fsync,
  var_std__getcwd,
  var_std__getenv,
  var_std__getegid,
  var_std__geteuid,
  var_std__getgid,
  var_std__gethostname,
  var_std__getlogin,
  var_std__getpid,
  var_std__getppid,
  var_std__getpwuid,
  var_std__getsid,
  var_std__getuid,
  var_std__isatty,
  var_std__kill,
  var_std__link,
  var_std__lseek,
  var_std__mkdir,
  var_std__mkfifo,
  var_std__open,
  var_std__opendir,
  var_std__readdir,
  var_std__realpath,
  var_std__rename,
  var_std__sethostname,
  var_std__shutdown,
  var_std__stat,
  var_std__strerror,
  var_std__wait,
  var_std__umask,
  var_std__unlink,
  var_std__shm_unlink,
  var_std__usleep,
  var_std_types__sequence,
  var_std__to_utf8,
  var_std_types__string,
  var_std_types__octet_string,
  var_std_types__wide_string,
  var_std__empty_string,
  var_std__get_terminal_attributes,
  var_std__set_terminal_attributes,
  var_std__backspace_character_of,
  var_std__use_canonical_mode,
  var_std__echo_characters,
  var_std__echo_new_lines,
  var_std__enable_xon_xoff_for_input,
  var_std__enable_xon_xoff_for_output,
  var_std__restart_output_on_any_character,
  var_std__ignore_cr_on_input,
  var_std__generate_signals,
  var_std__map_cr_to_lf_on_input,
  var_std__hangup_on_close,
  var_std__map_lf_to_crlf_on_output,
  var_std__minimum_characters_for_canoncial_read,
  var_std__timeout_for_reads,
  var_std__input_speed,
  var_std__output_speed,
  var_std_types__terminal_attributes,
  var_std_types__tuple,
  var_std__typed_tuple,
  var_builtin_types__tuple2,
  var_builtin_types__tuple3,
  var_builtin_types__tuple4,
  var_builtin_types__tuple5,
  var_builtin_types__tuple6,
  var_builtin_types__tuple7,
  var_builtin_types__tuple8,
  var_std__tuple,
  var_std__tuple_or_error,
  var_std__new_tuple,
  var_std__is_an_upper_case_letter_character,
  var_std__is_a_lower_case_letter_character,
  var_std__is_a_title_case_letter_character,
  var_std__is_a_letter_character,
  var_std__is_a_whitespace_character,
  var_std__is_a_zero_width_character,
  var_std__is_a_wide_character,
  var_std_types__unique_item,
  var_std__unique_item,
  var_std_types__value_range,
  var_std__get_terminal_size,
  var_std__exitstatus,
  var_std__pselect,
  var_std__do_not_close,
  var_std__waitpid,
  var_std__open_unix_socket,
  var_std__send_file_descriptor,
  var_std__open_tcp_client_socket,
  var_std__open_tcp_server_socket,
  var_std__accept,
  var_std__is_listening,
  var_std__get_first_mac_address,
  var_std_types__shared_memory,
  var_std__file_descriptor_of,
  var_std__write_at,
  var_std__create_shared_memory
};

static FUNKY_VARIABLE variables_table[];

static POSITIVE_INTEGER std__EXIT_SUCCESS;
static POSITIVE_INTEGER std__EXIT_FAILURE;
static OCTET_STRING std__program_name;
static LIST std__command_line_arguments;
static LIST std__environment_variables;
static FILE_TYPE std__BLOCK_DEVICE;
static FILE_TYPE std__CHARACTER_DEVICE;
static FILE_TYPE std__DIRECTORY;
static FILE_TYPE std__NAMED_PIPE;
static FILE_TYPE std__SYMBOLIC_LINK;
static FILE_TYPE std__REGULAR_FILE;
static FILE_TYPE std__SOCKET;
static FILE_TYPE std__UNKNOWN_FILE_TYPE;
static FILE_DESCRIPTOR std__STDIN_FILENO;
static FILE_DESCRIPTOR std__STDOUT_FILENO;
static FILE_DESCRIPTOR std__STDERR_FILENO;
static SHUTDOWN_TYPE std__SHUT_RD;
static SHUTDOWN_TYPE std__SHUT_WR;
static SHUTDOWN_TYPE std__SHUT_RDWR;
static SEEK_TYPE std__SEEK_SET;
static SEEK_TYPE std__SEEK_CUR;
static SEEK_TYPE std__SEEK_END;
static ERROR_NUMBER std__ENOERR;
static ERROR_NUMBER std__EPERM;
static ERROR_NUMBER std__ENOENT;
static ERROR_NUMBER std__ESRCH;
static ERROR_NUMBER std__EINTR;
static ERROR_NUMBER std__EIO;
static ERROR_NUMBER std__ENXIO;
static ERROR_NUMBER std__E2BIG;
static ERROR_NUMBER std__ENOEXEC;
static ERROR_NUMBER std__EBADF;
static ERROR_NUMBER std__ECHILD;
static ERROR_NUMBER std__EAGAIN;
static ERROR_NUMBER std__ENOMEM;
static ERROR_NUMBER std__EACCES;
static ERROR_NUMBER std__EFAULT;
static ERROR_NUMBER std__ENOTBLK;
static ERROR_NUMBER std__EBUSY;
static ERROR_NUMBER std__EEXIST;
static ERROR_NUMBER std__EXDEV;
static ERROR_NUMBER std__ENODEV;
static ERROR_NUMBER std__ENOTDIR;
static ERROR_NUMBER std__EISDIR;
static ERROR_NUMBER std__EINVAL;
static ERROR_NUMBER std__ENFILE;
static ERROR_NUMBER std__EMFILE;
static ERROR_NUMBER std__ENOTTY;
static ERROR_NUMBER std__ETXTBSY;
static ERROR_NUMBER std__EFBIG;
static ERROR_NUMBER std__ENOSPC;
static ERROR_NUMBER std__ESPIPE;
static ERROR_NUMBER std__EROFS;
static ERROR_NUMBER std__EMLINK;
static ERROR_NUMBER std__EPIPE;
static ERROR_NUMBER std__EDOM;
static ERROR_NUMBER std__ERANGE;
static ERROR_NUMBER std__EDEADLK;
static ERROR_NUMBER std__ENAMETOOLONG;
static ERROR_NUMBER std__ENOLCK;
static ERROR_NUMBER std__ENOSYS;
static ERROR_NUMBER std__ENOTEMPTY;
static ERROR_NUMBER std__EILSEQ;
static ERROR_NUMBER std__ELOOP;
static ERROR_NUMBER std__ENOMSG;
static ERROR_NUMBER std__EIDRM;
static ERROR_NUMBER std__ECHRNG;
static ERROR_NUMBER std__EL2NSYNC;
static ERROR_NUMBER std__EL3HLT;
static ERROR_NUMBER std__EL3RST;
static ERROR_NUMBER std__ELNRNG;
static ERROR_NUMBER std__EUNATCH;
static ERROR_NUMBER std__ENOCSI;
static ERROR_NUMBER std__EL2HLT;
static ERROR_NUMBER std__EBADE;
static ERROR_NUMBER std__EBADR;
static ERROR_NUMBER std__EXFULL;
static ERROR_NUMBER std__ENOANO;
static ERROR_NUMBER std__EBADRQC;
static ERROR_NUMBER std__EBADSLT;
static ERROR_NUMBER std__EBFONT;
static ERROR_NUMBER std__ENOSTR;
static ERROR_NUMBER std__ENODATA;
static ERROR_NUMBER std__ETIME;
static ERROR_NUMBER std__ENOSR;
static ERROR_NUMBER std__ENONET;
static ERROR_NUMBER std__ENOPKG;
static ERROR_NUMBER std__EREMOTE;
static ERROR_NUMBER std__ENOLINK;
static ERROR_NUMBER std__EADV;
static ERROR_NUMBER std__ESRMNT;
static ERROR_NUMBER std__ECOMM;
static ERROR_NUMBER std__EPROTO;
static ERROR_NUMBER std__EMULTIHOP;
static ERROR_NUMBER std__EDOTDOT;
static ERROR_NUMBER std__EBADMSG;
static ERROR_NUMBER std__EOVERFLOW;
static ERROR_NUMBER std__ENOTUNIQ;
static ERROR_NUMBER std__EBADFD;
static ERROR_NUMBER std__EREMCHG;
static ERROR_NUMBER std__ELIBACC;
static ERROR_NUMBER std__ELIBBAD;
static ERROR_NUMBER std__ELIBSCN;
static ERROR_NUMBER std__ELIBMAX;
static ERROR_NUMBER std__ELIBEXEC;
static ERROR_NUMBER std__ESTRPIPE;
static ERROR_NUMBER std__EUSERS;
static ERROR_NUMBER std__ENOTSOCK;
static ERROR_NUMBER std__EDESTADDRREQ;
static ERROR_NUMBER std__EMSGSIZE;
static ERROR_NUMBER std__EPROTOTYPE;
static ERROR_NUMBER std__ENOPROTOOPT;
static ERROR_NUMBER std__EPROTONOSUPPORT;
static ERROR_NUMBER std__ESOCKTNOSUPPORT;
static ERROR_NUMBER std__EOPNOTSUPP;
static ERROR_NUMBER std__EPFNOSUPPORT;
static ERROR_NUMBER std__EAFNOSUPPORT;
static ERROR_NUMBER std__EADDRINUSE;
static ERROR_NUMBER std__EADDRNOTAVAIL;
static ERROR_NUMBER std__ENETDOWN;
static ERROR_NUMBER std__ENETUNREACH;
static ERROR_NUMBER std__ENETRESET;
static ERROR_NUMBER std__ECONNABORTED;
static ERROR_NUMBER std__ECONNRESET;
static ERROR_NUMBER std__ENOBUFS;
static ERROR_NUMBER std__EISCONN;
static ERROR_NUMBER std__ENOTCONN;
static ERROR_NUMBER std__ESHUTDOWN;
static ERROR_NUMBER std__ETOOMANYREFS;
static ERROR_NUMBER std__ETIMEDOUT;
static ERROR_NUMBER std__ECONNREFUSED;
static ERROR_NUMBER std__EHOSTDOWN;
static ERROR_NUMBER std__EHOSTUNREACH;
static ERROR_NUMBER std__EALREADY;
static ERROR_NUMBER std__EINPROGRESS;
static ERROR_NUMBER std__ESTALE;
static ERROR_NUMBER std__EDQUOT;
static ERROR_NUMBER std__ENOMEDIUM;
static ERROR_NUMBER std__ECANCELED;
static ERROR_NUMBER std__EOWNERDEAD;
static ERROR_NUMBER std__ENOTRECOVERABLE;
static SIGNAL_NUMBER std__SIGHUP;
static SIGNAL_NUMBER std__SIGINT;
static SIGNAL_NUMBER std__SIGQUIT;
static SIGNAL_NUMBER std__SIGILL;
static SIGNAL_NUMBER std__SIGTRAP;
static SIGNAL_NUMBER std__SIGABRT;
static SIGNAL_NUMBER std__SIGIOT;
static SIGNAL_NUMBER std__SIGBUS;
static SIGNAL_NUMBER std__SIGFPE;
static SIGNAL_NUMBER std__SIGKILL;
static SIGNAL_NUMBER std__SIGUSR1;
static SIGNAL_NUMBER std__SIGSEGV;
static SIGNAL_NUMBER std__SIGUSR2;
static SIGNAL_NUMBER std__SIGPIPE;
static SIGNAL_NUMBER std__SIGALRM;
static SIGNAL_NUMBER std__SIGTERM;
static SIGNAL_NUMBER std__SIGSTKFLT;
static SIGNAL_NUMBER std__SIGCHLD;
static SIGNAL_NUMBER std__SIGCONT;
static SIGNAL_NUMBER std__SIGSTOP;
static SIGNAL_NUMBER std__SIGTSTP;
static SIGNAL_NUMBER std__SIGTTIN;
static SIGNAL_NUMBER std__SIGTTOU;
static SIGNAL_NUMBER std__SIGURG;
static SIGNAL_NUMBER std__SIGXCPU;
static SIGNAL_NUMBER std__SIGXFSZ;
static SIGNAL_NUMBER std__SIGVTALRM;
static SIGNAL_NUMBER std__SIGPROF;
static SIGNAL_NUMBER std__SIGWINCH;
static SIGNAL_NUMBER std__SIGIO;
static SIGNAL_NUMBER std__SIGPWR;
static SIGNAL_NUMBER std__SIGSYS;
static OCTET_STRING std__empty_string;

static void *create__std_types__array
  (
    long updates_length,
    ARRAY_VIEW *view,
    ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__boolean_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    BOOLEAN_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__character_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    CHARACTER_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__int8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__uint8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__int16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__uint16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__int32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__uint32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__int64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__uint64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__float32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__std_types__float64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  );

static void *create__c_function
  (
    int32_t parameter_count
  );

static void *create__std_types__character
  (
    uint32_t code
  );

static void *create__std_types__date_and_time
  (
    int64_t seconds,
    int32_t nanoseconds
  );

static void *create__tabular_function
  (

  );

static void *create__std_types__integer
  (
    uint64_t value
  );

static void *create__std_types__real
  (
    double value
  );

static void *create__std_types__file_type
  (
    int value
  );

static void *create__std_types__file_descriptor
  (
    int value
  );

static void *create__std_types__signal_number
  (
    int value
  );

static void *create__std_types__shutdown_type
  (
    int value
  );

static void *create__std_types__seek_type
  (
    int value
  );

static void *create__std_types__device_id
  (
    unsigned long value
  );

static void *create__std_types__directory
  (
    void *value
  );

static void *create__std_types__group_id
  (
    int value
  );

static void *create__std_types__inode_number
  (
    unsigned long value
  );

static void *create__std_types__process_id
  (
    int value
  );

static void *create__std_types__user_id
  (
    int value
  );

static void *create__std_types__error_number
  (
    int value
  );

static void *create__std_types__octet_string
  (
    long offset,
    long length,
    OCTET_DATA *data
  );

static void *create__std_types__wide_string
  (
    long offset,
    long length,
    WIDE_DATA *data
  );

static void *create__std_types__terminal_attributes
  (
    TERMIO_DATA *data
  );

static void *create__builtin_types__tuple2
  (
    NODE *node_0,
    NODE *node_1
  );

static void *create__builtin_types__tuple3
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2
  );

static void *create__builtin_types__tuple4
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3
  );

static void *create__builtin_types__tuple5
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4
  );

static void *create__builtin_types__tuple6
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5
  );

static void *create__builtin_types__tuple7
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6
  );

static void *create__builtin_types__tuple8
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6,
    NODE *node_7
  );

static void *create__std_types__unique_item
  (
    long id
  );

static void *create__std_types__shared_memory
  (
    int fd,
    long size,
    void *buf
  );
static void *collect_array_info(ARRAY_INFO *info);
static void *collect_dimension_info(DIMENSION_INFO *info);
static void *collect_array_view(ARRAY_VIEW *view);
static void *collect_array_updates(ARRAY_UPDATES *updates);
static void *collect_array_data(ARRAY_DATA *data);
static void *std_types__array___collect(ARRAY *node);
static long std_types__array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_boolean_array_data(BOOLEAN_ARRAY_DATA *data);
static void *std_types__boolean_array___collect(BOOLEAN_ARRAY *node);
static long std_types__boolean_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_character_array_data(CHARACTER_ARRAY_DATA *data);
static void *std_types__character_array___collect(CHARACTER_ARRAY *node);
static long std_types__character_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int8_array_data(INT8_ARRAY_DATA *data);
static void *std_types__int8_array___collect(INT8_ARRAY *node);
static long std_types__int8_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint8_array_data(UINT8_ARRAY_DATA *data);
static void *std_types__uint8_array___collect(UINT8_ARRAY *node);
static long std_types__uint8_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int16_array_data(INT16_ARRAY_DATA *data);
static void *std_types__int16_array___collect(INT16_ARRAY *node);
static long std_types__int16_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint16_array_data(UINT16_ARRAY_DATA *data);
static void *std_types__uint16_array___collect(UINT16_ARRAY *node);
static long std_types__uint16_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int32_array_data(INT32_ARRAY_DATA *data);
static void *std_types__int32_array___collect(INT32_ARRAY *node);
static long std_types__int32_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint32_array_data(UINT32_ARRAY_DATA *data);
static void *std_types__uint32_array___collect(UINT32_ARRAY *node);
static long std_types__uint32_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_int64_array_data(INT64_ARRAY_DATA *data);
static void *std_types__int64_array___collect(INT64_ARRAY *node);
static long std_types__int64_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_uint64_array_data(UINT64_ARRAY_DATA *data);
static void *std_types__uint64_array___collect(UINT64_ARRAY *node);
static long std_types__uint64_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_float32_array_data(FLOAT32_ARRAY_DATA *data);
static void *std_types__float32_array___collect(FLOAT32_ARRAY *node);
static long std_types__float32_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *collect_float64_array_data(FLOAT64_ARRAY_DATA *data);
static void *std_types__float64_array___collect(FLOAT64_ARRAY *node);
static long std_types__float64_array___debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types__true___to_bool(NODE *node, int *result_p);
static long std_types__true___debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types__false___to_bool(NODE *node, int *result_p);
static long std_types__false___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *c_function___collect(C_FUNCTION *node);
static long c_function___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__character___collect(CHARACTER *node);
static uint32_t std_types__character___to_uchar32(NODE *node, uint32_t *result_p);
static long std_types__character___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__date_and_time___collect(DATE_AND_TIME *node);
static long std_types__date_and_time___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__error___collect(ERROR *node);
static long std_types__error___debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types__object___to_int8(NODE *node);
static int std_types__undefined___to_int8(NODE *node);
static int std_types__object___to_int16(NODE *node);
static int std_types__undefined___to_int16(NODE *node);
static int std_types__object___to_int32(NODE *node);
static int std_types__undefined___to_int32(NODE *node);
static int std_types__object___to_int64(NODE *node);
static int std_types__undefined___to_int64(NODE *node);
static int std_types__object___to_uint8(NODE *node);
static int std_types__undefined___to_uint8(NODE *node);
static int std_types__object___to_uint16(NODE *node);
static int std_types__undefined___to_uint16(NODE *node);
static int std_types__object___to_uint32(NODE *node);
static int std_types__undefined___to_uint32(NODE *node);
static int std_types__object___to_uint64(NODE *node);
static int std_types__undefined___to_uint64(NODE *node);
static int std_types__object___to_uchar32(NODE *node);
static int std_types__undefined___to_uchar32(NODE *node);
static int std_types__object___to_bool(NODE *node);
static int std_types__undefined___to_bool(NODE *node);
static int std_types__object___to_int(NODE *node);
static int std_types__undefined___to_int(NODE *node);
static int std_types__object___to_uint(NODE *node);
static int std_types__undefined___to_uint(NODE *node);
static int std_types__object___to_long(NODE *node);
static int std_types__undefined___to_long(NODE *node);
static int std_types__object___to_ulong(NODE *node);
static int std_types__undefined___to_ulong(NODE *node);
static int std_types__object___to_float(NODE *node);
static int std_types__undefined___to_float(NODE *node);
static int std_types__object___to_double(NODE *node);
static int std_types__undefined___to_double(NODE *node);
static int std_types__object___to_c_string(NODE *node);
static int std_types__undefined___to_c_string(NODE *node);
static int std_types__object___to_octets(NODE *node);
static int std_types__undefined___to_octets(NODE *node);
static int std_types__object___get_item_of(NODE *node);
static int std_types__undefined___get_item_of(NODE *node);
static int std_types__object___length_of(NODE *node);
static int std_types__undefined___length_of(NODE *node);
static int std_types__object___unfold(NODE *node);
static int std_types__undefined___unfold(NODE *node);
static long std_types__function___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__list___collect(LIST *node);
static long std_types__list___debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types__list___get_item_of(NODE *node, long idx, NODE **result_p);
static int std_types__list___unfold(NODE *list);
static int std_types__list___length_of(NODE *node, long *result_p);
static void *std_types__integer___collect(INTEGER *node);
static void *std_types__real___collect(REAL *node);
static long builtin_types__positive_integer___debug_string(NODE *node, int indent, int max_depth, char *buf);
static long builtin_types__negative_integer___debug_string(NODE *node, int indent, int max_depth, char *buf);
static long std_types__real___debug_string(NODE *node, int indent, int max_depth, char *buf);
static int builtin_types__positive_integer___to_double(NODE *node, double *result_p);
static int builtin_types__positive_integer___to_float(NODE *node, float *result_p);
static int builtin_types__negative_integer___to_double(NODE *node, double *result_p);
static int builtin_types__negative_integer___to_float(NODE *node, float *result_p);
static int std_types__real___to_double(NODE *node, double *result_p);
static int std_types__real___to_float(NODE *node, float *result_p);
static int builtin_types__positive_integer___to_int(NODE *node, int *result_p);
static int builtin_types__negative_integer___to_int(NODE *node, int *result_p);
static int builtin_types__positive_integer___to_long(NODE *node, long *result_p);
static int builtin_types__negative_integer___to_long(NODE *node, long *result_p);
static int builtin_types__positive_integer___to_uint(NODE *node, uint *result_p);
static int builtin_types__positive_integer___to_ulong(NODE *node, unsigned long *result_p);
static int builtin_types__positive_integer___to_int8(NODE *node, int8_t *result_p);
static int builtin_types__negative_integer___to_int8(NODE *node, int8_t *result_p);
static int builtin_types__positive_integer___to_int16(NODE *node, int16_t *result_p);
static int builtin_types__negative_integer___to_int16(NODE *node, int16_t *result_p);
static int builtin_types__positive_integer___to_int32(NODE *node, int32_t *result_p);
static int builtin_types__negative_integer___to_int32(NODE *node, int32_t *result_p);
static int builtin_types__positive_integer___to_int64(NODE *node, int64_t *result_p);
static int builtin_types__negative_integer___to_int64(NODE *node, int64_t *result_p);
static int builtin_types__positive_integer___to_uint8(NODE *node, uint8_t *result_p);
static int builtin_types__positive_integer___to_uint16(NODE *node, uint16_t *result_p);
static int builtin_types__positive_integer___to_uint32(NODE *node, uint32_t *result_p);
static int builtin_types__positive_integer___to_uint64(NODE *node, uint64_t *result_p);
static void *std_types__object___collect(SIMPLE_NODE *node);
static long std_types__object___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__file_type___collect(FILE_TYPE *node);
static long std_types__file_type___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__file_descriptor___collect(FILE_DESCRIPTOR *node);
static long std_types__file_descriptor___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__signal_number___collect(SIGNAL_NUMBER *node);
static long std_types__signal_number___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__shutdown_type___collect(SHUTDOWN_TYPE *node);
static long std_types__shutdown_type___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__seek_type___collect(SEEK_TYPE *node);
static long std_types__seek_type___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__device_id___collect(DEVICE_ID *node);
static long std_types__device_id___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__directory___collect(DIRECTORY *node);
static long std_types__directory___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__group_id___collect(GROUP_ID *node);
static long std_types__group_id___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__inode_number___collect(INODE_NUMBER *node);
static long std_types__inode_number___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__process_id___collect(PROCESS_ID *node);
static long std_types__process_id___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__user_id___collect(USER_ID *node);
static long std_types__user_id___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__error_number___collect(ERROR_NUMBER *node);
static long std_types__error_number___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__octet_string___collect(OCTET_STRING *node);
static void *std_types__wide_string___collect(WIDE_STRING *node);
static long std_types__octet_string___debug_string(NODE *node, int indent, int max_depth, char *buf);
static long std_types__wide_string___debug_string(NODE *node, int indent, int max_depth, char *buf);
static int std_types__octet_string___get_item_of(NODE *node, long idx, NODE **result_p);
static int std_types__wide_string___get_item_of(NODE *node, long idx, NODE **result_p);
static int std_types__octet_string___to_c_string(NODE *node, char **result_p);
static int std_types__octet_string___to_octets(NODE *node, const uint8_t **buf_p, long *size_p);
static int std_types__octet_string___length_of(NODE *node, long *result_p);
static int std_types__wide_string___length_of(NODE *node, long *result_p);
static void *std_types__terminal_attributes___collect(TERMINAL_ATTRIBUTES *node);
static long std_types__terminal_attributes___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple2___collect(TUPLE2 *node);
static long builtin_types__tuple2___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple3___collect(TUPLE3 *node);
static long builtin_types__tuple3___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple4___collect(TUPLE4 *node);
static long builtin_types__tuple4___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple5___collect(TUPLE5 *node);
static long builtin_types__tuple5___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple6___collect(TUPLE6 *node);
static long builtin_types__tuple6___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple7___collect(TUPLE7 *node);
static long builtin_types__tuple7___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *builtin_types__tuple8___collect(TUPLE8 *node);
static long builtin_types__tuple8___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__undefined___collect(SIMPLE_NODE *node);
static long std_types__undefined___debug_string(NODE *node, int indent, int max_depth, char *buf);
static uint32_t to_upper_case(uint32_t chr);
static uint32_t to_lower_case(uint32_t chr);
static uint32_t to_title_case(uint32_t chr);
static void *std_types__unique_item___collect(UNIQUE_ITEM *node);
static long std_types__unique_item___debug_string(NODE *node, int indent, int max_depth, char *buf);
static void *std_types__shared_memory___collect(SHARED_MEMORY *node);
static long std_types__shared_memory___debug_string(NODE *node, int indent, int max_depth, char *buf);

int to_int8
  (
    NODE *node, int8_t *result_p
  )
  {
    return node->attributes->vtable->to_int8(node, result_p);
  }

int to_int16
  (
    NODE *node, int16_t *result_p
  )
  {
    return node->attributes->vtable->to_int16(node, result_p);
  }

int to_int32
  (
    NODE *node, int32_t *result_p
  )
  {
    return node->attributes->vtable->to_int32(node, result_p);
  }

int to_int64
  (
    NODE *node, int64_t *result_p
  )
  {
    return node->attributes->vtable->to_int64(node, result_p);
  }

int to_uint8
  (
    NODE *node, uint8_t *result_p
  )
  {
    return node->attributes->vtable->to_uint8(node, result_p);
  }

int to_uint16
  (
    NODE *node, uint16_t *result_p
  )
  {
    return node->attributes->vtable->to_uint16(node, result_p);
  }

int to_uint32
  (
    NODE *node, uint32_t *result_p
  )
  {
    return node->attributes->vtable->to_uint32(node, result_p);
  }

int to_uint64
  (
    NODE *node, uint64_t *result_p
  )
  {
    return node->attributes->vtable->to_uint64(node, result_p);
  }

int to_uchar32
  (
    NODE *node, uint32_t *result_p
  )
  {
    return node->attributes->vtable->to_uchar32(node, result_p);
  }

int to_bool
  (
    NODE *node, int *result_p
  )
  {
    return node->attributes->vtable->to_bool(node, result_p);
  }

int to_int
  (
    NODE *node, int *result_p
  )
  {
    return node->attributes->vtable->to_int(node, result_p);
  }

int to_uint
  (
    NODE *node, unsigned int *result_p
  )
  {
    return node->attributes->vtable->to_uint(node, result_p);
  }

int to_long
  (
    NODE *node, long *result_p
  )
  {
    return node->attributes->vtable->to_long(node, result_p);
  }

int to_ulong
  (
    NODE *node, unsigned long *result_p
  )
  {
    return node->attributes->vtable->to_ulong(node, result_p);
  }

int to_float
  (
    NODE *node, float *result_p
  )
  {
    return node->attributes->vtable->to_float(node, result_p);
  }

int to_double
  (
    NODE *node, double *result_p
  )
  {
    return node->attributes->vtable->to_double(node, result_p);
  }

int to_c_string
  (
    NODE *node, char **result_p
  )
  {
    return node->attributes->vtable->to_c_string(node, result_p);
  }

int to_octets
  (
    NODE *node, const uint8_t** buf_p, long *size_p
  )
  {
    return node->attributes->vtable->to_octets(node, buf_p, size_p);
  }

int get_item_of
  (
    NODE *node, long idx, NODE **result_p
  )
  {
    return node->attributes->vtable->get_item_of(node, idx, result_p);
  }

int length_of
  (
    NODE *node, long *result_p
  )
  {
    return node->attributes->vtable->length_of(node, result_p);
  }

int unfold
  (
    NODE *node
  )
  {
    return node->attributes->vtable->unfold(node);
  }

int debug_string
  (
    NODE *node, int indent, int max_depth, char *buf
  )
  {
    return node->attributes->vtable->debug_string(node, indent, max_depth, buf);
  }

static void *collect_array_info
  (
    ARRAY_INFO *info
  )
  {
    ARRAY_INFO *new_info = info;
    long size = info->dimension_count; // might be garbage if already collected
    int is_collected = IS_COLLECTED(info);
    if (is_collected) {
      void *new_location = *(void **)info;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_info = allocate(ALLOCATION_SIZE(sizeof(ARRAY_INFO)+size*sizeof(long)));
      new_info->dimension_count = info->dimension_count;
      memcpy(new_info->dimensions, info->dimensions, size*sizeof(long));
    }
    if (is_collected) *(void **)info = ENCODE_TO_LENGTH(new_info);
    return new_info;
  }

static void *collect_dimension_info
  (
    DIMENSION_INFO *info
  )
  {
    DIMENSION_INFO *new_info = info;
    int is_collected = IS_COLLECTED(info);
    if (is_collected) {
      void *new_location = *(void **)info;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_info = allocate(sizeof(DIMENSION_INFO));
      new_info->first_index = info->first_index;
      new_info->width = info->width;
    }
    if (is_collected) *(void **)info = ENCODE_TO_LENGTH(new_info);
    return new_info;
  }

static void *collect_array_view
  (
    ARRAY_VIEW *view
  )
  {
    ARRAY_VIEW *new_view = view;
    long size = view->dimension_count; // might be garbage if already collected
    int is_collected = IS_COLLECTED(view);
    if (is_collected) {
      void *new_location = *(void **)view;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_view = allocate(ALLOCATION_SIZE(sizeof(ARRAY_VIEW)+size*sizeof(DIMENSION_INFO)));
      new_view->dimension_count = view->dimension_count;
      memcpy(new_view->dimensions, view->dimensions, size*sizeof(DIMENSION_INFO));
    }
    if (is_collected) *(void **)view = ENCODE_TO_LENGTH(new_view);
    return new_view;
  }

static void *collect_array_updates
  (
    ARRAY_UPDATES *updates
  )
  {
    if (!updates) return updates;
    ARRAY_UPDATES *new_updates = updates;
    long size = updates->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(updates);
    if (is_collected) {
      void *new_location = *(void **)updates;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_updates = allocate(ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+size*sizeof(char)));
      new_updates->size = size;
      new_updates->length = size;
      memcpy(new_updates->buffer, updates->buffer, size*sizeof(char));
    } else {
      if (!IS_STATIC(updates)) {
	if (IS_ALREADY_MARKED(updates)) return updates;
	MARK(updates)
      }
    }
    if (is_collected) *(void **)updates = ENCODE_TO_LENGTH(new_updates);
    return new_updates;
  }

static ARRAY_VIEW *create_array_view
  (
    int dimension_count
  )
  {
    ARRAY_VIEW *view =
      allocate(ALLOCATION_SIZE(
	sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
    view->dimension_count = dimension_count;
    for (int i = 0; i < dimension_count; ++i) {
      long dimension;
      if (!to_long(TLS_arguments[i], &dimension)) return NULL;
      if (dimension < 1) {
	invalid_arguments();
	return NULL;
      }
      view->dimensions[i].first_index = 0;
      view->dimensions[i].width = dimension;
    }
    return view;
  }

static ARRAY_VIEW *create_new_array_view
  (
    ARRAY_VIEW *view
  )
  {
    int dimension_count = view->dimension_count;
    ARRAY_VIEW *new_view =
      allocate(ALLOCATION_SIZE(
	sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
    new_view->dimension_count = dimension_count;
    for (int i = 0; i < dimension_count; ++i) {
      new_view->dimensions[i].first_index = 0;
      new_view->dimensions[i].width = view->dimensions[i].width;
    }
    return new_view;
  }

static ARRAY_DATA *create_array_info_and_data
  (
    ARRAY_VIEW *view,
    int item_size
  )
  {
    int dimension_count = view->dimension_count;
    ARRAY_INFO *info =
      allocate(
	ALLOCATION_SIZE(sizeof(ARRAY_INFO)+dimension_count*sizeof(long)));
    info->dimension_count = dimension_count;
    long size = 1;
    for (int i = dimension_count-1; i >= 0; --i) {
      info->dimensions[i] = size;
      size *= view->dimensions[i].width;
    }
    ARRAY_DATA *data =
      allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
    data->info = info;
    data->size = size;
    return data;
  }

static ARRAY_DATA *create_array_data
  (
    ARRAY_INFO *info,
    long size,
    int item_size
  )
  {
    ARRAY_DATA *data =
      allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
    data->info = info;
    data->size = size;
    return data;
  }

static void *copy_array
  (
    ARRAY_VIEW *source_view,
    ARRAY_DATA *source_data,
    long source_offset,
    int i,
    int item_size,
    void *destination
  )
  {
    int dimension_count = source_view->dimension_count;
    long first_index = source_view->dimensions[i].first_index;
    long width = source_view->dimensions[i].width;
    if (i == dimension_count-1) {
      // last dimension
      source_offset += first_index;
      memcpy(
	destination,
	(char *)source_data->items+source_offset*item_size,
	width*item_size);
      return (char *)destination+width*item_size;
    } else {
      long dimension = source_data->info->dimensions[i];
      source_offset += first_index*dimension;
      while (--width >= 0) {
	destination = copy_array(
	  source_view, source_data, source_offset, i+1, item_size,
	  destination);
	source_offset += dimension;
      }
      return destination;
    }
  }

static ARRAY_DATA *new_array_data
  (
    ARRAY_INFO *info,
    int item_size
  )
  {
    int dimension_count = info->dimension_count;
    long size = info->dimensions[0];
    for (int i = 1; i < dimension_count; ++i) {
      size *= info->dimensions[i];
    }
    ARRAY_DATA *data =
      allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
    data->info = info;
    data->size = size;
    return data;
  }

static ARRAY_VIEW *create_sub_view
  (
    ARRAY_VIEW *view
  )
  {
    int dimension_count = view->dimension_count;
    ARRAY_VIEW *sub_view =
      allocate(ALLOCATION_SIZE(
	sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
    sub_view->dimension_count = dimension_count;
    int i;
    for (i = 0; i < dimension_count; ++i) {
      NODE *argument = TLS_arguments[1+i];
      if ((argument)->type != std_types__value_range.type) {
	invalid_arguments();
	return NULL;
      }
      long first;
      long last;
      if (
	!to_long(argument->tuple2.node_0, &first) ||
	!to_long(argument->tuple2.node_1, &last)
      ) {
	invalid_arguments();
	return NULL;
      }
      if (first < 0) {
	first += view->dimensions[i].width;
      } else {
	--first;
      }

      if (last < 0) {
	last += view->dimensions[i].width;
      } else {
	--last;
      }
      if (
	first < 0 || first >= view->dimensions[i].width ||
	last < 0 || last >= view->dimensions[i].width ||
	first > last
      ) {
	invalid_arguments();
	return NULL;
      }
      sub_view->dimensions[i].first_index =
	view->dimensions[i].first_index+first;
      sub_view->dimensions[i].width = last-first+1;
    }
    return sub_view;
  }

static void *add_update
  (
    ARRAY *node,
    long item_size
  )
  {
    long length = node->updates_length;
    ARRAY_UPDATES *updates = node->updates;
    if (length == 0) {
      long size = ALLOCATION_SIZE(item_size);
      updates = allocate_large(sizeof(ARRAY_UPDATES)+size);
      updates->size = size;
      updates->length = length+item_size;
    } else if (
      length != node->updates->length ||
      length+item_size > node->updates->size
    ) {
      long size = ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+2*length+item_size);
      updates = allocate_large(size);
      updates->size = size;
      memcpy(updates->buffer, node->updates->buffer, length);
    }
    updates->length = length+item_size;
    ARRAY *new_node = allocate(sizeof(ARRAY));
    new_node->type = node->type;
    new_node->attributes = node->attributes;
    new_node->updates_length = length+item_size;
    new_node->data = node->data;
    new_node->view = node->view;
    new_node->updates = updates;
    return new_node;
  }

static long compute_array_read_offset
  (
    NODE *array,
    ARRAY_INFO *info,
    ARRAY_VIEW *view
  )
  {
    long offset = 0;
    int i = 0;
    long idx;
    next:
    if (!to_long(TLS_arguments[i], &idx)) return -1;
    if (idx < 0) {
      idx += view->dimensions[i].width;
    } else {
      --idx;
    }
    if (idx < 0 || idx >= view->dimensions[i].width) {
      invalid_index(array);
      return -1;
    }
    idx += view->dimensions[i].first_index;
    offset += idx*info->dimensions[i];
    if (++i >= view->dimension_count) return offset;
    goto next;
  }

static long compute_array_write_offset
  (
    NODE *array,
    ARRAY_INFO *info,
    ARRAY_VIEW *view
  )
  {
    long offset = 0;
    int i = 0;
    long idx;
    next:
    if (!to_long(TLS_arguments[i], &idx)) return -1;
    if (idx < 0) {
      idx += view->dimensions[i].width;
    } else {
      --idx;
    }
    if (idx < 0 || idx >= view->dimensions[i].width) {
      invalid_index(array);
      return -1;
    }
    offset += idx;
    if (++i >= view->dimension_count) return offset;
    offset *= view->dimensions[i].width;
    goto next;
  }

static long array_debug_string
  (
    ARRAY_INFO *info,
    ARRAY_VIEW *view,
    int indent,
    char *buf,
    const char *typename
  )
  {
    char type[1024];
    char *p = type;
    print(&p, "<%s_array(", typename);
    int i;
    int dimension_count = view->dimension_count;
    for (i = 0; i < dimension_count; ++i) {
      if (i) *p++ = ' ';
      print(&p,
	"%d..%d",
	view->dimensions[i].first_index+1,
	view->dimensions[i].first_index+view->dimensions[i].width
      );
    }
    *p++ = ')';
    *p++ = '>';
    *p = 0;
    return debug_print(indent, buf, type);
  }

static int equal_array_type
  (
    NODE *left,
    NODE *right
  )
  {
    if ((left)->type != (right)->type) {
      error:
      invalid_arguments();
      return false;
    }
    ARRAY_VIEW *left_view = ((ARRAY *)left)->view;
    ARRAY_VIEW *right_view = ((ARRAY *)right)->view;
    if (
      left_view->dimension_count != right_view->dimension_count
    ) goto error;
    int i;
    for (i = 0; i < left_view->dimension_count; ++i) {
      if (
	left_view->dimensions[i].width != right_view->dimensions[i].width
      ) goto error;
    }
    return true;
  }

static void *collect_array_data
  (
    ARRAY_DATA *data
  )
  {
    if (!data) return data;
    ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*sizeof(NODE *)));
      new_data->size = size;
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    int i;
    for (i = 0; i < size; ++i) {
      new_data->items[i] = collect_node(data->items[i]);
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__array___collect
  (
    ARRAY *node
  )
  {
    ARRAY *new_node;
    new_node = allocate(sizeof(ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static ARRAY_DATA *apply_array_updates(ARRAY *node)
  {
    ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(NODE *));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(NODE *), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->array.data->info, node->array.view,
      indent, buf, "");
  }

static void *collect_boolean_array_data
  (
    BOOLEAN_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    BOOLEAN_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__boolean_array___collect
  (
    BOOLEAN_ARRAY *node
  )
  {
    BOOLEAN_ARRAY *new_node;
    new_node = allocate(sizeof(BOOLEAN_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_boolean_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static BOOLEAN_ARRAY_DATA *apply_boolean_array_updates(BOOLEAN_ARRAY *node)
  {
    BOOLEAN_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (BOOLEAN_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__boolean_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->boolean_array.data->info, node->boolean_array.view,
      indent, buf, "boolean");
  }

static void *collect_character_array_data
  (
    CHARACTER_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    CHARACTER_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(CHARACTER_ARRAY_DATA)+size*sizeof(uint32_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__character_array___collect
  (
    CHARACTER_ARRAY *node
  )
  {
    CHARACTER_ARRAY *new_node;
    new_node = allocate(sizeof(CHARACTER_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_character_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static CHARACTER_ARRAY_DATA *apply_character_array_updates(CHARACTER_ARRAY *node)
  {
    CHARACTER_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (CHARACTER_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint32_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint32_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__character_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->character_array.data->info, node->character_array.view,
      indent, buf, "uchar32");
  }

static void *collect_int8_array_data
  (
    INT8_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT8_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT8_ARRAY_DATA)+size*sizeof(int8_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int8_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__int8_array___collect
  (
    INT8_ARRAY *node
  )
  {
    INT8_ARRAY *new_node;
    new_node = allocate(sizeof(INT8_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int8_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT8_ARRAY_DATA *apply_int8_array_updates(INT8_ARRAY *node)
  {
    INT8_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT8_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int8_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int8_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__int8_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int8_array.data->info, node->int8_array.view,
      indent, buf, "int8");
  }

static long int8_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT8_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT8_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int8_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint8_array_data
  (
    UINT8_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT8_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint8_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__uint8_array___collect
  (
    UINT8_ARRAY *node
  )
  {
    UINT8_ARRAY *new_node;
    new_node = allocate(sizeof(UINT8_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint8_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT8_ARRAY_DATA *apply_uint8_array_updates(UINT8_ARRAY *node)
  {
    UINT8_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT8_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint8_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint8_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__uint8_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint8_array.data->info, node->uint8_array.view,
      indent, buf, "uint8");
  }

static unsigned long uint8_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT8_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT8_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    unsigned long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint8_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_int16_array_data
  (
    INT16_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT16_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT16_ARRAY_DATA)+size*sizeof(int16_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int16_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__int16_array___collect
  (
    INT16_ARRAY *node
  )
  {
    INT16_ARRAY *new_node;
    new_node = allocate(sizeof(INT16_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int16_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT16_ARRAY_DATA *apply_int16_array_updates(INT16_ARRAY *node)
  {
    INT16_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT16_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int16_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int16_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__int16_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int16_array.data->info, node->int16_array.view,
      indent, buf, "int16");
  }

static long int16_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT16_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT16_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int16_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint16_array_data
  (
    UINT16_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT16_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint16_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__uint16_array___collect
  (
    UINT16_ARRAY *node
  )
  {
    UINT16_ARRAY *new_node;
    new_node = allocate(sizeof(UINT16_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint16_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT16_ARRAY_DATA *apply_uint16_array_updates(UINT16_ARRAY *node)
  {
    UINT16_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT16_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint16_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint16_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__uint16_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint16_array.data->info, node->uint16_array.view,
      indent, buf, "uint16");
  }

static unsigned long uint16_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT16_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT16_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    unsigned long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint16_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_int32_array_data
  (
    INT32_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT32_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT32_ARRAY_DATA)+size*sizeof(int32_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__int32_array___collect
  (
    INT32_ARRAY *node
  )
  {
    INT32_ARRAY *new_node;
    new_node = allocate(sizeof(INT32_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int32_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT32_ARRAY_DATA *apply_int32_array_updates(INT32_ARRAY *node)
  {
    INT32_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT32_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int32_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int32_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__int32_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int32_array.data->info, node->int32_array.view,
      indent, buf, "int32");
  }

static long int32_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT32_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT32_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int32_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint32_array_data
  (
    UINT32_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT32_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__uint32_array___collect
  (
    UINT32_ARRAY *node
  )
  {
    UINT32_ARRAY *new_node;
    new_node = allocate(sizeof(UINT32_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint32_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT32_ARRAY_DATA *apply_uint32_array_updates(UINT32_ARRAY *node)
  {
    UINT32_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT32_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint32_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint32_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__uint32_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint32_array.data->info, node->uint32_array.view,
      indent, buf, "uint32");
  }

static unsigned long uint32_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT32_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT32_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    unsigned long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint32_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_int64_array_data
  (
    INT64_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    INT64_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(INT64_ARRAY_DATA)+size*sizeof(int64_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(int64_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__int64_array___collect
  (
    INT64_ARRAY *node
  )
  {
    INT64_ARRAY *new_node;
    new_node = allocate(sizeof(INT64_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_int64_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static INT64_ARRAY_DATA *apply_int64_array_updates(INT64_ARRAY *node)
  {
    INT64_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (INT64_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(int64_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(int64_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_INT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__int64_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int64_array.data->info, node->int64_array.view,
      indent, buf, "int64");
  }

static long int64_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    INT64_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    INT64_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += int64_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_uint64_array_data
  (
    UINT64_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    UINT64_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(uint64_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__uint64_array___collect
  (
    UINT64_ARRAY *node
  )
  {
    UINT64_ARRAY *new_node;
    new_node = allocate(sizeof(UINT64_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_uint64_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static UINT64_ARRAY_DATA *apply_uint64_array_updates(UINT64_ARRAY *node)
  {
    UINT64_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (UINT64_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(uint64_t));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(uint64_t), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_UINT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__uint64_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint64_array.data->info, node->uint64_array.view,
      indent, buf, "uint64");
  }

static unsigned long uint64_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    UINT64_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    UINT64_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    unsigned long result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += uint64_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_float32_array_data
  (
    FLOAT32_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    FLOAT32_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(FLOAT32_ARRAY_DATA)+size*sizeof(float)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(float));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__float32_array___collect
  (
    FLOAT32_ARRAY *node
  )
  {
    FLOAT32_ARRAY *new_node;
    new_node = allocate(sizeof(FLOAT32_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_float32_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static FLOAT32_ARRAY_DATA *apply_float32_array_updates(FLOAT32_ARRAY *node)
  {
    FLOAT32_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (FLOAT32_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(float));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(float), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__float32_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float32_array.data->info, node->float32_array.view,
      indent, buf, "float32");
  }

static double float32_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    FLOAT32_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    FLOAT32_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    double result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += float32_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static void *collect_float64_array_data
  (
    FLOAT64_ARRAY_DATA *data
  )
  {
    if (!data) return data;
    FLOAT64_ARRAY_DATA *new_data = data;
    long size = data->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(FLOAT64_ARRAY_DATA)+size*sizeof(double)));
      new_data->size = size;
      memcpy(new_data->items, data->items, size*sizeof(double));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    new_data->info = collect_array_info(data->info);
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__float64_array___collect
  (
    FLOAT64_ARRAY *node
  )
  {
    FLOAT64_ARRAY *new_node;
    new_node = allocate(sizeof(FLOAT64_ARRAY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->updates_length = node->updates_length;
    new_node->view = collect_array_view(node->view);
    new_node->data = collect_float64_array_data(node->data);
    new_node->updates = collect_array_updates(node->updates);
    return new_node;
  }

static FLOAT64_ARRAY_DATA *apply_float64_array_updates(FLOAT64_ARRAY *node)
  {
    FLOAT64_ARRAY_DATA *data = node->data;
    if (node->updates_length > 0) {
      ARRAY_VIEW *view = create_new_array_view(node->view);
      data = (FLOAT64_ARRAY_DATA *)
	create_array_info_and_data(view, sizeof(double));
      // copy items
      copy_array(
	node->view, (ARRAY_DATA *)node->data, 0, 0,
	sizeof(double), data->items);
      // apply updates
      char *update = node->updates->buffer;
      char *end_p = update+node->updates_length;
      while (update < end_p) {
	switch (*(TAG *)update) {
	  case SET_VALUE:;
	    UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	    data->items[set_value->offset] = set_value->value;
	    update += sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE);
	    break;
	}
      }
      node->updates_length = 0;
      node->view = view;
      node->data = data;
      node->updates = NULL;
    }
    return data;
  }

static long std_types__float64_array___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float64_array.data->info, node->float64_array.view,
      indent, buf, "float64");
  }

static double float64_array_scalar_product
  (
    ARRAY_VIEW *left_view,
    FLOAT64_ARRAY_DATA *left_data,
    long left_offset,
    ARRAY_VIEW *right_view,
    FLOAT64_ARRAY_DATA *right_data,
    long right_offset,
    int i
  )
  {
    int dimension_count = left_view->dimension_count;
    long first_left_index = left_view->dimensions[i].first_index;
    long first_right_index = right_view->dimensions[i].first_index;
    long width = left_view->dimensions[i].width;
    double result = 0;
    if (i == dimension_count-1) {
      // last dimension
      left_offset += first_left_index;
      right_offset += first_right_index;
      while (--width >= 0) {
	result +=
	  left_data->items[left_offset++] *
	  right_data->items[right_offset++];
      }
    } else {
      long left_dimension = left_data->info->dimensions[0];
      long right_dimension = right_data->info->dimensions[0];
      left_offset += first_left_index*left_dimension;
      right_offset += first_right_index*right_dimension;
      while (--width >= 0) {
	result += float64_array_scalar_product(
	  left_view, left_data, left_offset,
	  right_view, right_data, right_offset, i+1);
	left_offset += left_dimension;
	right_offset += right_dimension;
      }
    }
    return result;
  }

static int std_types__true___to_bool
  (
    NODE *node,
    int *result_p
  )
  {
    *result_p = true;
    return true;
  }

static long std_types__true___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "true");
  }

static int std_types__false___to_bool
  (
    NODE *node,
    int *result_p
  )
  {
    *result_p = false;
    return true;
  }

static long std_types__false___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "false");
  }

NODE *from_bool
  (
    int val
  )
  {
    if (val)
      return (NODE *)&std_types__true;
    else
      return (NODE *)&std_types__false;
  }

static void *c_function___collect
  (
    C_FUNCTION *node
  )
  {
    C_FUNCTION *new_node;
    new_node = allocate(sizeof(C_FUNCTION));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->parameter_count = node->parameter_count;
    return new_node;
  }

static long c_function___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<c function>");
  }

NODE *create_c_function
  (
    FUNC func,
    int par_cnt
  )
  {
    NODE *node = create__c_function(par_cnt);
    node->type = func;
    return node;
  }

static void *std_types__character___collect
  (
    CHARACTER *node
  )
  {
    CHARACTER *new_node;
    new_node = allocate(sizeof(CHARACTER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->code = node->code;
    return new_node;
  }

NODE *from_uchar32
  (
    uint32_t code
  )
  {
    return create__std_types__character(code);
  }

static uint32_t std_types__character___to_uchar32
  (
    NODE *node,
    uint32_t *result_p
  )
  {
    *result_p = node->character.code;
    return true;
  }

static long std_types__character___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    if (node->character.code == '@') {
      return debug_print(indent, buf, "'@@'");
    } else if (node->character.code == '\'') {
      return debug_print(indent, buf, "'@apos;'");
    } else if (
      node->character.code >= 0x20 && node->character.code < 0x7f /*||
      node->character.code >= 0xa0 && node->character.code < 0x100*/
    ) {
      return debug_print(indent, buf, "'%c'", node->character.code);
    } else {
      return debug_print(indent, buf, "'@0x%x;'", node->character.code);
    }
  }

static void *std_types__date_and_time___collect
  (
    DATE_AND_TIME *node
  )
  {
    DATE_AND_TIME *new_node;
    new_node = allocate(sizeof(DATE_AND_TIME));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->seconds = node->seconds;
    new_node->nanoseconds = node->nanoseconds;
    return new_node;
  }

static long std_types__date_and_time___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<date and time %d.%09d>",
      node->date_and_time.seconds, node->date_and_time.nanoseconds);
  }

static void year_month_day
  (
    NODE *node,
    int *year_p,
    int *month_p,
    int *day_p
  )
  {
    long days;
    int year, month, day, quads;
    int is_a_leap_year;
    days = node->date_and_time.seconds/86400;
    is_a_leap_year = false;
    if (days < 730) { // 1970, 1971
      year = days/365;
      days -= 365*year;
      year += 1970;
    } else { // 1972 and later
      days -= 730;
      quads = days/1461;
      days -= 1461*quads;
      year = 1972+4*quads;
      if (days >= 1096) {
	year += 3;
	days -= 1096;
      } else if (days >= 731) {
	year += 2;
	days -= 731;
      } else if (days >= 366) {
	++year;
	days -= 366;
      } else {
	is_a_leap_year = true;
      }
    }
    month = 1;
    if (days < 31) goto done; // January
    days -= 31;
    ++month;
    if (is_a_leap_year) {
      if (days < 29) goto done; // February
      days -= 29;
    } else {
      if (days < 28) goto done; // February
      days -= 28;
    }
    ++month;
    if (days < 31) goto done; // March
    days -= 31;
    ++month;
    if (days < 30) goto done; // April
    days -= 30;
    ++month;
    if (days < 31) goto done; // May
    days -= 31;
    ++month;
    if (days < 30) goto done; // June
    days -= 30;
    ++month;
    if (days < 31) goto done; // July
    days -= 31;
    ++month;
    if (days < 31) goto done; // August
    days -= 31;
    ++month;
    if (days < 30) goto done; // September
    days -= 30;
    ++month;
    if (days < 31) goto done; // October
    days -= 31;
    ++month;
    if (days < 30) goto done; // November
    days -= 30;
    ++month; // December
    done:
    if (year_p) *year_p = year;
    if (month_p) *month_p = month;
    if (day_p) *day_p = days+1;
  }

extern char **environ;

void initialize_environment
  (
    void
  )
  {
    memcpy(
      (NODE *)&std__program_name, from_c_string(main_argv[0]),
      sizeof(std__program_name));
    NODE *args = create_list(main_argc-1);
    int i;
    for (i = 1; i < main_argc; ++i) {
      set_list_item(args, i-1, from_c_string(main_argv[i]));
    }
    memcpy(
      (NODE *)&std__command_line_arguments, args,
      sizeof(std__command_line_arguments));
    char **p = environ;
    while (*p++);
    int n = p-environ-1;
    NODE *env_vars = create_list(n);
    for (i = 0; i < n; ++i) {
      set_list_item(env_vars, i, from_c_string(environ[i]));
    }
    memcpy(
      (NODE *)&std__environment_variables, env_vars,
      sizeof(std__environment_variables));
  }

static MESSAGE_TEXT *collect_message_text
  (
    MESSAGE_TEXT *text
  )
  {
    if (!text) return text;
    MESSAGE_TEXT *new_text = text;
    long size = text->size; // might be garbage if already collected
    int is_collected = IS_COLLECTED(text);
    if (is_collected) {
      void *new_location = *(void **)text;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_text = allocate(ALLOCATION_SIZE(sizeof(MESSAGE_TEXT)+size*sizeof(char)));
      new_text->size = size;
      memcpy(new_text->text, text->text, size*sizeof(char));
    } else {
      if (!IS_STATIC(text)) {
	if (IS_ALREADY_MARKED(text)) return text;
	MARK(text)
      }
    }
    if (is_collected) *(void **)text = ENCODE_TO_LENGTH(new_text);
    return new_text;
  }

static FUNC_DATA *collect_func_data
  (
    FUNC_DATA *data
  )
  {
    if (!data) return data;
    FUNC_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(FUNC_DATA)+size*sizeof(const TAB_NUM *)));
      new_data->length = size;
      memcpy(new_data->entries, data->entries, size*sizeof(const TAB_NUM *));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__error___collect
  (
    ERROR *node
  )
  {
    ERROR *new_node;
    new_node = allocate(sizeof(ERROR));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->err_no = node->err_no;
    new_node->attr_idx = node->attr_idx;
    new_node->instruction_counter = node->instruction_counter;
    new_node->category = collect_node(node->category);
    new_node->message = collect_message_text(node->message);
    new_node->object = collect_node(node->object);
    new_node->data = collect_func_data(node->data);
    return new_node;
  }

static long std_types__error___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    if (max_depth <= 1) {
      if (node->error.err_no) {
	return debug_print(
	  indent, buf, "<%s - %s>",
	  node->error.message->text, strerror(node->error.err_no));
      } else if (node->error.attr_idx) {
	return debug_print(
	  indent, buf, "<%s - %s>",
	  node->error.message->text,
	  polymorphic_function_names[node->error.attr_idx]);
      } else {
	return debug_print(indent, buf, "<%s>", node->error.message->text);
      }
    } else {
      FUNC_DATA *data = node->error.data;
      long n, len;
      long i;
      n = debug_print_indent(&indent, &buf);
      if (node->error.err_no) {
	if (node->error.instruction_counter) {
	  n += print(
	    &buf, "%s - %s! (instruction counter: %ld)\n",
	    node->error.message->text, strerror(node->error.err_no),
	    node->error.instruction_counter);
	} else {
	  n += print(
	    &buf, "%s - %s!\n",
	    node->error.message->text, strerror(node->error.err_no));
	}
      } else if (node->error.attr_idx) {
	if (node->error.instruction_counter) {
	  n += print(
	    &buf, "%s (%s)! (instruction counter: %ld)\n",
	    node->error.message->text,
	    polymorphic_function_names[node->error.attr_idx],
	    node->error.instruction_counter);
	} else {
	  n += print(
	    &buf, "%s (%s)!\n",
	    node->error.message->text,
	    polymorphic_function_names[node->error.attr_idx]);
	}
      } else {
	if (node->error.instruction_counter) {
	  n += print(
	    &buf, "%s! (instruction counter: %ld)\n",
	    node->error.message->text, node->error.instruction_counter);
	} else {
	  n += print(&buf, "%s!\n", node->error.message->text);
	}
      }
      if (node->error.object) {
	n += print(&buf, "%son object ", indent_to_string(indent));
	len = debug_string(node->error.object, indent, 1, buf);
	if (buf) buf += len;
	n += len;
      }
      const char *contents_indent = indent_to_string(indent);
      --max_depth;
      if (data->length < max_depth) {
	max_depth = data->length;
      }
      n += print(&buf, contents_indent);
      n += print(&buf, "stack trace:\n");
      for (i = 0; i < max_depth; ++i) {
	const char *module_name, *function_name;
	int line_no, column_no;
	const TAB_NUM *code = data->entries[i];
	n += print(&buf, contents_indent);
	retrieve_continuation_info(
	  code, &module_name, &function_name, &line_no, &column_no);
	if (function_name) {
	  n += print(&buf, "%s ", function_name);
	} else {
	  n += print(&buf, "<anonymous function> ");
	}
	n += print(&buf, "(called from %s", module_name);
	if (line_no > 0) {
	  n += print(&buf, ", line: %d, column: %d", line_no, column_no);
	}
	n += print(&buf, ")\n");
      }
      return n;
    }
  }

int propagate_error
  (
    NODE *node
  )
  {
    if (TLS_result_count < 1) TLS_result_count = 1;
    TLS_argument_count = TLS_result_count;
    for (int i = 0; i < TLS_result_count; ++i) {
      TLS_arguments[i] = node;
    }
    {
      NODE *result__node = (NODE *)(node);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
    return false;
  }

extern const TAB_NUM *tail_call_stack[256];
extern const TAB_NUM **tail_call_sp;
extern int do_dump_errors;

void print_code_reference
  (
    const TAB_NUM *code
  )
  {
    const char *module_name, *function_name;
    int line_no, column_no;
    retrieve_continuation_info(
      code, &module_name, &function_name, &line_no, &column_no);
    if (function_name) {
      fprintf(stderr, "%s ", function_name);
    } else {
      fprintf(stderr, "<anonymous function> ");
    }
    fprintf(stderr, "(called from %s", module_name);
    if (line_no > 0) {
      fprintf(stderr, ", line: %d, column: %d", line_no, column_no);
    }
    fprintf(stderr, ")\n");
  }

void create_error_message
  (
    NODE *category,
    const char *msg,
    int err_no,
    int attr_idx,
    NODE *node
  )
  {
    if (do_debug) {
      printf("E:%s\n", msg);
      sdd->break_at = instruction_counter;
    }
    NODE *err = NULL;
    int i;
    for (i = 0; i < TLS_argument_count; ++i) {
      if (TLS_arguments[i]->type == std_types__error.type) {
	err = TLS_arguments[i];
	break;
      }
    }
    if (!err) {
      if (do_dump_errors) {
	fprintf(stderr, "create error message \"%s\"\n", msg);
      }
      long size = ALLOCATION_SIZE(strlen(msg)+1);
      MESSAGE_TEXT *message = allocate(sizeof(MESSAGE_TEXT)+size);
      message->size = size;
      strcpy(message->text, msg);
      TLS_frame->code = TLS_code; // this was not initialized by the caller!
      long n = tail_call_sp-tail_call_stack;
      FRAME *trace = TLS_frame;
      while (trace) {
	++n;
	trace = trace->link;
      }
      --n; // do not use sentinel
      FUNC_DATA *data = allocate_large(sizeof(FUNC_DATA)+n*sizeof(TAB_NUM *));
      data->length = n;
      n = 0;
      while (tail_call_sp > tail_call_stack) {
	const TAB_NUM *code = *--tail_call_sp;
	if (do_dump_errors) {
	  fprintf(stderr, "tail call: ");
	  print_code_reference(code);
	}
	data->entries[n++] = code;
      }
      trace = TLS_frame;
      while (trace && trace->link) {
	if (do_dump_errors) print_code_reference(trace->code);
	data->entries[n++] = trace->code;
	trace = trace->link;
      }
      err =
	create__std_types__error(category, message, err_no, attr_idx, node, instruction_counter, data);
    }
    if (TLS_result_count < 1) TLS_result_count = 1;
    TLS_argument_count = TLS_result_count;
    for (i = 0; i < TLS_result_count; ++i) {
      TLS_arguments[i] = err;
    }
    {
      return;
    }
  }

static int std_types__object___to_int8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_int8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_int16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_int16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_int32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_int32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_int64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_int64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_uint8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_uint8
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_uint16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_uint16
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_uint32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_uint32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_uint64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_uint64
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_uchar32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A CHARACTER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_uchar32
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A CHARACTER", 0, 0, node);
    return false;
  }

static int std_types__object___to_bool
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A BOOLEAN", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_bool
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A BOOLEAN", 0, 0, node);
    return false;
  }

static int std_types__object___to_int
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_int
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_uint
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_uint
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_long
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_long
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_ulong
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_ulong
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT AN INTEGER", 0, 0, node);
    return false;
  }

static int std_types__object___to_float
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A NUMBER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_float
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A NUMBER", 0, 0, node);
    return false;
  }

static int std_types__object___to_double
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A NUMBER", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_double
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A NUMBER", 0, 0, node);
    return false;
  }

static int std_types__object___to_c_string
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_c_string
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types__object___to_octets
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types__undefined___to_octets
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ARGUMENT IS NOT A STRING", 0, 0, node);
    return false;
  }

static int std_types__object___get_item_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE UNDEFINED INTERNAL FUNCTION \"get_item_of\"",
      0, 0, node);
    return false;
  }

static int std_types__undefined___get_item_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE INTERNAL FUNCTION \"get_item_of\" ON AN UNDEFINED OBJECT", 0, 0, node);
    return false;
  }

static int std_types__object___length_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE UNDEFINED INTERNAL FUNCTION \"length_of\"",
      0, 0, node);
    return false;
  }

static int std_types__undefined___length_of
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE INTERNAL FUNCTION \"length_of\" ON AN UNDEFINED OBJECT", 0, 0, node);
    return false;
  }

static int std_types__object___unfold
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE UNDEFINED INTERNAL FUNCTION \"unfold\"",
      0, 0, node);
    return false;
  }

static int std_types__undefined___unfold
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTEMPT TO CALL THE INTERNAL FUNCTION \"unfold\" ON AN UNDEFINED OBJECT", 0, 0, node);
    return false;
  }

void no_such_function
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "NO SUCH FUNCTION", 0, 0, NULL);
  }

void invalid_attribute_redefinition
  (
    NODE *node,
    int attr_idx
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "INVALID ATTRIBUTE REDEFINITION", 0, attr_idx, node);
  }

void attribute_has_no_setter
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "ATTRIBUTE HAS NO SETTER",
      0, decode_attribute_index(last_attr_idx), TLS_arguments[0]);
  }

void too_few_arguments
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "TOO FEW ARGUMENTS", 0, 0, NULL);
  }

void too_many_arguments
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "TOO MANY ARGUMENTS", 0, 0, NULL);
  }

void invalid_arguments
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "INVALID ARGUMENTS", 0, 0, NULL);
  }

void result_count_mismatch
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "RESULT COUNT MISMATCH", 0, 0, NULL);
  }

void too_few_results
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "TOO FEW RESULTS", 0, 0, NULL);
  }

void too_many_results
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "TOO MANY RESULTS", 0, 0, NULL);
  }

void invalid_results
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "INVALID RESULTS", 0, 0, NULL);
  }

void invalid_index
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "INVALID INDEX", 0, 0, node);
  }

void invalid_dimension
  (
    NODE *node
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "INVALID DIMENSION", 0, 0, node);
  }

void divide_by_zero
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "DIVIDE BY ZERO", 0, 0, NULL);
  }

void missing_io_access_rights
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "MISSING IO ACCESS RIGHTS", 0, 0, NULL);
  }

void not_yet_implemented
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "NOT YET IMPLEMENTED", 0, 0, NULL);
  }

void open_failed
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__IO_ERROR-1],
      "OPEN FAILED", errno, 0, NULL);
  }

void close_failed
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__IO_ERROR-1],
      "CLOSE FAILED", errno, 0, NULL);
  }

void read_error
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__IO_ERROR-1],
      "READ ERROR", errno, 0, NULL);
  }

void write_error
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__IO_ERROR-1],
      "WRITE ERROR", errno, 0, NULL);
  }

void flush_failed
  (
    void
  )
  {
    create_error_message(
      module__builtin.constants_base[unique__std__IO_ERROR-1],
      "FLUSH FAILED", errno, 0, NULL);
  }

int close_fd(int *fd_p) {
  int err = 0;
  if (*fd_p >= 0) {
    do {
      err = close(*fd_p);
    } while (err == -1 && errno == EINTR);
    *fd_p = -1;
  }
  return err;
}

int dup_fd(int src_fd) {
  int fd;
  do {
    fd = dup(src_fd);
  } while (fd == -1 && errno == EINTR);
  return fd;
}

int dup2_fd(int src_fd, int dest_fd) {
  int err;
  do {
    err = dup2(src_fd, dest_fd);
  } while (err == -1 && errno == EINTR);
  return err;
}

static void close_on_exec
(
  int fd
)
{
  int flags;
  do {
    flags = fcntl(fd, F_GETFD);
  } while (flags == -1 && errno == EINTR);
  if (flags != -1) {
    flags |= FD_CLOEXEC;
    int result;
    do {
      result = fcntl(fd, F_SETFD, flags);
    } while (result == -1 && errno == EINTR);
  }
}

static long std_types__function___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    const char *module_name, *function_name;
    int line_no, column_no;
    const TAB_NUM *code =
      do_debug
      ? ((FUNCTION_INFO *)((unsigned long)node->type & -4L))->code
      : (const TAB_NUM *)((unsigned long)node->type & -4L);
    retrieve_continuation_info(
      code, &module_name, &function_name, &line_no, &column_no);
    return
      debug_print(
	indent, buf,
	"<function in module %s %d:%d>",
	module_name, line_no, column_no);
  }

NODE *create_function
  (
    const TAB_NUM *code
  )
  {
    NODE *node = create__tabular_function();
    node->type = (FUNC)((unsigned long)code|TABULAR_FUNCTION_TAG);
    return node;
  }

static LIST_DATA *collect_list_data
  (
    LIST_DATA *data
  )
  {
    if (!data) return data;
    LIST_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(LIST_DATA)+size*sizeof(NODE *)));
      new_data->size = size;
      new_data->length = size;
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    int i;
    for (i = 0; i < size; ++i) {
      new_data->items[i] = collect_node(data->items[i]);
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__list___collect
  (
    LIST *node
  )
  {
    if (!node) return node;
    LIST *new_node;
    long size = node->length; // might be garbage if already collected
    new_node = allocate(sizeof(LIST));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->offset = node->offset;
    new_node->length = size;
    new_node->data = collect_list_data(node->data);
    return new_node;
  }

static long std_types__list___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (node->list.length == 0) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  n = 1;
	}
	n += print(&buf, "<empty_list-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<empty_list>", node);
      /*}*/
    } else {
      if (max_depth <= 1) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<list");
	/*if (subtype) {
	  if (buf) *buf++ = '-';
	  ++n;
	  len = debug_string(subtype, 0, max_depth, buf);
	  --len; // remove trailing newline
	  if (buf) buf += len;
	  n += len;
	}*/
	if (node->list.length == 1) {
	  n += print(&buf, " of 1 item>\n", node);
	} else {
	  n += print(&buf, " of %ld items>\n", node->list.length);
	}
	return n;
      } else {
	long i;
	n = debug_print_indent(&indent, &buf);
	n += print(&buf, "list");
	/*if (subtype) {
	  if (buf) *buf++ = '-';
	  ++n;
	  len = debug_string(subtype, 0, max_depth, buf);
	  if (buf) buf += len;
	  n += len;
	} else {*/
	  if (buf) *buf++ = '\n';
	  ++n;
	/*}*/
	const char *contents_indent = indent_to_string(indent);
	long offset = node->list.offset;
	for (i = 0; i < node->list.length; ++i) {
	  n += print(&buf, contents_indent);
	  len =
	    debug_string(
	      node->list.data->items[offset+i], indent, max_depth-1, buf);
	  if (buf) buf += len;
	  n += len;
	}
	return n;
      }
    }
  }

static int std_types__list___get_item_of
  (
    NODE *node,
    long idx,
    NODE **result_p
  )
  {
    long length = node->list.length;
    if (idx < 0 || idx >= length) {
      invalid_index(node);
      return false;
    }
    *result_p = node->list.data->items[node->list.offset+idx];
    return true;
  }

NODE *create_list
  (
    long count
  )
  {
    if (count ==  0) return (NODE *)&std__empty_list;
    LIST_DATA *data = allocate_large(sizeof(LIST_DATA)+count*sizeof(NODE *));
    data->size = count;
    data->length = count;
    return create__std_types__list(0, count, data);
  }

void set_list_item
  (
    NODE *list,
    long idx,
    NODE *value
  )
  {
    list->list.data->items[list->list.offset+idx] = value;
  }

static int std_types__list___unfold
  (
    NODE *list
  )
  {
    long offset = list->list.offset;
    int i;
    for (i = 0; i < list->list.length; ++i) {
      TLS_arguments[TLS_argument_count++] = list->list.data->items[offset+i];
    }
    return true;
  }

static int std_types__list___length_of
  (
    NODE *node,
    long *result_p
  )
  {
    *result_p = node->list.length;
    return true;
  }

static void *std_types__integer___collect
  (
    INTEGER *node
  )
  {
    INTEGER *new_node;
    new_node = allocate(sizeof(INTEGER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static void *std_types__real___collect
  (
    REAL *node
  )
  {
    REAL *new_node;
    new_node = allocate(sizeof(REAL));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long builtin_types__positive_integer___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "%" PRIu64, node->integer.value);
  }

static long builtin_types__negative_integer___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "-%" PRIu64, node->integer.value);
  }

static long std_types__real___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "%.15g", node->real.value);
  }

NODE *from_float
  (
    float value
  )
  {
    return create__std_types__real(value);
  }

NODE *from_double
  (
    double value
  )
  {
    return create__std_types__real(value);
  }

static int builtin_types__positive_integer___to_double
  (
    NODE *node,
    double *result_p
  )
  {
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_float
  (
    NODE *node,
    float *result_p
  )
  {
    *result_p = (float) node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_double
  (
    NODE *node,
    double *result_p
  )
  {
    *result_p = -(double)node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_float
  (
    NODE *node,
    float *result_p
  )
  {
    *result_p = -(float)node->integer.value;
    return true;
  }

static int std_types__real___to_double
  (
    NODE *node,
    double *result_p
  )
  {
    *result_p = node->real.value;
    return true;
  }

static int std_types__real___to_float
  (
    NODE *node,
    float *result_p
  )
  {
    *result_p = (float) node->real.value;
    return true;
  }

NODE *create_negative_integer
  (
    uint64_t value
  )
  {
    if (value == 0) {
      return create__builtin_types__positive_integer(0);
    } else {
      return create__builtin_types__negative_integer(value);
    }
  }

#if TARGET_64
  static inline uint64_t umul64
    (
      uint64_t left,
      uint64_t right,
      uint64_t *result_low_p
    )
    {
      __uint128_t result = (__uint128_t)left * right;

      *result_low_p = result;
      return result >> 64;
    }
#else
  static uint64_t umul64
    (
      uint64_t left,
      uint64_t right,
      uint64_t *result_low_p
    )
    {
      uint64_t left_high = left >> 32;
      uint64_t left_low  = left & 0xffffffff;
      uint64_t right_high = right >> 32;
      uint64_t right_low  = right & 0xffffffff;

      uint64_t result_low = left_low * right_low;
      uint64_t result_mid_1 = left_low * right_high;
      uint64_t result_mid_2 = left_high * right_low;
      uint64_t result_high = left_high * right_high;

      uint64_t carry =
	(
	  (result_low >> 32) +
	  (result_mid_1 & 0xffffffff) +
	  (result_mid_2 & 0xffffffff)
	) >> 32;

      *result_low_p =
	result_low + (result_mid_1 << 32) + (result_mid_2 << 32);
      return
	result_high + (result_mid_1 >> 32) + (result_mid_2 >> 32) + carry;
    }
#endif

NODE *from_int
  (
    int value
  )
  {
    if (value >= 0)
      return create__builtin_types__positive_integer(value);
    else
      return create__builtin_types__negative_integer(-value);
  }

NODE *from_long
  (
    long value
  )
  {
    if (value >= 0)
      return create__builtin_types__positive_integer(value);
    else
      return create__builtin_types__negative_integer(-value);
  }

NODE *from_uint
  (
    unsigned int value
  )
  {
    return create__builtin_types__positive_integer(value);
  }

NODE *from_ulong
  (
    unsigned long value
  )
  {
    return create__builtin_types__positive_integer(value);
  }

NODE *from_int8
  (
    int8_t value
  )
  {
    if (value >= 0)
      return create__builtin_types__positive_integer(value);
    else
      return create__builtin_types__negative_integer(-value);
  }

NODE *from_int16
  (
    int16_t value
  )
  {
    if (value >= 0)
      return create__builtin_types__positive_integer(value);
    else
      return create__builtin_types__negative_integer(-value);
  }

NODE *from_int32
  (
    int32_t value
  )
  {
    if (value >= 0)
      return create__builtin_types__positive_integer(value);
    else
      return create__builtin_types__negative_integer(-value);
  }

NODE *from_int64
  (
    int64_t value
  )
  {
    if (value >= 0)
      return create__builtin_types__positive_integer(value);
    else
      return create__builtin_types__negative_integer(-value);
  }

NODE *from_uint8
  (
    uint8_t value
  )
  {
    return create__builtin_types__positive_integer(value);
  }

NODE *from_uint16
  (
    uint16_t value
  )
  {
    return create__builtin_types__positive_integer(value);
  }

NODE *from_uint32
  (
    uint32_t value
  )
  {
    return create__builtin_types__positive_integer(value);
  }

NODE *from_uint64
  (
    uint64_t value
  )
  {
    return create__builtin_types__positive_integer(value);
  }

static int builtin_types__positive_integer___to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if (node->integer.value > INT_MAX) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if (node->integer.value > -(uint64_t)INT_MIN) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_long
  (
    NODE *node,
    long *result_p
  )
  {
    if (node->integer.value > LONG_MAX) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"long\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_long
  (
    NODE *node,
    long *result_p
  )
  {
    if (node->integer.value > -(uint64_t)LONG_MIN) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"long\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_uint
  (
    NODE *node,
    uint *result_p
  )
  {
    if (node->integer.value > UINT_MAX) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_ulong
  (
    NODE *node,
    unsigned long *result_p
  ) {
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_int8
  (
    NODE *node,
    int8_t *result_p
  )
  {
    if (node->integer.value > 0x7f) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int8\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_int8
  (
    NODE *node,
    int8_t *result_p
  )
  {
    if (node->integer.value > 0x80) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int8\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_int16
  (
    NODE *node,
    int16_t *result_p
  )
  {
    if (node->integer.value > 0x7fff) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int16\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_int16
  (
    NODE *node,
    int16_t *result_p
  )
  {
    if (node->integer.value > 0x8000) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int16\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_int32
  (
    NODE *node,
    int32_t *result_p
  )
  {
    if (node->integer.value > 0x7fffffff) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int32\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_int32
  (
    NODE *node,
    int32_t *result_p
  )
  {
    if (node->integer.value > 0x80000000) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int32\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_int64
  (
    NODE *node,
    int64_t *result_p
  )
  {
    if (node->integer.value > 0x7fffffffffffffff) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int64\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__negative_integer___to_int64
  (
    NODE *node,
    int64_t *result_p
  )
  {
    if (node->integer.value > 0x8000000000000000) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"int64\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = -node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_uint8
  (
    NODE *node,
    uint8_t *result_p
  )
  {
    if (node->integer.value > 0xff) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint8\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_uint16
  (
    NODE *node,
    uint16_t *result_p
  )
  {
    if (node->integer.value > 0xffff) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint16\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_uint32
  (
    NODE *node,
    uint32_t *result_p
  )
  {
    if (node->integer.value > 0xffffffff) {
      create_error_message(
	module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	"Conversion of integer value to \"uint32\" failed!", 0, 0, NULL);
      return false;
    }
    *result_p = node->integer.value;
    return true;
  }

static int builtin_types__positive_integer___to_uint64
  (
    NODE *node,
    uint64_t *result_p
  ) {
    *result_p = node->integer.value;
    return true;
  }

static void *std_types__object___collect
  (
    SIMPLE_NODE *node
  )
  {
    SIMPLE_NODE *new_node;
    new_node = allocate(sizeof(SIMPLE_NODE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    return new_node;
  }

static long std_types__object___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    int type_no = node->attributes->vtable->type_no;
    if (max_depth == 0) {
      if (type_no) {
	const char *name = type_names[type_no];
	const char *namespace = name+strlen(name)+1;
	if (*namespace) {
	  return debug_print(indent, buf, "<%s::%s>", namespace, name);
	} else {
	  return debug_print(indent, buf, "<%s>", name);
	}
      } else {
	return debug_print(indent, buf, "<object>");
      }
    } else {
      int i, n, len;
      if (type_no) {
	const char *name = type_names[type_no];
	const char *namespace = name+strlen(name)+1;
	if (*namespace) {
	  n = debug_print_head(&indent, &buf, "%s::%s", namespace, name);
	} else {
	  n = debug_print_head(&indent, &buf, "%s", name);
	}
      } else {
	n = debug_print_head(&indent, &buf, "object");
      }
      const char *contents_indent = indent_to_string(indent);
      for (i = 1; i < next_polymorphic_function; ++i) {
	if ((i & 7) != 0) {
	  if (attribute_is_redefined[i]) {
	    NODE *attr = get_attribute(node, i);
	    if (CONTAINS_AN_ATTRIBUTE_VALUE(attr)) {
	      attr = RETRIEVE_ATTRIBUTE_VALUE(attr);
	      const char *poly_name = polymorphic_function_names[i];
	      const char *poly_namespace = poly_name;
	      while (*poly_namespace++);
	      n += print(&buf, contents_indent);
	      if (*poly_namespace) {
		n += print(&buf, "%s::", poly_namespace);
	      }
	      n += print(&buf, "%s:", poly_name);
	      len = debug_string(attr, -indent-2, max_depth-1, buf);
	      if (buf) buf += len;
	      n += len;
	    }
	  }
	}
      }
      return n;
    }
  }

extern int attributes_level;
extern int8_t *attribute_is_redefined;

static void *copy_attributes(
  OCTREE *to_attributes,
  OCTREE *from_attributes,
  int level,
  int idx
) {
  int i;
  if (level == 1) {
    NODE **to = (NODE **)to_attributes;
    NODE **from = (NODE **)from_attributes;
    NODE **new_node = NULL;
    for (i = 0; i < 8; ++i) {
      if (from[i] != to[i]) {
	if (
	  attribute_is_redefined[idx] &&
	  CONTAINS_AN_ATTRIBUTE_VALUE(from[i])
	) {
	  if (CONTAINS_AN_ATTRIBUTE_VALUE(to[i])) {
	    if (!new_node) {
	      new_node = (NODE **)allocate(sizeof(OCTREE));
	      memcpy(new_node, to, sizeof(OCTREE));
	    }
	    new_node[i] = from[i];
	  } else {
	    return (void *)(intptr_t)-idx; // 0 is not a valid attribute ID
	  }
	}
      }
      ++idx;
    }
    return new_node;
  } else {
    int n = (level == attributes_level ? 7 : 8);
    OCTREE *new_tree = NULL;
    for (i = 0; i < n; ++i) {
      if (from_attributes->nodes[i] != to_attributes->nodes[i]) {
	OCTREE *new_branch =
	  copy_attributes(
	    to_attributes->nodes[i],
	    from_attributes->nodes[i],
	    level-1,
	    idx);
	if (new_branch) {
	  if ((intptr_t)new_branch < 0) return new_branch;
	  if (!new_tree) {
	    new_tree = (OCTREE *)allocate(sizeof(OCTREE));
	    memcpy(new_tree, to_attributes, sizeof(OCTREE));
	  }
	  new_tree->nodes[i] = new_branch;
	}
      }
      idx += 1 << 3*(level-1);
    }
    return new_tree;
  }
}

NODE *create_polymorphic_function
  (
    int poly_idx
  )
  {
    NODE *node = allocate(sizeof(SIMPLE_NODE));
    node->type =
      (FUNC)(unsigned long)
      (POLYMORPHIC_FUNCTION_TAG|(poly_idx << 3));
    node->attributes =
      std_types__polymorphic_function.attributes;
    return node;
  }

NODE *create_polymorphic_function_with_setter
  (
    int poly_idx
  )
  {
    NODE *node = allocate(sizeof(SIMPLE_NODE));
    node->type =
      (FUNC)(unsigned long)
      (POLYMORPHIC_FUNCTION_WITH_SETTER_TAG|(poly_idx << 3));
    node->attributes =
      std_types__polymorphic_function_with_setter.attributes;
    return node;
  }

static void *std_types__file_type___collect
  (
    FILE_TYPE *node
  )
  {
    FILE_TYPE *new_node;
    new_node = allocate(sizeof(FILE_TYPE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__file_type___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<file_type %d>", node->file_type.value);
  }

static int file_type_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__file_type.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->file_type.value;
      return true;
    }
  }

static NODE *file_type_from_int
  (
    int value
  )
  {
    return create__std_types__file_type(value);
  }

static void *std_types__file_descriptor___collect
  (
    FILE_DESCRIPTOR *node
  )
  {
    FILE_DESCRIPTOR *new_node;
    new_node = allocate(sizeof(FILE_DESCRIPTOR));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__file_descriptor___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<file_descriptor %d>", node->file_descriptor.value);
  }

static int file_descriptor_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__file_descriptor.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->file_descriptor.value;
      return true;
    }
  }

static NODE *file_descriptor_from_int
  (
    int value
  )
  {
    return create__std_types__file_descriptor(value);
  }

static void *std_types__signal_number___collect
  (
    SIGNAL_NUMBER *node
  )
  {
    SIGNAL_NUMBER *new_node;
    new_node = allocate(sizeof(SIGNAL_NUMBER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__signal_number___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<signal_number %d>", node->signal_number.value);
  }

static int signal_number_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__signal_number.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->signal_number.value;
      return true;
    }
  }

static NODE *signal_number_from_int
  (
    int value
  )
  {
    return create__std_types__signal_number(value);
  }

static void *std_types__shutdown_type___collect
  (
    SHUTDOWN_TYPE *node
  )
  {
    SHUTDOWN_TYPE *new_node;
    new_node = allocate(sizeof(SHUTDOWN_TYPE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__shutdown_type___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<shutdown_type %d>", node->shutdown_type.value);
  }

static int shutdown_type_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__shutdown_type.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->shutdown_type.value;
      return true;
    }
  }

static NODE *shutdown_type_from_int
  (
    int value
  )
  {
    return create__std_types__shutdown_type(value);
  }

static void *std_types__seek_type___collect
  (
    SEEK_TYPE *node
  )
  {
    SEEK_TYPE *new_node;
    new_node = allocate(sizeof(SEEK_TYPE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__seek_type___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<seek_type %d>", node->seek_type.value);
  }

static int seek_type_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__seek_type.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->seek_type.value;
      return true;
    }
  }

static NODE *seek_type_from_int
  (
    int value
  )
  {
    return create__std_types__seek_type(value);
  }

static void *std_types__device_id___collect
  (
    DEVICE_ID *node
  )
  {
    DEVICE_ID *new_node;
    new_node = allocate(sizeof(DEVICE_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__device_id___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<device_id %d>", node->device_id.value);
  }

static int device_id_to_ulong
  (
    NODE *node,
    unsigned long *result_p
  )
  {
    if ((node)->type != std_types__device_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->device_id.value;
      return true;
    }
  }

static NODE *device_id_from_ulong
  (
    unsigned long value
  )
  {
    return create__std_types__device_id(value);
  }

static void *std_types__directory___collect
  (
    DIRECTORY *node
  )
  {
    DIRECTORY *new_node;
    new_node = allocate(sizeof(DIRECTORY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__directory___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<directory %d>", node->directory.value);
  }

static int directory_to_ptr
  (
    NODE *node,
    void * *result_p
  )
  {
    if ((node)->type != std_types__directory.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->directory.value;
      return true;
    }
  }

static NODE *directory_from_ptr
  (
    void * value
  )
  {
    return create__std_types__directory(value);
  }

static void *std_types__group_id___collect
  (
    GROUP_ID *node
  )
  {
    GROUP_ID *new_node;
    new_node = allocate(sizeof(GROUP_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__group_id___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<group_id %d>", node->group_id.value);
  }

static int group_id_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__group_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->group_id.value;
      return true;
    }
  }

static NODE *group_id_from_int
  (
    int value
  )
  {
    return create__std_types__group_id(value);
  }

static void *std_types__inode_number___collect
  (
    INODE_NUMBER *node
  )
  {
    INODE_NUMBER *new_node;
    new_node = allocate(sizeof(INODE_NUMBER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__inode_number___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<inode_number %d>", node->inode_number.value);
  }

static int inode_number_to_ulong
  (
    NODE *node,
    unsigned long *result_p
  )
  {
    if ((node)->type != std_types__inode_number.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->inode_number.value;
      return true;
    }
  }

static NODE *inode_number_from_ulong
  (
    unsigned long value
  )
  {
    return create__std_types__inode_number(value);
  }

static void *std_types__process_id___collect
  (
    PROCESS_ID *node
  )
  {
    PROCESS_ID *new_node;
    new_node = allocate(sizeof(PROCESS_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__process_id___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<process_id %d>", node->process_id.value);
  }

static int process_id_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__process_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->process_id.value;
      return true;
    }
  }

static NODE *process_id_from_int
  (
    int value
  )
  {
    return create__std_types__process_id(value);
  }

static void *std_types__user_id___collect
  (
    USER_ID *node
  )
  {
    USER_ID *new_node;
    new_node = allocate(sizeof(USER_ID));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__user_id___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<user_id %d>", node->user_id.value);
  }

static int user_id_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__user_id.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->user_id.value;
      return true;
    }
  }

static NODE *user_id_from_int
  (
    int value
  )
  {
    return create__std_types__user_id(value);
  }

static void *std_types__error_number___collect
  (
    ERROR_NUMBER *node
  )
  {
    ERROR_NUMBER *new_node;
    new_node = allocate(sizeof(ERROR_NUMBER));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->value = node->value;
    return new_node;
  }

static long std_types__error_number___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<error_number %d>", node->error_number.value);
  }

static int error_number_to_int
  (
    NODE *node,
    int *result_p
  )
  {
    if ((node)->type != std_types__error_number.type) {
      invalid_arguments();
      return false;
    } else {
      *result_p = node->error_number.value;
      return true;
    }
  }

static NODE *error_number_from_int
  (
    int value
  )
  {
    return create__std_types__error_number(value);
  }

static OCTET_DATA *collect_octet_data
  (
    OCTET_DATA *data
  )
  {
    if (!data) return data;
    OCTET_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(OCTET_DATA)+size*sizeof(uint8_t)));
      new_data->size = size;
      new_data->length = size;
      memcpy(new_data->buffer, data->buffer, size*sizeof(uint8_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__octet_string___collect
  (
    OCTET_STRING *node
  )
  {
    if (!node) return node;
    OCTET_STRING *new_node;
    long size = node->length; // might be garbage if already collected
    new_node = allocate(sizeof(OCTET_STRING));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->offset = node->offset;
    new_node->length = size;
    new_node->data = collect_octet_data(node->data);
    return new_node;
  }

static WIDE_DATA *collect_wide_data
  (
    WIDE_DATA *data
  )
  {
    if (!data) return data;
    WIDE_DATA *new_data = data;
    long size = data->length; // might be garbage if already collected
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(ALLOCATION_SIZE(sizeof(WIDE_DATA)+size*sizeof(uint32_t)));
      new_data->size = size;
      new_data->length = size;
      memcpy(new_data->buffer, data->buffer, size*sizeof(uint32_t));
    } else {
      if (!IS_STATIC(data)) {
	if (IS_ALREADY_MARKED(data)) return data;
	MARK(data)
      }
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__wide_string___collect
  (
    WIDE_STRING *node
  )
  {
    if (!node) return node;
    WIDE_STRING *new_node;
    long size = node->length; // might be garbage if already collected
    new_node = allocate(sizeof(WIDE_STRING));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->offset = node->offset;
    new_node->length = size;
    new_node->data = collect_wide_data(node->data);
    return new_node;
  }

static long std_types__octet_string___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    long len = 0;
    if (indent < 0) {
      if (buf) *buf++ = ' ';
      ++len;
    }
    if (buf) *buf++ = '\"';
    ++len;
    long i;
    long s = node->octet_string.offset;
    long e = s+node->octet_string.length;
    for (i = s; i < e; ++i) {
      uint8_t chr = node->octet_string.data->buffer[i];
      if (chr >= 0x20 && chr <= 0x7e) {
	if (chr == '\"') {
	  len += print(&buf, "@quot;");
	} else if (chr == '@') {
	  len += print(&buf, "@@");
	} else {
	  if (buf) *buf++ = chr;
	  ++len;
	}
      } else {
	len += print(&buf, "@0x%x;", chr);
      }
    }
    len += print(&buf, "\"\n");
    return len;
  }

static long std_types__wide_string___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    long len = 0;
    if (indent < 0) {
      if (buf) *buf++ = ' ';
      ++len;
    }
    if (buf) *buf++ = '\"';
    ++len;
    long i;
    long s = node->wide_string.offset;
    long e = s+node->wide_string.length;
    for (i = s; i < e; ++i) {
      uint32_t chr = node->wide_string.data->buffer[i];
      if (chr >= 0x20 && chr <= 0x7e) {
	if (chr == '\"') {
	  len += print(&buf, "@quot;");
	} else if (chr == '@') {
	  len += print(&buf, "@@");
	} else {
	  if (buf) *buf++ = chr;
	  ++len;
	}
      } else {
	len += print(&buf, "@0x%x;", chr);
      }
    }
    len += print(&buf, "\"\n");
    return len;
  }

static int std_types__octet_string___get_item_of
  (
    NODE *node,
    long idx,
    NODE **result_p
  )
  {
    long length = node->octet_string.length;
    if (idx < 0 || idx >= length) {
      invalid_index(node);
      return false;
    }
    *result_p =
      from_uchar32(
	node->octet_string.data->buffer[node->octet_string.offset+idx]);
    return true;
  }

static int std_types__wide_string___get_item_of
  (
    NODE *node,
    long idx,
    NODE **result_p
  )
  {
    long length = node->wide_string.length;
    if (idx < 0 || idx >= length) {
      invalid_index(node);
      return false;
    }
    *result_p =
      from_uchar32(
	node->wide_string.data->buffer[node->wide_string.offset+idx]);
    return true;
  }

static int std_types__octet_string___to_c_string
  (
    NODE *node,
    char **result_p
  )
  {
    long offset = node->octet_string.offset;
    long size = node->octet_string.length;
    char *buf = allocate_memory(size+1);
    memcpy(buf, node->octet_string.data->buffer+offset, size);
    buf[size] = 0;
    *result_p = buf;
    return true;
  }

static int std_types__octet_string___to_octets
  (
    NODE *node,
    const uint8_t **buf_p,
    long *size_p
  )
  {
    long offset = node->octet_string.offset;
    long size = node->octet_string.length;
    uint8_t *buf = allocate_memory(size);
    memcpy(buf, node->octet_string.data->buffer+offset, size);
    *buf_p = buf;
    *size_p = size;
    return true;
  }

NODE *from_latin_1_string
  (
    const uint8_t *str,
    long len
  )
  {
    if (len == 0) return (NODE *)&std__empty_string;
    long size = ALLOCATION_SIZE(len);
    OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+size);
    data->size = size;
    data->length = len;
    memcpy(data->buffer, str, len);
    return create__std_types__octet_string(0, len, data);
  }

NODE *from_uint32_string
  (
    const uint32_t *str,
    long len
  )
  {
    long size = ALLOCATION_SIZE(4*len);
    WIDE_DATA *data = allocate_large(sizeof(WIDE_DATA)+size);
    data->size = size;
    data->length = len;
    memcpy(data->buffer, str, 4*len);
    return create__std_types__wide_string(0, len, data);
  }

NODE *from_c_string
  (
    const char *str
  )
  {
    return from_latin_1_string((const uint8_t *)str, strlen(str));
  }

static int std_types__octet_string___length_of
  (
    NODE *node,
    long *result_p
  )
  {
    *result_p = node->octet_string.length;
    return true;
  }

static int std_types__wide_string___length_of
  (
    NODE *node,
    long *result_p
  )
  {
    *result_p = node->wide_string.length;
    return true;
  }

static TERMIO_DATA *collect_termio_data
  (
    TERMIO_DATA *data
  )
  {
    TERMIO_DATA *new_data = data;
    int is_collected = IS_COLLECTED(data);
    if (is_collected) {
      void *new_location = *(void **)data;
      if (IS_AN_INVALID_LENGTH(new_location)) {
	return DECODE_FROM_LENGTH(new_location);
      }
      new_data = allocate(sizeof(TERMIO_DATA));
      new_data->termios = data->termios;
    }
    if (is_collected) *(void **)data = ENCODE_TO_LENGTH(new_data);
    return new_data;
  }

static void *std_types__terminal_attributes___collect
  (
    TERMINAL_ATTRIBUTES *node
  )
  {
    TERMINAL_ATTRIBUTES *new_node;
    new_node = allocate(sizeof(TERMINAL_ATTRIBUTES));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->data = collect_termio_data(node->data);
    return new_node;
  }

static long std_types__terminal_attributes___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(indent, buf, "<terminal_attributes>");
  }

NODE *create_tuple
  (
    long count
  )
  {
    switch (count) {
      case 2:
	return create__builtin_types__tuple2(NULL, NULL);
      case 3:
	return create__builtin_types__tuple3(NULL, NULL, NULL);
      case 4:
	return create__builtin_types__tuple4(NULL, NULL, NULL, NULL);
      case 5:
	return create__builtin_types__tuple5(NULL, NULL, NULL, NULL, NULL);
      case 6:
	return create__builtin_types__tuple6(NULL, NULL, NULL, NULL, NULL, NULL);
      case 7:
	return create__builtin_types__tuple7(NULL, NULL, NULL, NULL, NULL, NULL, NULL);
      case 8:
	return create__builtin_types__tuple8(NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
      default:
	unrecoverable_error("Invalid tuple element count!");
    }
  }

void set_tuple_item
  (
    NODE *tuple,
    long idx,
    NODE *value
  )
  {
    ((NODE **)((SIMPLE_NODE *)tuple+1))[idx] = value;
  }

static void *builtin_types__tuple2___collect
  (
    TUPLE2 *node
  )
  {
    TUPLE2 *new_node;
    new_node = allocate(sizeof(TUPLE2));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    return new_node;
  }

static long builtin_types__tuple2___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 2 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple2.node_0;
      for (i = 0; i < 2; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin_types__tuple3___collect
  (
    TUPLE3 *node
  )
  {
    TUPLE3 *new_node;
    new_node = allocate(sizeof(TUPLE3));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    return new_node;
  }

static long builtin_types__tuple3___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 3 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple3.node_0;
      for (i = 0; i < 3; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin_types__tuple4___collect
  (
    TUPLE4 *node
  )
  {
    TUPLE4 *new_node;
    new_node = allocate(sizeof(TUPLE4));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    return new_node;
  }

static long builtin_types__tuple4___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 4 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple4.node_0;
      for (i = 0; i < 4; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin_types__tuple5___collect
  (
    TUPLE5 *node
  )
  {
    TUPLE5 *new_node;
    new_node = allocate(sizeof(TUPLE5));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    return new_node;
  }

static long builtin_types__tuple5___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 5 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple5.node_0;
      for (i = 0; i < 5; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin_types__tuple6___collect
  (
    TUPLE6 *node
  )
  {
    TUPLE6 *new_node;
    new_node = allocate(sizeof(TUPLE6));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    new_node->node_5 = collect_node(node->node_5);
    return new_node;
  }

static long builtin_types__tuple6___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 6 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple6.node_0;
      for (i = 0; i < 6; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin_types__tuple7___collect
  (
    TUPLE7 *node
  )
  {
    TUPLE7 *new_node;
    new_node = allocate(sizeof(TUPLE7));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    new_node->node_5 = collect_node(node->node_5);
    new_node->node_6 = collect_node(node->node_6);
    return new_node;
  }

static long builtin_types__tuple7___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 7 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple7.node_0;
      for (i = 0; i < 7; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *builtin_types__tuple8___collect
  (
    TUPLE8 *node
  )
  {
    TUPLE8 *new_node;
    new_node = allocate(sizeof(TUPLE8));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->node_0 = collect_node(node->node_0);
    new_node->node_1 = collect_node(node->node_1);
    new_node->node_2 = collect_node(node->node_2);
    new_node->node_3 = collect_node(node->node_3);
    new_node->node_4 = collect_node(node->node_4);
    new_node->node_5 = collect_node(node->node_5);
    new_node->node_6 = collect_node(node->node_6);
    new_node->node_7 = collect_node(node->node_7);
    return new_node;
  }

static long builtin_types__tuple8___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if ((subtype)->type == std_types__undefined.type) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 8 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple8.node_0;
      for (i = 0; i < 8; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

static void *std_types__undefined___collect
  (
    SIMPLE_NODE *node
  )
  {
    SIMPLE_NODE *new_node;
    new_node = allocate(sizeof(SIMPLE_NODE));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    return new_node;
  }

static long std_types__undefined___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  ) {
    return debug_print(indent, buf, "undefined");
  }

int is_an_upper_case_letter_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x41) return false;
    if (chr <= 0x5a) return true;
    if (chr < 0xc0) return false;
    if (chr <= 0xd6) return true;
    if (chr < 0xd8) return false;
    if (chr <= 0xde) return true;
    if (chr < 0x100) return false;
    if ((chr & 1) == 0 && chr <= 0x136) return true;
    if (chr < 0x139) return false;
    if ((chr & 1) == 1 && chr <= 0x147) return true;
    if (chr < 0x14a) return false;
    if ((chr & 1) == 0 && chr <= 0x178) return true;
    if (chr < 0x179) return false;
    if ((chr & 1) == 1 && chr <= 0x17d) return true;
    if (chr < 0x181) return false;
    if (chr <= 0x182) return true;
    if (chr < 0x184) return false;
    if ((chr & 1) == 0 && chr <= 0x186) return true;
    if (chr < 0x187) return false;
    if ((chr & 1) == 1 && chr <= 0x189) return true;
    if (chr < 0x18a) return false;
    if (chr <= 0x18b) return true;
    if (chr < 0x18e) return false;
    if (chr <= 0x191) return true;
    if (chr < 0x193) return false;
    if (chr <= 0x194) return true;
    if (chr < 0x196) return false;
    if (chr <= 0x198) return true;
    if (chr < 0x19c) return false;
    if (chr <= 0x19d) return true;
    if (chr < 0x19f) return false;
    if (chr <= 0x1a0) return true;
    if (chr < 0x1a2) return false;
    if ((chr & 1) == 0 && chr <= 0x1a6) return true;
    if (chr < 0x1a7) return false;
    if ((chr & 1) == 1 && chr <= 0x1a9) return true;
    if (chr < 0x1ac) return false;
    if ((chr & 1) == 0 && chr <= 0x1ae) return true;
    if (chr < 0x1af) return false;
    if ((chr & 1) == 1 && chr <= 0x1b1) return true;
    if (chr < 0x1b2) return false;
    if (chr <= 0x1b3) return true;
    if (chr < 0x1b5) return false;
    if ((chr & 1) == 1 && chr <= 0x1b7) return true;
    if (chr == 0x1b8) return true;
    if (chr == 0x1bc) return true;
    if (chr == 0x1c4) return true;
    if (chr == 0x1c7) return true;
    if (chr == 0x1ca) return true;
    if (chr < 0x1cd) return false;
    if ((chr & 1) == 1 && chr <= 0x1db) return true;
    if (chr < 0x1de) return false;
    if ((chr & 1) == 0 && chr <= 0x1ee) return true;
    if (chr == 0x1f1) return true;
    if (chr < 0x1f4) return false;
    if ((chr & 1) == 0 && chr <= 0x1f6) return true;
    if (chr < 0x1f7) return false;
    if (chr <= 0x1f8) return true;
    if (chr < 0x1fa) return false;
    if ((chr & 1) == 0 && chr <= 0x232) return true;
    if (chr < 0x23a) return false;
    if (chr <= 0x23b) return true;
    if (chr < 0x23d) return false;
    if (chr <= 0x23e) return true;
    if (chr < 0x241) return false;
    if ((chr & 1) == 1 && chr <= 0x243) return true;
    if (chr < 0x244) return false;
    if (chr <= 0x246) return true;
    if (chr < 0x248) return false;
    if ((chr & 1) == 0 && chr <= 0x24e) return true;
    if (chr < 0x370) return false;
    if ((chr & 1) == 0 && chr <= 0x372) return true;
    if (chr == 0x376) return true;
    if (chr == 0x37f) return true;
    if (chr < 0x386) return false;
    if ((chr & 1) == 0 && chr <= 0x388) return true;
    if (chr < 0x389) return false;
    if (chr <= 0x38a) return true;
    if (chr < 0x38c) return false;
    if ((chr & 1) == 0 && chr <= 0x38e) return true;
    if (chr < 0x38f) return false;
    if ((chr & 1) == 1 && chr <= 0x391) return true;
    if (chr < 0x392) return false;
    if (chr <= 0x3a1) return true;
    if (chr < 0x3a3) return false;
    if (chr <= 0x3ab) return true;
    if (chr == 0x3cf) return true;
    if (chr < 0x3d2) return false;
    if (chr <= 0x3d4) return true;
    if (chr < 0x3d8) return false;
    if ((chr & 1) == 0 && chr <= 0x3ee) return true;
    if (chr == 0x3f4) return true;
    if (chr < 0x3f7) return false;
    if ((chr & 1) == 1 && chr <= 0x3f9) return true;
    if (chr == 0x3fa) return true;
    if (chr < 0x3fd) return false;
    if (chr <= 0x42f) return true;
    if (chr < 0x460) return false;
    if ((chr & 1) == 0 && chr <= 0x480) return true;
    if (chr < 0x48a) return false;
    if ((chr & 1) == 0 && chr <= 0x4c0) return true;
    if (chr < 0x4c1) return false;
    if ((chr & 1) == 1 && chr <= 0x4cd) return true;
    if (chr < 0x4d0) return false;
    if ((chr & 1) == 0 && chr <= 0x52e) return true;
    if (chr < 0x531) return false;
    if (chr <= 0x556) return true;
    if (chr < 0x10a0) return false;
    if (chr <= 0x10c5) return true;
    if (chr == 0x10c7) return true;
    if (chr == 0x10cd) return true;
    if (chr < 0x13a0) return false;
    if (chr <= 0x13f5) return true;
    if (chr < 0x1c90) return false;
    if (chr <= 0x1cba) return true;
    if (chr < 0x1cbd) return false;
    if (chr <= 0x1cbf) return true;
    if (chr < 0x1e00) return false;
    if ((chr & 1) == 0 && chr <= 0x1e94) return true;
    if (chr < 0x1e9e) return false;
    if ((chr & 1) == 0 && chr <= 0x1efe) return true;
    if (chr < 0x1f08) return false;
    if (chr <= 0x1f0f) return true;
    if (chr < 0x1f18) return false;
    if (chr <= 0x1f1d) return true;
    if (chr < 0x1f28) return false;
    if (chr <= 0x1f2f) return true;
    if (chr < 0x1f38) return false;
    if (chr <= 0x1f3f) return true;
    if (chr < 0x1f48) return false;
    if (chr <= 0x1f4d) return true;
    if (chr < 0x1f59) return false;
    if ((chr & 1) == 1 && chr <= 0x1f5f) return true;
    if (chr < 0x1f68) return false;
    if (chr <= 0x1f6f) return true;
    if (chr < 0x1fb8) return false;
    if (chr <= 0x1fbb) return true;
    if (chr < 0x1fc8) return false;
    if (chr <= 0x1fcb) return true;
    if (chr < 0x1fd8) return false;
    if (chr <= 0x1fdb) return true;
    if (chr < 0x1fe8) return false;
    if (chr <= 0x1fec) return true;
    if (chr < 0x1ff8) return false;
    if (chr <= 0x1ffb) return true;
    if (chr == 0x2102) return true;
    if (chr == 0x2107) return true;
    if (chr < 0x210b) return false;
    if (chr <= 0x210d) return true;
    if (chr < 0x2110) return false;
    if (chr <= 0x2112) return true;
    if (chr == 0x2115) return true;
    if (chr < 0x2119) return false;
    if (chr <= 0x211d) return true;
    if (chr < 0x2124) return false;
    if ((chr & 1) == 0 && chr <= 0x212a) return true;
    if (chr < 0x212b) return false;
    if (chr <= 0x212d) return true;
    if (chr < 0x2130) return false;
    if (chr <= 0x2133) return true;
    if (chr < 0x213e) return false;
    if (chr <= 0x213f) return true;
    if (chr == 0x2145) return true;
    if (chr == 0x2183) return true;
    if (chr < 0x2c00) return false;
    if (chr <= 0x2c2f) return true;
    if (chr < 0x2c60) return false;
    if ((chr & 1) == 0 && chr <= 0x2c62) return true;
    if (chr < 0x2c63) return false;
    if (chr <= 0x2c64) return true;
    if (chr < 0x2c67) return false;
    if ((chr & 1) == 1 && chr <= 0x2c6d) return true;
    if (chr < 0x2c6e) return false;
    if (chr <= 0x2c70) return true;
    if (chr == 0x2c72) return true;
    if (chr == 0x2c75) return true;
    if (chr < 0x2c7e) return false;
    if (chr <= 0x2c80) return true;
    if (chr < 0x2c82) return false;
    if ((chr & 1) == 0 && chr <= 0x2ce2) return true;
    if (chr < 0x2ceb) return false;
    if ((chr & 1) == 1 && chr <= 0x2ced) return true;
    if (chr == 0x2cf2) return true;
    if (chr < 0xa640) return false;
    if ((chr & 1) == 0 && chr <= 0xa66c) return true;
    if (chr < 0xa680) return false;
    if ((chr & 1) == 0 && chr <= 0xa69a) return true;
    if (chr < 0xa722) return false;
    if ((chr & 1) == 0 && chr <= 0xa72e) return true;
    if (chr < 0xa732) return false;
    if ((chr & 1) == 0 && chr <= 0xa76e) return true;
    if (chr < 0xa779) return false;
    if ((chr & 1) == 1 && chr <= 0xa77d) return true;
    if (chr < 0xa77e) return false;
    if ((chr & 1) == 0 && chr <= 0xa786) return true;
    if (chr < 0xa78b) return false;
    if ((chr & 1) == 1 && chr <= 0xa78d) return true;
    if (chr < 0xa790) return false;
    if ((chr & 1) == 0 && chr <= 0xa792) return true;
    if (chr < 0xa796) return false;
    if ((chr & 1) == 0 && chr <= 0xa7aa) return true;
    if (chr < 0xa7ab) return false;
    if (chr <= 0xa7ae) return true;
    if (chr < 0xa7b0) return false;
    if (chr <= 0xa7b4) return true;
    if (chr < 0xa7b6) return false;
    if ((chr & 1) == 0 && chr <= 0xa7c4) return true;
    if (chr < 0xa7c5) return false;
    if (chr <= 0xa7c7) return true;
    if (chr == 0xa7c9) return true;
    if (chr == 0xa7d0) return true;
    if (chr < 0xa7d6) return false;
    if ((chr & 1) == 0 && chr <= 0xa7d8) return true;
    if (chr == 0xa7f5) return true;
    if (chr < 0xff21) return false;
    if (chr <= 0xff3a) return true;
    if (chr < 0x10400) return false;
    if (chr <= 0x10427) return true;
    if (chr < 0x104b0) return false;
    if (chr <= 0x104d3) return true;
    if (chr < 0x10570) return false;
    if (chr <= 0x1057a) return true;
    if (chr < 0x1057c) return false;
    if (chr <= 0x1058a) return true;
    if (chr < 0x1058c) return false;
    if (chr <= 0x10592) return true;
    if (chr < 0x10594) return false;
    if (chr <= 0x10595) return true;
    if (chr < 0x10c80) return false;
    if (chr <= 0x10cb2) return true;
    if (chr < 0x118a0) return false;
    if (chr <= 0x118bf) return true;
    if (chr < 0x16e40) return false;
    if (chr <= 0x16e5f) return true;
    if (chr < 0x1d400) return false;
    if (chr <= 0x1d419) return true;
    if (chr < 0x1d434) return false;
    if (chr <= 0x1d44d) return true;
    if (chr < 0x1d468) return false;
    if (chr <= 0x1d481) return true;
    if (chr < 0x1d49c) return false;
    if ((chr & 1) == 0 && chr <= 0x1d49e) return true;
    if (chr == 0x1d49f) return true;
    if (chr == 0x1d4a2) return true;
    if (chr < 0x1d4a5) return false;
    if (chr <= 0x1d4a6) return true;
    if (chr < 0x1d4a9) return false;
    if (chr <= 0x1d4ac) return true;
    if (chr < 0x1d4ae) return false;
    if (chr <= 0x1d4b5) return true;
    if (chr < 0x1d4d0) return false;
    if (chr <= 0x1d4e9) return true;
    if (chr < 0x1d504) return false;
    if (chr <= 0x1d505) return true;
    if (chr < 0x1d507) return false;
    if (chr <= 0x1d50a) return true;
    if (chr < 0x1d50d) return false;
    if (chr <= 0x1d514) return true;
    if (chr < 0x1d516) return false;
    if (chr <= 0x1d51c) return true;
    if (chr < 0x1d538) return false;
    if (chr <= 0x1d539) return true;
    if (chr < 0x1d53b) return false;
    if (chr <= 0x1d53e) return true;
    if (chr < 0x1d540) return false;
    if (chr <= 0x1d544) return true;
    if (chr == 0x1d546) return true;
    if (chr < 0x1d54a) return false;
    if (chr <= 0x1d550) return true;
    if (chr < 0x1d56c) return false;
    if (chr <= 0x1d585) return true;
    if (chr < 0x1d5a0) return false;
    if (chr <= 0x1d5b9) return true;
    if (chr < 0x1d5d4) return false;
    if (chr <= 0x1d5ed) return true;
    if (chr < 0x1d608) return false;
    if (chr <= 0x1d621) return true;
    if (chr < 0x1d63c) return false;
    if (chr <= 0x1d655) return true;
    if (chr < 0x1d670) return false;
    if (chr <= 0x1d689) return true;
    if (chr < 0x1d6a8) return false;
    if (chr <= 0x1d6c0) return true;
    if (chr < 0x1d6e2) return false;
    if (chr <= 0x1d6fa) return true;
    if (chr < 0x1d71c) return false;
    if (chr <= 0x1d734) return true;
    if (chr < 0x1d756) return false;
    if (chr <= 0x1d76e) return true;
    if (chr < 0x1d790) return false;
    if (chr <= 0x1d7a8) return true;
    if (chr == 0x1d7ca) return true;
    if (chr < 0x1e900) return false;
    if (chr <= 0x1e921) return true;
    return false;
  }

static uint32_t to_upper_case
  (
    uint32_t chr
  )
  {
    if (chr < 0x61) return chr;
    if (chr <= 0x7a) return chr-0x20;
    if (chr == 0xb5) return chr+0x2e7;
    if (chr < 0xe0) return chr;
    if (chr <= 0xf6) return chr-0x20;
    if (chr < 0xf8) return chr;
    if (chr <= 0xfe) return chr-0x20;
    if (chr == 0xff) return chr+0x79;
    if (chr < 0x101) return chr;
    if ((chr & 1) == 1 && chr <= 0x12f) return chr-1;
    if (chr == 0x131) return chr-0xe8;
    if (chr < 0x133) return chr;
    if ((chr & 1) == 1 && chr <= 0x137) return chr-1;
    if (chr < 0x13a) return chr;
    if ((chr & 1) == 0 && chr <= 0x148) return chr-1;
    if (chr < 0x14b) return chr;
    if ((chr & 1) == 1 && chr <= 0x177) return chr-1;
    if (chr < 0x17a) return chr;
    if ((chr & 1) == 0 && chr <= 0x17e) return chr-1;
    if (chr == 0x17f) return chr-0x12c;
    if (chr == 0x180) return chr+0xc3;
    if (chr < 0x183) return chr;
    if ((chr & 1) == 1 && chr <= 0x185) return chr-1;
    if (chr == 0x188) return chr-1;
    if (chr == 0x18c) return chr-1;
    if (chr == 0x192) return chr-1;
    if (chr == 0x195) return chr+0x61;
    if (chr == 0x199) return chr-1;
    if (chr == 0x19a) return chr+0xa3;
    if (chr == 0x19e) return chr+0x82;
    if (chr < 0x1a1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1a5) return chr-1;
    if (chr == 0x1a8) return chr-1;
    if (chr == 0x1ad) return chr-1;
    if (chr == 0x1b0) return chr-1;
    if (chr < 0x1b4) return chr;
    if ((chr & 1) == 0 && chr <= 0x1b6) return chr-1;
    if (chr == 0x1b9) return chr-1;
    if (chr == 0x1bd) return chr-1;
    if (chr == 0x1bf) return chr+0x38;
    if (chr == 0x1c5) return chr-1;
    if (chr == 0x1c6) return chr-2;
    if (chr == 0x1c8) return chr-1;
    if (chr == 0x1c9) return chr-2;
    if (chr == 0x1cb) return chr-1;
    if (chr == 0x1cc) return chr-2;
    if (chr < 0x1ce) return chr;
    if ((chr & 1) == 0 && chr <= 0x1dc) return chr-1;
    if (chr == 0x1dd) return chr-0x4f;
    if (chr < 0x1df) return chr;
    if ((chr & 1) == 1 && chr <= 0x1ef) return chr-1;
    if (chr == 0x1f2) return chr-1;
    if (chr == 0x1f3) return chr-2;
    if (chr == 0x1f5) return chr-1;
    if (chr < 0x1f9) return chr;
    if ((chr & 1) == 1 && chr <= 0x21f) return chr-1;
    if (chr < 0x223) return chr;
    if ((chr & 1) == 1 && chr <= 0x233) return chr-1;
    if (chr == 0x23c) return chr-1;
    if (chr < 0x23f) return chr;
    if (chr <= 0x240) return chr+0x2a3f;
    if (chr == 0x242) return chr-1;
    if (chr < 0x247) return chr;
    if ((chr & 1) == 1 && chr <= 0x24f) return chr-1;
    if (chr == 0x250) return chr+0x2a1f;
    if (chr == 0x251) return chr+0x2a1c;
    if (chr == 0x252) return chr+0x2a1e;
    if (chr == 0x253) return chr-0xd2;
    if (chr == 0x254) return chr-0xce;
    if (chr < 0x256) return chr;
    if (chr <= 0x257) return chr-0xcd;
    if (chr == 0x259) return chr-0xca;
    if (chr == 0x25b) return chr-0xcb;
    if (chr == 0x25c) return chr+0xa54f;
    if (chr == 0x260) return chr-0xcd;
    if (chr == 0x261) return chr+0xa54b;
    if (chr == 0x263) return chr-0xcf;
    if (chr == 0x265) return chr+0xa528;
    if (chr == 0x266) return chr+0xa544;
    if (chr == 0x268) return chr-0xd1;
    if (chr == 0x269) return chr-0xd3;
    if (chr == 0x26a) return chr+0xa544;
    if (chr == 0x26b) return chr+0x29f7;
    if (chr == 0x26c) return chr+0xa541;
    if (chr == 0x26f) return chr-0xd3;
    if (chr == 0x271) return chr+0x29fd;
    if (chr == 0x272) return chr-0xd5;
    if (chr == 0x275) return chr-0xd6;
    if (chr == 0x27d) return chr+0x29e7;
    if (chr == 0x280) return chr-0xda;
    if (chr == 0x282) return chr+0xa543;
    if (chr == 0x283) return chr-0xda;
    if (chr == 0x287) return chr+0xa52a;
    if (chr == 0x288) return chr-0xda;
    if (chr == 0x289) return chr-0x45;
    if (chr < 0x28a) return chr;
    if (chr <= 0x28b) return chr-0xd9;
    if (chr == 0x28c) return chr-0x47;
    if (chr == 0x292) return chr-0xdb;
    if (chr == 0x29d) return chr+0xa515;
    if (chr == 0x29e) return chr+0xa512;
    if (chr == 0x345) return chr+0x54;
    if (chr < 0x371) return chr;
    if ((chr & 1) == 1 && chr <= 0x373) return chr-1;
    if (chr == 0x377) return chr-1;
    if (chr < 0x37b) return chr;
    if (chr <= 0x37d) return chr+0x82;
    if (chr == 0x3ac) return chr-0x26;
    if (chr < 0x3ad) return chr;
    if (chr <= 0x3af) return chr-0x25;
    if (chr < 0x3b1) return chr;
    if (chr <= 0x3c1) return chr-0x20;
    if (chr == 0x3c2) return chr-0x1f;
    if (chr < 0x3c3) return chr;
    if (chr <= 0x3cb) return chr-0x20;
    if (chr == 0x3cc) return chr-0x40;
    if (chr < 0x3cd) return chr;
    if (chr <= 0x3ce) return chr-0x3f;
    if (chr == 0x3d0) return chr-0x3e;
    if (chr == 0x3d1) return chr-0x39;
    if (chr == 0x3d5) return chr-0x2f;
    if (chr == 0x3d6) return chr-0x36;
    if (chr == 0x3d7) return chr-8;
    if (chr < 0x3d9) return chr;
    if ((chr & 1) == 1 && chr <= 0x3ef) return chr-1;
    if (chr == 0x3f0) return chr-0x56;
    if (chr == 0x3f1) return chr-0x50;
    if (chr == 0x3f2) return chr+7;
    if (chr == 0x3f3) return chr-0x74;
    if (chr == 0x3f5) return chr-0x60;
    if (chr == 0x3f8) return chr-1;
    if (chr == 0x3fb) return chr-1;
    if (chr < 0x430) return chr;
    if (chr <= 0x44f) return chr-0x20;
    if (chr < 0x450) return chr;
    if (chr <= 0x45f) return chr-0x50;
    if (chr < 0x461) return chr;
    if ((chr & 1) == 1 && chr <= 0x481) return chr-1;
    if (chr < 0x48b) return chr;
    if ((chr & 1) == 1 && chr <= 0x4bf) return chr-1;
    if (chr < 0x4c2) return chr;
    if ((chr & 1) == 0 && chr <= 0x4ce) return chr-1;
    if (chr == 0x4cf) return chr-0xf;
    if (chr < 0x4d1) return chr;
    if ((chr & 1) == 1 && chr <= 0x52f) return chr-1;
    if (chr < 0x561) return chr;
    if (chr <= 0x586) return chr-0x30;
    if (chr < 0x10d0) return chr;
    if (chr <= 0x10fa) return chr+0xbc0;
    if (chr < 0x10fd) return chr;
    if (chr <= 0x10ff) return chr+0xbc0;
    if (chr < 0x13f8) return chr;
    if (chr <= 0x13fd) return chr-8;
    if (chr == 0x1c80) return chr-0x186e;
    if (chr == 0x1c81) return chr-0x186d;
    if (chr == 0x1c82) return chr-0x1864;
    if (chr < 0x1c83) return chr;
    if (chr <= 0x1c84) return chr-0x1862;
    if (chr == 0x1c85) return chr-0x1863;
    if (chr == 0x1c86) return chr-0x185c;
    if (chr == 0x1c87) return chr-0x1825;
    if (chr == 0x1c88) return chr+0x89c2;
    if (chr == 0x1d79) return chr+0x8a04;
    if (chr == 0x1d7d) return chr+0xee6;
    if (chr == 0x1d8e) return chr+0x8a38;
    if (chr < 0x1e01) return chr;
    if ((chr & 1) == 1 && chr <= 0x1e95) return chr-1;
    if (chr == 0x1e9b) return chr-0x3b;
    if (chr < 0x1ea1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1eff) return chr-1;
    if (chr < 0x1f00) return chr;
    if (chr <= 0x1f07) return chr+8;
    if (chr < 0x1f10) return chr;
    if (chr <= 0x1f15) return chr+8;
    if (chr < 0x1f20) return chr;
    if (chr <= 0x1f27) return chr+8;
    if (chr < 0x1f30) return chr;
    if (chr <= 0x1f37) return chr+8;
    if (chr < 0x1f40) return chr;
    if (chr <= 0x1f45) return chr+8;
    if (chr < 0x1f51) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f57) return chr+8;
    if (chr < 0x1f60) return chr;
    if (chr <= 0x1f67) return chr+8;
    if (chr < 0x1f70) return chr;
    if (chr <= 0x1f71) return chr+0x4a;
    if (chr < 0x1f72) return chr;
    if (chr <= 0x1f75) return chr+0x56;
    if (chr < 0x1f76) return chr;
    if (chr <= 0x1f77) return chr+0x64;
    if (chr < 0x1f78) return chr;
    if (chr <= 0x1f79) return chr+0x80;
    if (chr < 0x1f7a) return chr;
    if (chr <= 0x1f7b) return chr+0x70;
    if (chr < 0x1f7c) return chr;
    if (chr <= 0x1f7d) return chr+0x7e;
    if (chr < 0x1f80) return chr;
    if (chr <= 0x1f87) return chr+8;
    if (chr < 0x1f90) return chr;
    if (chr <= 0x1f97) return chr+8;
    if (chr < 0x1fa0) return chr;
    if (chr <= 0x1fa7) return chr+8;
    if (chr < 0x1fb0) return chr;
    if (chr <= 0x1fb1) return chr+8;
    if (chr == 0x1fb3) return chr+9;
    if (chr == 0x1fbe) return chr-0x1c25;
    if (chr == 0x1fc3) return chr+9;
    if (chr < 0x1fd0) return chr;
    if (chr <= 0x1fd1) return chr+8;
    if (chr < 0x1fe0) return chr;
    if (chr <= 0x1fe1) return chr+8;
    if (chr == 0x1fe5) return chr+7;
    if (chr == 0x1ff3) return chr+9;
    if (chr == 0x214e) return chr-0x1c;
    if (chr < 0x2170) return chr;
    if (chr <= 0x217f) return chr-0x10;
    if (chr == 0x2184) return chr-1;
    if (chr < 0x24d0) return chr;
    if (chr <= 0x24e9) return chr-0x1a;
    if (chr < 0x2c30) return chr;
    if (chr <= 0x2c5f) return chr-0x30;
    if (chr == 0x2c61) return chr-1;
    if (chr == 0x2c65) return chr-0x2a2b;
    if (chr == 0x2c66) return chr-0x2a28;
    if (chr < 0x2c68) return chr;
    if ((chr & 1) == 0 && chr <= 0x2c6c) return chr-1;
    if (chr == 0x2c73) return chr-1;
    if (chr == 0x2c76) return chr-1;
    if (chr < 0x2c81) return chr;
    if ((chr & 1) == 1 && chr <= 0x2ce3) return chr-1;
    if (chr < 0x2cec) return chr;
    if ((chr & 1) == 0 && chr <= 0x2cee) return chr-1;
    if (chr == 0x2cf3) return chr-1;
    if (chr < 0x2d00) return chr;
    if (chr <= 0x2d25) return chr-0x1c60;
    if (chr == 0x2d27) return chr-0x1c60;
    if (chr == 0x2d2d) return chr-0x1c60;
    if (chr < 0xa641) return chr;
    if ((chr & 1) == 1 && chr <= 0xa66d) return chr-1;
    if (chr < 0xa681) return chr;
    if ((chr & 1) == 1 && chr <= 0xa69b) return chr-1;
    if (chr < 0xa723) return chr;
    if ((chr & 1) == 1 && chr <= 0xa72f) return chr-1;
    if (chr < 0xa733) return chr;
    if ((chr & 1) == 1 && chr <= 0xa76f) return chr-1;
    if (chr < 0xa77a) return chr;
    if ((chr & 1) == 0 && chr <= 0xa77c) return chr-1;
    if (chr < 0xa77f) return chr;
    if ((chr & 1) == 1 && chr <= 0xa787) return chr-1;
    if (chr == 0xa78c) return chr-1;
    if (chr < 0xa791) return chr;
    if ((chr & 1) == 1 && chr <= 0xa793) return chr-1;
    if (chr == 0xa794) return chr+0x30;
    if (chr < 0xa797) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7a9) return chr-1;
    if (chr < 0xa7b5) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7c3) return chr-1;
    if (chr < 0xa7c8) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7ca) return chr-1;
    if (chr == 0xa7d1) return chr-1;
    if (chr < 0xa7d7) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7d9) return chr-1;
    if (chr == 0xa7f6) return chr-1;
    if (chr == 0xab53) return chr-0x3a0;
    if (chr < 0xab70) return chr;
    if (chr <= 0xabbf) return chr-0x97d0;
    if (chr < 0xff41) return chr;
    if (chr <= 0xff5a) return chr-0x20;
    if (chr < 0x10428) return chr;
    if (chr <= 0x1044f) return chr-0x28;
    if (chr < 0x104d8) return chr;
    if (chr <= 0x104fb) return chr-0x28;
    if (chr < 0x10597) return chr;
    if (chr <= 0x105a1) return chr-0x27;
    if (chr < 0x105a3) return chr;
    if (chr <= 0x105b1) return chr-0x27;
    if (chr < 0x105b3) return chr;
    if (chr <= 0x105b9) return chr-0x27;
    if (chr < 0x105bb) return chr;
    if (chr <= 0x105bc) return chr-0x27;
    if (chr < 0x10cc0) return chr;
    if (chr <= 0x10cf2) return chr-0x40;
    if (chr < 0x118c0) return chr;
    if (chr <= 0x118df) return chr-0x20;
    if (chr < 0x16e60) return chr;
    if (chr <= 0x16e7f) return chr-0x20;
    if (chr < 0x1e922) return chr;
    if (chr <= 0x1e943) return chr-0x22;
    return chr;
  }

int is_a_lower_case_letter_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x61) return false;
    if (chr <= 0x7a) return true;
    if (chr == 0xb5) return true;
    if (chr < 0xdf) return false;
    if (chr <= 0xf6) return true;
    if (chr < 0xf8) return false;
    if (chr <= 0xff) return true;
    if (chr < 0x101) return false;
    if ((chr & 1) == 1 && chr <= 0x137) return true;
    if (chr < 0x138) return false;
    if ((chr & 1) == 0 && chr <= 0x148) return true;
    if (chr < 0x149) return false;
    if ((chr & 1) == 1 && chr <= 0x177) return true;
    if (chr < 0x17a) return false;
    if ((chr & 1) == 0 && chr <= 0x17e) return true;
    if (chr < 0x17f) return false;
    if (chr <= 0x180) return true;
    if (chr < 0x183) return false;
    if ((chr & 1) == 1 && chr <= 0x185) return true;
    if (chr == 0x188) return true;
    if (chr < 0x18c) return false;
    if (chr <= 0x18d) return true;
    if (chr == 0x192) return true;
    if (chr == 0x195) return true;
    if (chr < 0x199) return false;
    if (chr <= 0x19b) return true;
    if (chr == 0x19e) return true;
    if (chr < 0x1a1) return false;
    if ((chr & 1) == 1 && chr <= 0x1a5) return true;
    if (chr < 0x1a8) return false;
    if ((chr & 1) == 0 && chr <= 0x1aa) return true;
    if (chr < 0x1ab) return false;
    if ((chr & 1) == 1 && chr <= 0x1ad) return true;
    if (chr == 0x1b0) return true;
    if (chr < 0x1b4) return false;
    if ((chr & 1) == 0 && chr <= 0x1b6) return true;
    if (chr < 0x1b9) return false;
    if (chr <= 0x1ba) return true;
    if (chr < 0x1bd) return false;
    if (chr <= 0x1bf) return true;
    if (chr == 0x1c6) return true;
    if (chr == 0x1c9) return true;
    if (chr < 0x1cc) return false;
    if ((chr & 1) == 0 && chr <= 0x1dc) return true;
    if (chr < 0x1dd) return false;
    if ((chr & 1) == 1 && chr <= 0x1ef) return true;
    if (chr == 0x1f0) return true;
    if (chr < 0x1f3) return false;
    if ((chr & 1) == 1 && chr <= 0x1f5) return true;
    if (chr < 0x1f9) return false;
    if ((chr & 1) == 1 && chr <= 0x233) return true;
    if (chr < 0x234) return false;
    if (chr <= 0x239) return true;
    if (chr == 0x23c) return true;
    if (chr < 0x23f) return false;
    if (chr <= 0x240) return true;
    if (chr == 0x242) return true;
    if (chr < 0x247) return false;
    if ((chr & 1) == 1 && chr <= 0x24f) return true;
    if (chr < 0x250) return false;
    if (chr <= 0x293) return true;
    if (chr < 0x295) return false;
    if (chr <= 0x2af) return true;
    if (chr < 0x371) return false;
    if ((chr & 1) == 1 && chr <= 0x373) return true;
    if (chr == 0x377) return true;
    if (chr < 0x37b) return false;
    if (chr <= 0x37d) return true;
    if (chr == 0x390) return true;
    if (chr < 0x3ac) return false;
    if (chr <= 0x3ce) return true;
    if (chr < 0x3d0) return false;
    if (chr <= 0x3d1) return true;
    if (chr < 0x3d5) return false;
    if (chr <= 0x3d7) return true;
    if (chr < 0x3d9) return false;
    if ((chr & 1) == 1 && chr <= 0x3ef) return true;
    if (chr < 0x3f0) return false;
    if (chr <= 0x3f3) return true;
    if (chr == 0x3f5) return true;
    if (chr == 0x3f8) return true;
    if (chr < 0x3fb) return false;
    if (chr <= 0x3fc) return true;
    if (chr < 0x430) return false;
    if (chr <= 0x45f) return true;
    if (chr < 0x461) return false;
    if ((chr & 1) == 1 && chr <= 0x481) return true;
    if (chr < 0x48b) return false;
    if ((chr & 1) == 1 && chr <= 0x4bf) return true;
    if (chr < 0x4c2) return false;
    if ((chr & 1) == 0 && chr <= 0x4ce) return true;
    if (chr < 0x4cf) return false;
    if ((chr & 1) == 1 && chr <= 0x52f) return true;
    if (chr < 0x560) return false;
    if (chr <= 0x588) return true;
    if (chr < 0x10d0) return false;
    if (chr <= 0x10fa) return true;
    if (chr < 0x10fd) return false;
    if (chr <= 0x10ff) return true;
    if (chr < 0x13f8) return false;
    if (chr <= 0x13fd) return true;
    if (chr < 0x1c80) return false;
    if (chr <= 0x1c88) return true;
    if (chr < 0x1d00) return false;
    if (chr <= 0x1d2b) return true;
    if (chr < 0x1d6b) return false;
    if (chr <= 0x1d77) return true;
    if (chr < 0x1d79) return false;
    if (chr <= 0x1d9a) return true;
    if (chr < 0x1e01) return false;
    if ((chr & 1) == 1 && chr <= 0x1e95) return true;
    if (chr < 0x1e96) return false;
    if (chr <= 0x1e9d) return true;
    if (chr < 0x1e9f) return false;
    if ((chr & 1) == 1 && chr <= 0x1eff) return true;
    if (chr < 0x1f00) return false;
    if (chr <= 0x1f07) return true;
    if (chr < 0x1f10) return false;
    if (chr <= 0x1f15) return true;
    if (chr < 0x1f20) return false;
    if (chr <= 0x1f27) return true;
    if (chr < 0x1f30) return false;
    if (chr <= 0x1f37) return true;
    if (chr < 0x1f40) return false;
    if (chr <= 0x1f45) return true;
    if (chr < 0x1f50) return false;
    if (chr <= 0x1f57) return true;
    if (chr < 0x1f60) return false;
    if (chr <= 0x1f67) return true;
    if (chr < 0x1f70) return false;
    if (chr <= 0x1f7d) return true;
    if (chr < 0x1f80) return false;
    if (chr <= 0x1f87) return true;
    if (chr < 0x1f90) return false;
    if (chr <= 0x1f97) return true;
    if (chr < 0x1fa0) return false;
    if (chr <= 0x1fa7) return true;
    if (chr < 0x1fb0) return false;
    if (chr <= 0x1fb4) return true;
    if (chr < 0x1fb6) return false;
    if (chr <= 0x1fb7) return true;
    if (chr == 0x1fbe) return true;
    if (chr < 0x1fc2) return false;
    if (chr <= 0x1fc4) return true;
    if (chr < 0x1fc6) return false;
    if (chr <= 0x1fc7) return true;
    if (chr < 0x1fd0) return false;
    if (chr <= 0x1fd3) return true;
    if (chr < 0x1fd6) return false;
    if (chr <= 0x1fd7) return true;
    if (chr < 0x1fe0) return false;
    if (chr <= 0x1fe7) return true;
    if (chr < 0x1ff2) return false;
    if (chr <= 0x1ff4) return true;
    if (chr < 0x1ff6) return false;
    if (chr <= 0x1ff7) return true;
    if (chr == 0x210a) return true;
    if (chr < 0x210e) return false;
    if (chr <= 0x210f) return true;
    if (chr == 0x2113) return true;
    if (chr == 0x212f) return true;
    if (chr == 0x2134) return true;
    if (chr == 0x2139) return true;
    if (chr < 0x213c) return false;
    if (chr <= 0x213d) return true;
    if (chr < 0x2146) return false;
    if (chr <= 0x2149) return true;
    if (chr == 0x214e) return true;
    if (chr == 0x2184) return true;
    if (chr < 0x2c30) return false;
    if (chr <= 0x2c5f) return true;
    if (chr == 0x2c61) return true;
    if (chr < 0x2c65) return false;
    if (chr <= 0x2c66) return true;
    if (chr < 0x2c68) return false;
    if ((chr & 1) == 0 && chr <= 0x2c6c) return true;
    if (chr < 0x2c71) return false;
    if ((chr & 1) == 1 && chr <= 0x2c73) return true;
    if (chr < 0x2c74) return false;
    if ((chr & 1) == 0 && chr <= 0x2c76) return true;
    if (chr < 0x2c77) return false;
    if (chr <= 0x2c7b) return true;
    if (chr < 0x2c81) return false;
    if ((chr & 1) == 1 && chr <= 0x2ce3) return true;
    if (chr == 0x2ce4) return true;
    if (chr < 0x2cec) return false;
    if ((chr & 1) == 0 && chr <= 0x2cee) return true;
    if (chr == 0x2cf3) return true;
    if (chr < 0x2d00) return false;
    if (chr <= 0x2d25) return true;
    if (chr == 0x2d27) return true;
    if (chr == 0x2d2d) return true;
    if (chr < 0xa641) return false;
    if ((chr & 1) == 1 && chr <= 0xa66d) return true;
    if (chr < 0xa681) return false;
    if ((chr & 1) == 1 && chr <= 0xa69b) return true;
    if (chr < 0xa723) return false;
    if ((chr & 1) == 1 && chr <= 0xa72f) return true;
    if (chr < 0xa730) return false;
    if (chr <= 0xa731) return true;
    if (chr < 0xa733) return false;
    if ((chr & 1) == 1 && chr <= 0xa771) return true;
    if (chr < 0xa772) return false;
    if (chr <= 0xa778) return true;
    if (chr < 0xa77a) return false;
    if ((chr & 1) == 0 && chr <= 0xa77c) return true;
    if (chr < 0xa77f) return false;
    if ((chr & 1) == 1 && chr <= 0xa787) return true;
    if (chr < 0xa78c) return false;
    if ((chr & 1) == 0 && chr <= 0xa78e) return true;
    if (chr < 0xa791) return false;
    if ((chr & 1) == 1 && chr <= 0xa793) return true;
    if (chr < 0xa794) return false;
    if (chr <= 0xa795) return true;
    if (chr < 0xa797) return false;
    if ((chr & 1) == 1 && chr <= 0xa7a9) return true;
    if (chr == 0xa7af) return true;
    if (chr < 0xa7b5) return false;
    if ((chr & 1) == 1 && chr <= 0xa7c3) return true;
    if (chr < 0xa7c8) return false;
    if ((chr & 1) == 0 && chr <= 0xa7ca) return true;
    if (chr < 0xa7d1) return false;
    if ((chr & 1) == 1 && chr <= 0xa7d9) return true;
    if (chr == 0xa7f6) return true;
    if (chr == 0xa7fa) return true;
    if (chr < 0xab30) return false;
    if (chr <= 0xab5a) return true;
    if (chr < 0xab60) return false;
    if (chr <= 0xab68) return true;
    if (chr < 0xab70) return false;
    if (chr <= 0xabbf) return true;
    if (chr < 0xfb00) return false;
    if (chr <= 0xfb06) return true;
    if (chr < 0xfb13) return false;
    if (chr <= 0xfb17) return true;
    if (chr < 0xff41) return false;
    if (chr <= 0xff5a) return true;
    if (chr < 0x10428) return false;
    if (chr <= 0x1044f) return true;
    if (chr < 0x104d8) return false;
    if (chr <= 0x104fb) return true;
    if (chr < 0x10597) return false;
    if (chr <= 0x105a1) return true;
    if (chr < 0x105a3) return false;
    if (chr <= 0x105b1) return true;
    if (chr < 0x105b3) return false;
    if (chr <= 0x105b9) return true;
    if (chr < 0x105bb) return false;
    if (chr <= 0x105bc) return true;
    if (chr < 0x10cc0) return false;
    if (chr <= 0x10cf2) return true;
    if (chr < 0x118c0) return false;
    if (chr <= 0x118df) return true;
    if (chr < 0x16e60) return false;
    if (chr <= 0x16e7f) return true;
    if (chr < 0x1d41a) return false;
    if (chr <= 0x1d433) return true;
    if (chr < 0x1d44e) return false;
    if (chr <= 0x1d454) return true;
    if (chr < 0x1d456) return false;
    if (chr <= 0x1d467) return true;
    if (chr < 0x1d482) return false;
    if (chr <= 0x1d49b) return true;
    if (chr < 0x1d4b6) return false;
    if (chr <= 0x1d4b9) return true;
    if (chr < 0x1d4bb) return false;
    if ((chr & 1) == 1 && chr <= 0x1d4bd) return true;
    if (chr < 0x1d4be) return false;
    if (chr <= 0x1d4c3) return true;
    if (chr < 0x1d4c5) return false;
    if (chr <= 0x1d4cf) return true;
    if (chr < 0x1d4ea) return false;
    if (chr <= 0x1d503) return true;
    if (chr < 0x1d51e) return false;
    if (chr <= 0x1d537) return true;
    if (chr < 0x1d552) return false;
    if (chr <= 0x1d56b) return true;
    if (chr < 0x1d586) return false;
    if (chr <= 0x1d59f) return true;
    if (chr < 0x1d5ba) return false;
    if (chr <= 0x1d5d3) return true;
    if (chr < 0x1d5ee) return false;
    if (chr <= 0x1d607) return true;
    if (chr < 0x1d622) return false;
    if (chr <= 0x1d63b) return true;
    if (chr < 0x1d656) return false;
    if (chr <= 0x1d66f) return true;
    if (chr < 0x1d68a) return false;
    if (chr <= 0x1d6a5) return true;
    if (chr < 0x1d6c2) return false;
    if (chr <= 0x1d6da) return true;
    if (chr < 0x1d6dc) return false;
    if (chr <= 0x1d6e1) return true;
    if (chr < 0x1d6fc) return false;
    if (chr <= 0x1d714) return true;
    if (chr < 0x1d716) return false;
    if (chr <= 0x1d71b) return true;
    if (chr < 0x1d736) return false;
    if (chr <= 0x1d74e) return true;
    if (chr < 0x1d750) return false;
    if (chr <= 0x1d755) return true;
    if (chr < 0x1d770) return false;
    if (chr <= 0x1d788) return true;
    if (chr < 0x1d78a) return false;
    if (chr <= 0x1d78f) return true;
    if (chr < 0x1d7aa) return false;
    if (chr <= 0x1d7c2) return true;
    if (chr < 0x1d7c4) return false;
    if (chr <= 0x1d7c9) return true;
    if (chr == 0x1d7cb) return true;
    if (chr < 0x1df00) return false;
    if (chr <= 0x1df09) return true;
    if (chr < 0x1df0b) return false;
    if (chr <= 0x1df1e) return true;
    if (chr < 0x1df25) return false;
    if (chr <= 0x1df2a) return true;
    if (chr < 0x1e922) return false;
    if (chr <= 0x1e943) return true;
    return false;
  }

static uint32_t to_lower_case
  (
    uint32_t chr
  )
  {
    if (chr < 0x41) return chr;
    if (chr <= 0x5a) return chr+0x20;
    if (chr < 0xc0) return chr;
    if (chr <= 0xd6) return chr+0x20;
    if (chr < 0xd8) return chr;
    if (chr <= 0xde) return chr+0x20;
    if (chr < 0x100) return chr;
    if ((chr & 1) == 0 && chr <= 0x12e) return chr+1;
    if (chr == 0x130) return chr-0xc7;
    if (chr < 0x132) return chr;
    if ((chr & 1) == 0 && chr <= 0x136) return chr+1;
    if (chr < 0x139) return chr;
    if ((chr & 1) == 1 && chr <= 0x147) return chr+1;
    if (chr < 0x14a) return chr;
    if ((chr & 1) == 0 && chr <= 0x176) return chr+1;
    if (chr == 0x178) return chr-0x79;
    if (chr < 0x179) return chr;
    if ((chr & 1) == 1 && chr <= 0x17d) return chr+1;
    if (chr == 0x181) return chr+0xd2;
    if (chr < 0x182) return chr;
    if ((chr & 1) == 0 && chr <= 0x184) return chr+1;
    if (chr == 0x186) return chr+0xce;
    if (chr == 0x187) return chr+1;
    if (chr < 0x189) return chr;
    if (chr <= 0x18a) return chr+0xcd;
    if (chr == 0x18b) return chr+1;
    if (chr == 0x18e) return chr+0x4f;
    if (chr == 0x18f) return chr+0xca;
    if (chr == 0x190) return chr+0xcb;
    if (chr == 0x191) return chr+1;
    if (chr == 0x193) return chr+0xcd;
    if (chr == 0x194) return chr+0xcf;
    if (chr == 0x196) return chr+0xd3;
    if (chr == 0x197) return chr+0xd1;
    if (chr == 0x198) return chr+1;
    if (chr == 0x19c) return chr+0xd3;
    if (chr == 0x19d) return chr+0xd5;
    if (chr == 0x19f) return chr+0xd6;
    if (chr < 0x1a0) return chr;
    if ((chr & 1) == 0 && chr <= 0x1a4) return chr+1;
    if (chr == 0x1a6) return chr+0xda;
    if (chr == 0x1a7) return chr+1;
    if (chr == 0x1a9) return chr+0xda;
    if (chr == 0x1ac) return chr+1;
    if (chr == 0x1ae) return chr+0xda;
    if (chr == 0x1af) return chr+1;
    if (chr < 0x1b1) return chr;
    if (chr <= 0x1b2) return chr+0xd9;
    if (chr < 0x1b3) return chr;
    if ((chr & 1) == 1 && chr <= 0x1b5) return chr+1;
    if (chr == 0x1b7) return chr+0xdb;
    if (chr == 0x1b8) return chr+1;
    if (chr == 0x1bc) return chr+1;
    if (chr == 0x1c4) return chr+2;
    if (chr == 0x1c5) return chr+1;
    if (chr == 0x1c7) return chr+2;
    if (chr == 0x1c8) return chr+1;
    if (chr == 0x1ca) return chr+2;
    if (chr < 0x1cb) return chr;
    if ((chr & 1) == 1 && chr <= 0x1db) return chr+1;
    if (chr < 0x1de) return chr;
    if ((chr & 1) == 0 && chr <= 0x1ee) return chr+1;
    if (chr == 0x1f1) return chr+2;
    if (chr < 0x1f2) return chr;
    if ((chr & 1) == 0 && chr <= 0x1f4) return chr+1;
    if (chr == 0x1f6) return chr-0x61;
    if (chr == 0x1f7) return chr-0x38;
    if (chr < 0x1f8) return chr;
    if ((chr & 1) == 0 && chr <= 0x21e) return chr+1;
    if (chr == 0x220) return chr-0x82;
    if (chr < 0x222) return chr;
    if ((chr & 1) == 0 && chr <= 0x232) return chr+1;
    if (chr == 0x23a) return chr+0x2a2b;
    if (chr == 0x23b) return chr+1;
    if (chr == 0x23d) return chr-0xa3;
    if (chr == 0x23e) return chr+0x2a28;
    if (chr == 0x241) return chr+1;
    if (chr == 0x243) return chr-0xc3;
    if (chr == 0x244) return chr+0x45;
    if (chr == 0x245) return chr+0x47;
    if (chr < 0x246) return chr;
    if ((chr & 1) == 0 && chr <= 0x24e) return chr+1;
    if (chr < 0x370) return chr;
    if ((chr & 1) == 0 && chr <= 0x372) return chr+1;
    if (chr == 0x376) return chr+1;
    if (chr == 0x37f) return chr+0x74;
    if (chr == 0x386) return chr+0x26;
    if (chr < 0x388) return chr;
    if (chr <= 0x38a) return chr+0x25;
    if (chr == 0x38c) return chr+0x40;
    if (chr < 0x38e) return chr;
    if (chr <= 0x38f) return chr+0x3f;
    if (chr < 0x391) return chr;
    if (chr <= 0x3a1) return chr+0x20;
    if (chr < 0x3a3) return chr;
    if (chr <= 0x3ab) return chr+0x20;
    if (chr == 0x3cf) return chr+8;
    if (chr < 0x3d8) return chr;
    if ((chr & 1) == 0 && chr <= 0x3ee) return chr+1;
    if (chr == 0x3f4) return chr-0x3c;
    if (chr == 0x3f7) return chr+1;
    if (chr == 0x3f9) return chr-7;
    if (chr == 0x3fa) return chr+1;
    if (chr < 0x3fd) return chr;
    if (chr <= 0x3ff) return chr-0x82;
    if (chr < 0x400) return chr;
    if (chr <= 0x40f) return chr+0x50;
    if (chr < 0x410) return chr;
    if (chr <= 0x42f) return chr+0x20;
    if (chr < 0x460) return chr;
    if ((chr & 1) == 0 && chr <= 0x480) return chr+1;
    if (chr < 0x48a) return chr;
    if ((chr & 1) == 0 && chr <= 0x4be) return chr+1;
    if (chr == 0x4c0) return chr+0xf;
    if (chr < 0x4c1) return chr;
    if ((chr & 1) == 1 && chr <= 0x4cd) return chr+1;
    if (chr < 0x4d0) return chr;
    if ((chr & 1) == 0 && chr <= 0x52e) return chr+1;
    if (chr < 0x531) return chr;
    if (chr <= 0x556) return chr+0x30;
    if (chr < 0x10a0) return chr;
    if (chr <= 0x10c5) return chr+0x1c60;
    if (chr == 0x10c7) return chr+0x1c60;
    if (chr == 0x10cd) return chr+0x1c60;
    if (chr < 0x13a0) return chr;
    if (chr <= 0x13ef) return chr+0x97d0;
    if (chr < 0x13f0) return chr;
    if (chr <= 0x13f5) return chr+8;
    if (chr < 0x1c90) return chr;
    if (chr <= 0x1cba) return chr-0xbc0;
    if (chr < 0x1cbd) return chr;
    if (chr <= 0x1cbf) return chr-0xbc0;
    if (chr < 0x1e00) return chr;
    if ((chr & 1) == 0 && chr <= 0x1e94) return chr+1;
    if (chr == 0x1e9e) return chr-0x1dbf;
    if (chr < 0x1ea0) return chr;
    if ((chr & 1) == 0 && chr <= 0x1efe) return chr+1;
    if (chr < 0x1f08) return chr;
    if (chr <= 0x1f0f) return chr-8;
    if (chr < 0x1f18) return chr;
    if (chr <= 0x1f1d) return chr-8;
    if (chr < 0x1f28) return chr;
    if (chr <= 0x1f2f) return chr-8;
    if (chr < 0x1f38) return chr;
    if (chr <= 0x1f3f) return chr-8;
    if (chr < 0x1f48) return chr;
    if (chr <= 0x1f4d) return chr-8;
    if (chr < 0x1f59) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f5f) return chr-8;
    if (chr < 0x1f68) return chr;
    if (chr <= 0x1f6f) return chr-8;
    if (chr < 0x1f88) return chr;
    if (chr <= 0x1f8f) return chr-8;
    if (chr < 0x1f98) return chr;
    if (chr <= 0x1f9f) return chr-8;
    if (chr < 0x1fa8) return chr;
    if (chr <= 0x1faf) return chr-8;
    if (chr < 0x1fb8) return chr;
    if (chr <= 0x1fb9) return chr-8;
    if (chr < 0x1fba) return chr;
    if (chr <= 0x1fbb) return chr-0x4a;
    if (chr == 0x1fbc) return chr-9;
    if (chr < 0x1fc8) return chr;
    if (chr <= 0x1fcb) return chr-0x56;
    if (chr == 0x1fcc) return chr-9;
    if (chr < 0x1fd8) return chr;
    if (chr <= 0x1fd9) return chr-8;
    if (chr < 0x1fda) return chr;
    if (chr <= 0x1fdb) return chr-0x64;
    if (chr < 0x1fe8) return chr;
    if (chr <= 0x1fe9) return chr-8;
    if (chr < 0x1fea) return chr;
    if (chr <= 0x1feb) return chr-0x70;
    if (chr == 0x1fec) return chr-7;
    if (chr < 0x1ff8) return chr;
    if (chr <= 0x1ff9) return chr-0x80;
    if (chr < 0x1ffa) return chr;
    if (chr <= 0x1ffb) return chr-0x7e;
    if (chr == 0x1ffc) return chr-9;
    if (chr == 0x2126) return chr-0x1d5d;
    if (chr == 0x212a) return chr-0x20bf;
    if (chr == 0x212b) return chr-0x2046;
    if (chr == 0x2132) return chr+0x1c;
    if (chr < 0x2160) return chr;
    if (chr <= 0x216f) return chr+0x10;
    if (chr == 0x2183) return chr+1;
    if (chr < 0x24b6) return chr;
    if (chr <= 0x24cf) return chr+0x1a;
    if (chr < 0x2c00) return chr;
    if (chr <= 0x2c2f) return chr+0x30;
    if (chr == 0x2c60) return chr+1;
    if (chr == 0x2c62) return chr-0x29f7;
    if (chr == 0x2c63) return chr-0xee6;
    if (chr == 0x2c64) return chr-0x29e7;
    if (chr < 0x2c67) return chr;
    if ((chr & 1) == 1 && chr <= 0x2c6b) return chr+1;
    if (chr == 0x2c6d) return chr-0x2a1c;
    if (chr == 0x2c6e) return chr-0x29fd;
    if (chr == 0x2c6f) return chr-0x2a1f;
    if (chr == 0x2c70) return chr-0x2a1e;
    if (chr == 0x2c72) return chr+1;
    if (chr == 0x2c75) return chr+1;
    if (chr < 0x2c7e) return chr;
    if (chr <= 0x2c7f) return chr-0x2a3f;
    if (chr < 0x2c80) return chr;
    if ((chr & 1) == 0 && chr <= 0x2ce2) return chr+1;
    if (chr < 0x2ceb) return chr;
    if ((chr & 1) == 1 && chr <= 0x2ced) return chr+1;
    if (chr == 0x2cf2) return chr+1;
    if (chr < 0xa640) return chr;
    if ((chr & 1) == 0 && chr <= 0xa66c) return chr+1;
    if (chr < 0xa680) return chr;
    if ((chr & 1) == 0 && chr <= 0xa69a) return chr+1;
    if (chr < 0xa722) return chr;
    if ((chr & 1) == 0 && chr <= 0xa72e) return chr+1;
    if (chr < 0xa732) return chr;
    if ((chr & 1) == 0 && chr <= 0xa76e) return chr+1;
    if (chr < 0xa779) return chr;
    if ((chr & 1) == 1 && chr <= 0xa77b) return chr+1;
    if (chr == 0xa77d) return chr-0x8a04;
    if (chr < 0xa77e) return chr;
    if ((chr & 1) == 0 && chr <= 0xa786) return chr+1;
    if (chr == 0xa78b) return chr+1;
    if (chr == 0xa78d) return chr-0xa528;
    if (chr < 0xa790) return chr;
    if ((chr & 1) == 0 && chr <= 0xa792) return chr+1;
    if (chr < 0xa796) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7a8) return chr+1;
    if (chr == 0xa7aa) return chr-0xa544;
    if (chr == 0xa7ab) return chr-0xa54f;
    if (chr == 0xa7ac) return chr-0xa54b;
    if (chr == 0xa7ad) return chr-0xa541;
    if (chr == 0xa7ae) return chr-0xa544;
    if (chr == 0xa7b0) return chr-0xa512;
    if (chr == 0xa7b1) return chr-0xa52a;
    if (chr == 0xa7b2) return chr-0xa515;
    if (chr == 0xa7b3) return chr+0x3a0;
    if (chr < 0xa7b4) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7c2) return chr+1;
    if (chr == 0xa7c4) return chr-0x30;
    if (chr == 0xa7c5) return chr-0xa543;
    if (chr == 0xa7c6) return chr-0x8a38;
    if (chr < 0xa7c7) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7c9) return chr+1;
    if (chr == 0xa7d0) return chr+1;
    if (chr < 0xa7d6) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7d8) return chr+1;
    if (chr == 0xa7f5) return chr+1;
    if (chr < 0xff21) return chr;
    if (chr <= 0xff3a) return chr+0x20;
    if (chr < 0x10400) return chr;
    if (chr <= 0x10427) return chr+0x28;
    if (chr < 0x104b0) return chr;
    if (chr <= 0x104d3) return chr+0x28;
    if (chr < 0x10570) return chr;
    if (chr <= 0x1057a) return chr+0x27;
    if (chr < 0x1057c) return chr;
    if (chr <= 0x1058a) return chr+0x27;
    if (chr < 0x1058c) return chr;
    if (chr <= 0x10592) return chr+0x27;
    if (chr < 0x10594) return chr;
    if (chr <= 0x10595) return chr+0x27;
    if (chr < 0x10c80) return chr;
    if (chr <= 0x10cb2) return chr+0x40;
    if (chr < 0x118a0) return chr;
    if (chr <= 0x118bf) return chr+0x20;
    if (chr < 0x16e40) return chr;
    if (chr <= 0x16e5f) return chr+0x20;
    if (chr < 0x1e900) return chr;
    if (chr <= 0x1e921) return chr+0x22;
    return chr;
  }

int is_a_title_case_letter_character
  (
    uint32_t chr
  )
  {
    if (chr == 0x1c5) return true;
    if (chr == 0x1c8) return true;
    if (chr == 0x1cb) return true;
    if (chr == 0x1f2) return true;
    if (chr < 0x1f88) return false;
    if (chr <= 0x1f8f) return true;
    if (chr < 0x1f98) return false;
    if (chr <= 0x1f9f) return true;
    if (chr < 0x1fa8) return false;
    if (chr <= 0x1faf) return true;
    if (chr == 0x1fbc) return true;
    if (chr == 0x1fcc) return true;
    if (chr == 0x1ffc) return true;
    return false;
  }

static uint32_t to_title_case
  (
    uint32_t chr
  )
  {
    if (chr < 0x61) return chr;
    if (chr <= 0x7a) return chr-0x20;
    if (chr == 0xb5) return chr+0x2e7;
    if (chr < 0xe0) return chr;
    if (chr <= 0xf6) return chr-0x20;
    if (chr < 0xf8) return chr;
    if (chr <= 0xfe) return chr-0x20;
    if (chr == 0xff) return chr+0x79;
    if (chr < 0x101) return chr;
    if ((chr & 1) == 1 && chr <= 0x12f) return chr-1;
    if (chr == 0x131) return chr-0xe8;
    if (chr < 0x133) return chr;
    if ((chr & 1) == 1 && chr <= 0x137) return chr-1;
    if (chr < 0x13a) return chr;
    if ((chr & 1) == 0 && chr <= 0x148) return chr-1;
    if (chr < 0x14b) return chr;
    if ((chr & 1) == 1 && chr <= 0x177) return chr-1;
    if (chr < 0x17a) return chr;
    if ((chr & 1) == 0 && chr <= 0x17e) return chr-1;
    if (chr == 0x17f) return chr-0x12c;
    if (chr == 0x180) return chr+0xc3;
    if (chr < 0x183) return chr;
    if ((chr & 1) == 1 && chr <= 0x185) return chr-1;
    if (chr == 0x188) return chr-1;
    if (chr == 0x18c) return chr-1;
    if (chr == 0x192) return chr-1;
    if (chr == 0x195) return chr+0x61;
    if (chr == 0x199) return chr-1;
    if (chr == 0x19a) return chr+0xa3;
    if (chr == 0x19e) return chr+0x82;
    if (chr < 0x1a1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1a5) return chr-1;
    if (chr == 0x1a8) return chr-1;
    if (chr == 0x1ad) return chr-1;
    if (chr == 0x1b0) return chr-1;
    if (chr < 0x1b4) return chr;
    if ((chr & 1) == 0 && chr <= 0x1b6) return chr-1;
    if (chr == 0x1b9) return chr-1;
    if (chr == 0x1bd) return chr-1;
    if (chr == 0x1bf) return chr+0x38;
    if (chr == 0x1c4) return chr+1;
    if (chr == 0x1c6) return chr-1;
    if (chr == 0x1c7) return chr+1;
    if (chr == 0x1c9) return chr-1;
    if (chr == 0x1ca) return chr+1;
    if (chr < 0x1cc) return chr;
    if ((chr & 1) == 0 && chr <= 0x1dc) return chr-1;
    if (chr == 0x1dd) return chr-0x4f;
    if (chr < 0x1df) return chr;
    if ((chr & 1) == 1 && chr <= 0x1ef) return chr-1;
    if (chr == 0x1f1) return chr+1;
    if (chr < 0x1f3) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f5) return chr-1;
    if (chr < 0x1f9) return chr;
    if ((chr & 1) == 1 && chr <= 0x21f) return chr-1;
    if (chr < 0x223) return chr;
    if ((chr & 1) == 1 && chr <= 0x233) return chr-1;
    if (chr == 0x23c) return chr-1;
    if (chr < 0x23f) return chr;
    if (chr <= 0x240) return chr+0x2a3f;
    if (chr == 0x242) return chr-1;
    if (chr < 0x247) return chr;
    if ((chr & 1) == 1 && chr <= 0x24f) return chr-1;
    if (chr == 0x250) return chr+0x2a1f;
    if (chr == 0x251) return chr+0x2a1c;
    if (chr == 0x252) return chr+0x2a1e;
    if (chr == 0x253) return chr-0xd2;
    if (chr == 0x254) return chr-0xce;
    if (chr < 0x256) return chr;
    if (chr <= 0x257) return chr-0xcd;
    if (chr == 0x259) return chr-0xca;
    if (chr == 0x25b) return chr-0xcb;
    if (chr == 0x25c) return chr+0xa54f;
    if (chr == 0x260) return chr-0xcd;
    if (chr == 0x261) return chr+0xa54b;
    if (chr == 0x263) return chr-0xcf;
    if (chr == 0x265) return chr+0xa528;
    if (chr == 0x266) return chr+0xa544;
    if (chr == 0x268) return chr-0xd1;
    if (chr == 0x269) return chr-0xd3;
    if (chr == 0x26a) return chr+0xa544;
    if (chr == 0x26b) return chr+0x29f7;
    if (chr == 0x26c) return chr+0xa541;
    if (chr == 0x26f) return chr-0xd3;
    if (chr == 0x271) return chr+0x29fd;
    if (chr == 0x272) return chr-0xd5;
    if (chr == 0x275) return chr-0xd6;
    if (chr == 0x27d) return chr+0x29e7;
    if (chr == 0x280) return chr-0xda;
    if (chr == 0x282) return chr+0xa543;
    if (chr == 0x283) return chr-0xda;
    if (chr == 0x287) return chr+0xa52a;
    if (chr == 0x288) return chr-0xda;
    if (chr == 0x289) return chr-0x45;
    if (chr < 0x28a) return chr;
    if (chr <= 0x28b) return chr-0xd9;
    if (chr == 0x28c) return chr-0x47;
    if (chr == 0x292) return chr-0xdb;
    if (chr == 0x29d) return chr+0xa515;
    if (chr == 0x29e) return chr+0xa512;
    if (chr == 0x345) return chr+0x54;
    if (chr < 0x371) return chr;
    if ((chr & 1) == 1 && chr <= 0x373) return chr-1;
    if (chr == 0x377) return chr-1;
    if (chr < 0x37b) return chr;
    if (chr <= 0x37d) return chr+0x82;
    if (chr == 0x3ac) return chr-0x26;
    if (chr < 0x3ad) return chr;
    if (chr <= 0x3af) return chr-0x25;
    if (chr < 0x3b1) return chr;
    if (chr <= 0x3c1) return chr-0x20;
    if (chr == 0x3c2) return chr-0x1f;
    if (chr < 0x3c3) return chr;
    if (chr <= 0x3cb) return chr-0x20;
    if (chr == 0x3cc) return chr-0x40;
    if (chr < 0x3cd) return chr;
    if (chr <= 0x3ce) return chr-0x3f;
    if (chr == 0x3d0) return chr-0x3e;
    if (chr == 0x3d1) return chr-0x39;
    if (chr == 0x3d5) return chr-0x2f;
    if (chr == 0x3d6) return chr-0x36;
    if (chr == 0x3d7) return chr-8;
    if (chr < 0x3d9) return chr;
    if ((chr & 1) == 1 && chr <= 0x3ef) return chr-1;
    if (chr == 0x3f0) return chr-0x56;
    if (chr == 0x3f1) return chr-0x50;
    if (chr == 0x3f2) return chr+7;
    if (chr == 0x3f3) return chr-0x74;
    if (chr == 0x3f5) return chr-0x60;
    if (chr == 0x3f8) return chr-1;
    if (chr == 0x3fb) return chr-1;
    if (chr < 0x430) return chr;
    if (chr <= 0x44f) return chr-0x20;
    if (chr < 0x450) return chr;
    if (chr <= 0x45f) return chr-0x50;
    if (chr < 0x461) return chr;
    if ((chr & 1) == 1 && chr <= 0x481) return chr-1;
    if (chr < 0x48b) return chr;
    if ((chr & 1) == 1 && chr <= 0x4bf) return chr-1;
    if (chr < 0x4c2) return chr;
    if ((chr & 1) == 0 && chr <= 0x4ce) return chr-1;
    if (chr == 0x4cf) return chr-0xf;
    if (chr < 0x4d1) return chr;
    if ((chr & 1) == 1 && chr <= 0x52f) return chr-1;
    if (chr < 0x561) return chr;
    if (chr <= 0x586) return chr-0x30;
    if (chr < 0x13f8) return chr;
    if (chr <= 0x13fd) return chr-8;
    if (chr == 0x1c80) return chr-0x186e;
    if (chr == 0x1c81) return chr-0x186d;
    if (chr == 0x1c82) return chr-0x1864;
    if (chr < 0x1c83) return chr;
    if (chr <= 0x1c84) return chr-0x1862;
    if (chr == 0x1c85) return chr-0x1863;
    if (chr == 0x1c86) return chr-0x185c;
    if (chr == 0x1c87) return chr-0x1825;
    if (chr == 0x1c88) return chr+0x89c2;
    if (chr == 0x1d79) return chr+0x8a04;
    if (chr == 0x1d7d) return chr+0xee6;
    if (chr == 0x1d8e) return chr+0x8a38;
    if (chr < 0x1e01) return chr;
    if ((chr & 1) == 1 && chr <= 0x1e95) return chr-1;
    if (chr == 0x1e9b) return chr-0x3b;
    if (chr < 0x1ea1) return chr;
    if ((chr & 1) == 1 && chr <= 0x1eff) return chr-1;
    if (chr < 0x1f00) return chr;
    if (chr <= 0x1f07) return chr+8;
    if (chr < 0x1f10) return chr;
    if (chr <= 0x1f15) return chr+8;
    if (chr < 0x1f20) return chr;
    if (chr <= 0x1f27) return chr+8;
    if (chr < 0x1f30) return chr;
    if (chr <= 0x1f37) return chr+8;
    if (chr < 0x1f40) return chr;
    if (chr <= 0x1f45) return chr+8;
    if (chr < 0x1f51) return chr;
    if ((chr & 1) == 1 && chr <= 0x1f57) return chr+8;
    if (chr < 0x1f60) return chr;
    if (chr <= 0x1f67) return chr+8;
    if (chr < 0x1f70) return chr;
    if (chr <= 0x1f71) return chr+0x4a;
    if (chr < 0x1f72) return chr;
    if (chr <= 0x1f75) return chr+0x56;
    if (chr < 0x1f76) return chr;
    if (chr <= 0x1f77) return chr+0x64;
    if (chr < 0x1f78) return chr;
    if (chr <= 0x1f79) return chr+0x80;
    if (chr < 0x1f7a) return chr;
    if (chr <= 0x1f7b) return chr+0x70;
    if (chr < 0x1f7c) return chr;
    if (chr <= 0x1f7d) return chr+0x7e;
    if (chr < 0x1f80) return chr;
    if (chr <= 0x1f87) return chr+8;
    if (chr < 0x1f90) return chr;
    if (chr <= 0x1f97) return chr+8;
    if (chr < 0x1fa0) return chr;
    if (chr <= 0x1fa7) return chr+8;
    if (chr < 0x1fb0) return chr;
    if (chr <= 0x1fb1) return chr+8;
    if (chr == 0x1fb3) return chr+9;
    if (chr == 0x1fbe) return chr-0x1c25;
    if (chr == 0x1fc3) return chr+9;
    if (chr < 0x1fd0) return chr;
    if (chr <= 0x1fd1) return chr+8;
    if (chr < 0x1fe0) return chr;
    if (chr <= 0x1fe1) return chr+8;
    if (chr == 0x1fe5) return chr+7;
    if (chr == 0x1ff3) return chr+9;
    if (chr == 0x214e) return chr-0x1c;
    if (chr < 0x2170) return chr;
    if (chr <= 0x217f) return chr-0x10;
    if (chr == 0x2184) return chr-1;
    if (chr < 0x24d0) return chr;
    if (chr <= 0x24e9) return chr-0x1a;
    if (chr < 0x2c30) return chr;
    if (chr <= 0x2c5f) return chr-0x30;
    if (chr == 0x2c61) return chr-1;
    if (chr == 0x2c65) return chr-0x2a2b;
    if (chr == 0x2c66) return chr-0x2a28;
    if (chr < 0x2c68) return chr;
    if ((chr & 1) == 0 && chr <= 0x2c6c) return chr-1;
    if (chr == 0x2c73) return chr-1;
    if (chr == 0x2c76) return chr-1;
    if (chr < 0x2c81) return chr;
    if ((chr & 1) == 1 && chr <= 0x2ce3) return chr-1;
    if (chr < 0x2cec) return chr;
    if ((chr & 1) == 0 && chr <= 0x2cee) return chr-1;
    if (chr == 0x2cf3) return chr-1;
    if (chr < 0x2d00) return chr;
    if (chr <= 0x2d25) return chr-0x1c60;
    if (chr == 0x2d27) return chr-0x1c60;
    if (chr == 0x2d2d) return chr-0x1c60;
    if (chr < 0xa641) return chr;
    if ((chr & 1) == 1 && chr <= 0xa66d) return chr-1;
    if (chr < 0xa681) return chr;
    if ((chr & 1) == 1 && chr <= 0xa69b) return chr-1;
    if (chr < 0xa723) return chr;
    if ((chr & 1) == 1 && chr <= 0xa72f) return chr-1;
    if (chr < 0xa733) return chr;
    if ((chr & 1) == 1 && chr <= 0xa76f) return chr-1;
    if (chr < 0xa77a) return chr;
    if ((chr & 1) == 0 && chr <= 0xa77c) return chr-1;
    if (chr < 0xa77f) return chr;
    if ((chr & 1) == 1 && chr <= 0xa787) return chr-1;
    if (chr == 0xa78c) return chr-1;
    if (chr < 0xa791) return chr;
    if ((chr & 1) == 1 && chr <= 0xa793) return chr-1;
    if (chr == 0xa794) return chr+0x30;
    if (chr < 0xa797) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7a9) return chr-1;
    if (chr < 0xa7b5) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7c3) return chr-1;
    if (chr < 0xa7c8) return chr;
    if ((chr & 1) == 0 && chr <= 0xa7ca) return chr-1;
    if (chr == 0xa7d1) return chr-1;
    if (chr < 0xa7d7) return chr;
    if ((chr & 1) == 1 && chr <= 0xa7d9) return chr-1;
    if (chr == 0xa7f6) return chr-1;
    if (chr == 0xab53) return chr-0x3a0;
    if (chr < 0xab70) return chr;
    if (chr <= 0xabbf) return chr-0x97d0;
    if (chr < 0xff41) return chr;
    if (chr <= 0xff5a) return chr-0x20;
    if (chr < 0x10428) return chr;
    if (chr <= 0x1044f) return chr-0x28;
    if (chr < 0x104d8) return chr;
    if (chr <= 0x104fb) return chr-0x28;
    if (chr < 0x10597) return chr;
    if (chr <= 0x105a1) return chr-0x27;
    if (chr < 0x105a3) return chr;
    if (chr <= 0x105b1) return chr-0x27;
    if (chr < 0x105b3) return chr;
    if (chr <= 0x105b9) return chr-0x27;
    if (chr < 0x105bb) return chr;
    if (chr <= 0x105bc) return chr-0x27;
    if (chr < 0x10cc0) return chr;
    if (chr <= 0x10cf2) return chr-0x40;
    if (chr < 0x118c0) return chr;
    if (chr <= 0x118df) return chr-0x20;
    if (chr < 0x16e60) return chr;
    if (chr <= 0x16e7f) return chr-0x20;
    if (chr < 0x1e922) return chr;
    if (chr <= 0x1e943) return chr-0x22;
    return chr;
  }

int is_a_letter_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x41) return false;
    if (chr <= 0x5a) return true;
    if (chr < 0x61) return false;
    if (chr <= 0x7a) return true;
    if (chr == 0xb5) return true;
    if (chr < 0xc0) return false;
    if (chr <= 0xd6) return true;
    if (chr < 0xd8) return false;
    if (chr <= 0xf6) return true;
    if (chr < 0xf8) return false;
    if (chr <= 0x1ba) return true;
    if (chr < 0x1bc) return false;
    if (chr <= 0x1bf) return true;
    if (chr < 0x1c4) return false;
    if (chr <= 0x293) return true;
    if (chr < 0x295) return false;
    if (chr <= 0x2af) return true;
    if (chr < 0x370) return false;
    if (chr <= 0x373) return true;
    if (chr < 0x376) return false;
    if (chr <= 0x377) return true;
    if (chr < 0x37b) return false;
    if (chr <= 0x37d) return true;
    if (chr == 0x37f) return true;
    if (chr < 0x386) return false;
    if ((chr & 1) == 0 && chr <= 0x388) return true;
    if (chr < 0x389) return false;
    if (chr <= 0x38a) return true;
    if (chr < 0x38c) return false;
    if ((chr & 1) == 0 && chr <= 0x38e) return true;
    if (chr < 0x38f) return false;
    if (chr <= 0x3a1) return true;
    if (chr < 0x3a3) return false;
    if (chr <= 0x3f5) return true;
    if (chr < 0x3f7) return false;
    if (chr <= 0x481) return true;
    if (chr < 0x48a) return false;
    if (chr <= 0x52f) return true;
    if (chr < 0x531) return false;
    if (chr <= 0x556) return true;
    if (chr < 0x560) return false;
    if (chr <= 0x588) return true;
    if (chr < 0x10a0) return false;
    if (chr <= 0x10c5) return true;
    if (chr == 0x10c7) return true;
    if (chr == 0x10cd) return true;
    if (chr < 0x10d0) return false;
    if (chr <= 0x10fa) return true;
    if (chr < 0x10fd) return false;
    if (chr <= 0x10ff) return true;
    if (chr < 0x13a0) return false;
    if (chr <= 0x13f5) return true;
    if (chr < 0x13f8) return false;
    if (chr <= 0x13fd) return true;
    if (chr < 0x1c80) return false;
    if (chr <= 0x1c88) return true;
    if (chr < 0x1c90) return false;
    if (chr <= 0x1cba) return true;
    if (chr < 0x1cbd) return false;
    if (chr <= 0x1cbf) return true;
    if (chr < 0x1d00) return false;
    if (chr <= 0x1d2b) return true;
    if (chr < 0x1d6b) return false;
    if (chr <= 0x1d77) return true;
    if (chr < 0x1d79) return false;
    if (chr <= 0x1d9a) return true;
    if (chr < 0x1e00) return false;
    if (chr <= 0x1f15) return true;
    if (chr < 0x1f18) return false;
    if (chr <= 0x1f1d) return true;
    if (chr < 0x1f20) return false;
    if (chr <= 0x1f45) return true;
    if (chr < 0x1f48) return false;
    if (chr <= 0x1f4d) return true;
    if (chr < 0x1f50) return false;
    if (chr <= 0x1f57) return true;
    if (chr < 0x1f59) return false;
    if ((chr & 1) == 1 && chr <= 0x1f5f) return true;
    if (chr < 0x1f60) return false;
    if (chr <= 0x1f7d) return true;
    if (chr < 0x1f80) return false;
    if (chr <= 0x1fb4) return true;
    if (chr < 0x1fb6) return false;
    if (chr <= 0x1fbc) return true;
    if (chr == 0x1fbe) return true;
    if (chr < 0x1fc2) return false;
    if (chr <= 0x1fc4) return true;
    if (chr < 0x1fc6) return false;
    if (chr <= 0x1fcc) return true;
    if (chr < 0x1fd0) return false;
    if (chr <= 0x1fd3) return true;
    if (chr < 0x1fd6) return false;
    if (chr <= 0x1fdb) return true;
    if (chr < 0x1fe0) return false;
    if (chr <= 0x1fec) return true;
    if (chr < 0x1ff2) return false;
    if (chr <= 0x1ff4) return true;
    if (chr < 0x1ff6) return false;
    if (chr <= 0x1ffc) return true;
    if (chr == 0x2102) return true;
    if (chr == 0x2107) return true;
    if (chr < 0x210a) return false;
    if (chr <= 0x2113) return true;
    if (chr == 0x2115) return true;
    if (chr < 0x2119) return false;
    if (chr <= 0x211d) return true;
    if (chr < 0x2124) return false;
    if ((chr & 1) == 0 && chr <= 0x212a) return true;
    if (chr < 0x212b) return false;
    if (chr <= 0x212d) return true;
    if (chr < 0x212f) return false;
    if (chr <= 0x2134) return true;
    if (chr == 0x2139) return true;
    if (chr < 0x213c) return false;
    if (chr <= 0x213f) return true;
    if (chr < 0x2145) return false;
    if (chr <= 0x2149) return true;
    if (chr == 0x214e) return true;
    if (chr < 0x2183) return false;
    if (chr <= 0x2184) return true;
    if (chr < 0x2c00) return false;
    if (chr <= 0x2c7b) return true;
    if (chr < 0x2c7e) return false;
    if (chr <= 0x2ce4) return true;
    if (chr < 0x2ceb) return false;
    if (chr <= 0x2cee) return true;
    if (chr < 0x2cf2) return false;
    if (chr <= 0x2cf3) return true;
    if (chr < 0x2d00) return false;
    if (chr <= 0x2d25) return true;
    if (chr == 0x2d27) return true;
    if (chr == 0x2d2d) return true;
    if (chr < 0xa640) return false;
    if (chr <= 0xa66d) return true;
    if (chr < 0xa680) return false;
    if (chr <= 0xa69b) return true;
    if (chr < 0xa722) return false;
    if (chr <= 0xa76f) return true;
    if (chr < 0xa771) return false;
    if (chr <= 0xa787) return true;
    if (chr < 0xa78b) return false;
    if (chr <= 0xa78e) return true;
    if (chr < 0xa790) return false;
    if (chr <= 0xa7ca) return true;
    if (chr < 0xa7d0) return false;
    if (chr <= 0xa7d1) return true;
    if (chr < 0xa7d3) return false;
    if ((chr & 1) == 1 && chr <= 0xa7d5) return true;
    if (chr < 0xa7d6) return false;
    if (chr <= 0xa7d9) return true;
    if (chr < 0xa7f5) return false;
    if (chr <= 0xa7f6) return true;
    if (chr == 0xa7fa) return true;
    if (chr < 0xab30) return false;
    if (chr <= 0xab5a) return true;
    if (chr < 0xab60) return false;
    if (chr <= 0xab68) return true;
    if (chr < 0xab70) return false;
    if (chr <= 0xabbf) return true;
    if (chr < 0xfb00) return false;
    if (chr <= 0xfb06) return true;
    if (chr < 0xfb13) return false;
    if (chr <= 0xfb17) return true;
    if (chr < 0xff21) return false;
    if (chr <= 0xff3a) return true;
    if (chr < 0xff41) return false;
    if (chr <= 0xff5a) return true;
    if (chr < 0x10400) return false;
    if (chr <= 0x1044f) return true;
    if (chr < 0x104b0) return false;
    if (chr <= 0x104d3) return true;
    if (chr < 0x104d8) return false;
    if (chr <= 0x104fb) return true;
    if (chr < 0x10570) return false;
    if (chr <= 0x1057a) return true;
    if (chr < 0x1057c) return false;
    if (chr <= 0x1058a) return true;
    if (chr < 0x1058c) return false;
    if (chr <= 0x10592) return true;
    if (chr < 0x10594) return false;
    if (chr <= 0x10595) return true;
    if (chr < 0x10597) return false;
    if (chr <= 0x105a1) return true;
    if (chr < 0x105a3) return false;
    if (chr <= 0x105b1) return true;
    if (chr < 0x105b3) return false;
    if (chr <= 0x105b9) return true;
    if (chr < 0x105bb) return false;
    if (chr <= 0x105bc) return true;
    if (chr < 0x10c80) return false;
    if (chr <= 0x10cb2) return true;
    if (chr < 0x10cc0) return false;
    if (chr <= 0x10cf2) return true;
    if (chr < 0x118a0) return false;
    if (chr <= 0x118df) return true;
    if (chr < 0x16e40) return false;
    if (chr <= 0x16e7f) return true;
    if (chr < 0x1d400) return false;
    if (chr <= 0x1d454) return true;
    if (chr < 0x1d456) return false;
    if (chr <= 0x1d49c) return true;
    if (chr < 0x1d49e) return false;
    if (chr <= 0x1d49f) return true;
    if (chr == 0x1d4a2) return true;
    if (chr < 0x1d4a5) return false;
    if (chr <= 0x1d4a6) return true;
    if (chr < 0x1d4a9) return false;
    if (chr <= 0x1d4ac) return true;
    if (chr < 0x1d4ae) return false;
    if (chr <= 0x1d4b9) return true;
    if (chr < 0x1d4bb) return false;
    if ((chr & 1) == 1 && chr <= 0x1d4bd) return true;
    if (chr < 0x1d4be) return false;
    if (chr <= 0x1d4c3) return true;
    if (chr < 0x1d4c5) return false;
    if (chr <= 0x1d505) return true;
    if (chr < 0x1d507) return false;
    if (chr <= 0x1d50a) return true;
    if (chr < 0x1d50d) return false;
    if (chr <= 0x1d514) return true;
    if (chr < 0x1d516) return false;
    if (chr <= 0x1d51c) return true;
    if (chr < 0x1d51e) return false;
    if (chr <= 0x1d539) return true;
    if (chr < 0x1d53b) return false;
    if (chr <= 0x1d53e) return true;
    if (chr < 0x1d540) return false;
    if (chr <= 0x1d544) return true;
    if (chr == 0x1d546) return true;
    if (chr < 0x1d54a) return false;
    if (chr <= 0x1d550) return true;
    if (chr < 0x1d552) return false;
    if (chr <= 0x1d6a5) return true;
    if (chr < 0x1d6a8) return false;
    if (chr <= 0x1d6c0) return true;
    if (chr < 0x1d6c2) return false;
    if (chr <= 0x1d6da) return true;
    if (chr < 0x1d6dc) return false;
    if (chr <= 0x1d6fa) return true;
    if (chr < 0x1d6fc) return false;
    if (chr <= 0x1d714) return true;
    if (chr < 0x1d716) return false;
    if (chr <= 0x1d734) return true;
    if (chr < 0x1d736) return false;
    if (chr <= 0x1d74e) return true;
    if (chr < 0x1d750) return false;
    if (chr <= 0x1d76e) return true;
    if (chr < 0x1d770) return false;
    if (chr <= 0x1d788) return true;
    if (chr < 0x1d78a) return false;
    if (chr <= 0x1d7a8) return true;
    if (chr < 0x1d7aa) return false;
    if (chr <= 0x1d7c2) return true;
    if (chr < 0x1d7c4) return false;
    if (chr <= 0x1d7cb) return true;
    if (chr < 0x1df00) return false;
    if (chr <= 0x1df09) return true;
    if (chr < 0x1df0b) return false;
    if (chr <= 0x1df1e) return true;
    if (chr < 0x1df25) return false;
    if (chr <= 0x1df2a) return true;
    if (chr < 0x1e900) return false;
    if (chr <= 0x1e943) return true;
    return false;
  }

int is_a_whitespace_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x1) return false;
    if (chr <= 0x20) return true;
    if (chr < 0x7f) return false;
    if (chr <= 0xa0) return true;
    if (chr == 0x1680) return true;
    if (chr < 0x2000) return false;
    if (chr <= 0x200a) return true;
    if (chr < 0x2028) return false;
    if (chr <= 0x2029) return true;
    if (chr == 0x202f) return true;
    if (chr == 0x205f) return true;
    if (chr == 0x3000) return true;
    return false;
  }

int is_a_zero_width_character
  (
    uint32_t chr
  )
  {
    if (chr < 0x300) return false;
    if (chr <= 0x36f) return true;
    if (chr < 0x483) return false;
    if (chr <= 0x487) return true;
    if (chr < 0x591) return false;
    if (chr <= 0x5bd) return true;
    if (chr < 0x5bf) return false;
    if ((chr & 1) == 1 && chr <= 0x5c1) return true;
    if (chr < 0x5c2) return false;
    if ((chr & 1) == 0 && chr <= 0x5c4) return true;
    if (chr < 0x5c5) return false;
    if ((chr & 1) == 1 && chr <= 0x5c7) return true;
    if (chr < 0x610) return false;
    if (chr <= 0x61a) return true;
    if (chr < 0x64b) return false;
    if (chr <= 0x65f) return true;
    if (chr == 0x670) return true;
    if (chr < 0x6d6) return false;
    if (chr <= 0x6dc) return true;
    if (chr < 0x6df) return false;
    if (chr <= 0x6e4) return true;
    if (chr < 0x6e7) return false;
    if (chr <= 0x6e8) return true;
    if (chr < 0x6ea) return false;
    if (chr <= 0x6ed) return true;
    if (chr == 0x711) return true;
    if (chr < 0x730) return false;
    if (chr <= 0x74a) return true;
    if (chr < 0x7a6) return false;
    if (chr <= 0x7b0) return true;
    if (chr < 0x7eb) return false;
    if (chr <= 0x7f3) return true;
    if (chr == 0x7fd) return true;
    if (chr < 0x816) return false;
    if (chr <= 0x819) return true;
    if (chr < 0x81b) return false;
    if (chr <= 0x823) return true;
    if (chr < 0x825) return false;
    if (chr <= 0x827) return true;
    if (chr < 0x829) return false;
    if (chr <= 0x82d) return true;
    if (chr < 0x859) return false;
    if (chr <= 0x85b) return true;
    if (chr < 0x898) return false;
    if (chr <= 0x89f) return true;
    if (chr < 0x8ca) return false;
    if (chr <= 0x8e1) return true;
    if (chr < 0x8e3) return false;
    if (chr <= 0x902) return true;
    if (chr < 0x93a) return false;
    if ((chr & 1) == 0 && chr <= 0x93c) return true;
    if (chr < 0x941) return false;
    if (chr <= 0x948) return true;
    if (chr == 0x94d) return true;
    if (chr < 0x951) return false;
    if (chr <= 0x957) return true;
    if (chr < 0x962) return false;
    if (chr <= 0x963) return true;
    if (chr == 0x981) return true;
    if (chr == 0x9bc) return true;
    if (chr < 0x9c1) return false;
    if (chr <= 0x9c4) return true;
    if (chr == 0x9cd) return true;
    if (chr < 0x9e2) return false;
    if (chr <= 0x9e3) return true;
    if (chr == 0x9fe) return true;
    if (chr < 0xa01) return false;
    if (chr <= 0xa02) return true;
    if (chr == 0xa3c) return true;
    if (chr < 0xa41) return false;
    if (chr <= 0xa42) return true;
    if (chr < 0xa47) return false;
    if (chr <= 0xa48) return true;
    if (chr < 0xa4b) return false;
    if (chr <= 0xa4d) return true;
    if (chr == 0xa51) return true;
    if (chr < 0xa70) return false;
    if (chr <= 0xa71) return true;
    if (chr == 0xa75) return true;
    if (chr < 0xa81) return false;
    if (chr <= 0xa82) return true;
    if (chr == 0xabc) return true;
    if (chr < 0xac1) return false;
    if (chr <= 0xac5) return true;
    if (chr < 0xac7) return false;
    if (chr <= 0xac8) return true;
    if (chr == 0xacd) return true;
    if (chr < 0xae2) return false;
    if (chr <= 0xae3) return true;
    if (chr < 0xafa) return false;
    if (chr <= 0xaff) return true;
    if (chr == 0xb01) return true;
    if (chr == 0xb3c) return true;
    if (chr < 0xb3f) return false;
    if ((chr & 1) == 1 && chr <= 0xb41) return true;
    if (chr < 0xb42) return false;
    if (chr <= 0xb44) return true;
    if (chr == 0xb4d) return true;
    if (chr < 0xb55) return false;
    if (chr <= 0xb56) return true;
    if (chr < 0xb62) return false;
    if (chr <= 0xb63) return true;
    if (chr == 0xb82) return true;
    if (chr == 0xbc0) return true;
    if (chr == 0xbcd) return true;
    if (chr == 0xc00) return true;
    if (chr == 0xc04) return true;
    if (chr < 0xc3c) return false;
    if ((chr & 1) == 0 && chr <= 0xc3e) return true;
    if (chr < 0xc3f) return false;
    if (chr <= 0xc40) return true;
    if (chr < 0xc46) return false;
    if (chr <= 0xc48) return true;
    if (chr < 0xc4a) return false;
    if (chr <= 0xc4d) return true;
    if (chr < 0xc55) return false;
    if (chr <= 0xc56) return true;
    if (chr < 0xc62) return false;
    if (chr <= 0xc63) return true;
    if (chr == 0xc81) return true;
    if (chr == 0xcbc) return true;
    if (chr == 0xcbf) return true;
    if (chr == 0xcc6) return true;
    if (chr < 0xccc) return false;
    if (chr <= 0xccd) return true;
    if (chr < 0xce2) return false;
    if (chr <= 0xce3) return true;
    if (chr < 0xd00) return false;
    if (chr <= 0xd01) return true;
    if (chr < 0xd3b) return false;
    if (chr <= 0xd3c) return true;
    if (chr < 0xd41) return false;
    if (chr <= 0xd44) return true;
    if (chr == 0xd4d) return true;
    if (chr < 0xd62) return false;
    if (chr <= 0xd63) return true;
    if (chr == 0xd81) return true;
    if (chr == 0xdca) return true;
    if (chr < 0xdd2) return false;
    if (chr <= 0xdd4) return true;
    if (chr == 0xdd6) return true;
    if (chr == 0xe31) return true;
    if (chr < 0xe34) return false;
    if (chr <= 0xe3a) return true;
    if (chr < 0xe47) return false;
    if (chr <= 0xe4e) return true;
    if (chr == 0xeb1) return true;
    if (chr < 0xeb4) return false;
    if (chr <= 0xebc) return true;
    if (chr < 0xec8) return false;
    if (chr <= 0xece) return true;
    if (chr < 0xf18) return false;
    if (chr <= 0xf19) return true;
    if (chr < 0xf35) return false;
    if ((chr & 1) == 1 && chr <= 0xf39) return true;
    if (chr < 0xf71) return false;
    if (chr <= 0xf7e) return true;
    if (chr < 0xf80) return false;
    if (chr <= 0xf84) return true;
    if (chr < 0xf86) return false;
    if (chr <= 0xf87) return true;
    if (chr < 0xf8d) return false;
    if (chr <= 0xf97) return true;
    if (chr < 0xf99) return false;
    if (chr <= 0xfbc) return true;
    if (chr == 0xfc6) return true;
    if (chr < 0x102d) return false;
    if (chr <= 0x1030) return true;
    if (chr < 0x1032) return false;
    if (chr <= 0x1037) return true;
    if (chr < 0x1039) return false;
    if (chr <= 0x103a) return true;
    if (chr < 0x103d) return false;
    if (chr <= 0x103e) return true;
    if (chr < 0x1058) return false;
    if (chr <= 0x1059) return true;
    if (chr < 0x105e) return false;
    if (chr <= 0x1060) return true;
    if (chr < 0x1071) return false;
    if (chr <= 0x1074) return true;
    if (chr == 0x1082) return true;
    if (chr < 0x1085) return false;
    if (chr <= 0x1086) return true;
    if (chr == 0x108d) return true;
    if (chr == 0x109d) return true;
    if (chr < 0x135d) return false;
    if (chr <= 0x135f) return true;
    if (chr < 0x1712) return false;
    if (chr <= 0x1714) return true;
    if (chr < 0x1732) return false;
    if (chr <= 0x1733) return true;
    if (chr < 0x1752) return false;
    if (chr <= 0x1753) return true;
    if (chr < 0x1772) return false;
    if (chr <= 0x1773) return true;
    if (chr < 0x17b4) return false;
    if (chr <= 0x17b5) return true;
    if (chr < 0x17b7) return false;
    if (chr <= 0x17bd) return true;
    if (chr == 0x17c6) return true;
    if (chr < 0x17c9) return false;
    if (chr <= 0x17d3) return true;
    if (chr == 0x17dd) return true;
    if (chr < 0x180b) return false;
    if (chr <= 0x180d) return true;
    if (chr == 0x180f) return true;
    if (chr < 0x1885) return false;
    if (chr <= 0x1886) return true;
    if (chr == 0x18a9) return true;
    if (chr < 0x1920) return false;
    if (chr <= 0x1922) return true;
    if (chr < 0x1927) return false;
    if (chr <= 0x1928) return true;
    if (chr == 0x1932) return true;
    if (chr < 0x1939) return false;
    if (chr <= 0x193b) return true;
    if (chr < 0x1a17) return false;
    if (chr <= 0x1a18) return true;
    if (chr == 0x1a1b) return true;
    if (chr < 0x1a56) return false;
    if ((chr & 1) == 0 && chr <= 0x1a58) return true;
    if (chr < 0x1a59) return false;
    if (chr <= 0x1a5e) return true;
    if (chr < 0x1a60) return false;
    if ((chr & 1) == 0 && chr <= 0x1a62) return true;
    if (chr < 0x1a65) return false;
    if (chr <= 0x1a6c) return true;
    if (chr < 0x1a73) return false;
    if (chr <= 0x1a7c) return true;
    if (chr == 0x1a7f) return true;
    if (chr < 0x1ab0) return false;
    if (chr <= 0x1abd) return true;
    if (chr < 0x1abf) return false;
    if (chr <= 0x1ace) return true;
    if (chr < 0x1b00) return false;
    if (chr <= 0x1b03) return true;
    if (chr < 0x1b34) return false;
    if ((chr & 1) == 0 && chr <= 0x1b36) return true;
    if (chr < 0x1b37) return false;
    if (chr <= 0x1b3a) return true;
    if (chr == 0x1b3c) return true;
    if (chr == 0x1b42) return true;
    if (chr < 0x1b6b) return false;
    if (chr <= 0x1b73) return true;
    if (chr < 0x1b80) return false;
    if (chr <= 0x1b81) return true;
    if (chr < 0x1ba2) return false;
    if (chr <= 0x1ba5) return true;
    if (chr < 0x1ba8) return false;
    if (chr <= 0x1ba9) return true;
    if (chr < 0x1bab) return false;
    if (chr <= 0x1bad) return true;
    if (chr < 0x1be6) return false;
    if ((chr & 1) == 0 && chr <= 0x1be8) return true;
    if (chr == 0x1be9) return true;
    if (chr < 0x1bed) return false;
    if ((chr & 1) == 1 && chr <= 0x1bef) return true;
    if (chr < 0x1bf0) return false;
    if (chr <= 0x1bf1) return true;
    if (chr < 0x1c2c) return false;
    if (chr <= 0x1c33) return true;
    if (chr < 0x1c36) return false;
    if (chr <= 0x1c37) return true;
    if (chr < 0x1cd0) return false;
    if (chr <= 0x1cd2) return true;
    if (chr < 0x1cd4) return false;
    if (chr <= 0x1ce0) return true;
    if (chr < 0x1ce2) return false;
    if (chr <= 0x1ce8) return true;
    if (chr == 0x1ced) return true;
    if (chr == 0x1cf4) return true;
    if (chr < 0x1cf8) return false;
    if (chr <= 0x1cf9) return true;
    if (chr < 0x1dc0) return false;
    if (chr <= 0x1dff) return true;
    if (chr < 0x20d0) return false;
    if (chr <= 0x20dc) return true;
    if (chr == 0x20e1) return true;
    if (chr < 0x20e5) return false;
    if (chr <= 0x20f0) return true;
    if (chr < 0x2cef) return false;
    if (chr <= 0x2cf1) return true;
    if (chr == 0x2d7f) return true;
    if (chr < 0x2de0) return false;
    if (chr <= 0x2dff) return true;
    if (chr < 0x302a) return false;
    if (chr <= 0x302d) return true;
    if (chr < 0x3099) return false;
    if (chr <= 0x309a) return true;
    if (chr == 0xa66f) return true;
    if (chr < 0xa674) return false;
    if (chr <= 0xa67d) return true;
    if (chr < 0xa69e) return false;
    if (chr <= 0xa69f) return true;
    if (chr < 0xa6f0) return false;
    if (chr <= 0xa6f1) return true;
    if (chr == 0xa802) return true;
    if (chr == 0xa806) return true;
    if (chr == 0xa80b) return true;
    if (chr < 0xa825) return false;
    if (chr <= 0xa826) return true;
    if (chr == 0xa82c) return true;
    if (chr < 0xa8c4) return false;
    if (chr <= 0xa8c5) return true;
    if (chr < 0xa8e0) return false;
    if (chr <= 0xa8f1) return true;
    if (chr == 0xa8ff) return true;
    if (chr < 0xa926) return false;
    if (chr <= 0xa92d) return true;
    if (chr < 0xa947) return false;
    if (chr <= 0xa951) return true;
    if (chr < 0xa980) return false;
    if (chr <= 0xa982) return true;
    if (chr == 0xa9b3) return true;
    if (chr < 0xa9b6) return false;
    if (chr <= 0xa9b9) return true;
    if (chr < 0xa9bc) return false;
    if (chr <= 0xa9bd) return true;
    if (chr == 0xa9e5) return true;
    if (chr < 0xaa29) return false;
    if (chr <= 0xaa2e) return true;
    if (chr < 0xaa31) return false;
    if (chr <= 0xaa32) return true;
    if (chr < 0xaa35) return false;
    if (chr <= 0xaa36) return true;
    if (chr == 0xaa43) return true;
    if (chr == 0xaa4c) return true;
    if (chr == 0xaa7c) return true;
    if (chr < 0xaab0) return false;
    if ((chr & 1) == 0 && chr <= 0xaab2) return true;
    if (chr < 0xaab3) return false;
    if (chr <= 0xaab4) return true;
    if (chr < 0xaab7) return false;
    if (chr <= 0xaab8) return true;
    if (chr < 0xaabe) return false;
    if (chr <= 0xaabf) return true;
    if (chr == 0xaac1) return true;
    if (chr < 0xaaec) return false;
    if (chr <= 0xaaed) return true;
    if (chr == 0xaaf6) return true;
    if (chr == 0xabe5) return true;
    if (chr == 0xabe8) return true;
    if (chr == 0xabed) return true;
    if (chr == 0xfb1e) return true;
    if (chr < 0xfe00) return false;
    if (chr <= 0xfe0f) return true;
    if (chr < 0xfe20) return false;
    if (chr <= 0xfe2f) return true;
    if (chr == 0x101fd) return true;
    if (chr == 0x102e0) return true;
    if (chr < 0x10376) return false;
    if (chr <= 0x1037a) return true;
    if (chr < 0x10a01) return false;
    if (chr <= 0x10a03) return true;
    if (chr < 0x10a05) return false;
    if (chr <= 0x10a06) return true;
    if (chr < 0x10a0c) return false;
    if (chr <= 0x10a0f) return true;
    if (chr < 0x10a38) return false;
    if (chr <= 0x10a3a) return true;
    if (chr == 0x10a3f) return true;
    if (chr < 0x10ae5) return false;
    if (chr <= 0x10ae6) return true;
    if (chr < 0x10d24) return false;
    if (chr <= 0x10d27) return true;
    if (chr < 0x10eab) return false;
    if (chr <= 0x10eac) return true;
    if (chr < 0x10efd) return false;
    if (chr <= 0x10eff) return true;
    if (chr < 0x10f46) return false;
    if (chr <= 0x10f50) return true;
    if (chr < 0x10f82) return false;
    if (chr <= 0x10f85) return true;
    if (chr == 0x11001) return true;
    if (chr < 0x11038) return false;
    if (chr <= 0x11046) return true;
    if (chr == 0x11070) return true;
    if (chr < 0x11073) return false;
    if (chr <= 0x11074) return true;
    if (chr < 0x1107f) return false;
    if (chr <= 0x11081) return true;
    if (chr < 0x110b3) return false;
    if (chr <= 0x110b6) return true;
    if (chr < 0x110b9) return false;
    if (chr <= 0x110ba) return true;
    if (chr == 0x110c2) return true;
    if (chr < 0x11100) return false;
    if (chr <= 0x11102) return true;
    if (chr < 0x11127) return false;
    if (chr <= 0x1112b) return true;
    if (chr < 0x1112d) return false;
    if (chr <= 0x11134) return true;
    if (chr == 0x11173) return true;
    if (chr < 0x11180) return false;
    if (chr <= 0x11181) return true;
    if (chr < 0x111b6) return false;
    if (chr <= 0x111be) return true;
    if (chr < 0x111c9) return false;
    if (chr <= 0x111cc) return true;
    if (chr == 0x111cf) return true;
    if (chr < 0x1122f) return false;
    if (chr <= 0x11231) return true;
    if (chr < 0x11234) return false;
    if ((chr & 1) == 0 && chr <= 0x11236) return true;
    if (chr == 0x11237) return true;
    if (chr == 0x1123e) return true;
    if (chr == 0x11241) return true;
    if (chr == 0x112df) return true;
    if (chr < 0x112e3) return false;
    if (chr <= 0x112ea) return true;
    if (chr < 0x11300) return false;
    if (chr <= 0x11301) return true;
    if (chr < 0x1133b) return false;
    if (chr <= 0x1133c) return true;
    if (chr == 0x11340) return true;
    if (chr < 0x11366) return false;
    if (chr <= 0x1136c) return true;
    if (chr < 0x11370) return false;
    if (chr <= 0x11374) return true;
    if (chr < 0x11438) return false;
    if (chr <= 0x1143f) return true;
    if (chr < 0x11442) return false;
    if (chr <= 0x11444) return true;
    if (chr == 0x11446) return true;
    if (chr == 0x1145e) return true;
    if (chr < 0x114b3) return false;
    if (chr <= 0x114b8) return true;
    if (chr == 0x114ba) return true;
    if (chr < 0x114bf) return false;
    if (chr <= 0x114c0) return true;
    if (chr < 0x114c2) return false;
    if (chr <= 0x114c3) return true;
    if (chr < 0x115b2) return false;
    if (chr <= 0x115b5) return true;
    if (chr < 0x115bc) return false;
    if (chr <= 0x115bd) return true;
    if (chr < 0x115bf) return false;
    if (chr <= 0x115c0) return true;
    if (chr < 0x115dc) return false;
    if (chr <= 0x115dd) return true;
    if (chr < 0x11633) return false;
    if (chr <= 0x1163a) return true;
    if (chr < 0x1163d) return false;
    if ((chr & 1) == 1 && chr <= 0x1163f) return true;
    if (chr == 0x11640) return true;
    if (chr < 0x116ab) return false;
    if ((chr & 1) == 1 && chr <= 0x116ad) return true;
    if (chr < 0x116b0) return false;
    if (chr <= 0x116b5) return true;
    if (chr == 0x116b7) return true;
    if (chr < 0x1171d) return false;
    if (chr <= 0x1171f) return true;
    if (chr < 0x11722) return false;
    if (chr <= 0x11725) return true;
    if (chr < 0x11727) return false;
    if (chr <= 0x1172b) return true;
    if (chr < 0x1182f) return false;
    if (chr <= 0x11837) return true;
    if (chr < 0x11839) return false;
    if (chr <= 0x1183a) return true;
    if (chr < 0x1193b) return false;
    if (chr <= 0x1193c) return true;
    if (chr == 0x1193e) return true;
    if (chr == 0x11943) return true;
    if (chr < 0x119d4) return false;
    if (chr <= 0x119d7) return true;
    if (chr < 0x119da) return false;
    if (chr <= 0x119db) return true;
    if (chr == 0x119e0) return true;
    if (chr < 0x11a01) return false;
    if (chr <= 0x11a0a) return true;
    if (chr < 0x11a33) return false;
    if (chr <= 0x11a38) return true;
    if (chr < 0x11a3b) return false;
    if (chr <= 0x11a3e) return true;
    if (chr == 0x11a47) return true;
    if (chr < 0x11a51) return false;
    if (chr <= 0x11a56) return true;
    if (chr < 0x11a59) return false;
    if (chr <= 0x11a5b) return true;
    if (chr < 0x11a8a) return false;
    if (chr <= 0x11a96) return true;
    if (chr < 0x11a98) return false;
    if (chr <= 0x11a99) return true;
    if (chr < 0x11c30) return false;
    if (chr <= 0x11c36) return true;
    if (chr < 0x11c38) return false;
    if (chr <= 0x11c3d) return true;
    if (chr == 0x11c3f) return true;
    if (chr < 0x11c92) return false;
    if (chr <= 0x11ca7) return true;
    if (chr < 0x11caa) return false;
    if (chr <= 0x11cb0) return true;
    if (chr < 0x11cb2) return false;
    if (chr <= 0x11cb3) return true;
    if (chr < 0x11cb5) return false;
    if (chr <= 0x11cb6) return true;
    if (chr < 0x11d31) return false;
    if (chr <= 0x11d36) return true;
    if (chr < 0x11d3a) return false;
    if ((chr & 1) == 0 && chr <= 0x11d3c) return true;
    if (chr < 0x11d3d) return false;
    if ((chr & 1) == 1 && chr <= 0x11d3f) return true;
    if (chr < 0x11d40) return false;
    if (chr <= 0x11d45) return true;
    if (chr == 0x11d47) return true;
    if (chr < 0x11d90) return false;
    if (chr <= 0x11d91) return true;
    if (chr < 0x11d95) return false;
    if ((chr & 1) == 1 && chr <= 0x11d97) return true;
    if (chr < 0x11ef3) return false;
    if (chr <= 0x11ef4) return true;
    if (chr < 0x11f00) return false;
    if (chr <= 0x11f01) return true;
    if (chr < 0x11f36) return false;
    if (chr <= 0x11f3a) return true;
    if (chr < 0x11f40) return false;
    if ((chr & 1) == 0 && chr <= 0x11f42) return true;
    if (chr == 0x13440) return true;
    if (chr < 0x13447) return false;
    if (chr <= 0x13455) return true;
    if (chr < 0x16af0) return false;
    if (chr <= 0x16af4) return true;
    if (chr < 0x16b30) return false;
    if (chr <= 0x16b36) return true;
    if (chr == 0x16f4f) return true;
    if (chr < 0x16f8f) return false;
    if (chr <= 0x16f92) return true;
    if (chr == 0x16fe4) return true;
    if (chr < 0x1bc9d) return false;
    if (chr <= 0x1bc9e) return true;
    if (chr < 0x1cf00) return false;
    if (chr <= 0x1cf2d) return true;
    if (chr < 0x1cf30) return false;
    if (chr <= 0x1cf46) return true;
    if (chr < 0x1d167) return false;
    if (chr <= 0x1d169) return true;
    if (chr < 0x1d17b) return false;
    if (chr <= 0x1d182) return true;
    if (chr < 0x1d185) return false;
    if (chr <= 0x1d18b) return true;
    if (chr < 0x1d1aa) return false;
    if (chr <= 0x1d1ad) return true;
    if (chr < 0x1d242) return false;
    if (chr <= 0x1d244) return true;
    if (chr < 0x1da00) return false;
    if (chr <= 0x1da36) return true;
    if (chr < 0x1da3b) return false;
    if (chr <= 0x1da6c) return true;
    if (chr == 0x1da75) return true;
    if (chr == 0x1da84) return true;
    if (chr < 0x1da9b) return false;
    if (chr <= 0x1da9f) return true;
    if (chr < 0x1daa1) return false;
    if (chr <= 0x1daaf) return true;
    if (chr < 0x1e000) return false;
    if (chr <= 0x1e006) return true;
    if (chr < 0x1e008) return false;
    if (chr <= 0x1e018) return true;
    if (chr < 0x1e01b) return false;
    if (chr <= 0x1e021) return true;
    if (chr < 0x1e023) return false;
    if (chr <= 0x1e024) return true;
    if (chr < 0x1e026) return false;
    if (chr <= 0x1e02a) return true;
    if (chr == 0x1e08f) return true;
    if (chr < 0x1e130) return false;
    if (chr <= 0x1e136) return true;
    if (chr == 0x1e2ae) return true;
    if (chr < 0x1e2ec) return false;
    if (chr <= 0x1e2ef) return true;
    if (chr < 0x1e4ec) return false;
    if (chr <= 0x1e4ef) return true;
    if (chr < 0x1e8d0) return false;
    if (chr <= 0x1e8d6) return true;
    if (chr < 0x1e944) return false;
    if (chr <= 0x1e94a) return true;
    if (chr < 0xe0100) return false;
    if (chr <= 0xe01ef) return true;
    return false;
  }

int is_a_wide_character
  (
    uint32_t chr
  )
  {
    if (chr <= 0x10ff) return false;
    if (chr >= 0x1100 && chr <= 0x115f) return true;
    if (chr >= 0x1160 && chr <= 0x2319) return false;
    if (chr >= 0x231a && chr <= 0x231b) return true;
    if (chr >= 0x231c && chr <= 0x2328) return false;
    if (chr >= 0x2329 && chr <= 0x232a) return true;
    if (chr >= 0x232b && chr <= 0x23e8) return false;
    if (chr >= 0x23e9 && chr <= 0x23ec) return true;
    if (chr >= 0x23ed && chr <= 0x23ef) return false;
    if (chr == 0x23f0) return true;
    if (chr >= 0x23f1 && chr <= 0x23f2) return false;
    if (chr == 0x23f3) return true;
    if (chr >= 0x23f4 && chr <= 0x25fc) return false;
    if (chr >= 0x25fd && chr <= 0x25fe) return true;
    if (chr >= 0x25ff && chr <= 0x2613) return false;
    if (chr >= 0x2614 && chr <= 0x2615) return true;
    if (chr >= 0x2616 && chr <= 0x2647) return false;
    if (chr >= 0x2648 && chr <= 0x2653) return true;
    if (chr >= 0x2654 && chr <= 0x267e) return false;
    if (chr == 0x267f) return true;
    if (chr >= 0x2680 && chr <= 0x2692) return false;
    if (chr == 0x2693) return true;
    if (chr >= 0x2694 && chr <= 0x26a0) return false;
    if (chr == 0x26a1) return true;
    if (chr >= 0x26a2 && chr <= 0x26a9) return false;
    if (chr >= 0x26aa && chr <= 0x26ab) return true;
    if (chr >= 0x26ac && chr <= 0x26bc) return false;
    if (chr >= 0x26bd && chr <= 0x26be) return true;
    if (chr >= 0x26bf && chr <= 0x26c3) return false;
    if (chr >= 0x26c4 && chr <= 0x26c5) return true;
    if (chr >= 0x26c6 && chr <= 0x26cd) return false;
    if (chr == 0x26ce) return true;
    if (chr >= 0x26cf && chr <= 0x26d3) return false;
    if (chr == 0x26d4) return true;
    if (chr >= 0x26d5 && chr <= 0x26e9) return false;
    if (chr == 0x26ea) return true;
    if (chr >= 0x26eb && chr <= 0x26f1) return false;
    if (chr >= 0x26f2 && chr <= 0x26f3) return true;
    if (chr == 0x26f4) return false;
    if (chr == 0x26f5) return true;
    if (chr >= 0x26f6 && chr <= 0x26f9) return false;
    if (chr == 0x26fa) return true;
    if (chr >= 0x26fb && chr <= 0x26fc) return false;
    if (chr == 0x26fd) return true;
    if (chr >= 0x26fe && chr <= 0x2704) return false;
    if (chr == 0x2705) return true;
    if (chr >= 0x2706 && chr <= 0x2709) return false;
    if (chr >= 0x270a && chr <= 0x270b) return true;
    if (chr >= 0x270c && chr <= 0x2727) return false;
    if (chr == 0x2728) return true;
    if (chr >= 0x2729 && chr <= 0x274b) return false;
    if (chr == 0x274c) return true;
    if (chr == 0x274d) return false;
    if (chr == 0x274e) return true;
    if (chr >= 0x274f && chr <= 0x2752) return false;
    if (chr >= 0x2753 && chr <= 0x2755) return true;
    if (chr == 0x2756) return false;
    if (chr == 0x2757) return true;
    if (chr >= 0x2758 && chr <= 0x2794) return false;
    if (chr >= 0x2795 && chr <= 0x2797) return true;
    if (chr >= 0x2798 && chr <= 0x27af) return false;
    if (chr == 0x27b0) return true;
    if (chr >= 0x27b1 && chr <= 0x27be) return false;
    if (chr == 0x27bf) return true;
    if (chr >= 0x27c0 && chr <= 0x2b1a) return false;
    if (chr >= 0x2b1b && chr <= 0x2b1c) return true;
    if (chr >= 0x2b1d && chr <= 0x2b4f) return false;
    if (chr == 0x2b50) return true;
    if (chr >= 0x2b51 && chr <= 0x2b54) return false;
    if (chr == 0x2b55) return true;
    if (chr >= 0x2b56 && chr <= 0x2e5d) return false;
    if (chr >= 0x2e80 && chr <= 0x2e99) return true;
    if (chr >= 0x2e9b && chr <= 0x2ef3) return true;
    if (chr >= 0x2f00 && chr <= 0x2fd5) return true;
    if (chr >= 0x2ff0 && chr <= 0x303e) return true;
    if (chr == 0x303f) return false;
    if (chr >= 0x3041 && chr <= 0x3096) return true;
    if (chr >= 0x3099 && chr <= 0x30ff) return true;
    if (chr >= 0x3105 && chr <= 0x312f) return true;
    if (chr >= 0x3131 && chr <= 0x318e) return true;
    if (chr >= 0x3190 && chr <= 0x31e3) return true;
    if (chr >= 0x31ef && chr <= 0x321e) return true;
    if (chr >= 0x3220 && chr <= 0x3247) return true;
    if (chr >= 0x3248 && chr <= 0x324f) return false;
    if (chr >= 0x3250 && chr <= 0x4dbf) return true;
    if (chr >= 0x4dc0 && chr <= 0x4dff) return false;
    if (chr >= 0x4e00 && chr <= 0xa48c) return true;
    if (chr >= 0xa490 && chr <= 0xa4c6) return true;
    if (chr >= 0xa4d0 && chr <= 0xa95f) return false;
    if (chr >= 0xa960 && chr <= 0xa97c) return true;
    if (chr >= 0xa980 && chr <= 0xabf9) return false;
    if (chr >= 0xac00 && chr <= 0xd7a3) return true;
    if (chr >= 0xd7b0 && chr <= 0xf8ff) return false;
    if (chr >= 0xf900 && chr <= 0xfaff) return true;
    if (chr >= 0xfb00 && chr <= 0xfe0f) return false;
    if (chr >= 0xfe10 && chr <= 0xfe19) return true;
    if (chr >= 0xfe20 && chr <= 0xfe2f) return false;
    if (chr >= 0xfe30 && chr <= 0xfe52) return true;
    if (chr >= 0xfe54 && chr <= 0xfe66) return true;
    if (chr >= 0xfe68 && chr <= 0xfe6b) return true;
    if (chr >= 0xfe70 && chr <= 0xfeff) return false;
    if (chr >= 0xff01 && chr <= 0xff60) return true;
    if (chr >= 0xff61 && chr <= 0xffdc) return false;
    if (chr >= 0xffe0 && chr <= 0xffe6) return true;
    if (chr >= 0xffe8 && chr <= 0x16f9f) return false;
    if (chr >= 0x16fe0 && chr <= 0x16fe4) return true;
    if (chr >= 0x16ff0 && chr <= 0x16ff1) return true;
    if (chr >= 0x17000 && chr <= 0x187f7) return true;
    if (chr >= 0x18800 && chr <= 0x18cd5) return true;
    if (chr >= 0x18d00 && chr <= 0x18d08) return true;
    if (chr >= 0x1aff0 && chr <= 0x1aff3) return true;
    if (chr >= 0x1aff5 && chr <= 0x1affb) return true;
    if (chr >= 0x1affd && chr <= 0x1affe) return true;
    if (chr >= 0x1b000 && chr <= 0x1b122) return true;
    if (chr == 0x1b132) return true;
    if (chr >= 0x1b150 && chr <= 0x1b152) return true;
    if (chr == 0x1b155) return true;
    if (chr >= 0x1b164 && chr <= 0x1b167) return true;
    if (chr >= 0x1b170 && chr <= 0x1b2fb) return true;
    if (chr >= 0x1bc00 && chr <= 0x1f003) return false;
    if (chr == 0x1f004) return true;
    if (chr >= 0x1f005 && chr <= 0x1f0ce) return false;
    if (chr == 0x1f0cf) return true;
    if (chr >= 0x1f0d1 && chr <= 0x1f18d) return false;
    if (chr == 0x1f18e) return true;
    if (chr >= 0x1f18f && chr <= 0x1f190) return false;
    if (chr >= 0x1f191 && chr <= 0x1f19a) return true;
    if (chr >= 0x1f19b && chr <= 0x1f1ff) return false;
    if (chr >= 0x1f200 && chr <= 0x1f202) return true;
    if (chr >= 0x1f210 && chr <= 0x1f23b) return true;
    if (chr >= 0x1f240 && chr <= 0x1f248) return true;
    if (chr >= 0x1f250 && chr <= 0x1f251) return true;
    if (chr >= 0x1f260 && chr <= 0x1f265) return true;
    if (chr >= 0x1f300 && chr <= 0x1f320) return true;
    if (chr >= 0x1f321 && chr <= 0x1f32c) return false;
    if (chr >= 0x1f32d && chr <= 0x1f335) return true;
    if (chr == 0x1f336) return false;
    if (chr >= 0x1f337 && chr <= 0x1f37c) return true;
    if (chr == 0x1f37d) return false;
    if (chr >= 0x1f37e && chr <= 0x1f393) return true;
    if (chr >= 0x1f394 && chr <= 0x1f39f) return false;
    if (chr >= 0x1f3a0 && chr <= 0x1f3ca) return true;
    if (chr >= 0x1f3cb && chr <= 0x1f3ce) return false;
    if (chr >= 0x1f3cf && chr <= 0x1f3d3) return true;
    if (chr >= 0x1f3d4 && chr <= 0x1f3df) return false;
    if (chr >= 0x1f3e0 && chr <= 0x1f3f0) return true;
    if (chr >= 0x1f3f1 && chr <= 0x1f3f3) return false;
    if (chr == 0x1f3f4) return true;
    if (chr >= 0x1f3f5 && chr <= 0x1f3f7) return false;
    if (chr >= 0x1f3f8 && chr <= 0x1f43e) return true;
    if (chr == 0x1f43f) return false;
    if (chr == 0x1f440) return true;
    if (chr == 0x1f441) return false;
    if (chr >= 0x1f442 && chr <= 0x1f4fc) return true;
    if (chr >= 0x1f4fd && chr <= 0x1f4fe) return false;
    if (chr >= 0x1f4ff && chr <= 0x1f53d) return true;
    if (chr >= 0x1f53e && chr <= 0x1f54a) return false;
    if (chr >= 0x1f54b && chr <= 0x1f54e) return true;
    if (chr == 0x1f54f) return false;
    if (chr >= 0x1f550 && chr <= 0x1f567) return true;
    if (chr >= 0x1f568 && chr <= 0x1f579) return false;
    if (chr == 0x1f57a) return true;
    if (chr >= 0x1f57b && chr <= 0x1f594) return false;
    if (chr >= 0x1f595 && chr <= 0x1f596) return true;
    if (chr >= 0x1f597 && chr <= 0x1f5a3) return false;
    if (chr == 0x1f5a4) return true;
    if (chr >= 0x1f5a5 && chr <= 0x1f5fa) return false;
    if (chr >= 0x1f5fb && chr <= 0x1f64f) return true;
    if (chr >= 0x1f650 && chr <= 0x1f67f) return false;
    if (chr >= 0x1f680 && chr <= 0x1f6c5) return true;
    if (chr >= 0x1f6c6 && chr <= 0x1f6cb) return false;
    if (chr == 0x1f6cc) return true;
    if (chr >= 0x1f6cd && chr <= 0x1f6cf) return false;
    if (chr >= 0x1f6d0 && chr <= 0x1f6d2) return true;
    if (chr >= 0x1f6d3 && chr <= 0x1f6d4) return false;
    if (chr >= 0x1f6d5 && chr <= 0x1f6d7) return true;
    if (chr >= 0x1f6dc && chr <= 0x1f6df) return true;
    if (chr >= 0x1f6e0 && chr <= 0x1f6ea) return false;
    if (chr >= 0x1f6eb && chr <= 0x1f6ec) return true;
    if (chr >= 0x1f6f0 && chr <= 0x1f6f3) return false;
    if (chr >= 0x1f6f4 && chr <= 0x1f6fc) return true;
    if (chr >= 0x1f700 && chr <= 0x1f7d9) return false;
    if (chr >= 0x1f7e0 && chr <= 0x1f7eb) return true;
    if (chr == 0x1f7f0) return true;
    if (chr >= 0x1f800 && chr <= 0x1f90b) return false;
    if (chr >= 0x1f90c && chr <= 0x1f93a) return true;
    if (chr == 0x1f93b) return false;
    if (chr >= 0x1f93c && chr <= 0x1f945) return true;
    if (chr == 0x1f946) return false;
    if (chr >= 0x1f947 && chr <= 0x1f9ff) return true;
    if (chr >= 0x1fa00 && chr <= 0x1fa6d) return false;
    if (chr >= 0x1fa70 && chr <= 0x1fa7c) return true;
    if (chr >= 0x1fa80 && chr <= 0x1fa88) return true;
    if (chr >= 0x1fa90 && chr <= 0x1fabd) return true;
    if (chr >= 0x1fabf && chr <= 0x1fac5) return true;
    if (chr >= 0x1face && chr <= 0x1fadb) return true;
    if (chr >= 0x1fae0 && chr <= 0x1fae8) return true;
    if (chr >= 0x1faf0 && chr <= 0x1faf8) return true;
    if (chr >= 0x1fb00 && chr <= 0x1fbf9) return false;
    if (chr >= 0x20000 && chr <= 0x2fffd) return true;
    if (chr >= 0x30000 && chr <= 0x3fffd) return true;
    return false;
  }

static long unique_idx = 1;
static const char **my_unique_item_names;

static void *std_types__unique_item___collect
  (
    UNIQUE_ITEM *node
  )
  {
    UNIQUE_ITEM *new_node;
    new_node = allocate(sizeof(UNIQUE_ITEM));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->id = node->id;
    return new_node;
  }

NODE *register_unique_item
  (
    const char *name
  )
  {
    if (unique_idx == 0) {
      my_unique_item_names = allocate_memory(sizeof(const char *));
    } else if (is_a_power_of_two(unique_idx)) {
      my_unique_item_names =
	reallocate_memory(
	  my_unique_item_names,
	  2*unique_idx*sizeof(const char *));
    }
    my_unique_item_names[unique_idx] = name;
    return create__std_types__unique_item(unique_idx++);
  }

static long std_types__unique_item___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf,
      node->unique_item.id == 0 ? "<unique_item>" :
      my_unique_item_names[node->unique_item.id]);
  }

static int flags_to_int
(
  NODE *node,
  int *result_p
)
{
  char *flags_str = NULL;
  int flags = 0;
  if (!to_c_string(node, &flags_str)) return false;
  switch (flags_str[0]) {
    case 'R':
      flags = O_NONBLOCK;
    case 'r':
      if (flags_str[1] == '+') {
	if (flags_str[2] == 0) {
	  flags |= O_CLOEXEC|O_RDWR;
	  break;
	} else {
	  goto err;
	}
      } else if (flags_str[1] == 0) {
	flags |= O_CLOEXEC|O_RDONLY;
	break;
      } else {
	goto err;
	goto err;
      }
    case 'W':
      flags = O_NONBLOCK;
    case 'w':
      if (flags_str[1] == '+') {
	if (flags_str[2] == 0) {
	  flags |= O_CLOEXEC|O_RDWR|O_CREAT|O_TRUNC;
	  break;
	} else {
	  goto err;
	}
      } else if (flags_str[1] == 0) {
	flags |= O_CLOEXEC|O_WRONLY|O_CREAT|O_TRUNC;
	break;
      } else {
	goto err;
      }
    case 'A':
      flags = O_NONBLOCK;
    case 'a':
      if (flags_str[1] == '+') {
	if (flags_str[2] == 0) {
	  flags |= O_CLOEXEC|O_RDWR|O_CREAT|O_APPEND;
	  break;
	} else {
	  goto err;
	}
      } else if (flags_str[1] == 0) {
	flags |= O_CLOEXEC|O_WRONLY|O_CREAT|O_APPEND;
	break;
      } else {
	goto err;
      }
    default:
      goto err;
  }
  deallocate_memory(flags_str);
  *result_p = flags;
  return true;

  err:
  deallocate_memory(flags_str);
  create_error_message(
    module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
    "Conversion to open flags failed!", 0, 0, NULL);
  return false;
}

static int mode_to_int
(
  NODE *node,
  int *result_p
)
{
  char *mode_str = NULL;
  int mode = 0;
  if (!to_c_string(node, &mode_str)) return false;
  if (strlen(mode_str) != 9) goto err;
  switch (mode_str[0]) {
    case 'r':
      mode |= 0400;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[1]) {
    case 'w':
      mode |= 0200;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[2]) {
    case 'x':
      mode |= 0100;
      break;
    case 's':
      mode |= 0100|S_ISUID;
      break;
    case 'S':
      mode |= S_ISUID;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[3]) {
    case 'r':
      mode |= 040;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[4]) {
    case 'w':
      mode |= 020;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[5]) {
    case 'x':
      mode |= 010;
      break;
    case 's':
      mode |= 010|S_ISGID;
      break;
    case 'S':
      mode |= S_ISGID;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[6]) {
    case 'r':
      mode |= 04;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[7]) {
    case 'w':
      mode |= 02;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  switch (mode_str[8]) {
    case 'x':
      mode |= 01;
      break;
    case 't':
      mode |= 01|S_ISVTX;
      break;
    case 'T':
      mode |= S_ISVTX;
      break;
    case '-':
      break;
    default:
      goto err;
  }
  deallocate_memory(mode_str);
  *result_p = mode;
  return true;

  err:
  deallocate_memory(mode_str);
  create_error_message(
    module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
    "Conversion to file mode failed!", 0, 0, NULL);
  return false;
}

static NODE *mode_from_int
(
  int value
)
{
  char mode[12];
  if (S_ISREG(value)) {
    mode[0] = '-';
  } else if (S_ISBLK(value)) {
    mode[0] = 'b';
  } else if (S_ISCHR(value)) {
    mode[0] = 'c';
  } else if (S_ISDIR(value)) {
    mode[0] = 'd';
  } else if (S_ISLNK(value)) {
    mode[0] = 'l';
  } else if (S_ISFIFO(value)) {
    mode[0] = 'p';
  } else {
    mode[0] = 0;
  }
  if (value & 0400) {
    mode[1] = 'r';
  } else {
    mode[1] = '-';
  }
  if (value & 0200) {
    mode[2] = 'w';
  } else {
    mode[2] = '-';
  }
  if (value & 0100) {
    if (value & S_ISUID) {
      mode[3] = 's';
    } else {
      mode[3] = 'x';
    }
  } else {
    if (value & S_ISUID) {
      mode[3] = 'S';
    } else {
      mode[3] = '-';
    }
  }
  if (value & 040) {
    mode[4] = 'r';
  } else {
    mode[4] = '-';
  }
  if (value & 020) {
    mode[5] = 'w';
  } else {
    mode[5] = '-';
  }
  if (value & 010) {
    if (value & S_ISGID) {
      mode[6] = 's';
    } else {
      mode[6] = 'x';
    }
  } else {
    if (value & S_ISGID) {
      mode[6] = 'S';
    } else {
      mode[6] = '-';
    }
  }
  if (value & 04) {
    mode[7] = 'r';
  } else {
    mode[7] = '-';
  }
  if (value & 02) {
    mode[8] = 'w';
  } else {
    mode[8] = '-';
  }
  if (value & 01) {
    if (value & S_ISVTX) {
      mode[9] = 't';
    } else {
      mode[9] = 'x';
    }
  } else {
    if (value & S_ISVTX) {
      mode[9] = 'T';
    } else {
      mode[9] = '-';
    }
  }
  mode[10] = 0;
  return from_c_string(mode[0] ? mode : mode+1);
}

static int initialize_fd_set
  (
    fd_set *set,
    NODE *descriptors,
    long *descriptor_count_p,
    int *last_fd_p
  )
  {
    long descriptor_count;
    if (!length_of(descriptors, &descriptor_count)) return false;
    FD_ZERO(set);
    int last_fd = *last_fd_p;
    long i;
    for (i = 0; i < descriptor_count; ++i) {
      NODE *descriptor;
      if (!get_item_of(descriptors, i, &descriptor)) return false;
      if ((descriptor)->type != std_types__file_descriptor.type) {
	create_error_message(
	  module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	  "Invalid arguments!", 0, 0, NULL);
	return false;
      }
      int fd = descriptor->file_descriptor.value;
      FD_SET(fd, set);
      if (fd > last_fd) last_fd = fd;
    }
    *descriptor_count_p = descriptor_count;
    *last_fd_p = last_fd;
    return true;
  }

static NODE *create_descriptor_list
  (
    fd_set *set,
    int fd_count,
    NODE *descriptors,
    long descriptor_count
  )
  {
    LIST_DATA *data =
      allocate_large(sizeof(LIST_DATA)+fd_count*sizeof(NODE *));
    data->size = fd_count;
    data->length = fd_count;
    int n = 0;
    long i;
    for (i = 0; i < descriptor_count; ++i) {
      NODE *descriptor;
      get_item_of(descriptors, i, &descriptor);
      int fd = descriptor->file_descriptor.value;
      if (FD_ISSET(fd, set)) {
	data->items[n++] = descriptor;
      }
    }
    return create__std_types__list(0, fd_count, data);
  }

static void *std_types__shared_memory___collect
  (
    SHARED_MEMORY *node
  )
  {
    if (!node) return node;
    SHARED_MEMORY *new_node;
    long size = node->size; // might be garbage if already collected
    new_node = allocate(sizeof(SHARED_MEMORY));
    new_node->type = node->type;
    *(void **)node = ENCODE_ADDRESS(new_node);
    new_node->attributes = collect_attributes(node->attributes);
    new_node->fd = node->fd;
    new_node->size = size;
    new_node->buf = node->buf;
    return new_node;
  }

static long std_types__shared_memory___debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<shared_memory %d: %ld>",
      node->shared_memory.fd, node->shared_memory.size);
  }

static void std_types__generic_array___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the generic array prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__array___type (void)
  {
    ARRAY_DATA *data = TLS_myself->array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_array_updates((ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->array.view);
      if (offset < 0) return;
      NODE *value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(value);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->array.view);
      if (offset < 0) return;
      NODE *value;
      value = TLS_arguments[dimension_count];
      long length = TLS_myself->array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_ARRAY_DATA_SET_VALUE));
      UPDATE_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__boolean_array___type (void)
  {
    BOOLEAN_ARRAY_DATA *data = TLS_myself->boolean_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->boolean_array.view);
      if (offset < 0) return;
      int value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_bool(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->boolean_array.view);
      if (offset < 0) return;
      int value;
      if (!to_bool(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->boolean_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE));
      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->boolean_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__character_array___type (void)
  {
    CHARACTER_ARRAY_DATA *data = TLS_myself->character_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_character_array_updates((CHARACTER_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->character_array.view);
      if (offset < 0) return;
      uint32_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uchar32(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->character_array.view);
      if (offset < 0) return;
      uint32_t value;
      if (!to_uchar32(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->character_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE));
      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->character_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__int8_array___type (void)
  {
    INT8_ARRAY_DATA *data = TLS_myself->int8_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int8_array_updates((INT8_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int8_array.view);
      if (offset < 0) return;
      int8_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int8(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int8_array.view);
      if (offset < 0) return;
      int8_t value;
      if (!to_int8(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int8_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE));
      UPDATE_INT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT8_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__uint8_array___type (void)
  {
    UINT8_ARRAY_DATA *data = TLS_myself->uint8_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint8_array_updates((UINT8_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint8_array.view);
      if (offset < 0) return;
      uint8_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint8(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint8_array.view);
      if (offset < 0) return;
      uint8_t value;
      if (!to_uint8(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint8_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT8_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__int16_array___type (void)
  {
    INT16_ARRAY_DATA *data = TLS_myself->int16_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int16_array_updates((INT16_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int16_array.view);
      if (offset < 0) return;
      int16_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int16(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int16_array.view);
      if (offset < 0) return;
      int16_t value;
      if (!to_int16(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int16_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE));
      UPDATE_INT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT16_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__uint16_array___type (void)
  {
    UINT16_ARRAY_DATA *data = TLS_myself->uint16_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint16_array_updates((UINT16_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint16_array.view);
      if (offset < 0) return;
      uint16_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint16(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint16_array.view);
      if (offset < 0) return;
      uint16_t value;
      if (!to_uint16(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint16_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT16_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__int32_array___type (void)
  {
    INT32_ARRAY_DATA *data = TLS_myself->int32_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int32_array_updates((INT32_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int32_array.view);
      if (offset < 0) return;
      int32_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int32(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int32_array.view);
      if (offset < 0) return;
      int32_t value;
      if (!to_int32(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int32_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE));
      UPDATE_INT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT32_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__uint32_array___type (void)
  {
    UINT32_ARRAY_DATA *data = TLS_myself->uint32_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint32_array_updates((UINT32_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint32_array.view);
      if (offset < 0) return;
      uint32_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint32(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint32_array.view);
      if (offset < 0) return;
      uint32_t value;
      if (!to_uint32(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint32_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT32_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__int64_array___type (void)
  {
    INT64_ARRAY_DATA *data = TLS_myself->int64_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_int64_array_updates((INT64_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->int64_array.view);
      if (offset < 0) return;
      int64_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_int64(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->int64_array.view);
      if (offset < 0) return;
      int64_t value;
      if (!to_int64(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->int64_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE));
      UPDATE_INT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT64_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->int64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__uint64_array___type (void)
  {
    UINT64_ARRAY_DATA *data = TLS_myself->uint64_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_uint64_array_updates((UINT64_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->uint64_array.view);
      if (offset < 0) return;
      uint64_t value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_uint64(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->uint64_array.view);
      if (offset < 0) return;
      uint64_t value;
      if (!to_uint64(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->uint64_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT64_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->uint64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__float32_array___type (void)
  {
    FLOAT32_ARRAY_DATA *data = TLS_myself->float32_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->float32_array.view);
      if (offset < 0) return;
      float value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_float(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->float32_array.view);
      if (offset < 0) return;
      float value;
      if (!to_float(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->float32_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->float32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__float64_array___type (void)
  {
    FLOAT64_ARRAY_DATA *data = TLS_myself->float64_array.data;
    int dimension_count = data->info->dimension_count;
    if (TLS_argument_count < dimension_count) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > dimension_count+1) {
      too_many_arguments();
      return;
    }
    if (TLS_argument_count == dimension_count) {
      // get item
      data = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_myself);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	TLS_myself, data->info, TLS_myself->float64_array.view);
      if (offset < 0) return;
      double value;
      value = data->items[offset];
      {
        NODE *result__node = (NODE *)(from_double(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      // set item
      long offset = compute_array_write_offset(
	TLS_myself, data->info, TLS_myself->float64_array.view);
      if (offset < 0) return;
      double value;
      if (!to_double(TLS_arguments[dimension_count], &value)) return;
      long length = TLS_myself->float64_array.updates_length;
      TLS_myself =
	add_update(
	  (ARRAY *)TLS_myself, sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *)
	(TLS_myself->float64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      {
        NODE *result__node = (NODE *)(TLS_myself);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__true___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the boolean value true as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__false___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the boolean value false as a function!", 0, 0, NULL);
      return;
    }
  }

static void c_function___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the C function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types__character___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a character value as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__date_and_time___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a date-and-time object as a function!", 0, 0, NULL);
      return;
    }
  }

void std_types__error___type (void)
  {
    if (TLS_result_count < 1) TLS_result_count = 1;
    TLS_argument_count = TLS_result_count;
    int i;
    for (i = 0; i < TLS_result_count; ++i) {
      TLS_arguments[i] = TLS_myself;
    }
    {
      return;
    }
  }

static void std_types__object___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call an object as a function!", 0, 0, NULL);
      return;
    }
  }

void std_types__undefined___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call an undefined object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__function___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void tabular_function___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the tabular function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types__generic_list___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the generic list prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

void std_types__list___type (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    long length = TLS_myself->list.length;
    long idx;
    if (!to_long(TLS_arguments[0], &idx)) return;
    if (idx < 0) idx = length+idx+1;
    if (idx < 1 || idx > length) {
      invalid_index(TLS_myself);
      return;
    };
    long offset = TLS_myself->list.offset;
    if (TLS_argument_count == 1)
      {
        NODE *result__node = (NODE *)(TLS_myself->list.data->items[offset+idx-1]);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    NODE *item = TLS_arguments[1];
    LIST_DATA *new_data = allocate_large(sizeof(LIST_DATA)+length*sizeof(NODE *));
    memcpy(
      new_data->items, TLS_myself->list.data->items+offset, length*sizeof(NODE *));
    new_data->items[idx-1] = item;
    new_data->size = length;
    new_data->length = length;
    NODE *node = create__std_types__list(0, length, new_data);
    node->type = TLS_myself->type;
    node->attributes = TLS_myself->attributes;
    {
      NODE *result__node = (NODE *)(node);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void std_types__number___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a numeric value as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__integer___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the integer protoype object as a function!", 0, 0, NULL);
      return;
    }
  }

void builtin_types__positive_integer___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a positive integer value as a function!", 0, 0, NULL);
      return;
    }
  }

void builtin_types__negative_integer___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a negative integer value as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__real___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a real number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__polymorphic_function___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the polymorphic-function protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types__polymorphic_function_with_setter___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the polymorphic-function-with-setter protoype object!", 0, 0, NULL);
      return;
    }
  }

static void std_types__file_type___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a file type as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__file_descriptor___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a file descriptor as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__signal_number___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a signal number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__shutdown_type___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a shutdown type as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__seek_type___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a seek type as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__device_id___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a device id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__directory___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a directory as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__group_id___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a group id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__inode_number___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a inode number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__process_id___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a process id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__user_id___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a user id as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__error_number___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a error number as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__passwd___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a passwd as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__stat___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a stat as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__dirent___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a dirent as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__string___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the string prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__octet_string___type (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long idx;
    if (!to_long(TLS_arguments[0], &idx)) return;
    long length = TLS_myself->octet_string.length;
    if (idx < 0) idx = length+idx+1;
    if (idx < 1 || idx > length) {
      invalid_index(TLS_myself);
      return;
    };
    long offset = TLS_myself->octet_string.offset;
    if (TLS_argument_count == 1)
      {
        NODE *result__node = (NODE *)(from_uchar32(TLS_myself->octet_string.data->buffer[offset+idx-1]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    uint32_t chr;
    if (!to_uchar32(TLS_arguments[1], &chr)) return;;
    OCTET_DATA *data = TLS_myself->octet_string.data;
    if (data->buffer[idx-1] == chr) {
      NODE *result__node = (NODE *)(TLS_myself);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (chr > 0xff) {
      long size = ALLOCATION_SIZE(4*length);
      WIDE_DATA *new_data = allocate_large(sizeof(WIDE_DATA)+size);
      long i;
      for (i = 0; i < length; ++i) {
	new_data->buffer[i] = data->buffer[offset+i];
      }
      new_data->size = size;
      new_data->length = length;
      new_data->buffer[idx-1] = chr;
      {
        NODE *result__node = (NODE *)(create__std_types__wide_string(0, length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      long size = ALLOCATION_SIZE(length);
      OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+size);
      memcpy(new_data->buffer, data->buffer+offset, length);
      new_data->size = size;
      new_data->length = length;
      new_data->buffer[idx-1] = chr;
      {
        NODE *result__node = (NODE *)(create__std_types__octet_string(0, length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void std_types__wide_string___type (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long idx;
    if (!to_long(TLS_arguments[0], &idx)) return;
    long length = TLS_myself->wide_string.length;
    if (idx < 0) idx = length+idx+1;
    if (idx < 1 || idx > length) {
      invalid_index(TLS_myself);
      return;
    };
    long offset = TLS_myself->wide_string.offset;
    if (TLS_argument_count == 1)
      {
        NODE *result__node = (NODE *)(from_uchar32(TLS_myself->wide_string.data->buffer[offset+idx-1]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    uint32_t chr;
    if (!to_uchar32(TLS_arguments[1], &chr)) return;;
    WIDE_DATA *data = TLS_myself->wide_string.data;
    if (data->buffer[idx-1] == chr) {
      NODE *result__node = (NODE *)(TLS_myself);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (chr <= 0xff && data->buffer[offset+idx-1] > 0xff) {
      long i;
      for (i = 0; i < length; ++i) {
	if (i != idx-1 && data->buffer[offset+i] > 0xff) goto quad;
      }
      long size = ALLOCATION_SIZE(length);
      OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+size);
      for (i = 0; i < length; ++i) {
	new_data->buffer[i] = data->buffer[offset+i];
      }
      new_data->size = size;
      new_data->length = length;
      new_data->buffer[idx-1] = chr;
      {
        NODE *result__node = (NODE *)(create__std_types__octet_string(0, length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    quad:;
    long size = ALLOCATION_SIZE(4*length);
    WIDE_DATA *new_data = allocate_large(sizeof(WIDE_DATA)+size);
    memcpy(new_data->buffer, data->buffer+offset, 4*length);
    new_data->size = size;
    new_data->length = length;
    new_data->buffer[idx-1] = chr;
    {
      NODE *result__node = (NODE *)(create__std_types__wide_string(0, length, new_data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void std_types__terminal_attributes___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call terminal attributes as a function!", 0, 0, NULL);
      return;
    };
  }

static void std_types__tuple___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call the tuple prototype object as a function!", 0, 0, NULL);
      return;
    }
  }

static void builtin_types__tuple2___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = (NODE *)&std_types__undefined;
      case 7: TLS_arguments[6] = (NODE *)&std_types__undefined;
      case 6: TLS_arguments[5] = (NODE *)&std_types__undefined;
      case 5: TLS_arguments[4] = (NODE *)&std_types__undefined;
      case 4: TLS_arguments[3] = (NODE *)&std_types__undefined;
      case 3: TLS_arguments[2] = (NODE *)&std_types__undefined;
      case 2: TLS_arguments[1] = TLS_myself->tuple2.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple2.node_0;
    }
    {
      return;
    }
  }

static void builtin_types__tuple3___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = (NODE *)&std_types__undefined;
      case 7: TLS_arguments[6] = (NODE *)&std_types__undefined;
      case 6: TLS_arguments[5] = (NODE *)&std_types__undefined;
      case 5: TLS_arguments[4] = (NODE *)&std_types__undefined;
      case 4: TLS_arguments[3] = (NODE *)&std_types__undefined;
      case 3: TLS_arguments[2] = TLS_myself->tuple3.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple3.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple3.node_0;
    }
    {
      return;
    }
  }

static void builtin_types__tuple4___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = (NODE *)&std_types__undefined;
      case 7: TLS_arguments[6] = (NODE *)&std_types__undefined;
      case 6: TLS_arguments[5] = (NODE *)&std_types__undefined;
      case 5: TLS_arguments[4] = TLS_myself->tuple4.node_3;
      case 4: TLS_arguments[3] = TLS_myself->tuple4.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple4.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple4.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple4.node_0;
    }
    {
      return;
    }
  }

static void builtin_types__tuple5___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = (NODE *)&std_types__undefined;
      case 7: TLS_arguments[6] = (NODE *)&std_types__undefined;
      case 6: TLS_arguments[5] = TLS_myself->tuple5.node_4;
      case 5: TLS_arguments[4] = TLS_myself->tuple5.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple5.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple5.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple5.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple5.node_0;
    }
    {
      return;
    }
  }

static void builtin_types__tuple6___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = (NODE *)&std_types__undefined;
      case 7: TLS_arguments[6] = (NODE *)&std_types__undefined;
      case 6: TLS_arguments[5] = TLS_myself->tuple6.node_5;
      case 5: TLS_arguments[4] = TLS_myself->tuple6.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple6.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple6.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple6.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple6.node_0;
    }
    {
      return;
    }
  }

static void builtin_types__tuple7___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = (NODE *)&std_types__undefined;
      case 7: TLS_arguments[6] = TLS_myself->tuple7.node_6;
      case 6: TLS_arguments[5] = TLS_myself->tuple7.node_5;
      case 5: TLS_arguments[4] = TLS_myself->tuple7.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple7.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple7.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple7.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple7.node_0;
    }
    {
      return;
    }
  }

static void builtin_types__tuple8___type (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count < 1) {
      too_few_results();
      return;
    }
    if (TLS_result_count > 8) {
      too_many_results();
      return;
    }
    TLS_argument_count = TLS_result_count;
    switch (TLS_result_count) {
      case 8: TLS_arguments[7] = TLS_myself->tuple8.node_7;
      case 7: TLS_arguments[6] = TLS_myself->tuple8.node_6;
      case 6: TLS_arguments[5] = TLS_myself->tuple8.node_5;
      case 5: TLS_arguments[4] = TLS_myself->tuple8.node_4;
      case 4: TLS_arguments[3] = TLS_myself->tuple8.node_3;
      case 3: TLS_arguments[2] = TLS_myself->tuple8.node_2;
      case 2: TLS_arguments[1] = TLS_myself->tuple8.node_1;
      case 1: TLS_arguments[0] = TLS_myself->tuple8.node_0;
    }
    {
      return;
    }
  }

static void std_types__unique_item___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a unique item as a function!", 0, 0, NULL);
      return;
    }
  }

static void std_types__shared_memory___type (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to call a shared memory object as a function!", 0, 0, NULL);
      return;
    }
  }

SIMPLE_NODE std_types__generic_array = {
  std_types__generic_array___type, NULL
};

ARRAY std_types__array = {
  std_types__array___type, NULL
};

BOOLEAN_ARRAY std_types__boolean_array = {
  std_types__boolean_array___type, NULL
};

CHARACTER_ARRAY std_types__character_array = {
  std_types__character_array___type, NULL
};

INT8_ARRAY std_types__int8_array = {
  std_types__int8_array___type, NULL
};

UINT8_ARRAY std_types__uint8_array = {
  std_types__uint8_array___type, NULL
};

INT16_ARRAY std_types__int16_array = {
  std_types__int16_array___type, NULL
};

UINT16_ARRAY std_types__uint16_array = {
  std_types__uint16_array___type, NULL
};

INT32_ARRAY std_types__int32_array = {
  std_types__int32_array___type, NULL
};

UINT32_ARRAY std_types__uint32_array = {
  std_types__uint32_array___type, NULL
};

INT64_ARRAY std_types__int64_array = {
  std_types__int64_array___type, NULL
};

UINT64_ARRAY std_types__uint64_array = {
  std_types__uint64_array___type, NULL
};

FLOAT32_ARRAY std_types__float32_array = {
  std_types__float32_array___type, NULL
};

FLOAT64_ARRAY std_types__float64_array = {
  std_types__float64_array___type, NULL
};

SIMPLE_NODE std_types__true = {
  std_types__true___type, NULL
};

SIMPLE_NODE std_types__false = {
  std_types__false___type, NULL
};

C_FUNCTION c_function = {
  c_function___type, NULL
};

CHARACTER std_types__character = {
  std_types__character___type, NULL
};

DATE_AND_TIME std_types__date_and_time = {
  std_types__date_and_time___type, NULL
};

ERROR std_types__error = {
  std_types__error___type, NULL
};

SIMPLE_NODE std_types__object = {
  std_types__object___type, NULL
};

SIMPLE_NODE std_types__undefined = {
  std_types__undefined___type, NULL
};

SIMPLE_NODE std_types__function = {
  std_types__function___type, NULL
};

TABULAR_FUNCTION tabular_function = {
  tabular_function___type, NULL
};

SIMPLE_NODE std_types__generic_list = {
  std_types__generic_list___type, NULL
};

LIST std_types__list = {
  std_types__list___type, NULL
};

SIMPLE_NODE std_types__number = {
  std_types__number___type, NULL
};

INTEGER std_types__integer = {
  std_types__integer___type, NULL
};

POSITIVE_INTEGER builtin_types__positive_integer = {
  builtin_types__positive_integer___type, NULL
};

NEGATIVE_INTEGER builtin_types__negative_integer = {
  builtin_types__negative_integer___type, NULL
};

REAL std_types__real = {
  std_types__real___type, NULL
};

SIMPLE_NODE std_types__polymorphic_function = {
  std_types__polymorphic_function___type, NULL
};

SIMPLE_NODE std_types__polymorphic_function_with_setter = {
  std_types__polymorphic_function_with_setter___type, NULL
};

FILE_TYPE std_types__file_type = {
  std_types__file_type___type, NULL
};

FILE_DESCRIPTOR std_types__file_descriptor = {
  std_types__file_descriptor___type, NULL
};

SIGNAL_NUMBER std_types__signal_number = {
  std_types__signal_number___type, NULL
};

SHUTDOWN_TYPE std_types__shutdown_type = {
  std_types__shutdown_type___type, NULL
};

SEEK_TYPE std_types__seek_type = {
  std_types__seek_type___type, NULL
};

DEVICE_ID std_types__device_id = {
  std_types__device_id___type, NULL
};

DIRECTORY std_types__directory = {
  std_types__directory___type, NULL
};

GROUP_ID std_types__group_id = {
  std_types__group_id___type, NULL
};

INODE_NUMBER std_types__inode_number = {
  std_types__inode_number___type, NULL
};

PROCESS_ID std_types__process_id = {
  std_types__process_id___type, NULL
};

USER_ID std_types__user_id = {
  std_types__user_id___type, NULL
};

ERROR_NUMBER std_types__error_number = {
  std_types__error_number___type, NULL
};

SIMPLE_NODE std_types__passwd = {
  std_types__passwd___type, NULL
};

SIMPLE_NODE std_types__stat = {
  std_types__stat___type, NULL
};

SIMPLE_NODE std_types__dirent = {
  std_types__dirent___type, NULL
};

SIMPLE_NODE std_types__string = {
  std_types__string___type, NULL
};

OCTET_STRING std_types__octet_string = {
  std_types__octet_string___type, NULL
};

WIDE_STRING std_types__wide_string = {
  std_types__wide_string___type, NULL
};

TERMINAL_ATTRIBUTES std_types__terminal_attributes = {
  std_types__terminal_attributes___type, NULL
};

SIMPLE_NODE std_types__tuple = {
  std_types__tuple___type, NULL
};

TUPLE2 builtin_types__tuple2 = {
  builtin_types__tuple2___type, NULL
};

TUPLE3 builtin_types__tuple3 = {
  builtin_types__tuple3___type, NULL
};

TUPLE4 builtin_types__tuple4 = {
  builtin_types__tuple4___type, NULL
};

TUPLE5 builtin_types__tuple5 = {
  builtin_types__tuple5___type, NULL
};

TUPLE6 builtin_types__tuple6 = {
  builtin_types__tuple6___type, NULL
};

TUPLE7 builtin_types__tuple7 = {
  builtin_types__tuple7___type, NULL
};

TUPLE8 builtin_types__tuple8 = {
  builtin_types__tuple8___type, NULL
};

UNIQUE_ITEM std_types__unique_item = {
  std_types__unique_item___type, NULL
};

SHARED_MEMORY std_types__shared_memory = {
  std_types__shared_memory___type, NULL
};

static POSITIVE_INTEGER std__EXIT_SUCCESS = {
  builtin_types__positive_integer___type, NULL, EXIT_SUCCESS
};

static POSITIVE_INTEGER std__EXIT_FAILURE = {
  builtin_types__positive_integer___type, NULL, EXIT_FAILURE
};

static OCTET_STRING std__program_name = {
  std_types__octet_string___type, NULL, 0, 0, NULL
};

static LIST std__command_line_arguments = {
  std_types__list___type, NULL, 0, 0, NULL
};

static LIST std__environment_variables = {
  std_types__list___type, NULL, 0, 0, NULL
};

TUPLE2 std_types__key_value_pair = {
  builtin_types__tuple2___type, NULL, (NODE *)&std_types__undefined, (NODE *)&std_types__undefined
};

LIST std__empty_list = {
  std_types__list___type, NULL, 0, 0, NULL
};

static FILE_TYPE std__BLOCK_DEVICE = {
  std_types__file_type___type, NULL, DT_BLK
};

static FILE_TYPE std__CHARACTER_DEVICE = {
  std_types__file_type___type, NULL, DT_CHR
};

static FILE_TYPE std__DIRECTORY = {
  std_types__file_type___type, NULL, DT_DIR
};

static FILE_TYPE std__NAMED_PIPE = {
  std_types__file_type___type, NULL, DT_FIFO
};

static FILE_TYPE std__SYMBOLIC_LINK = {
  std_types__file_type___type, NULL, DT_LNK
};

static FILE_TYPE std__REGULAR_FILE = {
  std_types__file_type___type, NULL, DT_REG
};

static FILE_TYPE std__SOCKET = {
  std_types__file_type___type, NULL, DT_SOCK
};

static FILE_TYPE std__UNKNOWN_FILE_TYPE = {
  std_types__file_type___type, NULL, DT_UNKNOWN
};

static FILE_DESCRIPTOR std__STDIN_FILENO = {
  std_types__file_descriptor___type, NULL, STDIN_FILENO
};

static FILE_DESCRIPTOR std__STDOUT_FILENO = {
  std_types__file_descriptor___type, NULL, STDOUT_FILENO
};

static FILE_DESCRIPTOR std__STDERR_FILENO = {
  std_types__file_descriptor___type, NULL, STDERR_FILENO
};

static SHUTDOWN_TYPE std__SHUT_RD = {
  std_types__shutdown_type___type, NULL, SHUT_RD
};

static SHUTDOWN_TYPE std__SHUT_WR = {
  std_types__shutdown_type___type, NULL, SHUT_WR
};

static SHUTDOWN_TYPE std__SHUT_RDWR = {
  std_types__shutdown_type___type, NULL, SHUT_RDWR
};

static SEEK_TYPE std__SEEK_SET = {
  std_types__seek_type___type, NULL, SEEK_SET
};

static SEEK_TYPE std__SEEK_CUR = {
  std_types__seek_type___type, NULL, SEEK_CUR
};

static SEEK_TYPE std__SEEK_END = {
  std_types__seek_type___type, NULL, SEEK_END
};

static ERROR_NUMBER std__ENOERR = {
  std_types__error_number___type, NULL, 0
};

static ERROR_NUMBER std__EPERM = {
  std_types__error_number___type, NULL, EPERM
};

static ERROR_NUMBER std__ENOENT = {
  std_types__error_number___type, NULL, ENOENT
};

static ERROR_NUMBER std__ESRCH = {
  std_types__error_number___type, NULL, ESRCH
};

static ERROR_NUMBER std__EINTR = {
  std_types__error_number___type, NULL, EINTR
};

static ERROR_NUMBER std__EIO = {
  std_types__error_number___type, NULL, EIO
};

static ERROR_NUMBER std__ENXIO = {
  std_types__error_number___type, NULL, ENXIO
};

static ERROR_NUMBER std__E2BIG = {
  std_types__error_number___type, NULL, E2BIG
};

static ERROR_NUMBER std__ENOEXEC = {
  std_types__error_number___type, NULL, ENOEXEC
};

static ERROR_NUMBER std__EBADF = {
  std_types__error_number___type, NULL, EBADF
};

static ERROR_NUMBER std__ECHILD = {
  std_types__error_number___type, NULL, ECHILD
};

static ERROR_NUMBER std__EAGAIN = {
  std_types__error_number___type, NULL, EAGAIN
};

static ERROR_NUMBER std__ENOMEM = {
  std_types__error_number___type, NULL, ENOMEM
};

static ERROR_NUMBER std__EACCES = {
  std_types__error_number___type, NULL, EACCES
};

static ERROR_NUMBER std__EFAULT = {
  std_types__error_number___type, NULL, EFAULT
};

static ERROR_NUMBER std__ENOTBLK = {
  std_types__error_number___type, NULL, ENOTBLK
};

static ERROR_NUMBER std__EBUSY = {
  std_types__error_number___type, NULL, EBUSY
};

static ERROR_NUMBER std__EEXIST = {
  std_types__error_number___type, NULL, EEXIST
};

static ERROR_NUMBER std__EXDEV = {
  std_types__error_number___type, NULL, EXDEV
};

static ERROR_NUMBER std__ENODEV = {
  std_types__error_number___type, NULL, ENODEV
};

static ERROR_NUMBER std__ENOTDIR = {
  std_types__error_number___type, NULL, ENOTDIR
};

static ERROR_NUMBER std__EISDIR = {
  std_types__error_number___type, NULL, EISDIR
};

static ERROR_NUMBER std__EINVAL = {
  std_types__error_number___type, NULL, EINVAL
};

static ERROR_NUMBER std__ENFILE = {
  std_types__error_number___type, NULL, ENFILE
};

static ERROR_NUMBER std__EMFILE = {
  std_types__error_number___type, NULL, EMFILE
};

static ERROR_NUMBER std__ENOTTY = {
  std_types__error_number___type, NULL, ENOTTY
};

static ERROR_NUMBER std__ETXTBSY = {
  std_types__error_number___type, NULL, ETXTBSY
};

static ERROR_NUMBER std__EFBIG = {
  std_types__error_number___type, NULL, EFBIG
};

static ERROR_NUMBER std__ENOSPC = {
  std_types__error_number___type, NULL, ENOSPC
};

static ERROR_NUMBER std__ESPIPE = {
  std_types__error_number___type, NULL, ESPIPE
};

static ERROR_NUMBER std__EROFS = {
  std_types__error_number___type, NULL, EROFS
};

static ERROR_NUMBER std__EMLINK = {
  std_types__error_number___type, NULL, EMLINK
};

static ERROR_NUMBER std__EPIPE = {
  std_types__error_number___type, NULL, EPIPE
};

static ERROR_NUMBER std__EDOM = {
  std_types__error_number___type, NULL, EDOM
};

static ERROR_NUMBER std__ERANGE = {
  std_types__error_number___type, NULL, ERANGE
};

static ERROR_NUMBER std__EDEADLK = {
  std_types__error_number___type, NULL, EDEADLK
};

static ERROR_NUMBER std__ENAMETOOLONG = {
  std_types__error_number___type, NULL, ENAMETOOLONG
};

static ERROR_NUMBER std__ENOLCK = {
  std_types__error_number___type, NULL, ENOLCK
};

static ERROR_NUMBER std__ENOSYS = {
  std_types__error_number___type, NULL, ENOSYS
};

static ERROR_NUMBER std__ENOTEMPTY = {
  std_types__error_number___type, NULL, ENOTEMPTY
};

static ERROR_NUMBER std__EILSEQ = {
  std_types__error_number___type, NULL, EILSEQ
};

static ERROR_NUMBER std__ELOOP = {
  std_types__error_number___type, NULL, ELOOP
};

static ERROR_NUMBER std__ENOMSG = {
  std_types__error_number___type, NULL, ENOMSG
};

static ERROR_NUMBER std__EIDRM = {
  std_types__error_number___type, NULL, EIDRM
};

static ERROR_NUMBER std__ECHRNG = {
  std_types__error_number___type, NULL, ECHRNG
};

static ERROR_NUMBER std__EL2NSYNC = {
  std_types__error_number___type, NULL, EL2NSYNC
};

static ERROR_NUMBER std__EL3HLT = {
  std_types__error_number___type, NULL, EL3HLT
};

static ERROR_NUMBER std__EL3RST = {
  std_types__error_number___type, NULL, EL3RST
};

static ERROR_NUMBER std__ELNRNG = {
  std_types__error_number___type, NULL, ELNRNG
};

static ERROR_NUMBER std__EUNATCH = {
  std_types__error_number___type, NULL, EUNATCH
};

static ERROR_NUMBER std__ENOCSI = {
  std_types__error_number___type, NULL, ENOCSI
};

static ERROR_NUMBER std__EL2HLT = {
  std_types__error_number___type, NULL, EL2HLT
};

static ERROR_NUMBER std__EBADE = {
  std_types__error_number___type, NULL, EBADE
};

static ERROR_NUMBER std__EBADR = {
  std_types__error_number___type, NULL, EBADR
};

static ERROR_NUMBER std__EXFULL = {
  std_types__error_number___type, NULL, EXFULL
};

static ERROR_NUMBER std__ENOANO = {
  std_types__error_number___type, NULL, ENOANO
};

static ERROR_NUMBER std__EBADRQC = {
  std_types__error_number___type, NULL, EBADRQC
};

static ERROR_NUMBER std__EBADSLT = {
  std_types__error_number___type, NULL, EBADSLT
};

static ERROR_NUMBER std__EBFONT = {
  std_types__error_number___type, NULL, EBFONT
};

static ERROR_NUMBER std__ENOSTR = {
  std_types__error_number___type, NULL, ENOSTR
};

static ERROR_NUMBER std__ENODATA = {
  std_types__error_number___type, NULL, ENODATA
};

static ERROR_NUMBER std__ETIME = {
  std_types__error_number___type, NULL, ETIME
};

static ERROR_NUMBER std__ENOSR = {
  std_types__error_number___type, NULL, ENOSR
};

static ERROR_NUMBER std__ENONET = {
  std_types__error_number___type, NULL, ENONET
};

static ERROR_NUMBER std__ENOPKG = {
  std_types__error_number___type, NULL, ENOPKG
};

static ERROR_NUMBER std__EREMOTE = {
  std_types__error_number___type, NULL, EREMOTE
};

static ERROR_NUMBER std__ENOLINK = {
  std_types__error_number___type, NULL, ENOLINK
};

static ERROR_NUMBER std__EADV = {
  std_types__error_number___type, NULL, EADV
};

static ERROR_NUMBER std__ESRMNT = {
  std_types__error_number___type, NULL, ESRMNT
};

static ERROR_NUMBER std__ECOMM = {
  std_types__error_number___type, NULL, ECOMM
};

static ERROR_NUMBER std__EPROTO = {
  std_types__error_number___type, NULL, EPROTO
};

static ERROR_NUMBER std__EMULTIHOP = {
  std_types__error_number___type, NULL, EMULTIHOP
};

static ERROR_NUMBER std__EDOTDOT = {
  std_types__error_number___type, NULL, EDOTDOT
};

static ERROR_NUMBER std__EBADMSG = {
  std_types__error_number___type, NULL, EBADMSG
};

static ERROR_NUMBER std__EOVERFLOW = {
  std_types__error_number___type, NULL, EOVERFLOW
};

static ERROR_NUMBER std__ENOTUNIQ = {
  std_types__error_number___type, NULL, ENOTUNIQ
};

static ERROR_NUMBER std__EBADFD = {
  std_types__error_number___type, NULL, EBADFD
};

static ERROR_NUMBER std__EREMCHG = {
  std_types__error_number___type, NULL, EREMCHG
};

static ERROR_NUMBER std__ELIBACC = {
  std_types__error_number___type, NULL, ELIBACC
};

static ERROR_NUMBER std__ELIBBAD = {
  std_types__error_number___type, NULL, ELIBBAD
};

static ERROR_NUMBER std__ELIBSCN = {
  std_types__error_number___type, NULL, ELIBSCN
};

static ERROR_NUMBER std__ELIBMAX = {
  std_types__error_number___type, NULL, ELIBMAX
};

static ERROR_NUMBER std__ELIBEXEC = {
  std_types__error_number___type, NULL, ELIBEXEC
};

static ERROR_NUMBER std__ESTRPIPE = {
  std_types__error_number___type, NULL, ESTRPIPE
};

static ERROR_NUMBER std__EUSERS = {
  std_types__error_number___type, NULL, EUSERS
};

static ERROR_NUMBER std__ENOTSOCK = {
  std_types__error_number___type, NULL, ENOTSOCK
};

static ERROR_NUMBER std__EDESTADDRREQ = {
  std_types__error_number___type, NULL, EDESTADDRREQ
};

static ERROR_NUMBER std__EMSGSIZE = {
  std_types__error_number___type, NULL, EMSGSIZE
};

static ERROR_NUMBER std__EPROTOTYPE = {
  std_types__error_number___type, NULL, EPROTOTYPE
};

static ERROR_NUMBER std__ENOPROTOOPT = {
  std_types__error_number___type, NULL, ENOPROTOOPT
};

static ERROR_NUMBER std__EPROTONOSUPPORT = {
  std_types__error_number___type, NULL, EPROTONOSUPPORT
};

static ERROR_NUMBER std__ESOCKTNOSUPPORT = {
  std_types__error_number___type, NULL, ESOCKTNOSUPPORT
};

static ERROR_NUMBER std__EOPNOTSUPP = {
  std_types__error_number___type, NULL, EOPNOTSUPP
};

static ERROR_NUMBER std__EPFNOSUPPORT = {
  std_types__error_number___type, NULL, EPFNOSUPPORT
};

static ERROR_NUMBER std__EAFNOSUPPORT = {
  std_types__error_number___type, NULL, EAFNOSUPPORT
};

static ERROR_NUMBER std__EADDRINUSE = {
  std_types__error_number___type, NULL, EADDRINUSE
};

static ERROR_NUMBER std__EADDRNOTAVAIL = {
  std_types__error_number___type, NULL, EADDRNOTAVAIL
};

static ERROR_NUMBER std__ENETDOWN = {
  std_types__error_number___type, NULL, ENETDOWN
};

static ERROR_NUMBER std__ENETUNREACH = {
  std_types__error_number___type, NULL, ENETUNREACH
};

static ERROR_NUMBER std__ENETRESET = {
  std_types__error_number___type, NULL, ENETRESET
};

static ERROR_NUMBER std__ECONNABORTED = {
  std_types__error_number___type, NULL, ECONNABORTED
};

static ERROR_NUMBER std__ECONNRESET = {
  std_types__error_number___type, NULL, ECONNRESET
};

static ERROR_NUMBER std__ENOBUFS = {
  std_types__error_number___type, NULL, ENOBUFS
};

static ERROR_NUMBER std__EISCONN = {
  std_types__error_number___type, NULL, EISCONN
};

static ERROR_NUMBER std__ENOTCONN = {
  std_types__error_number___type, NULL, ENOTCONN
};

static ERROR_NUMBER std__ESHUTDOWN = {
  std_types__error_number___type, NULL, ESHUTDOWN
};

static ERROR_NUMBER std__ETOOMANYREFS = {
  std_types__error_number___type, NULL, ETOOMANYREFS
};

static ERROR_NUMBER std__ETIMEDOUT = {
  std_types__error_number___type, NULL, ETIMEDOUT
};

static ERROR_NUMBER std__ECONNREFUSED = {
  std_types__error_number___type, NULL, ECONNREFUSED
};

static ERROR_NUMBER std__EHOSTDOWN = {
  std_types__error_number___type, NULL, EHOSTDOWN
};

static ERROR_NUMBER std__EHOSTUNREACH = {
  std_types__error_number___type, NULL, EHOSTUNREACH
};

static ERROR_NUMBER std__EALREADY = {
  std_types__error_number___type, NULL, EALREADY
};

static ERROR_NUMBER std__EINPROGRESS = {
  std_types__error_number___type, NULL, EINPROGRESS
};

static ERROR_NUMBER std__ESTALE = {
  std_types__error_number___type, NULL, ESTALE
};

static ERROR_NUMBER std__EDQUOT = {
  std_types__error_number___type, NULL, EDQUOT
};

static ERROR_NUMBER std__ENOMEDIUM = {
  std_types__error_number___type, NULL, ENOMEDIUM
};

static ERROR_NUMBER std__ECANCELED = {
  std_types__error_number___type, NULL, ECANCELED
};

static ERROR_NUMBER std__EOWNERDEAD = {
  std_types__error_number___type, NULL, EOWNERDEAD
};

static ERROR_NUMBER std__ENOTRECOVERABLE = {
  std_types__error_number___type, NULL, ENOTRECOVERABLE
};

static SIGNAL_NUMBER std__SIGHUP = {
  std_types__signal_number___type, NULL, SIGHUP
};

static SIGNAL_NUMBER std__SIGINT = {
  std_types__signal_number___type, NULL, SIGINT
};

static SIGNAL_NUMBER std__SIGQUIT = {
  std_types__signal_number___type, NULL, SIGQUIT
};

static SIGNAL_NUMBER std__SIGILL = {
  std_types__signal_number___type, NULL, SIGILL
};

static SIGNAL_NUMBER std__SIGTRAP = {
  std_types__signal_number___type, NULL, SIGTRAP
};

static SIGNAL_NUMBER std__SIGABRT = {
  std_types__signal_number___type, NULL, SIGABRT
};

static SIGNAL_NUMBER std__SIGIOT = {
  std_types__signal_number___type, NULL, SIGIOT
};

static SIGNAL_NUMBER std__SIGBUS = {
  std_types__signal_number___type, NULL, SIGBUS
};

static SIGNAL_NUMBER std__SIGFPE = {
  std_types__signal_number___type, NULL, SIGFPE
};

static SIGNAL_NUMBER std__SIGKILL = {
  std_types__signal_number___type, NULL, SIGKILL
};

static SIGNAL_NUMBER std__SIGUSR1 = {
  std_types__signal_number___type, NULL, SIGUSR1
};

static SIGNAL_NUMBER std__SIGSEGV = {
  std_types__signal_number___type, NULL, SIGSEGV
};

static SIGNAL_NUMBER std__SIGUSR2 = {
  std_types__signal_number___type, NULL, SIGUSR2
};

static SIGNAL_NUMBER std__SIGPIPE = {
  std_types__signal_number___type, NULL, SIGPIPE
};

static SIGNAL_NUMBER std__SIGALRM = {
  std_types__signal_number___type, NULL, SIGALRM
};

static SIGNAL_NUMBER std__SIGTERM = {
  std_types__signal_number___type, NULL, SIGTERM
};

static SIGNAL_NUMBER std__SIGSTKFLT = {
  std_types__signal_number___type, NULL, SIGSTKFLT
};

static SIGNAL_NUMBER std__SIGCHLD = {
  std_types__signal_number___type, NULL, SIGCHLD
};

static SIGNAL_NUMBER std__SIGCONT = {
  std_types__signal_number___type, NULL, SIGCONT
};

static SIGNAL_NUMBER std__SIGSTOP = {
  std_types__signal_number___type, NULL, SIGSTOP
};

static SIGNAL_NUMBER std__SIGTSTP = {
  std_types__signal_number___type, NULL, SIGTSTP
};

static SIGNAL_NUMBER std__SIGTTIN = {
  std_types__signal_number___type, NULL, SIGTTIN
};

static SIGNAL_NUMBER std__SIGTTOU = {
  std_types__signal_number___type, NULL, SIGTTOU
};

static SIGNAL_NUMBER std__SIGURG = {
  std_types__signal_number___type, NULL, SIGURG
};

static SIGNAL_NUMBER std__SIGXCPU = {
  std_types__signal_number___type, NULL, SIGXCPU
};

static SIGNAL_NUMBER std__SIGXFSZ = {
  std_types__signal_number___type, NULL, SIGXFSZ
};

static SIGNAL_NUMBER std__SIGVTALRM = {
  std_types__signal_number___type, NULL, SIGVTALRM
};

static SIGNAL_NUMBER std__SIGPROF = {
  std_types__signal_number___type, NULL, SIGPROF
};

static SIGNAL_NUMBER std__SIGWINCH = {
  std_types__signal_number___type, NULL, SIGWINCH
};

static SIGNAL_NUMBER std__SIGIO = {
  std_types__signal_number___type, NULL, SIGIO
};

static SIGNAL_NUMBER std__SIGPWR = {
  std_types__signal_number___type, NULL, SIGPWR
};

static SIGNAL_NUMBER std__SIGSYS = {
  std_types__signal_number___type, NULL, SIGSYS
};

LIST std_types__sequence = {
  std_types__list___type, NULL, 0, 0, NULL
};

static OCTET_STRING std__empty_string = {
  std_types__octet_string___type, NULL, 0, 0, NULL
};

TUPLE2 std_types__value_range = {
  builtin_types__tuple2___type, NULL, (NODE *)&std_types__undefined, (NODE *)&std_types__undefined
};

static void *create__std_types__array
  (
    long updates_length,
    ARRAY_VIEW *view,
    ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    ARRAY *node = allocate(sizeof(ARRAY));
    node->type = std_types__array___type;
    node->attributes = std_types__array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__boolean_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    BOOLEAN_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    BOOLEAN_ARRAY *node = allocate(sizeof(BOOLEAN_ARRAY));
    node->type = std_types__boolean_array___type;
    node->attributes = std_types__boolean_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__character_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    CHARACTER_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    CHARACTER_ARRAY *node = allocate(sizeof(CHARACTER_ARRAY));
    node->type = std_types__character_array___type;
    node->attributes = std_types__character_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__int8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT8_ARRAY *node = allocate(sizeof(INT8_ARRAY));
    node->type = std_types__int8_array___type;
    node->attributes = std_types__int8_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__uint8_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT8_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT8_ARRAY *node = allocate(sizeof(UINT8_ARRAY));
    node->type = std_types__uint8_array___type;
    node->attributes = std_types__uint8_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__int16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT16_ARRAY *node = allocate(sizeof(INT16_ARRAY));
    node->type = std_types__int16_array___type;
    node->attributes = std_types__int16_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__uint16_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT16_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT16_ARRAY *node = allocate(sizeof(UINT16_ARRAY));
    node->type = std_types__uint16_array___type;
    node->attributes = std_types__uint16_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__int32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT32_ARRAY *node = allocate(sizeof(INT32_ARRAY));
    node->type = std_types__int32_array___type;
    node->attributes = std_types__int32_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__uint32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT32_ARRAY *node = allocate(sizeof(UINT32_ARRAY));
    node->type = std_types__uint32_array___type;
    node->attributes = std_types__uint32_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__int64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    INT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    INT64_ARRAY *node = allocate(sizeof(INT64_ARRAY));
    node->type = std_types__int64_array___type;
    node->attributes = std_types__int64_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__uint64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    UINT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    UINT64_ARRAY *node = allocate(sizeof(UINT64_ARRAY));
    node->type = std_types__uint64_array___type;
    node->attributes = std_types__uint64_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__float32_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT32_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    FLOAT32_ARRAY *node = allocate(sizeof(FLOAT32_ARRAY));
    node->type = std_types__float32_array___type;
    node->attributes = std_types__float32_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__std_types__float64_array
  (
    long updates_length,
    ARRAY_VIEW *view,
    FLOAT64_ARRAY_DATA *data,
    ARRAY_UPDATES *updates
  )
  {
    FLOAT64_ARRAY *node = allocate(sizeof(FLOAT64_ARRAY));
    node->type = std_types__float64_array___type;
    node->attributes = std_types__float64_array.attributes;
    node->updates_length = updates_length;
    node->view = view;
    node->data = data;
    node->updates = updates;
    return node;
  }

static void *create__c_function
  (
    int32_t parameter_count
  )
  {
    C_FUNCTION *node = allocate(sizeof(C_FUNCTION));
    node->type = c_function___type;
    node->attributes = c_function.attributes;
    node->parameter_count = parameter_count;
    return node;
  }

static void *create__std_types__character
  (
    uint32_t code
  )
  {
    CHARACTER *node = allocate(sizeof(CHARACTER));
    node->type = std_types__character___type;
    node->attributes = std_types__character.attributes;
    node->code = code;
    return node;
  }

static void *create__std_types__date_and_time
  (
    int64_t seconds,
    int32_t nanoseconds
  )
  {
    DATE_AND_TIME *node = allocate(sizeof(DATE_AND_TIME));
    node->type = std_types__date_and_time___type;
    node->attributes = std_types__date_and_time.attributes;
    node->seconds = seconds;
    node->nanoseconds = nanoseconds;
    return node;
  }

void *create__std_types__error
  (
    NODE *category,
    MESSAGE_TEXT *message,
    int err_no,
    int attr_idx,
    NODE *object,
    size_t instruction_counter,
    FUNC_DATA *data
  )
  {
    ERROR *node = allocate(sizeof(ERROR));
    node->type = std_types__error___type;
    node->attributes = std_types__error.attributes;
    node->category = category;
    node->message = message;
    node->err_no = err_no;
    node->attr_idx = attr_idx;
    node->object = object;
    node->instruction_counter = instruction_counter;
    node->data = data;
    return node;
  }

static void *create__tabular_function
  (

  )
  {
    TABULAR_FUNCTION *node = allocate(sizeof(TABULAR_FUNCTION));
    node->type = tabular_function___type;
    node->attributes = tabular_function.attributes;
    return node;
  }

void *create__std_types__list
  (
    long offset,
    long length,
    LIST_DATA *data
  )
  {
    LIST *node = allocate(sizeof(LIST));
    node->type = std_types__list___type;
    node->attributes = std_types__list.attributes;
    node->offset = offset;
    node->length = length;
    node->data = data;
    return node;
  }

static void *create__std_types__integer
  (
    uint64_t value
  )
  {
    INTEGER *node = allocate(sizeof(INTEGER));
    node->type = std_types__integer___type;
    node->attributes = std_types__integer.attributes;
    node->value = value;
    return node;
  }

void *create__builtin_types__positive_integer
  (
    uint64_t value
  )
  {
    POSITIVE_INTEGER *node = allocate(sizeof(POSITIVE_INTEGER));
    node->type = builtin_types__positive_integer___type;
    node->attributes = builtin_types__positive_integer.attributes;
    node->value = value;
    return node;
  }

void *create__builtin_types__negative_integer
  (
    uint64_t value
  )
  {
    NEGATIVE_INTEGER *node = allocate(sizeof(NEGATIVE_INTEGER));
    node->type = builtin_types__negative_integer___type;
    node->attributes = builtin_types__negative_integer.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__real
  (
    double value
  )
  {
    REAL *node = allocate(sizeof(REAL));
    node->type = std_types__real___type;
    node->attributes = std_types__real.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__file_type
  (
    int value
  )
  {
    FILE_TYPE *node = allocate(sizeof(FILE_TYPE));
    node->type = std_types__file_type___type;
    node->attributes = std_types__file_type.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__file_descriptor
  (
    int value
  )
  {
    FILE_DESCRIPTOR *node = allocate(sizeof(FILE_DESCRIPTOR));
    node->type = std_types__file_descriptor___type;
    node->attributes = std_types__file_descriptor.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__signal_number
  (
    int value
  )
  {
    SIGNAL_NUMBER *node = allocate(sizeof(SIGNAL_NUMBER));
    node->type = std_types__signal_number___type;
    node->attributes = std_types__signal_number.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__shutdown_type
  (
    int value
  )
  {
    SHUTDOWN_TYPE *node = allocate(sizeof(SHUTDOWN_TYPE));
    node->type = std_types__shutdown_type___type;
    node->attributes = std_types__shutdown_type.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__seek_type
  (
    int value
  )
  {
    SEEK_TYPE *node = allocate(sizeof(SEEK_TYPE));
    node->type = std_types__seek_type___type;
    node->attributes = std_types__seek_type.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__device_id
  (
    unsigned long value
  )
  {
    DEVICE_ID *node = allocate(sizeof(DEVICE_ID));
    node->type = std_types__device_id___type;
    node->attributes = std_types__device_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__directory
  (
    void *value
  )
  {
    DIRECTORY *node = allocate(sizeof(DIRECTORY));
    node->type = std_types__directory___type;
    node->attributes = std_types__directory.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__group_id
  (
    int value
  )
  {
    GROUP_ID *node = allocate(sizeof(GROUP_ID));
    node->type = std_types__group_id___type;
    node->attributes = std_types__group_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__inode_number
  (
    unsigned long value
  )
  {
    INODE_NUMBER *node = allocate(sizeof(INODE_NUMBER));
    node->type = std_types__inode_number___type;
    node->attributes = std_types__inode_number.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__process_id
  (
    int value
  )
  {
    PROCESS_ID *node = allocate(sizeof(PROCESS_ID));
    node->type = std_types__process_id___type;
    node->attributes = std_types__process_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__user_id
  (
    int value
  )
  {
    USER_ID *node = allocate(sizeof(USER_ID));
    node->type = std_types__user_id___type;
    node->attributes = std_types__user_id.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__error_number
  (
    int value
  )
  {
    ERROR_NUMBER *node = allocate(sizeof(ERROR_NUMBER));
    node->type = std_types__error_number___type;
    node->attributes = std_types__error_number.attributes;
    node->value = value;
    return node;
  }

static void *create__std_types__octet_string
  (
    long offset,
    long length,
    OCTET_DATA *data
  )
  {
    OCTET_STRING *node = allocate(sizeof(OCTET_STRING));
    node->type = std_types__octet_string___type;
    node->attributes = std_types__octet_string.attributes;
    node->offset = offset;
    node->length = length;
    node->data = data;
    return node;
  }

static void *create__std_types__wide_string
  (
    long offset,
    long length,
    WIDE_DATA *data
  )
  {
    WIDE_STRING *node = allocate(sizeof(WIDE_STRING));
    node->type = std_types__wide_string___type;
    node->attributes = std_types__wide_string.attributes;
    node->offset = offset;
    node->length = length;
    node->data = data;
    return node;
  }

static void *create__std_types__terminal_attributes
  (
    TERMIO_DATA *data
  )
  {
    TERMINAL_ATTRIBUTES *node = allocate(sizeof(TERMINAL_ATTRIBUTES));
    node->type = std_types__terminal_attributes___type;
    node->attributes = std_types__terminal_attributes.attributes;
    node->data = data;
    return node;
  }

static void *create__builtin_types__tuple2
  (
    NODE *node_0,
    NODE *node_1
  )
  {
    TUPLE2 *node = allocate(sizeof(TUPLE2));
    node->type = builtin_types__tuple2___type;
    node->attributes = builtin_types__tuple2.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    return node;
  }

static void *create__builtin_types__tuple3
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2
  )
  {
    TUPLE3 *node = allocate(sizeof(TUPLE3));
    node->type = builtin_types__tuple3___type;
    node->attributes = builtin_types__tuple3.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    return node;
  }

static void *create__builtin_types__tuple4
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3
  )
  {
    TUPLE4 *node = allocate(sizeof(TUPLE4));
    node->type = builtin_types__tuple4___type;
    node->attributes = builtin_types__tuple4.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    return node;
  }

static void *create__builtin_types__tuple5
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4
  )
  {
    TUPLE5 *node = allocate(sizeof(TUPLE5));
    node->type = builtin_types__tuple5___type;
    node->attributes = builtin_types__tuple5.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    return node;
  }

static void *create__builtin_types__tuple6
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5
  )
  {
    TUPLE6 *node = allocate(sizeof(TUPLE6));
    node->type = builtin_types__tuple6___type;
    node->attributes = builtin_types__tuple6.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    node->node_5 = node_5;
    return node;
  }

static void *create__builtin_types__tuple7
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6
  )
  {
    TUPLE7 *node = allocate(sizeof(TUPLE7));
    node->type = builtin_types__tuple7___type;
    node->attributes = builtin_types__tuple7.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    node->node_5 = node_5;
    node->node_6 = node_6;
    return node;
  }

static void *create__builtin_types__tuple8
  (
    NODE *node_0,
    NODE *node_1,
    NODE *node_2,
    NODE *node_3,
    NODE *node_4,
    NODE *node_5,
    NODE *node_6,
    NODE *node_7
  )
  {
    TUPLE8 *node = allocate(sizeof(TUPLE8));
    node->type = builtin_types__tuple8___type;
    node->attributes = builtin_types__tuple8.attributes;
    node->node_0 = node_0;
    node->node_1 = node_1;
    node->node_2 = node_2;
    node->node_3 = node_3;
    node->node_4 = node_4;
    node->node_5 = node_5;
    node->node_6 = node_6;
    node->node_7 = node_7;
    return node;
  }

static void *create__std_types__unique_item
  (
    long id
  )
  {
    UNIQUE_ITEM *node = allocate(sizeof(UNIQUE_ITEM));
    node->type = std_types__unique_item___type;
    node->attributes = std_types__unique_item.attributes;
    node->id = id;
    return node;
  }

static void *create__std_types__shared_memory
  (
    int fd,
    long size,
    void *buf
  )
  {
    SHARED_MEMORY *node = allocate(sizeof(SHARED_MEMORY));
    node->type = std_types__shared_memory___type;
    node->attributes = std_types__shared_memory.attributes;
    node->fd = fd;
    node->size = size;
    node->buf = buf;
    return node;
  }

static void entry__std_types__array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_DATA *data = TLS_arguments[0]->array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types__undefined;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    NODE *initial_value;
    initial_value = TLS_arguments[TLS_argument_count-1];
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->array.data->info,
	TLS_arguments[0]->array.data->size, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types__undefined;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__array(0, TLS_arguments[0]->array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__array__std__range (void)
  {
    ARRAY *array = (ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    ARRAY_DATA *data = apply_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->boolean_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    BOOLEAN_ARRAY_DATA *data = TLS_arguments[0]->boolean_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    BOOLEAN_ARRAY_DATA *left =
      apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right =
      apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[0]);
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__boolean_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_boolean_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int initial_value;
    if (!to_bool(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->boolean_array.data->info,
	TLS_arguments[0]->boolean_array.data->size, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, TLS_arguments[0]->boolean_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__boolean_array__std__range (void)
  {
    BOOLEAN_ARRAY *array = (BOOLEAN_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = apply_boolean_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__boolean_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->character_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    CHARACTER_ARRAY_DATA *data = TLS_arguments[0]->character_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    CHARACTER_ARRAY_DATA *left = apply_character_array_updates((CHARACTER_ARRAY *)TLS_arguments[0]);
    CHARACTER_ARRAY_DATA *right = apply_character_array_updates((CHARACTER_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint32_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__character_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__character_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_character_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint32_t initial_value;
    if (!to_uchar32(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__character_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->character_array.data->info,
	TLS_arguments[0]->character_array.data->size, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__character_array(0, TLS_arguments[0]->character_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character_array__std__range (void)
  {
    CHARACTER_ARRAY *array = (CHARACTER_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = apply_character_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__character_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int8_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int8_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int8_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT8_ARRAY_DATA *data = TLS_arguments[0]->int8_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int8_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[0]);
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int8_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int8_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[0]);
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int8_array_scalar_product(
    	  TLS_arguments[0]->int8_array.view, left, 0,
    	  TLS_arguments[1]->int8_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__int8_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_int8_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int8_t initial_value;
    if (!to_int8(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int8_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int8_array.data->info,
	TLS_arguments[0]->int8_array.data->size, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int8_array(0, TLS_arguments[0]->int8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int8_array__std__range (void)
  {
    INT8_ARRAY *array = (INT8_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT8_ARRAY_DATA *data = apply_int8_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__int8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint8_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT8_ARRAY_DATA *data = TLS_arguments[0]->uint8_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint8_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left =
      apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right =
      apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[0]);
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint8_array_scalar_product(
    	  TLS_arguments[0]->uint8_array.view, left, 0,
    	  TLS_arguments[1]->uint8_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__uint8_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_uint8_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint8_t initial_value;
    if (!to_uint8(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint8_array.data->info,
	TLS_arguments[0]->uint8_array.data->size, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, TLS_arguments[0]->uint8_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint8_array__std__range (void)
  {
    UINT8_ARRAY *array = (UINT8_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT8_ARRAY_DATA *data = apply_uint8_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__uint8_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int16_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int16_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int16_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT16_ARRAY_DATA *data = TLS_arguments[0]->int16_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int16_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[0]);
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int16_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int16_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[0]);
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int16_array_scalar_product(
    	  TLS_arguments[0]->int16_array.view, left, 0,
    	  TLS_arguments[1]->int16_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__int16_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_int16_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int16_t initial_value;
    if (!to_int16(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int16_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int16_array.data->info,
	TLS_arguments[0]->int16_array.data->size, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int16_array(0, TLS_arguments[0]->int16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int16_array__std__range (void)
  {
    INT16_ARRAY *array = (INT16_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT16_ARRAY_DATA *data = apply_int16_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__int16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint16_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT16_ARRAY_DATA *data = TLS_arguments[0]->uint16_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint16_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left =
      apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right =
      apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[0]);
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint16_array_scalar_product(
    	  TLS_arguments[0]->uint16_array.view, left, 0,
    	  TLS_arguments[1]->uint16_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__uint16_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_uint16_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint16_t initial_value;
    if (!to_uint16(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint16_array.data->info,
	TLS_arguments[0]->uint16_array.data->size, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, TLS_arguments[0]->uint16_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint16_array__std__range (void)
  {
    UINT16_ARRAY *array = (UINT16_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT16_ARRAY_DATA *data = apply_uint16_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__uint16_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int32_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int32_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int32_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT32_ARRAY_DATA *data = TLS_arguments[0]->int32_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int32_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[0]);
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int32_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int32_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[0]);
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int32_array_scalar_product(
    	  TLS_arguments[0]->int32_array.view, left, 0,
    	  TLS_arguments[1]->int32_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__int32_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_int32_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int32_t initial_value;
    if (!to_int32(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int32_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int32_array.data->info,
	TLS_arguments[0]->int32_array.data->size, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int32_array(0, TLS_arguments[0]->int32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int32_array__std__range (void)
  {
    INT32_ARRAY *array = (INT32_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT32_ARRAY_DATA *data = apply_int32_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__int32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint32_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT32_ARRAY_DATA *data = TLS_arguments[0]->uint32_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint32_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left =
      apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right =
      apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[0]);
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint32_array_scalar_product(
    	  TLS_arguments[0]->uint32_array.view, left, 0,
    	  TLS_arguments[1]->uint32_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__uint32_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_uint32_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint32_t initial_value;
    if (!to_uint32(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint32_array.data->info,
	TLS_arguments[0]->uint32_array.data->size, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, TLS_arguments[0]->uint32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint32_array__std__range (void)
  {
    UINT32_ARRAY *array = (UINT32_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT32_ARRAY_DATA *data = apply_uint32_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__uint32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int64_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->int64_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int64_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT64_ARRAY_DATA *data = TLS_arguments[0]->int64_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int64_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[0]);
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(int64_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int64_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[0]);
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_long(
    	int64_array_scalar_product(
    	  TLS_arguments[0]->int64_array.view, left, 0,
    	  TLS_arguments[1]->int64_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__int64_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_int64_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    int64_t initial_value;
    if (!to_int64(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int64_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->int64_array.data->info,
	TLS_arguments[0]->int64_array.data->size, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__int64_array(0, TLS_arguments[0]->int64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__int64_array__std__range (void)
  {
    INT64_ARRAY *array = (INT64_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT64_ARRAY_DATA *data = apply_int64_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__int64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->uint64_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT64_ARRAY_DATA *data = TLS_arguments[0]->uint64_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(uint64_t)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left =
      apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right =
      apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[0]);
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_ulong(
    	uint64_array_scalar_product(
    	  TLS_arguments[0]->uint64_array.view, left, 0,
    	  TLS_arguments[1]->uint64_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__uint64_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_uint64_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    uint64_t initial_value;
    if (!to_uint64(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->uint64_array.data->info,
	TLS_arguments[0]->uint64_array.data->size, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, TLS_arguments[0]->uint64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__uint64_array__std__range (void)
  {
    UINT64_ARRAY *array = (UINT64_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT64_ARRAY_DATA *data = apply_uint64_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__uint64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float32_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->float32_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float32_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT32_ARRAY_DATA *data = TLS_arguments[0]->float32_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float32_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[0]);
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(float)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float32_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[0]);
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_double(
    	float32_array_scalar_product(
    	  TLS_arguments[0]->float32_array.view, left, 0,
    	  TLS_arguments[1]->float32_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__float32_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__float32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_float32_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    float initial_value;
    if (!to_float(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__float32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float32_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->float32_array.data->info,
	TLS_arguments[0]->float32_array.data->size, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__float32_array(0, TLS_arguments[0]->float32_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float32_array__std__range (void)
  {
    FLOAT32_ARRAY *array = (FLOAT32_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = apply_float32_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__float32_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float64_array__std__length_of (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    ARRAY_VIEW *view = TLS_arguments[0]->float64_array.view;
    int dimension = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[1], &dimension)) return;
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(TLS_arguments[0]);
	return;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(view->dimensions[dimension-1].width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float64_array__std__dimension_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT64_ARRAY_DATA *data = TLS_arguments[0]->float64_array.data;
    {
      NODE *result__node = (NODE *)(from_long(data->info->dimension_count));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float64_array__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0])) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[0]);
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_bool(memcmp(
    	left->items, right->items,sizeof(double)*left->size) == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float64_array__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[1] == TLS_arguments[0]) {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (!equal_array_type(TLS_arguments[1], TLS_arguments[0]))
      {
        invalid_arguments();
        return;
      }
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[0]);
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)TLS_arguments[1]);
    {
      NODE *result__node = (NODE *)(from_double(
    	float64_array_scalar_product(
    	  TLS_arguments[0]->float64_array.view, left, 0,
    	  TLS_arguments[1]->float64_array.view, right, 0,
    	  0)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__float64_array (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__float64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__initialized_float64_array (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    ARRAY_VIEW *view = create_array_view(TLS_argument_count-1);
    if (!view) return;
    double initial_value;
    if (!to_double(TLS_arguments[TLS_argument_count-1], &initial_value)) return;
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__float64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float64_array__std__create_empty_array (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_data(TLS_arguments[0]->float64_array.data->info,
	TLS_arguments[0]->float64_array.data->size, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__float64_array(0, TLS_arguments[0]->float64_array.view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__float64_array__std__range (void)
  {
    FLOAT64_ARRAY *array = (FLOAT64_ARRAY *)TLS_arguments[0];
    int dimension_count = array->view->dimension_count;
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 1+dimension_count) {
      too_many_arguments();
      return;
    }
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = apply_float64_array_updates(array);
    {
      NODE *result__node = (NODE *)(create__std_types__float64_array(0, view, data, NULL));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__pass (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 0) {
      result_count_mismatch();
      return;
    }
    {
      return;
    }
  }

static void entry__std__result_count (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_int(*TLS_frame->link->code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__true__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__true.type) {
      {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__false__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__false.type) {
      {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__c_function__std__parameter_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[0]->c_function.parameter_count < 0)
      {
        NODE *result__node = (NODE *)(&std_types__undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    else
      {
        NODE *result__node = (NODE *)(from_uint32(TLS_arguments[0]->c_function.parameter_count));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
  }

static void entry__std__character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t code;
    if (!to_uint32(TLS_arguments[0], &code)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__character(code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character__std__plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long offset;
    if (!to_long(TLS_arguments[1], &offset)) return;
    int64_t code = (int64_t)TLS_arguments[0]->character.code+offset;
    if (code >= 0x100000000LL || code < 0) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__character((uint32_t)code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character__std__minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__character.type) {
      {
        NODE *result__node = (NODE *)(from_long(
      	  (long)TLS_arguments[0]->character.code-(long)TLS_arguments[1]->character.code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    } else {
      long offset;
      if (!to_long(TLS_arguments[1], &offset)) return;
      long code = (long)TLS_arguments[0]->character.code-offset;
      if (code >= 0x100000000LL || code < 0) {
        invalid_arguments();
        return;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__character((uint32_t)code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__character__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__character.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->character.code == TLS_arguments[1]->character.code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__character__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__character.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->character.code < TLS_arguments[1]->character.code));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types__character__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t hash = TLS_arguments[0]->character.code;
    hash *= 179234567;
    hash ^= hash >> 27 | hash << 5;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types__character__std__to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if (TLS_arguments[0]->character.code <= 0xff) {
      char buf[1];
      buf[0] = TLS_arguments[0]->character.code;
      {
        NODE *result__node = (NODE *)(from_latin_1_string((const uint8_t *)buf, 1));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(from_uint32_string(&TLS_arguments[0]->character.code, 1));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__character__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_uint32(TLS_arguments[0]->character.code));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character__std__width_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_uint32(is_a_wide_character(TLS_arguments[0]->character.code) ? 2 : 1));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__from_unix_time (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int64_t sec;
    if (!to_int64(TLS_arguments[0], &sec)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__date_and_time(sec, 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__date_and_time (void)
  {
    if (TLS_argument_count != 6) {
      invalid_arguments();
      return;
    }
    int year, month, day, hour, minute;
    double second;

    if (!to_int(TLS_arguments[0], &year)) return;
    if (!to_int(TLS_arguments[1], &month)) return;
    if (!to_int(TLS_arguments[2], &day)) return;
    if (!to_int(TLS_arguments[3], &hour)) return;
    if (!to_int(TLS_arguments[4], &minute)) return;
    if (!to_double(TLS_arguments[5], &second)) return;
    int64_t seconds = floor(second);
    int32_t nanoseconds = 1000000000*(second-seconds);
    if (
      year < 1970 ||
      month < 1 || month > 12 ||
      day < 1 ||
      hour < 0 || hour > 23 ||
      minute < 0 || minute > 59 ||
      seconds < 0 || seconds > 59
    ) {
      NODE *result__node = (NODE *)(&std_types__undefined);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    int64_t days = 0;
    year -= 1970;
    if (year >= 2) {
      days += 730;
      year -= 2;
      days += 1461*(year/4);
      year %= 4;
      days += 365*year;
      if (year > 0) ++days;
    } else {
      if (year == 1971) days += 365;
      year += 2;
    }
    int m;
    for (m = 1; m <= 12; ++m) {
      int d;
      switch (m) {
	case 2:
	  d = year == 0 ? 29 : 28;
	  break;
	case 4: case 6: case 9: case 11:
	  d = 30;
	  break;
	default:
	  d = 31;
      }
      if (month > m) days += d;
      if (month == m && day > d) {
        NODE *result__node = (NODE *)(&std_types__undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    days += day-1;
    seconds += 86400*(uint64_t)days+3600*hour+60*minute;
    {
      NODE *result__node = (NODE *)(create__std_types__date_and_time(seconds, nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__year_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int year;
    year_month_day(TLS_arguments[0], &year, NULL, NULL);
    {
      NODE *result__node = (NODE *)(from_int(year));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__month_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int month;
    year_month_day(TLS_arguments[0], NULL, &month, NULL);
    {
      NODE *result__node = (NODE *)(from_int(month));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__day_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int day;
    year_month_day(TLS_arguments[0], NULL, NULL, &day);
    {
      NODE *result__node = (NODE *)(from_int(day));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__day_of_week_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(
    	(3+TLS_arguments[0]->date_and_time.seconds/86400)%7+1));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__hour_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int seconds = TLS_arguments[0]->date_and_time.seconds%86400;
    {
      NODE *result__node = (NODE *)(from_int(seconds/3600));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__minute_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int seconds = TLS_arguments[0]->date_and_time.seconds%3600;
    {
      NODE *result__node = (NODE *)(from_int(seconds/60));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__second_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_double(
    	TLS_arguments[0]->date_and_time.seconds%60+
    	TLS_arguments[0]->date_and_time.nanoseconds/1000000000.0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__time_shift_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    // This insane looking sequence of calls correctly computes the time shift!!!
    struct tm tm;
    time_t t1 = TLS_arguments[0]->date_and_time.seconds;
    localtime_r(&t1, &tm);
    int isdst = tm.tm_isdst;
    gmtime_r(&t1, &tm);
    tm.tm_isdst = isdst;
    time_t t2 = mktime(&tm);
    {
      NODE *result__node = (NODE *)(from_uint64(t1-t2));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__seconds_since_epoch (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_uint64(TLS_arguments[0]->date_and_time.seconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    int64_t seconds = TLS_arguments[0]->date_and_time.seconds;
    int32_t nanoseconds = TLS_arguments[0]->date_and_time.nanoseconds;
    double delta;
    if (!to_double(TLS_arguments[1], &delta)) return;
    int64_t delta_seconds = round(delta);
    int32_t delta_nanoseconds = 1000000000*(delta-delta_seconds);
    seconds += delta_seconds;
    nanoseconds += delta_nanoseconds;
    if (nanoseconds >= 1000000000) {
      nanoseconds -= 1000000000;
      ++seconds;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__date_and_time(seconds, nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    int64_t seconds = TLS_arguments[0]->date_and_time.seconds;
    int32_t nanoseconds = TLS_arguments[0]->date_and_time.nanoseconds;
    if ((TLS_arguments[1])->type == std_types__date_and_time.type) {
      int64_t seconds_2 = TLS_arguments[1]->date_and_time.seconds;
      int32_t nanoseconds_2 = TLS_arguments[1]->date_and_time.nanoseconds;
      {
        NODE *result__node = (NODE *)(from_double(
      	seconds-seconds_2+(nanoseconds-nanoseconds_2)/1000000000.0));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      double delta;
      if (!to_double(TLS_arguments[1], &delta)) return;
      int64_t delta_seconds = round(delta);
      int32_t delta_nanoseconds = 1000000000*(delta-delta_seconds);
      seconds -= delta_seconds;
      nanoseconds -= delta_nanoseconds;
      if (nanoseconds < 0) {
	nanoseconds += 1000000000;
	--seconds;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__date_and_time(seconds, nanoseconds));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__date_and_time__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *left, *right;
    left = TLS_arguments[0];
    right = TLS_arguments[1];
    if ((TLS_arguments[1])->type != std_types__date_and_time.type) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(left->date_and_time.seconds == right->date_and_time.seconds &&
          left->date_and_time.nanoseconds == right->date_and_time.nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__date_and_time__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *left, *right;
    left = TLS_arguments[0];
    right = TLS_arguments[1];
    if ((TLS_arguments[1])->type != std_types__date_and_time.type) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(left->date_and_time.seconds < right->date_and_time.seconds ||
          left->date_and_time.seconds == right->date_and_time.seconds &&
          left->date_and_time.nanoseconds < right->date_and_time.nanoseconds));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__current_time (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    struct timespec timespec;
    clock_gettime(CLOCK_REALTIME, &timespec);
    {
      NODE *result__node = (NODE *)(create__std_types__date_and_time(timespec.tv_sec, timespec.tv_nsec));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__debug__current_time (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    struct timespec timespec;
    clock_gettime(CLOCK_REALTIME, &timespec);
    {
      NODE *result__node = (NODE *)(create__std_types__date_and_time(timespec.tv_sec, timespec.tv_nsec));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__debug__string (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }

    NODE *node = TLS_arguments[0];
    int indent = 0;
    int depth = 1;
    if (TLS_argument_count >= 2) {
      if ((TLS_arguments[1])->type != std_types__undefined.type) {
	if (!to_int(TLS_arguments[1], &indent)) return;
      }
    }
    if (TLS_argument_count >= 3) {
      if (!to_int(TLS_arguments[2], &depth)) return;
    }
    long len = debug_string(node, indent, depth, NULL);
    char *buf = allocate_memory(len+1);
      // <sprintf> might be used and might add a null-byte;
      // therefor allocate 1 byte more
    len = debug_string(node, indent, depth, buf);
    NODE *result = from_latin_1_string((const uint8_t *)buf, len);
    deallocate_memory(buf);
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__debug__write (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *buf;
    long len;
    if (!to_octets(TLS_arguments[0], (const uint8_t **)&buf, &len)) return;
    char *p = buf;
    retry:;
    long bytes_written = write(STDERR_FILENO, p, len);
    if (bytes_written == -1) {
      if (errno == EINTR) goto retry;
    } else if (bytes_written < len) {
      p += bytes_written;
      len -= bytes_written;
      goto retry;
    }
    deallocate_memory(buf);
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__debug__dump_object (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    NODE *node = TLS_arguments[TLS_argument_count-1];
    int depth = 1;
    if (TLS_argument_count == 2) {
      if (!to_int(TLS_arguments[0], &depth)) return;
    }
    long len = debug_string(node, 0, depth, NULL);
    char *buf = allocate_memory(len+1);
    char *p = buf;
    len = debug_string(node, 0, depth, buf);
    retry:;
    long bytes_written = write(STDERR_FILENO, p, len);
    if (bytes_written == -1) {
      if (errno == EINTR) goto retry;
    } else if (bytes_written < len) {
      p += bytes_written;
      len -= bytes_written;
      goto retry;
    }
    deallocate_memory(buf);
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__debug__has_io_access_rights (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(!TLS_deny_io));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__debug__exit (void)
  {
    // ignore all arguments
    exit(EXIT_FAILURE);
  }

static void entry__std__error_check (void)
  {
    int i;
    if (TLS_result_count != 0) {
      result_count_mismatch();
      return;
    }
    for (i = 0; i < TLS_argument_count; ++i) {
      if ((TLS_arguments[i])->type == std_types__error.type) {
	{
	  NODE *result__node = (NODE *)(TLS_arguments[i]);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    }
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__debug__total_garbage_collections (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(total_garbage_collections));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__installation_prefix (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_c_string(PREFIX));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__package_version (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_c_string(PACKAGE_VERSION));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error__std__error_category_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(TLS_arguments[0]->error.category);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error__std__error_message_text_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_c_string(TLS_arguments[0]->error.message->text));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error__std__error_details_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *details = TLS_arguments[0]->error.object;
    if (!details) details = (NODE *)&std_types__undefined;
    {
      NODE *result__node = (NODE *)(details);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error__std__errno_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_arguments[0]->error.err_no) {
      {
        NODE *result__node = (NODE *)(error_number_from_int(TLS_arguments[0]->error.err_no));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__error__std__failed_attribute_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_arguments[0]->error.attr_idx) {
      {
        NODE *result__node = (NODE *)(from_c_string(polymorphic_function_names[TLS_arguments[0]->error.attr_idx]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std__error (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    char *msg;
    NODE *obj;
    NODE *category =
      TLS_argument_count >= 2 ? TLS_arguments[0] :
      module__builtin.constants_base[unique__std__APPLICATION_ERROR-1];
    if (!to_c_string(TLS_arguments[TLS_argument_count >= 2 ? 1 : 0], &msg)) return;
    obj = TLS_argument_count == 3 ? TLS_arguments[2] : NULL;
    create_error_message(category, msg, 0, 0, obj);
    deallocate_memory(msg);
  }

static void entry__std__exec (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type != std_types__list.type) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int i;
    sigset_t set;
    int ret = sigpending(&set);
    if (ret != -1) {
      // cancel all pending signals
      for (i = 1; i <= 31; ++i) {
	if (sigismember(&set, i)) {
	  signal(i, SIG_IGN);
	}
      }
    }

    NODE *arguments = TLS_arguments[1];
    char **args = allocate_memory((arguments->list.length+2)*sizeof(char *));
    for (i = 0; i < arguments->list.length+1; ++i) {
      args[i] = NULL;
    }
    // convert the command and all arguments into C-strings
    if (!to_c_string(TLS_arguments[0], &args[0])) goto cleanup;
    long offset = arguments->list.offset;
    for (i = 0; i < arguments->list.length; ++i) {
      if (!to_c_string(arguments->list.data->items[offset+i], &args[i+1]))
	goto cleanup;
    }
    args[arguments->list.length+1] = NULL;

    int err = execvp(args[0], args); // This call should not return!
    create_error_message(
      module__builtin.constants_base[unique__std__IO_ERROR-1],
      "EXEC FAILED", errno, 0, NULL);

    cleanup:

    if (args) {
      for (i = 0; i < arguments->list.length+1; ++i) {
	deallocate_memory(args[i]);
      }
      deallocate_memory(args);
    }
  }

static void entry__std__create_process (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 6) {
      too_many_arguments();
      return;
    }
    if ((TLS_arguments[1])->type != std_types__list.type) {
      invalid_arguments();
      return;
    }
    NODE *environment = (NODE *)&std_types__undefined;
    if (TLS_argument_count >= 3) {
      environment = TLS_arguments[2];
      if (
	(environment)->type != std_types__undefined.type &&
	(environment)->type != std_types__list.type
      ) {
        invalid_arguments();
        return;
      }
    }
    if (
      TLS_argument_count >= 4 &&
      (TLS_arguments[3])->type != std_types__file_descriptor.type
    ) {
      invalid_arguments();
      return;
    }
    if (
      TLS_argument_count >= 5 &&
      (TLS_arguments[4])->type != std_types__file_descriptor.type
    ) {
      invalid_arguments();
      return;
    }
    if (
      TLS_argument_count >= 6 &&
      (TLS_arguments[5])->type != std_types__file_descriptor.type
    ) {
      invalid_arguments();
      return;
    }

    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    char **envp = NULL;

    // initialize all pipe handles to invalid file descriptors
    struct {
      int read_fd;
      int write_fd;
    } in_pipe = {-1, -1}, out_pipe = {-1, -1}, err_pipe = {-1, -1};

    NODE *arguments = TLS_arguments[1];
    char **args = allocate_memory((arguments->list.length+2)*sizeof(char *));
    int i;
    for (i = 0; i < arguments->list.length+1; ++i) {
      args[i] = NULL;
    }
    // convert the command and all arguments into C-strings
    if (!to_c_string(TLS_arguments[0], &args[0])) goto cleanup;
    long offset = arguments->list.offset;
    for (i = 0; i < arguments->list.length; ++i) {
      if (!to_c_string(arguments->list.data->items[offset+i], &args[i+1]))
	goto cleanup;
    }
    args[arguments->list.length+1] = NULL;

    if (TLS_argument_count < 4) {
      if (pipe((int *)&in_pipe) != 0) {
	pipe_creation_failed:
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "PIPE_CREATION FAILED", errno, 0, NULL);
	goto cleanup;
      }
    }
    if (TLS_argument_count < 5) {
      if (pipe((int *)&out_pipe) != 0) goto pipe_creation_failed;
    }
    if (TLS_argument_count < 6) {
      if (pipe((int *)&err_pipe) != 0) goto pipe_creation_failed;
    }

    pid_t pid = fork();
    if (pid == 0) {
      // child process

      // we must take care of the case that any of the supplied file descriptors
      // is a standard file descriptor, if so then let's duplicate them

      int fd_in, fd_out, fd_err;

      if (TLS_argument_count >= 4) {
	fd_in = TLS_arguments[3]->file_descriptor.value;
	if (fd_in < 3) { // it's a standard file descriptor
	  fd_in = dup_fd(fd_in);
	}
      }
      if (TLS_argument_count >= 5) {
	fd_out = TLS_arguments[4]->file_descriptor.value;
	if (fd_out < 3) { // it's a standard file descriptor
	  fd_out = dup_fd(fd_out);
	}
      }
      if (TLS_argument_count >= 6) {
	fd_err = TLS_arguments[5]->file_descriptor.value;
	if (fd_err < 3) { // it's a standard file descriptor
	  fd_err = dup_fd(fd_err);
	}
      }

      if (TLS_argument_count >= 4) {
	dup2_fd(fd_in, STDIN_FILENO);
	close(fd_in);
      } else {
	close(in_pipe.write_fd);
	dup2_fd(in_pipe.read_fd, STDIN_FILENO);
	close(in_pipe.read_fd);
      }
      if (TLS_argument_count >= 5) {
	dup2_fd(fd_out, STDOUT_FILENO);
	close(fd_out);
      } else {
	close(out_pipe.read_fd);
	dup2_fd(out_pipe.write_fd, STDOUT_FILENO);
	close(out_pipe.write_fd);
      }
      if (TLS_argument_count >= 6) {
	dup2_fd(fd_err, STDERR_FILENO);
	close(fd_err);
      } else {
	close(err_pipe.read_fd);
	dup2_fd(err_pipe.write_fd, STDERR_FILENO);
	close(err_pipe.write_fd);
      }

      if ((environment)->type == std_types__list.type) {
	envp = allocate_memory((environment->list.length+1)*sizeof(char *));
	int i;
	for (i = 0; i < environment->list.length; ++i) {
	  envp[i] = NULL;
	}
	// convert the environment into C-strings
	long offset = environment->list.offset;
	for (i = 0; i < environment->list.length; ++i) {
	  if (!to_c_string(environment->list.data->items[offset+i], &envp[i]))
	    goto cleanup;
	}
	envp[environment->list.length] = NULL;
	execvpe(args[0], args, envp);
      } else {
	execvp(args[0], args);
      }
      fprintf(stderr, "EXEC \"%s\" FAILED - %s\n", args[0], strerror(errno));
      exit(EXIT_FAILURE);
    }

    // parent process

    if (pid == -1) {
      create_error_message(
	      module__builtin.constants_base[unique__std__IO_ERROR-1],
	"FORK FAILED", errno, 0, NULL);
      goto cleanup;
    }

    NODE *child_pid, *child_stdin, *child_stdout, *child_stderr;

    child_pid = process_id_from_int(pid);
    if (TLS_argument_count < 4) {
      child_stdin = file_descriptor_from_int(in_pipe.write_fd);
      close_on_exec(in_pipe.write_fd);
    }
    child_stdout = file_descriptor_from_int(out_pipe.read_fd);
    close_on_exec(out_pipe.read_fd);
    child_stderr = file_descriptor_from_int(err_pipe.read_fd);
    close_on_exec(err_pipe.read_fd);

    if (TLS_argument_count == 4) {
      // we got *stdin* from the caller
      TLS_argument_count = 3;
      TLS_arguments[0] = child_pid;
      TLS_arguments[1] = child_stdout;
      TLS_arguments[2] = child_stderr;
      goto cleanup_2;
    } else if (TLS_argument_count == 5) {
      // we got *stdin* and *stdout* from the caller
      TLS_argument_count = 2;
      TLS_arguments[0] = child_pid;
      TLS_arguments[1] = child_stderr;
      goto cleanup_2;
    } else if (TLS_argument_count == 6) {
      // we got *stdin*, *stdout* and *stderr* from the caller
      TLS_argument_count = 1;
      TLS_arguments[0] = child_pid;
      goto cleanup_2;
    } else {
      TLS_argument_count = 4;
      TLS_arguments[0] = child_pid;
      TLS_arguments[1] = child_stdin;
      TLS_arguments[2] = child_stdout;
      TLS_arguments[3] = child_stderr;
      goto cleanup_2;
    }

    cleanup:

    close_fd(&in_pipe.write_fd);
    close_fd(&out_pipe.read_fd);
    close_fd(&err_pipe.read_fd);

    cleanup_2:

    close_fd(&in_pipe.read_fd);
    close_fd(&out_pipe.write_fd);
    close_fd(&err_pipe.write_fd);

    if (args) {
      for (i = 0; i < arguments->list.length+1; ++i) {
	deallocate_memory(args[i]);
      }
      deallocate_memory(args);
    }
    if (envp) {
      for (i = 0; i < environment->list.length; ++i) {
	deallocate_memory(envp[i]);
      }
      deallocate_memory(envp);
    }
  }

static void entry__std_types__function__std__parameter_count_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    const TAB_NUM *code =
      do_debug
      ? ((FUNCTION_INFO *)((unsigned long)TLS_arguments[0]->type & -4L))->code
      : (const TAB_NUM *)((unsigned long)TLS_arguments[0]->type & -4L);
    int par_count = code[1];
    if (par_count < 0)
      {
        NODE *result__node = (NODE *)(&std_types__undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    else
      {
        NODE *result__node = (NODE *)(from_uint32(par_count));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
  }

static void entry__std_types__function__std__new (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (((long)TLS_arguments[1]->type & 3)!= TABULAR_FUNCTION_TAG) {
      invalid_arguments();
      return;
    }
    NODE *node = create__tabular_function();
    node->type = TLS_arguments[1]->type;
    node->attributes = TLS_arguments[0]->attributes;
    {
      NODE *result__node = (NODE *)(node);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__list (void)
  {
    if (TLS_argument_count < 0) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count == 0) {
      NODE *result__node = (NODE *)((NODE *)&std__empty_list);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    LIST_DATA *data =
      allocate_large(sizeof(LIST_DATA)+TLS_argument_count*sizeof(NODE *));
    data->size = TLS_argument_count;
    data->length = TLS_argument_count;
    int i = 0;
    for (i = 0; i < TLS_argument_count; ++i) {
      data->items[i] = TLS_arguments[i];
    }
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, TLS_argument_count, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__list__std__length_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->list.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__list__std__is_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->list.length == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__list__std__is_not_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->list.length > 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__list__std__push (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    NODE *value = TLS_arguments[1];
    long start_offset = self->list.offset;
    long left_length = self->list.length;
    long end_offset = start_offset+left_length;
    long new_length = left_length+1;
    LIST_DATA *data = self->list.data;
    if (!data || data->size < end_offset+1 || data->length != end_offset) {
      long new_size = ALLOCATION_SIZE(2*new_length);
      LIST_DATA *new_data = allocate_large(sizeof(LIST_DATA)+new_size*sizeof(NODE *));
      if (data) memcpy(new_data->items, data->items+start_offset, left_length*sizeof(NODE *));
      start_offset = 0;
      end_offset = left_length;
      new_data->size = new_size;
      data = new_data;
    }
    data->items[end_offset] = value;
    data->length = end_offset+1;
    NODE *result = create__std_types__list(start_offset, new_length, data);
    result->attributes = self->attributes; // maintain attributes
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types__list__std__drop (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *list = TLS_arguments[0];
    long length = list->list.length;
    if (length == 0) {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to drop an element from an empty list!", 0, 0, NULL);
      return;
    }
    NODE *result =
      create__std_types__list(list->list.offset, length-1, list->list.data);
    result->attributes = list->attributes; // maintain attributes
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types__list__std__pop (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 2) {
      result_count_mismatch();
      return;
    }
    if (TLS_result_count != 2) {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Invalid number of expected results!", 0, 0, NULL);
      return;
    }
    NODE *list = TLS_arguments[0];
    long offset = list->list.offset;
    long length = list->list.length;
    if (length == 0) {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to pop an element from an empty list!", 0, 0, NULL);
      return;
    }
    NODE *new_list = create__std_types__list(offset, length-1, list->list.data);
    new_list->attributes = list->attributes; // maintain attributes
    TLS_argument_count = 2;
    TLS_arguments[0] = new_list;
    TLS_arguments[1] = list->list.data->items[offset+length-1];
    {
      return;
    }
  }

static void entry__std_types__list__std__peek (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *list = TLS_arguments[0];
    long length = list->list.length;
    if (length == 0) {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to peek an element of an empty list!", 0, 0, NULL);
      return;
    }
    {
      NODE *result__node = (NODE *)(list->list.data->items[list->list.offset+length-1]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__list__std__append (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    long left_length = left->list.length;
    long new_length = left_length;
    int i;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      if ((right)->type != std_types__list.type) {
        invalid_arguments();
        return;
      }
      new_length += right->list.length;
    }
    if (new_length == left_length) {
      NODE *result__node = (NODE *)(left);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_length == 0 && TLS_argument_count == 2) {
      NODE *right = TLS_arguments[1];
      NODE *result =
	create__std_types__list(right->list.offset, right->list.length, right->list.data);
      result->attributes = left->attributes; // maintain attributes
      {
        NODE *result__node = (NODE *)(result);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      };
    }
    long left_offset = left->list.offset;
    LIST_DATA *data = left->list.data;
    if (
      !data || data->size < left_offset+new_length ||
      data->length != left_offset+left_length
    ) {
      long new_size = 2*new_length;
      LIST_DATA *new_data =
	allocate_large(sizeof(LIST_DATA)+new_size*sizeof(NODE *));
      if (data) {
	memcpy(
	  new_data->items, data->items+left_offset, left_length*sizeof(NODE *));
      }
      left_offset = 0;
      new_data->size = new_size;
      data = new_data;
    }
    long offset = left_offset+left_length;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      long right_offset = right->list.offset;
      long right_length = right->list.length;
      if (right_length > 0) {
	memcpy(
	  data->items+offset,
	  right->list.data->items+right_offset,
	  right_length*sizeof(NODE *));
	offset += right_length;
      }
    }
    data->length = left_offset+new_length;
    NODE *result = create__std_types__list(left_offset, new_length, data);
    result->attributes = left->attributes; // maintain attributes
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types__list__std__range (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    long first_idx, last_idx;
    if (!to_long(TLS_arguments[1], &first_idx)) return;
    if (!to_long(TLS_arguments[2], &last_idx)) return;
    long length = self->list.length;
    if (first_idx < 0) first_idx = length+first_idx+1;
    if (last_idx < 0) last_idx = length+last_idx+1;
    if (first_idx < 1 || first_idx > length+1) {
      invalid_index(self);
      return;
    };
    if (last_idx < 0 || last_idx > length) {
      invalid_index(self);
      return;
    };
    if (first_idx > last_idx+1) {
      invalid_arguments();
      return;
    }
    if (first_idx == 1 && last_idx == length) {
      NODE *result__node = (NODE *)(self);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long new_len = last_idx-first_idx+1;
    if (new_len == 0) {
      NODE *result__node = (NODE *)((NODE *)&std__empty_list);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__list(self->list.offset+first_idx-1, new_len, self->list.data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__list__std__spread (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long length = self->list.length;
    if (TLS_result_count != length) {
      result_count_mismatch();
      return;
    }
    TLS_argument_count = length;
    int i;
    for (i = 0; i < length; ++i) {
      TLS_arguments[i] = self->list.data->items[i];
    }
    {
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__negate (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(create_negative_integer(TLS_arguments[0]->integer.value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__negate (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__negate (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(-TLS_arguments[0]->real.value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint64_t low, high;
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->integer.value*TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint64_t low, high;
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	if (low == 0) {
	  {
	    NODE *result__node = (NODE *)(create__builtin_types__positive_integer(0));
	    TLS_arguments[0] = result__node;
	    TLS_argument_count = 1;
	    return;
	  }
	} else {
	  {
	    NODE *result__node = (NODE *)(create_negative_integer(low));
	    TLS_arguments[0] = result__node;
	    TLS_argument_count = 1;
	    return;
	  }
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      high =
	umul64(TLS_arguments[0]->integer.value, TLS_arguments[1]->integer.value, &low);
      if (high == 0) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(low));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(-(TLS_arguments[0]->integer.value*TLS_arguments[1]->real.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(TLS_arguments[0]);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    long val = floor(TLS_arguments[0]->real.value);
    {
      NODE *result__node = (NODE *)(from_long(val));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__floor (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(floor(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__ceil (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(ceil(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__round (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(round(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    char buf[24];
    sprintf(buf, "-%" PRIu64, TLS_arguments[0]->integer.value);
    {
      NODE *result__node = (NODE *)(from_c_string(buf));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    char buf[24];
    sprintf(buf, "%" PRIu64, TLS_arguments[0]->integer.value);
    {
      NODE *result__node = (NODE *)(from_c_string(buf));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    char buf[24];
    sprintf(buf, "%.15g", TLS_arguments[0]->real.value);
    {
      NODE *result__node = (NODE *)(from_c_string(buf));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__over (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value == 0) {
        divide_by_zero();
        return;
      }
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types__real((double)TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types__real(-((double)TLS_arguments[0]->integer.value /
	  	    TLS_arguments[1]->integer.value)));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      if (TLS_arguments[1]->real.value == 0.0) {
        divide_by_zero();
        return;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->integer.value/TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__over (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types__real((double)TLS_arguments[0]->integer.value /
	  	    TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value == 0) {
        divide_by_zero();
        return;
      }
      if (TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value == 0) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__std_types__real(-((double)TLS_arguments[0]->integer.value /
	  	    TLS_arguments[1]->integer.value)));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      if (TLS_arguments[1]->real.value == 0.0) {
        divide_by_zero();
        return;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__real(-(TLS_arguments[0]->integer.value/TLS_arguments[1]->real.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__div (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      uint64_t value =
	(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value-1) /
	TLS_arguments[1]->integer.value;
      {
        NODE *result__node = (NODE *)(create_negative_integer(value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__div (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	uint64_t value =
	  (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value-1) /
	  TLS_arguments[1]->integer.value;
	{
	  NODE *result__node = (NODE *)(create_negative_integer(value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value / TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__mod (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      long result = TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value;
      if (result != 0) result = TLS_arguments[1]->integer.value-result;
      {
        NODE *result__node = (NODE *)(create_negative_integer(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__mod (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value) {
	long result = TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value;
	if (result != 0) result = TLS_arguments[1]->integer.value-result;
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(result));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
        divide_by_zero();
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create_negative_integer(
      	  TLS_arguments[0]->integer.value % TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash =
      (uint32_t)TLS_arguments[0]->integer.value ^ (TLS_arguments[0]->integer.value >> 32);
    hash *= 179234567;
    hash ^= hash >> 27 | hash << 5;
    //hash *= 257913241;
    //hash ^= hash >> 21 | hash << 11;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash =
      (uint32_t)TLS_arguments[0]->integer.value ^ (TLS_arguments[0]->integer.value >> 32);
    hash *= 179234567;
    hash ^= hash >> 27 | hash << 5;
    //hash *= 326987239;
    //hash ^= hash >> 21 | hash << 11;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash =
      (uint32_t)TLS_arguments[0]->integer.value ^ (TLS_arguments[0]->integer.value >> 32);
    hash ^= hash >> 23 | hash << 9;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__ln (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(log(TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__ln (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(log(-TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__ln (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(log(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__exp (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(exp(TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__exp (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(exp(-TLS_arguments[0]->integer.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__real__std__exp (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__real(exp(TLS_arguments[0]->real.value)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__real (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *str;
    if (!to_c_string(TLS_arguments[0], &str)) return;
    NODE *result = from_double(atof(str));
    deallocate_memory(str);
    {
      NODE *result__node = (NODE *)(result);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *buf;
    if (!to_c_string(TLS_arguments[0], &buf)) return;
    int sign = 1;
    unsigned long value = 0;
    char *str = buf;
    if (*str == '-') {
      sign = -1;
      ++str;
    } else if (*str == '+') {
      ++str;
    }
    if (*str < '0' || *str > '9') {
      invalid_arguments();
      goto cleanup;
    }
    char c;
    next:
    c = *str++;
    if (c < '0' || c > '9') {
      NODE *result;
      if (sign < 0 && value != 0) {
	result = create__builtin_types__negative_integer(value);
      } else {
	result = create__builtin_types__positive_integer(value);
      }
      {
        NODE *result__node = (NODE *)(result);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
      goto cleanup;
    } else {
      unsigned long old_value = value;
      value <<= 1;
      if (value < old_value) goto overflow;
      unsigned long intermediate_value = value;
      value <<= 1;
      if (value < intermediate_value) goto overflow;
      intermediate_value = value;
      value += old_value;
      if (value < intermediate_value) goto overflow;
      intermediate_value = value;
      value <<= 1;
      if (value < intermediate_value) goto overflow;
      intermediate_value = value;
      value += c-'0';
      if (value < intermediate_value) goto overflow;
      goto next;
    }

    overflow:

    create_error_message(
      module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
      "std::integer OVERFLOW", 0, 0, NULL);

    cleanup:

    deallocate_memory(buf);
    return;
  }

static void entry__std__sqrt (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(sqrt(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__pow (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    double base;
    if (!to_double(TLS_arguments[0], &base)) return;
    double exponent;
    if (!to_double(TLS_arguments[1], &exponent)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(pow(base, exponent)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__exit (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int status;
    if (!to_int(TLS_arguments[0], &status)) return;
    exit(status);
  }

static void entry__builtin_types__positive_integer__std__plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >= TLS_arguments[0]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      if (TLS_arguments[0]->integer.value >= TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->integer.value+TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      if (
	TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >=
	TLS_arguments[0]->integer.value
      ) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[0]->integer.value > TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[1]->real.value-TLS_arguments[0]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types__real__std__plus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value+TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value+TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value-TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[0]->integer.value >= TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      if (TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >= TLS_arguments[0]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->integer.value-TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      if (TLS_arguments[0]->integer.value > TLS_arguments[1]->integer.value) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[0]->integer.value-TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[1]->integer.value-TLS_arguments[0]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (
	TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value >=
	TLS_arguments[0]->integer.value
      ) {
	{
	  NODE *result__node = (NODE *)(create_negative_integer(
		    TLS_arguments[0]->integer.value+TLS_arguments[1]->integer.value));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(-(TLS_arguments[0]->integer.value+TLS_arguments[1]->real.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types__real__std__minus (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value-TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value-TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value+TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types__real__std__times (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value*TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value*TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(-(TLS_arguments[0]->real.value*TLS_arguments[1]->integer.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types__real__std__over (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__real.type) {
      if (TLS_arguments[1]->real.value == 0.0) {
        divide_by_zero();
        return;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value/TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      if (TLS_arguments[1]->integer.value == 0) {
        divide_by_zero();
        return;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__real(TLS_arguments[0]->real.value/TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(create__std_types__real(-(TLS_arguments[0]->real.value/TLS_arguments[1]->integer.value)));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__builtin_types__negative_integer__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value == -TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__real__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value == TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(-TLS_arguments[0]->real.value == TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__builtin_types__positive_integer__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value < TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value < TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__negative_integer__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value > TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->integer.value > -TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std_types__real__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__real.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value < TLS_arguments[1]->real.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->real.value < TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((TLS_arguments[1])->type == builtin_types__negative_integer.type) {
      {
        NODE *result__node = (NODE *)(from_bool(-TLS_arguments[0]->real.value > TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__shift_left (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value << TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__shift_right (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value >> TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__bit_and (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value & TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__bit_or (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value | TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__builtin_types__positive_integer__std__bit_xor (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    if ((TLS_arguments[1])->type == builtin_types__positive_integer.type) {
      {
        NODE *result__node = (NODE *)(create__builtin_types__positive_integer(TLS_arguments[0]->integer.value ^ TLS_arguments[1]->integer.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    {
      invalid_arguments();
      return;
    }
  }

static void entry__std__sin (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(sin(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__cos (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(cos(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__tan (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(tan(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__asin (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(asin(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__acos (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(acos(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__atan (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    double arg;
    if (!to_double(TLS_arguments[0], &arg)) return;
    {
      NODE *result__node = (NODE *)(create__std_types__real(atan(arg)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__debug__object_type (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *node = TLS_arguments[0];
    int type_no = node->attributes->vtable->type_no;
    if (type_no) {
      const char *name = type_names[type_no];
      const char *namespace = name+strlen(name)+1;
      if (*namespace) {
	char buf[256];
	sprintf(buf, "%s::%s", namespace, name);
	{
	  NODE *result__node = (NODE *)(from_c_string(buf));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(from_c_string(name));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string("object"));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__debug__object_attributes (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *node = TLS_arguments[0];
    int n = 0;
    for (int i = 1; i < next_polymorphic_function; ++i) {
      if ((i & 7) != 0) {
	if (attribute_is_redefined[i]) {
	  NODE *attr = get_attribute(node, i);
	  if (CONTAINS_AN_ATTRIBUTE_VALUE(attr)) {
	    ++n;
	  }
	}
      }
    }
    LIST_DATA *data = allocate_large(sizeof(LIST_DATA)+2*n*sizeof(NODE *));
    data->size = 2*n;
    data->length = 2*n;
    n = 0;
    for (int i = 1; i < next_polymorphic_function; ++i) {
      if ((i & 7) != 0) {
	if (attribute_is_redefined[i]) {
	  NODE *attr = get_attribute(node, i);
	  if (CONTAINS_AN_ATTRIBUTE_VALUE(attr)) {
	    attr = RETRIEVE_ATTRIBUTE_VALUE(attr);
	    const char *poly_name = polymorphic_function_names[i];
	    const char *poly_namespace = poly_name;
	    while (*poly_namespace++);
	    if (*poly_namespace) {
	      char buf[256];
	      sprintf(buf, "%s::%s", poly_namespace, poly_name);
	      poly_name = buf;
	    }
	    data->items[n++] = from_c_string(poly_name);
	    data->items[n++] = attr;
	  }
	}
      }
    }
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, n, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__std_types__object__std__new (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *to = TLS_arguments[0];
    NODE *from = TLS_arguments[1];
    if (
      from->type == std_types__undefined.type ||
      from->type == std_types__error.type
    ) {
      NODE *result__node = (NODE *)(from);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (from->type != to->type) {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "TYPE MISMATCH", 0, 0, NULL);
      return;
    }
    ATTRIBUTES *attributes =
      copy_attributes(
	(OCTREE *)to->attributes,
	(OCTREE *)from->attributes,
	attributes_level,
	0);
    if (attributes) {
      if ((intptr_t)attributes < 0) {
	invalid_attribute_redefinition(to, -(intptr_t)attributes);
      } else {
	NODE *node = copy(from, from->attributes->vtable->size);
	node->attributes = attributes;
	{
	  NODE *result__node = (NODE *)(node);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else if (to->attributes != from->attributes) {
      NODE *node = copy(from, from->attributes->vtable->size);
      node->attributes = to->attributes;
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(from);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__file_type__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__file_type.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->file_type.value ==
      	  TLS_arguments[1]->file_type.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__file_type__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->file_type.value;
    hash += 4243007357u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__file_type (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__file_type(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__file_type__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->file_type.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__file_descriptor__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__file_descriptor.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->file_descriptor.value ==
      	  TLS_arguments[1]->file_descriptor.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__file_descriptor__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->file_descriptor.value;
    hash += 1659535014u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__file_descriptor (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__file_descriptor(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__file_descriptor__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->file_descriptor.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__signal_number__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__signal_number.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->signal_number.value ==
      	  TLS_arguments[1]->signal_number.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__signal_number__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->signal_number.value;
    hash += 8379021777u;
    hash *= 2567483615;
    hash ^= hash >> 14 | hash << 18;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__signal_number (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__signal_number(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__signal_number__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->signal_number.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__shutdown_type__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__shutdown_type.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->shutdown_type.value ==
      	  TLS_arguments[1]->shutdown_type.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__shutdown_type__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->shutdown_type.value;
    hash += 1037657925u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__shutdown_type (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__shutdown_type(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__shutdown_type__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->shutdown_type.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__seek_type__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__seek_type.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->seek_type.value == TLS_arguments[1]->seek_type.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__seek_type__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->seek_type.value;
    hash += 49284017u;
    hash *= 783461037;
    hash ^= hash >> 21 | hash << 11;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__seek_type (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__seek_type(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__seek_type__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->seek_type.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__device_id__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__device_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->device_id.value ==
      	  TLS_arguments[1]->device_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__device_id__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->device_id.value;
    hash += 1532833290u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__device_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value;
    if (!(to_ulong(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__device_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__device_id__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value = TLS_arguments[0]->device_id.value;
    {
      NODE *result__node = (NODE *)(from_ulong(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__directory__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__directory.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->directory.value ==
      	  TLS_arguments[1]->directory.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__directory__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = (uint32_t)(long)TLS_arguments[0]->directory.value;
    hash += 835235593u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std_types__group_id__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__group_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->group_id.value ==
      	  TLS_arguments[1]->group_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__group_id__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->group_id.value;
    hash += 1390477003u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__group_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__group_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__group_id__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->group_id.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__inode_number__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__inode_number.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->inode_number.value ==
      	  TLS_arguments[1]->inode_number.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__inode_number__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->inode_number.value;
    hash += 524255112u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__inode_number (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value;
    if (!(to_ulong(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__inode_number(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__inode_number__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    unsigned long value = TLS_arguments[0]->inode_number.value;
    {
      NODE *result__node = (NODE *)(from_ulong(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__process_id__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__process_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->process_id.value ==
      	  TLS_arguments[1]->process_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__process_id__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->process_id.value;
    hash += 3109630881u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__process_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__process_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__process_id__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->process_id.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__user_id__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__user_id.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->user_id.value ==
      	  TLS_arguments[1]->user_id.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__user_id__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->user_id.value;
    hash += 4053581900u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__user_id (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__user_id(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__user_id__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->user_id.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error_number__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if ((TLS_arguments[1])->type == std_types__error_number.type)
      {
        NODE *result__node = (NODE *)(from_bool(
      	  TLS_arguments[0]->error_number.value ==
      	  TLS_arguments[1]->error_number.value));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error_number__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->error_number.value;
    hash += 1056763753u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__error_number (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value;
    if (!(to_int(TLS_arguments[0], &value))) return;
    {
      NODE *result__node = (NODE *)(create__std_types__error_number(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__error_number__std__to_integer (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int value = TLS_arguments[0]->error_number.value;
    {
      NODE *result__node = (NODE *)(from_int(value));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__access (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    char *mode_str = NULL;
    int mode;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!to_c_string(TLS_arguments[1], &mode_str)) goto cleanup;
    mode = 0;
    for(int i = 0; mode_str[i]; i++) {
      switch(mode_str[i]) {
	case 'r':
	  mode |= R_OK;
	  break;
	case 'w':
	  mode |= W_OK;
	  break;
	case 'x':
	  mode |= X_OK;
	  break;
	default:
	  create_error_message(
	    module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
	    "ACCESS: INVALID MODE", 0, 0, NULL);
	  goto cleanup;
      }
    }
    if (event__mode != EM__REPLAY) {
      result = access(filename, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("access");
        } else {
          failed__action("access");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("access")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("access");
      print__c_string(filename);
      print__c_string(mode_str);
      print__integer(result);
      end__report();
    }
    if (result == 0) {
      {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    } else {
      if (errno == EACCES) {
	{
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	}
      } else {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "ACCESS FAILED", errno, 0, NULL);
      }
    }
    cleanup:
    deallocate_memory(filename);
    deallocate_memory(mode_str);
  }

static void entry__std__chdir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *pathname = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &pathname)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chdir(pathname);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("chdir");
        } else {
          failed__action("chdir");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("chdir")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("chdir");
      print__c_string(pathname);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"CHDIR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(pathname);
  }

static void entry__std__chmod (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int mode;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!mode_to_int(TLS_arguments[1], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chmod(filename, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("chmod");
        } else {
          failed__action("chmod");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("chmod")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("chmod");
      print__c_string(filename);
      print__integer(mode);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"CHMOD FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__chown (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int owner;
    int group;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!user_id_to_int(TLS_arguments[1], &owner)) goto cleanup;
    if (!group_id_to_int(TLS_arguments[2], &group)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chown(filename, owner, group);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("chown");
        } else {
          failed__action("chown");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("chown")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("chown");
      print__c_string(filename);
      print__integer(owner);
      print__integer(group);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"CHOWN FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__chroot (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *pathname = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &pathname)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = chroot(pathname);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("chroot");
        } else {
          failed__action("chroot");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("chroot")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("chroot");
      print__c_string(pathname);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"CHROOT FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(pathname);
  }

static void entry__std_types__file_descriptor__std__close (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd = TLS_arguments[0]->file_descriptor.value;
    int result;
    if (event__mode != EM__REPLAY) {
      do {
	result = close(fd);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("close");
        } else {
          failed__action("close");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("close")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("close");
      print__integer(fd);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"CLOSE FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__closedir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    void *dir = NULL;
    int result;
    if (!directory_to_ptr(TLS_arguments[0], &dir)) return;
    if (event__mode != EM__REPLAY) {
      result = closedir(dir);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("closedir");
        } else {
          failed__action("closedir");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("closedir")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("closedir");
      print__pointer(dir);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"CLOSEDIR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__dup2 (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int old_fd;
    int new_fd;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &old_fd)) return;
    if (!file_descriptor_to_int(TLS_arguments[1], &new_fd)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = dup2(old_fd, new_fd);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("dup2");
        } else {
          failed__action("dup2");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("dup2")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("dup2");
      print__integer(old_fd);
      print__integer(new_fd);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"DUP2 FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__fstat (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    struct stat statbuf;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (event__mode != EM__REPLAY) {
      result = fstat(fd, &statbuf);
      if (event__mode == EM__RECORD) {
        record__event("fstat");
        store__integer(result);
        store__memory(&statbuf, sizeof(statbuf));
        end__record();
      }
    } else {
      replay__event("fstat");
      retrieve__integer(&result);
      retrieve__fixed_memory((uint8_t *)&statbuf, sizeof(statbuf));
      report__event("fstat");
      print__integer(fd);
      print__integer(result);
      print__memory(&statbuf, sizeof(statbuf));
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"FSTAT FAILED", errno, 0, NULL);
    } else {
      NODE *node__device_of = device_id_from_ulong(statbuf.st_dev);
      NODE *node__inode_number_of = inode_number_from_ulong(statbuf.st_ino);
      NODE *node__type_of = file_type_from_int(statbuf.st_mode >> 12);
      NODE *node__mode_of = mode_from_int(statbuf.st_mode);
      NODE *node__link_count_of = from_int(statbuf.st_nlink);
      NODE *node__user_id_of = user_id_from_int(statbuf.st_uid);
      NODE *node__group_id_of = group_id_from_int(statbuf.st_gid);
      NODE *node__root_device_of = device_id_from_ulong(statbuf.st_rdev);
      NODE *node__size_of = from_long(statbuf.st_size);
      NODE *node__block_size_of = from_long(statbuf.st_blksize);
      NODE *node__block_count_of = from_long(statbuf.st_blocks);
      NODE *node_access_time_of =
	create__std_types__date_and_time(statbuf.st_atim.tv_sec, statbuf.st_atim.tv_nsec);
      NODE *node_modification_time_of =
	create__std_types__date_and_time(statbuf.st_mtim.tv_sec, statbuf.st_mtim.tv_nsec);
      NODE *node_status_change_time_of =
	create__std_types__date_and_time(statbuf.st_ctim.tv_sec, statbuf.st_ctim.tv_nsec);
      NODE *node = clone_object_and_attributes((NODE *)&std_types__stat);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_std__device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__mode_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__mode_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__link_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__link_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__root_device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__root_device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__block_size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__access_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_access_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__modification_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_modification_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__status_change_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_status_change_time_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__fsync (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (event__mode != EM__REPLAY) {
      result = fsync(fd);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("fsync");
        } else {
          failed__action("fsync");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("fsync")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("fsync");
      print__integer(fd);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"FSYNC FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__getcwd (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    uint8_t static_buf[1024];
    uint8_t *buf = NULL;
    size_t size;
    char *result = NULL;
    if (event__mode != EM__REPLAY) {
      buf = static_buf;
      size = 1024;
      retry:
      result = getcwd((char *)buf, size);
      if (buf == static_buf) buf = NULL;
      if (errno == ERANGE) {
	size += size;
	buf = reallocate_memory(buf, size);
	goto retry;
      }
      if (event__mode == EM__RECORD) {
        record__event("getcwd");
        store__c_string(result);
        end__record();
      }
    } else {
      replay__event("getcwd");
      retrieve__c_string(&result);
      report__event("getcwd");
      print__c_string(result);
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETCWD FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    deallocate_memory(buf);
  }

static void entry__std__getenv (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *var_name = NULL;
    char *result = NULL;
    if (!to_c_string(TLS_arguments[0], &var_name)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = getenv(var_name);
      if (event__mode == EM__RECORD) {
        record__event("getenv");
        store__c_string(result);
        end__record();
      }
    } else {
      replay__event("getenv");
      retrieve__c_string(&result);
      report__event("getenv");
      print__c_string(var_name);
      print__c_string(result);
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETENV FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(var_name);
  }

static void entry__std__getegid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getegid();
      if (event__mode == EM__RECORD) {
        record__event("getegid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("getegid");
      retrieve__integer(&result);
      report__event("getegid");
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(group_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__geteuid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = geteuid();
      if (event__mode == EM__RECORD) {
        record__event("geteuid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("geteuid");
      retrieve__integer(&result);
      report__event("geteuid");
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(user_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__getgid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getgid();
      if (event__mode == EM__RECORD) {
        record__event("getgid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("getgid");
      retrieve__integer(&result);
      report__event("getgid");
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(group_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__gethostname (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char buf[HOST_NAME_MAX+1];
    int result;
    if (event__mode != EM__REPLAY) {
      result = gethostname(buf, sizeof(buf));
      if (event__mode == EM__RECORD) {
        record__event("gethostname");
        store__memory(buf, result);
        end__record();
      }
    } else {
      replay__event("gethostname");
      result = retrieve__memory((uint8_t **)&buf);
      report__event("gethostname");
      print__memory(buf, result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETHOSTNAME FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(buf));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__getlogin (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *result = NULL;
    if (event__mode != EM__REPLAY) {
      result = getlogin();
      if (event__mode == EM__RECORD) {
        record__event("getlogin");
        store__c_string(result);
        end__record();
      }
    } else {
      replay__event("getlogin");
      retrieve__c_string(&result);
      report__event("getlogin");
      print__c_string(result);
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETLOGIN FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__getpid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getpid();
      if (event__mode == EM__RECORD) {
        record__event("getpid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("getpid");
      retrieve__integer(&result);
      report__event("getpid");
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(process_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__getppid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getppid();
      if (event__mode == EM__RECORD) {
        record__event("getppid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("getppid");
      retrieve__integer(&result);
      report__event("getppid");
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(process_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__getpwuid (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int uid;
    struct passwd *result = NULL;
    if (!user_id_to_int(TLS_arguments[0], &uid)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = getpwuid(uid);
      } while (result == NULL && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("getpwuid");
        store__memory(&result, sizeof(result));
        end__record();
      }
    } else {
      replay__event("getpwuid");
      retrieve__fixed_memory((uint8_t *)&result, sizeof(result));
      report__event("getpwuid");
      print__integer(uid);
      print__memory(&result, sizeof(result));
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETPWUID FAILED", errno, 0, NULL);
    } else {
      NODE *node__username_of = from_c_string(result->pw_name);
      NODE *node__password_of = from_c_string(result->pw_passwd);
      NODE *node__user_id_of = user_id_from_int(result->pw_uid);
      NODE *node__group_id_of = group_id_from_int(result->pw_gid);
      NODE *node__user_information_of = from_c_string(result->pw_gecos);
      NODE *node__home_directory_of = from_c_string(result->pw_dir);
      NODE *node__shell_of = from_c_string(result->pw_shell);
      NODE *node = clone_object_and_attributes((NODE *)&std_types__passwd);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_std__username_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__username_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__password_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__password_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__user_information_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_information_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__home_directory_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__home_directory_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__shell_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__shell_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__getsid (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int pid;
    int result;
    if (!process_id_to_int(TLS_arguments[0], &pid)) return;
    if (event__mode != EM__REPLAY) {
      result = getsid(pid);
      if (event__mode == EM__RECORD) {
        record__event("getsid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("getsid");
      retrieve__integer(&result);
      report__event("getsid");
      print__integer(pid);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETSID FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(process_id_from_int(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__getuid (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int result;
    if (event__mode != EM__REPLAY) {
      result = getuid();
      if (event__mode == EM__RECORD) {
        record__event("getuid");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("getuid");
      retrieve__integer(&result);
      report__event("getuid");
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(user_id_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__isatty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    int result;
    if (event__mode != EM__REPLAY) {
      result = isatty(fd);
      if (event__mode == EM__RECORD) {
        record__event("isatty");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("isatty");
      retrieve__integer(&result);
      report__event("isatty");
      print__integer(fd);
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(from_bool(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__kill (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int pid;
    int sig;
    int result;
    if (!process_id_to_int(TLS_arguments[0], &pid)) return;
    if (!signal_number_to_int(TLS_arguments[1], &sig)) return;
    if (event__mode != EM__REPLAY) {
      result = kill(pid, sig);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("kill");
        } else {
          failed__action("kill");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("kill")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("kill");
      print__integer(pid);
      print__integer(sig);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"KILL FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__link (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *old_path;
    char *new_path;
    if (!to_c_string(TLS_arguments[0], &old_path)) return;
    if (!to_c_string(TLS_arguments[1], &new_path)) {
      deallocate_memory(old_path);
      return;
    }
    if (event__mode != EM__REPLAY) {
      if (link(old_path, new_path) == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "LINK FAILED", errno, 0, NULL);
      } else {
	TLS_argument_count = 0;
      }
      if (event__mode == EM__RECORD) {
        record__event("link");
        store__c_string(old_path);
        store__c_string(new_path);
        end__record();
      }
    } else {
      replay__event("link");
      retrieve__c_string(&old_path);
      retrieve__c_string(&new_path);
      report__event("link");
      print__c_string(old_path);
      print__c_string(new_path);
      end__report();
    }
    deallocate_memory(old_path);
    deallocate_memory(new_path);
  }

static void entry__std__lseek (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    long offset;
    int whence;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (!to_long(TLS_arguments[1], &offset)) return;
    if (!seek_type_to_int(TLS_arguments[2], &whence)) return;
    off_t result;
    if (event__mode != EM__REPLAY) {
      result = lseek(fd, offset, whence);
      if (event__mode == EM__RECORD) {
        record__event("lseek");
        store__integer(fd);
        store__long_integer(offset);
        store__integer(whence);
        store__long_integer(result);
        end__record();
      }
    } else {
      replay__event("lseek");
      retrieve__integer(&fd);
      retrieve__long_integer(&offset);
      retrieve__integer(&whence);
      retrieve__long_integer(&result);
      report__event("lseek");
      print__integer(fd);
      print__long_integer(offset);
      print__integer(whence);
      print__long_integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"LSEEK FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_long(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__mkdir (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *pathname = NULL;
    int mode = 0755;
    int result;
    if (!to_c_string(TLS_arguments[0], &pathname)) goto cleanup;
    if (TLS_argument_count >= 2 && !mode_to_int(TLS_arguments[1], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = mkdir(pathname, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("mkdir");
        } else {
          failed__action("mkdir");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("mkdir")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("mkdir");
      print__c_string(pathname);
      print__integer(mode);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"MKDIR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(pathname);
  }

static void entry__std__mkfifo (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int mode = 0644;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (TLS_argument_count >= 2 && !mode_to_int(TLS_arguments[1], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = mkfifo(filename, mode);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("mkfifo");
        } else {
          failed__action("mkfifo");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("mkfifo")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("mkfifo");
      print__c_string(filename);
      print__integer(mode);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"MKFIFO FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__open (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int flags;
    int mode = 0644;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (!flags_to_int(TLS_arguments[1], &flags)) goto cleanup;
    if (TLS_argument_count >= 3 && !mode_to_int(TLS_arguments[2], &mode)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      do {
	result = open(filename, flags, mode);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("open");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("open");
      retrieve__integer(&result);
      report__event("open");
      print__c_string(filename);
      print__integer(flags);
      print__integer(mode);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"OPEN FAILED", errno, 0, TLS_arguments[0]);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__opendir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *name = NULL;
    void *result = NULL;
    if (!to_c_string(TLS_arguments[0], &name)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = opendir(name);
      if (event__mode == EM__RECORD) {
        record__event("opendir");
        store__pointer(result);
        end__record();
      }
    } else {
      replay__event("opendir");
      retrieve__pointer((const void **)&result);
      report__event("opendir");
      print__c_string(name);
      print__pointer(result);
      end__report();
    }
    if (!result) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"OPENDIR FAILED", errno, 0, TLS_arguments[0]);
    } else {
      {
        NODE *result__node = (NODE *)(directory_from_ptr(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(name);
  }

static void entry__std_types__file_descriptor__std__read (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd = TLS_arguments[0]->file_descriptor.value;
    uint8_t *buf = NULL;
    size_t size;
    ssize_t bytes_read;
    if (!to_ulong(TLS_arguments[1], (unsigned long *)&size)) goto cleanup;
    buf = allocate_memory(size);
    if (event__mode != EM__REPLAY) {
      do {
	bytes_read = read(fd, (char *)buf, size);
      } while (bytes_read == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("read");
        store__memory(buf, bytes_read);
        end__record();
      }
    } else {
      replay__event("read");
      bytes_read = retrieve__memory((uint8_t **)&buf);
      report__event("read");
      print__integer(fd);
      print__unsigned_long_integer(size);
      print__memory(buf, bytes_read);
      end__report();
    }
    if (bytes_read == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"READ FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_latin_1_string(buf, bytes_read));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(buf);
  }

static void entry__std__readdir (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    void *dir = NULL;
    struct dirent *result = NULL;
    if (!directory_to_ptr(TLS_arguments[0], &dir)) return;
    if (event__mode != EM__REPLAY) {
      result = readdir(dir);
      if (event__mode == EM__RECORD) {
        record__event("readdir");
        store__memory(&result, sizeof(result));
        end__record();
      }
    } else {
      replay__event("readdir");
      retrieve__fixed_memory((uint8_t *)&result, sizeof(result));
      report__event("readdir");
      print__pointer(dir);
      print__memory(&result, sizeof(result));
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"READDIR FAILED", errno, 0, NULL);
    } else {
      NODE *node__inode_number_of = inode_number_from_ulong(result->d_ino);
      NODE *node__type_of = file_type_from_int(result->d_type);
      NODE *node__name_of = from_c_string(result->d_name);
      NODE *node = clone_object_and_attributes((NODE *)&std_types__dirent);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_std__inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__name_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__name_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__realpath (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    char *resolved_name = NULL;
    char *result = NULL;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = realpath(filename, resolved_name);
      if (event__mode == EM__RECORD) {
        record__event("realpath");
        store__c_string(result);
        end__record();
      }
    } else {
      replay__event("realpath");
      retrieve__c_string(&result);
      report__event("realpath");
      print__c_string(filename);
      print__c_string(result);
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"REALPATH FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
    deallocate_memory(resolved_name);
    free(result);
  }

static void entry__std__rename (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *old_filename = NULL;
    char *new_filename = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &old_filename)) goto cleanup;
    if (!to_c_string(TLS_arguments[1], &new_filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = rename(old_filename, new_filename);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("rename");
        } else {
          failed__action("rename");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("rename")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("rename");
      print__c_string(old_filename);
      print__c_string(new_filename);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"RENAME FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(old_filename);
    deallocate_memory(new_filename);
  }

static void entry__std__sethostname (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    uint8_t *buf = NULL;
    size_t size;
    int result;
    if (
      !to_octets(TLS_arguments[1],
      (const uint8_t **)&buf, (long *)&size)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      do {
	result = sethostname((char *)buf, size);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("sethostname");
        } else {
          failed__action("sethostname");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("sethostname")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("sethostname");
      print__memory(buf, size);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"SETHOSTNAME FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(buf);
  }

static void entry__std__shutdown (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    int how;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (!shutdown_type_to_int(TLS_arguments[1], &how)) return;
    if (event__mode != EM__REPLAY) {
      result = shutdown(fd, how);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("shutdown");
        } else {
          failed__action("shutdown");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("shutdown")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("shutdown");
      print__integer(fd);
      print__integer(how);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"SHUTDOWN FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__stat (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    struct stat statbuf;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = stat(filename, &statbuf);
      if (event__mode == EM__RECORD) {
        record__event("stat");
        store__integer(result);
        store__memory(&statbuf, sizeof(statbuf));
        end__record();
      }
    } else {
      replay__event("stat");
      retrieve__integer(&result);
      retrieve__fixed_memory((uint8_t *)&statbuf, sizeof(statbuf));
      report__event("stat");
      print__c_string(filename);
      print__integer(result);
      print__memory(&statbuf, sizeof(statbuf));
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"STAT FAILED", errno, 0, TLS_arguments[0]);
    } else {
      NODE *node__device_of = device_id_from_ulong(statbuf.st_dev);
      NODE *node__inode_number_of = inode_number_from_ulong(statbuf.st_ino);
      NODE *node__type_of = file_type_from_int(statbuf.st_mode >> 12);
      NODE *node__mode_of = mode_from_int(statbuf.st_mode);
      NODE *node__link_count_of = from_int(statbuf.st_nlink);
      NODE *node__user_id_of = user_id_from_int(statbuf.st_uid);
      NODE *node__group_id_of = group_id_from_int(statbuf.st_gid);
      NODE *node__root_device_of = device_id_from_ulong(statbuf.st_rdev);
      NODE *node__size_of = from_long(statbuf.st_size);
      NODE *node__block_size_of = from_long(statbuf.st_blksize);
      NODE *node__block_count_of = from_long(statbuf.st_blocks);
      NODE *node_access_time_of =
	create__std_types__date_and_time(statbuf.st_atim.tv_sec, statbuf.st_atim.tv_nsec);
      NODE *node_modification_time_of =
	create__std_types__date_and_time(statbuf.st_mtim.tv_sec, statbuf.st_mtim.tv_nsec);
      NODE *node_status_change_time_of =
	create__std_types__date_and_time(statbuf.st_ctim.tv_sec, statbuf.st_ctim.tv_nsec);
      NODE *node = clone_object_and_attributes((NODE *)&std_types__stat);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_std__device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__mode_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__mode_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__link_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__link_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__root_device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__root_device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__block_size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__access_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_access_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__modification_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_modification_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_std__status_change_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_status_change_time_of));
      {
        NODE *result__node = (NODE *)(node);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__strerror (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int errnum;
    char *result = NULL;
    if (!error_number_to_int(TLS_arguments[0], &errnum)) return;
    if (event__mode != EM__REPLAY) {
      result = strerror(errnum);
      if (event__mode == EM__RECORD) {
        record__event("strerror");
        store__c_string(result);
        end__record();
      }
    } else {
      replay__event("strerror");
      retrieve__c_string(&result);
      report__event("strerror");
      print__integer(errnum);
      print__c_string(result);
      end__report();
    }
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"STRERROR FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_c_string(result));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__wait (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int status;
    int result;
    if (event__mode != EM__REPLAY) {
      do {
	result = wait(&status);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("wait");
        store__integer(result);
        store__integer(status);
        end__record();
      }
    } else {
      replay__event("wait");
      retrieve__integer(&result);
      retrieve__integer(&status);
      report__event("wait");
      print__integer(result);
      print__integer(status);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"WAIT FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 2;
      TLS_arguments[0] = process_id_from_int(result);
      TLS_arguments[1] = from_int(status);
    }
  }

static void entry__std_types__file_descriptor__std__write (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd = TLS_arguments[0]->file_descriptor.value;
    uint8_t *buf = NULL;
    ssize_t size;
    ssize_t bytes_written;
    if (
      !to_octets(TLS_arguments[1], (const uint8_t **)&buf, &size)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      do {
	bytes_written = write(fd, (char *)buf, size);
      } while (bytes_written == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        if (bytes_written == size) {
          successful__action("write");
        } else {
          failed__action("write");
          store__long_integer(bytes_written);
          end__report();
        }
      }
    } else {
      if (replay__action("write")) {
        retrieve__long_integer(&bytes_written);
      } else {
        bytes_written = size;
      }
      report__event("write");
      print__integer(fd);
      print__memory(buf, size);
      end__report();
    }
    if (bytes_written == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"WRITE FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_long(bytes_written));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(buf);
  }

static void entry__std__umask (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int mask;
    int result;
    if (!mode_to_int(TLS_arguments[0], &mask)) return;
    if (event__mode != EM__REPLAY) {
      result = umask(mask);
      if (event__mode == EM__RECORD) {
        record__event("umask");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("umask");
      retrieve__integer(&result);
      report__event("umask");
      print__integer(mask);
      print__integer(result);
      end__report();
    }
    {
      NODE *result__node = (NODE *)(mode_from_int(result));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__unlink (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int result;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      result = unlink(filename);
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("unlink");
        } else {
          failed__action("unlink");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("unlink")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("unlink");
      print__c_string(filename);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"UNLINK FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__shm_unlink (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    #ifdef __ANDROID__
      {
        create_error_message(
          module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
          "shm_unlink is not supported on Android!", 0, 0, NULL);
        return;
      }
    #else
      char *filename = NULL;
      int result;
      if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
      if (event__mode != EM__REPLAY) {
	result = shm_unlink(filename);
        if (event__mode == EM__RECORD) {
	  if (result == 0) {
	    successful__action("shm_unlink");
	  } else {
	    failed__action("shm_unlink");
	    store__integer(result);
	    end__record();
	  }
        }
      } else {
        if (replay__action("shm_unlink")) {
          retrieve__integer(&result);
        } else {
          result = 0;
        }
        report__event("shm_unlink");
        print__c_string(filename);
        print__integer(result);
        end__report();
      }
      if (result == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "SHM_UNLINK FAILED", errno, 0, NULL);
      } else {
	TLS_argument_count = 0;
      }
      cleanup:
      deallocate_memory(filename);
    #endif
  }

static void entry__std__usleep (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    unsigned int microseconds;
    int result;
    if (!to_uint(TLS_arguments[0], &microseconds)) return;
    if (event__mode != EM__REPLAY) {
      result = usleep(microseconds);
      if (event__mode == EM__RECORD) {
        record__event("usleep");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("usleep");
      retrieve__integer(&result);
      report__event("usleep");
      print__unsigned_integer(microseconds);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"SLEEP FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std_types__octet_string__std__length_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->octet_string.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__length_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->wide_string.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__is_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->octet_string.length == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__is_not_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->octet_string.length > 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__is_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->wide_string.length == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__is_not_empty (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->wide_string.length > 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__push (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[1], &chr_code)) return;;
    NODE *self = TLS_arguments[0];
    long left_start_offset = self->octet_string.offset;
    long length = self->octet_string.length;
    long end_offset = left_start_offset+length;
    long new_length = length+1;
    OCTET_DATA *data = self->octet_string.data;
    if (chr_code <= 0xff) {
      if (!data || data->size < end_offset+1 || data->length != end_offset) {
	long new_size = ALLOCATION_SIZE(2*new_length);
	OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+new_size);
	if (data) {
	  memcpy(
	    new_data->buffer,
	    data->buffer+left_start_offset,
	    length);
	}
	left_start_offset = 0;
	end_offset = length;
	new_data->size = new_size;
	data = new_data;
      }
      data->buffer[end_offset] = (uint8_t)chr_code;
      data->length = end_offset+1;
      {
        NODE *result__node = (NODE *)(create__std_types__octet_string(left_start_offset, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      WIDE_DATA *new_data = allocate_large(sizeof(WIDE_DATA)+new_size);
      new_data->size = new_size;
      new_data->length = new_length;
      if (data) {
	long idx;
	for (idx = 0; idx < length; ++idx) {
	  new_data->buffer[idx] = data->buffer[left_start_offset+idx];
	}
      }
      new_data->buffer[length] = chr_code;
      {
        NODE *result__node = (NODE *)(create__std_types__wide_string(0, new_length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__wide_string__std__push (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[1], &chr_code)) return;;
    NODE *self = TLS_arguments[0];
    long start_offset = self->wide_string.offset;
    long length = self->wide_string.length;
    long end_offset = start_offset+length;
    long new_length = length+1;
    WIDE_DATA *data = self->wide_string.data;
    if (!data || data->size < 4*(end_offset+1) || data->length != end_offset) {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      WIDE_DATA *new_data = allocate_large(sizeof(WIDE_DATA)+new_size);
      if (data) {
	memcpy(
	  new_data->buffer,
	  data->buffer+start_offset,
	  4*length);
      }
      start_offset = 0;
      end_offset = length;
      new_data->size = new_size;
      data = new_data;
    }
    data->buffer[end_offset] = chr_code;
    data->length = end_offset+1;
    {
      NODE *result__node = (NODE *)(create__std_types__wide_string(start_offset, new_length, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__append (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    long left_length = left->octet_string.length;
    long new_length = left_length;
    int is_a_std_types__wide_string = false;
    int i;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      if ((right)->type == std_types__wide_string.type) {
	is_a_std_types__wide_string = true;
      } else if ((right)->type != std_types__octet_string.type) {
	{
	  invalid_arguments();
	  return;
	}
      }
      new_length += right->octet_string.length;
    }
    if (new_length == left_length) {
      NODE *result__node = (NODE *)(left);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_length == 0 && TLS_argument_count == 2) {
      {
        NODE *result__node = (NODE *)(TLS_arguments[1]);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    long left_offset = left->octet_string.offset;
    OCTET_DATA *data = left->octet_string.data;
    if (is_a_std_types__wide_string) {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      WIDE_DATA *new_data =
	allocate_large(sizeof(WIDE_DATA)+new_size);
      new_data->size = new_size;
      new_data->length = new_length;
      long idx;
      for (idx = 0; idx < left_length; ++idx) {
	new_data->buffer[idx] = data->buffer[left_offset+idx];
      }
      long offset = left_length;
      for (i = 1; i < TLS_argument_count; ++i) {
	NODE *right = TLS_arguments[i];
	long right_offset = right->octet_string.offset;
	long right_length = right->octet_string.length;
	if ((right)->type == std_types__wide_string.type) {
	  memcpy(
	    new_data->buffer+offset,
	    right->wide_string.data->buffer+right_offset,
	    4*right_length);
	} else {
	  for (idx = 0; idx < right_length; ++idx) {
	    new_data->buffer[offset+idx] =
	      right->octet_string.data->buffer[right_offset+idx];
	  }
	}
	offset += right_length;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__wide_string(0, new_length, new_data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      if (
	!data || data->size < left_offset+new_length ||
	data->length != left_offset+left_length
      ) {
	long new_size = ALLOCATION_SIZE(2*new_length);
	OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+new_size);
	if (data) {
	  memcpy(new_data->buffer, data->buffer+left_offset, left_length);
	}
	left_offset = 0;
	new_data->size = new_size;
	data = new_data;
      }
      long offset = left_offset+left_length;
      for (i = 1; i < TLS_argument_count; ++i) {
	NODE *right = TLS_arguments[i];
	long right_length = right->octet_string.length;
	memcpy(
	  data->buffer+offset,
	  right->octet_string.data->buffer+right->octet_string.offset,
	  right_length);
	offset += right_length;
      }
      data->length = left_offset+new_length;
      {
        NODE *result__node = (NODE *)(create__std_types__octet_string(left_offset, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__wide_string__std__append (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    long left_length = left->wide_string.length;
    long new_length = left_length;
    int i;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      if (
	(right)->type == std_types__octet_string.type ||
	(right)->type == std_types__wide_string.type
      ) {
	new_length += right->octet_string.length;
      } else {
	{
	  invalid_arguments();
	  return;
	}
      }
    }
    if (new_length == left_length) {
      NODE *result__node = (NODE *)(left);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_length == 0 && TLS_argument_count == 2) {
      {
        NODE *result__node = (NODE *)(TLS_arguments[1]);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    long left_offset = left->wide_string.offset;
    WIDE_DATA *data = left->wide_string.data;
    if (
      data->size < 4*(left_offset+new_length) ||
      data->length != left_offset+left_length
    ) {
      long new_size = ALLOCATION_SIZE(4*2*new_length);
      WIDE_DATA *new_data =
	allocate_large(sizeof(WIDE_DATA)+new_size);
      memcpy(new_data->buffer, data->buffer+left_offset, 4*left_length);
      left_offset = 0;
      new_data->size = new_size;
      data = new_data;
    }
    long offset = left_offset+left_length;
    for (i = 1; i < TLS_argument_count; ++i) {
      NODE *right = TLS_arguments[i];
      long right_offset = right->octet_string.offset;
      long right_length = right->octet_string.length;
      if ((right)->type == std_types__wide_string.type) {
	memcpy(
	  data->buffer+offset,
	  right->wide_string.data->buffer+right_offset,
	  4*right_length);
      } else {
	long idx;
	for (idx = 0; idx < right_length; ++idx) {
	  data->buffer[offset+idx] =
	    right->octet_string.data->buffer[right_offset+idx];
	}
      }
      offset += right_length;
    }
    data->length = left_offset+new_length;
    {
      NODE *result__node = (NODE *)(create__std_types__wide_string(left_offset, new_length, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__range (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    long first_idx, last_idx;
    if (!to_long(TLS_arguments[1], &first_idx)) return;
    if (!to_long(TLS_arguments[2], &last_idx)) return;
    long length = self->octet_string.length;
    if (first_idx < 0) first_idx = length+first_idx+1;
    if (last_idx < 0) last_idx = length+last_idx+1;
    if (first_idx < 1 || first_idx > length+1) {
      invalid_index(self);
      return;
    };
    if (last_idx < 0 || last_idx > length) {
      invalid_index(self);
      return;
    };
    if (first_idx > last_idx+1) {
      invalid_arguments();
      return;
    }
    if (first_idx == 1 && last_idx == length) {
      NODE *result__node = (NODE *)(self);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long new_len = last_idx-first_idx+1;
    if (new_len == 0) {
      NODE *result__node = (NODE *)((NODE *)&std__empty_string);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    {
      NODE *result__node = (NODE *)(create__std_types__octet_string(self->octet_string.offset+first_idx-1, new_len, self->octet_string.data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__range (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    long first_idx, last_idx;
    if (!to_long(TLS_arguments[1], &first_idx)) return;;
    if (!to_long(TLS_arguments[2], &last_idx)) return;;
    long length = self->octet_string.length;
    if (first_idx < 0) first_idx = length+first_idx+1;
    if (last_idx < 0) last_idx = length+last_idx+1;
    if (first_idx < 1 || first_idx > length+1) {
      invalid_index(self);
      return;
    };
    if (last_idx < 0 || last_idx > length) {
      invalid_index(self);
      return;
    };
    if (first_idx > last_idx+1) {
      invalid_arguments();
      return;
    }
    if (first_idx == 1 && last_idx == length) {
      NODE *result__node = (NODE *)(self);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long new_len = last_idx-first_idx+1;
    if (new_len == 0) {
      NODE *result__node = (NODE *)((NODE *)&std__empty_string);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long idx;
    long offset = self->wide_string.offset;
    WIDE_DATA *data = self->wide_string.data;
    for (idx = first_idx-1; idx < last_idx; ++idx) {
      if (data->buffer[offset+idx] > 0xff) {
	{
	  NODE *result__node = (NODE *)(create__std_types__wide_string(offset+first_idx-1, new_len, data));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    }
    long new_size = ALLOCATION_SIZE(new_len);
    OCTET_DATA *new_data = allocate_large(sizeof(OCTET_DATA)+new_size);
    new_data->size = new_size;
    new_data->length = new_len;
    offset += first_idx-1;
    for (idx = 0; idx < new_len; ++idx) {
      new_data->buffer[idx] = data->buffer[idx+offset];
    }
    {
      NODE *result__node = (NODE *)(create__std_types__octet_string(0, new_len, new_data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    uint8_t *buf = self->octet_string.data->buffer+self->octet_string.offset;
    long length = self->octet_string.length;
    uint32_t hash = 0x7890abcd;
    long i;
    if (length > 16) {
      for (i = length-8; i < length; ++i) {
	hash = (hash << 7) | (hash >> 25);
	hash ^= buf[i];
      }
      length = 8;
    }
    for (i = 0; i < length; ++i) {
      hash = (hash << 7) | (hash >> 25);
      hash ^= buf[i];
    }
    hash *= 234256597;
    hash ^= hash >> 26 | hash << 6;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *self = TLS_arguments[0];
    uint32_t *buf =
      self->wide_string.data->buffer+self->wide_string.offset;
    long length = self->wide_string.length;
    uint32_t hash = 0x3456789a;
    long i;
    if (length > 16) {
      for (i = length-8; i < length; ++i) {
	hash = (hash << 13) | (hash >> 19);
	hash ^= buf[i];
      }
      length = 8;
    }
    for (i = 0; i < length; ++i) {
      hash = (hash << 13) | (hash >> 19);
      hash ^= buf[i];
    }
    hash *= 234256597;
    hash ^= hash >> 22 | hash << 10;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type != std_types__octet_string.type) {
      if ((TLS_arguments[1])->type == std_types__error.type) {
	{
	  invalid_arguments();
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    }
    OCTET_DATA *left_data = left->octet_string.data;
    OCTET_DATA *right_data = right->octet_string.data;
    long left_offset = left->octet_string.offset;
    long right_offset = right->octet_string.offset;
    long length = left->octet_string.length;
    if (length != right->octet_string.length) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_offset == right_offset && left_data == right_data) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long i;
    for (i = 0; i < length; ++i) {
      if (left_data->buffer[left_offset+i] != right_data->buffer[right_offset+i]) {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    if (left_offset == right_offset) {
      // join the two versions of the string data to simplify future comparisons
      join_nodes(&left->octet_string.data, &right->octet_string.data);
    }
    {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type != std_types__wide_string.type) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    WIDE_DATA *left_data = left->wide_string.data;
    WIDE_DATA *right_data = right->wide_string.data;
    long left_offset = left->wide_string.offset;
    long right_offset = right->wide_string.offset;
    long length = left->wide_string.length;
    if (length != right->wide_string.length) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if (left_offset == right_offset && left_data == right_data) {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    long i;
    for (i = 0; i < length; ++i) {
      if (left_data->buffer[left_offset+i] != right_data->buffer[right_offset+i]) {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
    if (left_offset == right_offset) {
      // join the two versions of the string data to simplify future comparisons
      join_nodes(&left->wide_string.data, &right->wide_string.data);
    }
    {
      NODE *result__node = (NODE *)(&std_types__true);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type == std_types__octet_string.type) {
      OCTET_DATA *left_data = left->octet_string.data;
      OCTET_DATA *right_data = right->octet_string.data;
      long left_offset = left->octet_string.offset;
      long right_offset = right->octet_string.offset;
      long left_length = left->octet_string.length;
      long right_length = right->octet_string.length;
      if (left_offset == right_offset && left_length == right_length && left_data == right_data)
	{
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint8_t left_chr = left_data->buffer[left_offset+i];
	uint8_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types__true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      if (left_offset == right_offset && left_length == right_length) { // both strings are equal!
	// join the two versions of the string data to simplify future comparisons
	join_nodes(&left->octet_string.data, &right->octet_string.data);
      }
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((right)->type == std_types__wide_string.type) {
      OCTET_DATA *left_data = left->octet_string.data;
      WIDE_DATA *right_data = right->wide_string.data;
      long left_offset = left->octet_string.offset;
      long right_offset = right->wide_string.offset;
      long left_length = left->octet_string.length;
      long right_length = right->wide_string.length;
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint32_t left_chr = left_data->buffer[left_offset+i];
	uint32_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types__true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        invalid_arguments();
        return;
      }
    }
  }

static void entry__std_types__wide_string__std__less (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    NODE *left = TLS_arguments[0];
    NODE *right = TLS_arguments[1];
    if (left == right) {
      NODE *result__node = (NODE *)(&std_types__false);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
    if ((right)->type == std_types__octet_string.type) {
      WIDE_DATA *left_data = left->wide_string.data;
      OCTET_DATA *right_data = right->octet_string.data;
      long left_offset = left->wide_string.offset;
      long right_offset = right->octet_string.offset;
      long left_length = left->wide_string.length;
      long right_length = right->octet_string.length;
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint32_t left_chr = left_data->buffer[left_offset+i];
	uint32_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types__true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((right)->type == std_types__wide_string.type) {
      WIDE_DATA *left_data = left->wide_string.data;
      WIDE_DATA *right_data = right->wide_string.data;
      long left_offset = left->wide_string.offset;
      long right_offset = right->wide_string.offset;
      long left_length = left->wide_string.length;
      long right_length = right->wide_string.length;
      if (left_offset == right_offset && left_length == right_length && left_data == right_data)
	{
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      long length = left_length;
      if (right_length < length) length = right_length;
      long i;
      for (i = 0; i < length; ++i) {
	uint32_t left_chr = left_data->buffer[left_offset+i];
	uint32_t right_chr = right_data->buffer[right_offset+i];
	if (left_chr < right_chr) {
	  NODE *result__node = (NODE *)(&std_types__true);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
	if (left_chr > right_chr) {
	  NODE *result__node = (NODE *)(&std_types__false);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      if (left_length < right_length) {
        NODE *result__node = (NODE *)(&std_types__true);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
      if (left_offset == right_offset && left_length == right_length) { // both strings are equal!
	// join the two versions of the string data to simplify future comparisons
	join_nodes(&left->octet_string.data, &right->octet_string.data);
      }
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        invalid_arguments();
        return;
      }
    }
  }

static void entry__std_types__octet_string__std__width_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->octet_string.length));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__width_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    long width = 0;
    NODE *string = TLS_arguments[0];
    WIDE_DATA *data = string->wide_string.data;
    long offset = string->wide_string.offset;
    long length = string->wide_string.length;
    for (long i = 0; i < length; ++i) {
      uint32_t chr = data->buffer[offset+i];
      if (is_a_wide_character(chr)) {
	width += 2;
      } else {
	++width;
      }
    }
    {
      NODE *result__node = (NODE *)(from_long(width));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__octet_string__std__from_utf8 (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long offset = self->octet_string.offset;
    long length = self->octet_string.length;
    uint8_t *buf = self->octet_string.data->buffer+offset;
    int is_latin_1 = true;
    uint8_t chr;
    long src_idx, dest_idx;
    // check vor valid utf-8 encoding
    // the allowed maximum size is 32 bits instead of 21 bits!
    long new_length = 0;
    src_idx = 0;
    while (src_idx < length) {
      int n; // number of continuation octets
      chr = buf[src_idx++];
      if (chr >= 0x80) {
	if ((chr & 0xe0) == 0xc0) { // 2 byte code
	  if (chr & 0x3c) is_latin_1 = false; // more than 8 bits
	  n = 1;
	} else if ((chr & 0xf0) == 0xe0) { // 3 byte code
	  is_latin_1 = false;
	  n = 2;
	} else if ((chr & 0xf8) == 0xf0) { // 4 byte code
	  is_latin_1 = false;
	  n = 3;
	} else if ((chr & 0xfc) == 0xf8) { // 5 byte code
	  is_latin_1 = false;
	  n = 4;
	} else if ((chr & 0xfe) == 0xfc) { // 6 byte code
	  is_latin_1 = false;
	  n = 5;
	} else if (chr == 0xfe) { // 7 byte code
	  if (buf[src_idx] & 0x3e) {
	    invalid_arguments();
	    return;
	  } // more than 32 bits
	  is_latin_1 = false;
	  n = 6;
	} else {
	  invalid_arguments();
	  return;
	}
	if (src_idx+n > length) {
	  invalid_arguments();
	  return;
	}
	while (--n >= 0) {
	  chr = buf[src_idx++];
	  if ((chr & 0xc0) != 0x80) {
	    invalid_arguments();
	    return;
	  }
	}
      }
      ++new_length;
    }
    if (is_latin_1) {
      long new_size = ALLOCATION_SIZE(new_length);
      OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+new_size);
      data->size = new_size;
      data->length = new_length;
      src_idx = 0;
      for (dest_idx = 0; dest_idx < new_length; ++dest_idx) {
	uint8_t chr;
	chr = buf[src_idx++];
	if (chr >= 0x80) {
	  chr = ((chr & 0x1f) << 6) | (buf[src_idx++] & 0x3f);
	}
	data->buffer[dest_idx] = chr;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__octet_string(0, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      long new_size = ALLOCATION_SIZE(4*new_length);
      WIDE_DATA *data = allocate_large(sizeof(WIDE_DATA)+new_size);
      data->size = new_size;
      data->length = new_length;
      src_idx = 0;
      for (dest_idx = 0; dest_idx < new_length; ++dest_idx) {
	uint32_t chr;
	chr = buf[src_idx++];
	if (chr >= 0x80) {
	  int n; // number of continuation octets
	  if ((chr & 0xe0) == 0xc0) { // 2 byte code
	    chr &= 0x1f;
	    n = 1;
	  } else if ((chr & 0xf0) == 0xe0) { // 3 byte code
	    chr &= 0x0f;
	    n = 2;
	  } else if ((chr & 0xf8) == 0xf0) { // 4 byte code
	    chr &= 0x07;
	    n = 3;
	  } else if ((chr & 0xfc) == 0xf8) { // 5 byte code
	    chr &= 0x03;
	    n = 4;
	  } else if ((chr & 0xfe) == 0xfc) { // 6 byte code
	    chr &= 0x01;
	    n = 5;
	  } else { // 7 byte code
	    chr = 0;
	    n = 6;
	  }
	  while (--n >= 0) {
	    chr = (chr << 6) | (buf[src_idx++] & 0x3f);
	  }
	}
	data->buffer[dest_idx] = chr;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__wide_string(0, new_length, data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__octet_string__std__to_utf8 (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long offset = self->octet_string.offset;
    long length = self->octet_string.length;
    long new_len = length;
    uint8_t *src = self->octet_string.data->buffer+offset;
    long i;
    for(i = 0; i < length; ++i) {
      uint8_t chr = src[i];
      if (chr >= 0x80) {
	++new_len;
      }
    }
    long size = ALLOCATION_SIZE(new_len);
    OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+size);
    data->size = size;
    data->length = new_len;
    uint8_t *dst = data->buffer;
    for(i = 0; i < length; ++i) {
      uint8_t chr = src[i];
      if (chr >= 0x80) {
	*dst++ = chr >> 6 | 0xc0;
	*dst++ = chr & 0x3f | 0x80;
      } else {
	*dst++ = chr;
      }
    }
    {
      NODE *result__node = (NODE *)(create__std_types__octet_string(0, new_len, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__wide_string__std__to_utf8 (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    long offset = self->wide_string.offset;
    long length = self->wide_string.length;
    long new_len = length;
    uint32_t *src = self->wide_string.data->buffer+offset;
    long i;
    for(i = 0; i < length; ++i) {
      uint32_t chr = src[i];
      if (chr >= 0x80) {
	if (chr >= 0x800) {
	  if (chr >= 0x10000) {
	    if (chr >= 0x200000) {
	      if (chr >= 0x4000000) {
		if (chr >= 0x80000000) {
		  new_len += 6;
		} else {
		  new_len += 5;
		}
	      } else {
		new_len += 4;
	      }
	    } else {
	      new_len += 3;
	    }
	  } else {
	    new_len += 2;
	  }
	} else {
	  ++new_len;
	}
      }
    }
    long size = ALLOCATION_SIZE(new_len);
    OCTET_DATA *data = allocate_large(sizeof(OCTET_DATA)+size);
    data->size = size;
    data->length = new_len;
    uint8_t *dst = data->buffer;
    for(i = 0; i < length; ++i) {
      uint32_t chr = src[i];
      if (chr >= 0x80) {
	if (chr >= 0x800) {
	  if (chr >= 0x10000) {
	    if (chr >= 0x200000) {
	      if (chr >= 0x4000000) {
		if (chr >= 0x80000000) {
		  *dst++ = 0xfe;
		  *dst++ = (chr >> 30) & 0x3f | 0x80;
		  *dst++ = (chr >> 24) & 0x3f | 0x80;
		  *dst++ = (chr >> 18) & 0x3f | 0x80;
		  *dst++ = (chr >> 12) & 0x3f | 0x80;
		  *dst++ = (chr >> 6) & 0x3f | 0x80;
		  *dst++ = chr & 0x3f | 0x80;
		} else {
		  *dst++ = chr >> 30 | 0xfc0;
		  *dst++ = (chr >> 24) & 0x3f | 0x80;
		  *dst++ = (chr >> 18) & 0x3f | 0x80;
		  *dst++ = (chr >> 12) & 0x3f | 0x80;
		  *dst++ = (chr >> 6) & 0x3f | 0x80;
		  *dst++ = chr & 0x3f | 0x80;
		}
	      } else {
		*dst++ = chr >> 24 | 0xf8;
		*dst++ = (chr >> 18) & 0x3f | 0x80;
		*dst++ = (chr >> 12) & 0x3f | 0x80;
		*dst++ = (chr >> 6) & 0x3f | 0x80;
		*dst++ = chr & 0x3f | 0x80;
	      }
	    } else {
	      *dst++ = chr >> 18 | 0xf0;
	      *dst++ = (chr >> 12) & 0x3f | 0x80;
	      *dst++ = (chr >> 6) & 0x3f | 0x80;
	      *dst++ = chr & 0x3f | 0x80;
	    }
	  } else {
	    *dst++ = chr >> 12 | 0xe0;
	    *dst++ = (chr >> 6) & 0x3f | 0x80;
	    *dst++ = chr & 0x3f | 0x80;
	  }
	} else {
	  *dst++ = chr >> 6 | 0xc0;
	  *dst++ = chr & 0x3f | 0x80;
	}
      } else {
	*dst++ = chr;
      }
    }
    {
      NODE *result__node = (NODE *)(create__std_types__octet_string(0, new_len, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__file_descriptor__std__get_terminal_attributes (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    int fd = TLS_arguments[0]->file_descriptor.value;
    TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
    int success;
    if (event__mode != EM__REPLAY) {
      success = tcgetattr(fd, &data->termios);
      if (event__mode == EM__RECORD) {
        record__event("get_terminal_attributes");
        store__integer(success);
        store__memory(&data->termios, sizeof(data->termios));
        end__record();
      }
    } else {
      replay__event("get_terminal_attributes");
      retrieve__integer(&success);
      retrieve__fixed_memory((uint8_t *)&data->termios, sizeof(data->termios));
    }
    if (success == 0) {
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__undefined);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__file_descriptor__std__set_terminal_attributes (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    int fd = TLS_arguments[0]->file_descriptor.value;
    NODE *attributes = TLS_arguments[1];
    if ((attributes)->type != ((NODE *)&std_types__terminal_attributes)->type)
      {
        invalid_arguments();
        return;
      }
    int success;
    if (event__mode != EM__REPLAY) {
      success =
	tcsetattr(fd, TCSANOW, &attributes->terminal_attributes.data->termios);
      if (event__mode == EM__RECORD) {
        if (success == 0) {
          successful__action("set_terminal_attributes");
        } else {
          failed__action("set_terminal_attributes");
          store__integer(success);
          end__record();
        }
      }
    } else {
      if (replay__action("set_terminal_attributes")) {
        retrieve__integer(&success);
      } else {
        success = 0;
      }
    }
    {
      NODE *result__node = (NODE *)(from_bool(success == 0));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__terminal_attributes__std__backspace_character_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    {
      NODE *result__node = (NODE *)(from_uchar32(termios->c_cc[VERASE]));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__terminal_attributes__std__use_canonical_mode (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ICANON));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ICANON;
      } else {
	data->termios.c_lflag &= ~ICANON;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__echo_characters (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ECHO));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ECHO;
      } else {
	data->termios.c_lflag &= ~ECHO;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__echo_new_lines (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ECHONL));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ECHONL;
      } else {
	data->termios.c_lflag &= ~ECHONL;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__enable_xon_xoff_for_input (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IXOFF));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IXOFF;
      } else {
	data->termios.c_iflag &= ~IXOFF;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__enable_xon_xoff_for_output (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IXON));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IXON;
      } else {
	data->termios.c_iflag &= ~IXON;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__restart_output_on_any_character (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IXANY));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IXANY;
      } else {
	data->termios.c_iflag &= ~IXANY;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__ignore_cr_on_input (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & IGNCR));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= IGNCR;
      } else {
	data->termios.c_iflag &= ~IGNCR;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__generate_signals (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_lflag & ISIG));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_lflag |= ISIG;
      } else {
	data->termios.c_lflag &= ~ISIG;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__map_cr_to_lf_on_input (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_iflag & ICRNL));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_iflag |= ICRNL;
      } else {
	data->termios.c_iflag &= ~ICRNL;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__hangup_on_close (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_oflag & HUPCL));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_oflag |= HUPCL;
      } else {
	data->termios.c_oflag &= ~HUPCL;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__map_lf_to_crlf_on_output (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_bool(termios->c_oflag & ONLCR));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int do_set;
      if (!to_bool(TLS_arguments[1], &do_set)) return;;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      if (do_set) {
	data->termios.c_oflag |= ONLCR;
      } else {
	data->termios.c_oflag &= ~ONLCR;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__minimum_characters_for_canoncial_read (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_int(termios->c_cc[VMIN]));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      int value;
      if (!to_int(TLS_arguments[1], &value)) return;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      data->termios.c_cc[VMIN] = value;
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__timeout_for_reads (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      {
        NODE *result__node = (NODE *)(from_double((double)termios->c_cc[VTIME]/10));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else {
      double value;
      if (!to_double(TLS_arguments[1], &value)) return;
      value *= 10;
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      data->termios.c_cc[VTIME] = value;
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__input_speed (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      int speed = cfgetispeed(termios);
      switch (speed) {
	case B0:
	  speed = 0;
	  break;
	case B50:
	  speed = 50;
	  break;
	case B75:
	  speed = 75;
	  break;
	case B110:
	  speed = 110;
	  break;
	case B134:
	  speed = 134;
	  break;
	case B150:
	  speed = 150;
	  break;
	case B200:
	  speed = 200;
	  break;
	case B300:
	  speed = 300;
	  break;
	case B600:
	  speed = 600;
	  break;
	case B1200:
	  speed = 1200;
	  break;
	case B1800:
	  speed = 1800;
	  break;
	case B2400:
	  speed = 2400;
	  break;
	case B4800:
	  speed = 4800;
	  break;
	case B9600:
	  speed = 9600;
	  break;
	case B19200:
	  speed = 19200;
	  break;
	case B38400:
	  speed = 38400;
	  break;
	case B57600:
	  speed = 57600;
	  break;
	case B115200:
	  speed = 115200;
	  break;
	case B230400:
	  speed = 230400;
	  break;
	default:
	  speed = -1;
      }
      if (speed < 0) {
	{
	  NODE *result__node = (NODE *)(&std_types__undefined);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(from_int(speed));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else {
      int speed;
      if (!to_int(TLS_arguments[1], &speed)) return;;
      switch (speed) {
	case 0:
	  speed = B0;
	  break;
	case 50:
	  speed = B50;
	  break;
	case 75:
	  speed = B75;
	  break;
	case 110:
	  speed = B110;
	  break;
	case 134:
	  speed = B134;
	  break;
	case 150:
	  speed = B150;
	  break;
	case 200:
	  speed = B200;
	  break;
	case 300:
	  speed = B300;
	  break;
	case 600:
	  speed = B600;
	  break;
	case 1200:
	  speed = B1200;
	  break;
	case 1800:
	  speed = B1800;
	  break;
	case 2400:
	  speed = B2400;
	  break;
	case 4800:
	  speed = B4800;
	  break;
	case 9600:
	  speed = B9600;
	  break;
	case 19200:
	  speed = B19200;
	  break;
	case 38400:
	  speed = B38400;
	  break;
	case 57600:
	  speed = B57600;
	  break;
	case 115200:
	  speed = B115200;
	  break;
	case 230400:
	  speed = B230400;
	  break;
	default:
	  {
	    invalid_arguments();
	    return;
	  }
      }
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      cfsetispeed(&data->termios, speed);
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__terminal_attributes__std__output_speed (void)
  {
    if (TLS_argument_count < 1) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 2) {
      too_many_arguments();
      return;
    }
    struct termios *termios = &TLS_arguments[0]->terminal_attributes.data->termios;
    if (TLS_argument_count == 1) {
      int speed = cfgetospeed(termios);
      switch (speed) {
	case B0:
	  speed = 0;
	  break;
	case B50:
	  speed = 50;
	  break;
	case B75:
	  speed = 75;
	  break;
	case B110:
	  speed = 110;
	  break;
	case B134:
	  speed = 134;
	  break;
	case B150:
	  speed = 150;
	  break;
	case B200:
	  speed = 200;
	  break;
	case B300:
	  speed = 300;
	  break;
	case B600:
	  speed = 600;
	  break;
	case B1200:
	  speed = 1200;
	  break;
	case B1800:
	  speed = 1800;
	  break;
	case B2400:
	  speed = 2400;
	  break;
	case B4800:
	  speed = 4800;
	  break;
	case B9600:
	  speed = 9600;
	  break;
	case B19200:
	  speed = 19200;
	  break;
	case B38400:
	  speed = 38400;
	  break;
	case B57600:
	  speed = 57600;
	  break;
	case B115200:
	  speed = 115200;
	  break;
	case B230400:
	  speed = 230400;
	  break;
	default:
	  speed = -1;
      }
      if (speed < 0) {
	{
	  NODE *result__node = (NODE *)(&std_types__undefined);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      } else {
	{
	  NODE *result__node = (NODE *)(from_int(speed));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
    } else {
      int speed;
      if (!to_int(TLS_arguments[1], &speed)) return;;
      switch (speed) {
	case 0:
	  speed = B0;
	  break;
	case 50:
	  speed = B50;
	  break;
	case 75:
	  speed = B75;
	  break;
	case 110:
	  speed = B110;
	  break;
	case 134:
	  speed = B134;
	  break;
	case 150:
	  speed = B150;
	  break;
	case 200:
	  speed = B200;
	  break;
	case 300:
	  speed = B300;
	  break;
	case 600:
	  speed = B600;
	  break;
	case 1200:
	  speed = B1200;
	  break;
	case 1800:
	  speed = B1800;
	  break;
	case 2400:
	  speed = B2400;
	  break;
	case 4800:
	  speed = B4800;
	  break;
	case 9600:
	  speed = B9600;
	  break;
	case 19200:
	  speed = B19200;
	  break;
	case 38400:
	  speed = B38400;
	  break;
	case 57600:
	  speed = B57600;
	  break;
	case 115200:
	  speed = B115200;
	  break;
	case 230400:
	  speed = B230400;
	  break;
	default:
	  {
	    invalid_arguments();
	    return;
	  }
      }
      TERMIO_DATA *data = allocate(sizeof(TERMIO_DATA));
      data->termios = *termios;
      cfsetospeed(&data->termios, speed);
      {
        NODE *result__node = (NODE *)(create__std_types__terminal_attributes(data));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__tuple__std__typed_tuple (void)
  {
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "Attempt to clone the tuple prototype object!", 0, 0, NULL);
      return;
    }
  }

static void entry__builtin_types__tuple2__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+2*sizeof(NODE *));
    data->size = 2;
    data->length = 2;
    data->items[0] = self->tuple2.node_0;
    data->items[1] = self->tuple2.node_1;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 2, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple2__std__typed_tuple (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple2(TLS_arguments[1], TLS_arguments[2]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple3__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+3*sizeof(NODE *));
    data->size = 3;
    data->length = 3;
    data->items[0] = self->tuple3.node_0;
    data->items[1] = self->tuple3.node_1;
    data->items[2] = self->tuple3.node_2;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 3, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple3__std__typed_tuple (void)
  {
    if (TLS_argument_count != 4) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple3(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple4__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+4*sizeof(NODE *));
    data->size = 4;
    data->length = 4;
    data->items[0] = self->tuple4.node_0;
    data->items[1] = self->tuple4.node_1;
    data->items[2] = self->tuple4.node_2;
    data->items[3] = self->tuple4.node_3;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 4, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple4__std__typed_tuple (void)
  {
    if (TLS_argument_count != 5) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple4(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple5__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+5*sizeof(NODE *));
    data->size = 5;
    data->length = 5;
    data->items[0] = self->tuple5.node_0;
    data->items[1] = self->tuple5.node_1;
    data->items[2] = self->tuple5.node_2;
    data->items[3] = self->tuple5.node_3;
    data->items[4] = self->tuple5.node_4;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 5, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple5__std__typed_tuple (void)
  {
    if (TLS_argument_count != 6) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple5(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple6__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+6*sizeof(NODE *));
    data->size = 6;
    data->length = 6;
    data->items[0] = self->tuple6.node_0;
    data->items[1] = self->tuple6.node_1;
    data->items[2] = self->tuple6.node_2;
    data->items[3] = self->tuple6.node_3;
    data->items[4] = self->tuple6.node_4;
    data->items[5] = self->tuple6.node_5;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 6, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple6__std__typed_tuple (void)
  {
    if (TLS_argument_count != 7) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple6(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple7__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+7*sizeof(NODE *));
    data->size = 7;
    data->length = 7;
    data->items[0] = self->tuple7.node_0;
    data->items[1] = self->tuple7.node_1;
    data->items[2] = self->tuple7.node_2;
    data->items[3] = self->tuple7.node_3;
    data->items[4] = self->tuple7.node_4;
    data->items[5] = self->tuple7.node_5;
    data->items[6] = self->tuple7.node_6;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 7, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple7__std__typed_tuple (void)
  {
    if (TLS_argument_count != 8) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple7(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple8__std__to_list (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    NODE *self = TLS_arguments[0];
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+8*sizeof(NODE *));
    data->size = 8;
    data->length = 8;
    data->items[0] = self->tuple8.node_0;
    data->items[1] = self->tuple8.node_1;
    data->items[2] = self->tuple8.node_2;
    data->items[3] = self->tuple8.node_3;
    data->items[4] = self->tuple8.node_4;
    data->items[5] = self->tuple8.node_5;
    data->items[6] = self->tuple8.node_6;
    data->items[7] = self->tuple8.node_7;
    {
      NODE *result__node = (NODE *)(create__std_types__list(0, 8, data));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__builtin_types__tuple8__std__typed_tuple (void)
  {
    if (TLS_argument_count != 9) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *clone =
      create__builtin_types__tuple8(TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7], TLS_arguments[8]);
    clone->attributes = prototype->attributes;
    {
      NODE *result__node = (NODE *)(clone);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__tuple (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 8) {
      too_many_arguments();
      return;
    }
    switch (TLS_argument_count) {
      case 2:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple2(TLS_arguments[0], TLS_arguments[1]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 3:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple3(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 4:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple4(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 5:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple5(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 6:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple6(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 7:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple7(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 8:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple8(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
    }
  }

static void entry__std__tuple_or_error (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 8) {
      too_many_arguments();
      return;
    }
    int i;
    for (i = 0; i < TLS_argument_count; ++i) {
      if ((TLS_arguments[i])->type == std_types__error.type)
	{
	  NODE *result__node = (NODE *)(TLS_arguments[i]);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
    }
    switch (TLS_argument_count) {
      case 2:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple2(TLS_arguments[0], TLS_arguments[1]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 3:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple3(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 4:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple4(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 5:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple5(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 6:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple6(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 7:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple7(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      case 8:
	{
	  NODE *result__node = (NODE *)(create__builtin_types__tuple8(TLS_arguments[0], TLS_arguments[1], TLS_arguments[2], TLS_arguments[3], TLS_arguments[4], TLS_arguments[5], TLS_arguments[6], TLS_arguments[7]));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
    }
  }

static void entry__std__new_tuple (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *prototype = TLS_arguments[0];
    NODE *list = TLS_arguments[1];
    if ((list)->type != std_types__list.type) {
      invalid_arguments();
      return;
    }
    long offset = list->list.offset;
    long length = list->list.length;
    if (length < 2) {
      {
        create_error_message(
          module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
          "tuple_from_list - TOO FEW ITEMS", 0, 0, NULL);
        return;
      }
      return;
    } else if (length > 8) {
      {
        create_error_message(
          module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
          "tuple_from_list - TOO MANY ITEMS", 0, 0, NULL);
        return;
      }
      return;
    }
    LIST_DATA *data = list->list.data;
    NODE *tuple;
    switch (length) {
      case 2:
	tuple =
	  create__builtin_types__tuple2(data->items[offset+0], data->items[offset+1]);
	break;
      case 3:
	tuple =
	  create__builtin_types__tuple3(data->items[offset+0], data->items[offset+1], data->items[offset+2]);
	break;
      case 4:
	tuple =
	  create__builtin_types__tuple4(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3]);
	break;
      case 5:
	tuple =
	  create__builtin_types__tuple5(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4]);
	break;
      case 6:
	tuple =
	  create__builtin_types__tuple6(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4], data->items[offset+5]);
	break;
      case 7:
	tuple =
	  create__builtin_types__tuple7(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4], data->items[offset+5], data->items[offset+6]);
	break;
      case 8:
	tuple =
	  create__builtin_types__tuple8(data->items[offset+0], data->items[offset+1], data->items[offset+2], data->items[offset+3], data->items[offset+4], data->items[offset+5], data->items[offset+6], data->items[offset+7]);
	break;
    }
    if ((prototype)->type != std_types__tuple.type) {
      // std_types__tuple is generic and cannot be used!
      tuple->attributes = prototype->attributes;
    }
    {
      NODE *result__node = (NODE *)(tuple);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character__std__to_upper_case (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(create__std_types__character(to_upper_case(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_an_upper_case_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_an_upper_case_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character__std__to_lower_case (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(create__std_types__character(to_lower_case(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_a_lower_case_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_lower_case_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__character__std__to_title_case (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(create__std_types__character(to_title_case(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_a_title_case_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_title_case_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_a_letter_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_letter_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_a_whitespace_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_whitespace_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_a_zero_width_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_zero_width_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std__is_a_wide_character (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_result_count != 1) {
      result_count_mismatch();
      return;
    }
    uint32_t chr_code;
    if (!to_uchar32(TLS_arguments[0], &chr_code)) return;;
    {
      NODE *result__node = (NODE *)(from_bool(is_a_wide_character(chr_code)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__unique_item__std__to_string (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_c_string(my_unique_item_names[TLS_arguments[0]->unique_item.id]));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__unique_item__std__equal (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    NODE *right = TLS_arguments[1];
    if ((right)->type == std_types__unique_item.type) {
      {
        NODE *result__node = (NODE *)(from_bool(TLS_arguments[0]->unique_item.id == right->unique_item.id));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    } else if ((right)->type == std_types__error.type) {
      {
        invalid_arguments();
        return;
      }
    } else {
      {
        NODE *result__node = (NODE *)(&std_types__false);
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std_types__unique_item__std__hash (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    uint32_t hash = TLS_arguments[0]->unique_item.id;
    hash *= 1893456841;
    hash ^= hash >> 25 | hash << 7;
    {
      NODE *result__node = (NODE *)(from_uint32(hash));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    };
  }

static void entry__std__unique_item (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    char *name;
    if (!to_c_string(TLS_arguments[0], &name)) return;
    long i;
    for (i = 1; i < unique_idx; ++i) {
      if (strcmp(name, my_unique_item_names[i]) == 0) {
	{
	  NODE *result__node = (NODE *)(create__std_types__unique_item(i));
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	}
	goto cleanup;
      }
    }
    {
      create_error_message(
        module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
        "NO SUCH UNIQUE ITEM", 0, 0, NULL);
      return;
    }

    cleanup:

    deallocate_memory(name);
  }

static void entry__std_types__file_descriptor__std__get_terminal_size (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }

    int fd = TLS_arguments[0]->file_descriptor.value;
    int success, width, height;
    struct winsize winsize;

    if (event__mode != EM__REPLAY) {
      success = ioctl(fd, TIOCGWINSZ, &winsize);
      width = winsize.ws_col;
      height = winsize.ws_row;
      if (event__mode == EM__RECORD) {
        record__event("get_terminal_size");
        store__integer(success);
        store__integer(width);
        store__integer(height);
        end__record();
      }
    } else {
      replay__event("get_terminal_size");
      retrieve__integer(&success);
      retrieve__integer(&width);
      retrieve__integer(&height);
    }
    if (success == 0) {
      NODE *width_node = from_int(width);
      NODE *height_node = from_int(height);
      TLS_argument_count = 2;;
      TLS_arguments[0] = width_node;
      TLS_arguments[1] = height_node;
      {
        return;
      }
    } else {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"IOCTL FAILED", errno, 0, NULL);
    }
  }

static void entry__std__exitstatus (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    int status;
    if (!to_int(TLS_arguments[0], &status)) return;
    {
      NODE *result__node = (NODE *)(from_int(WEXITSTATUS(status)));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
    }
  }

static void entry__std__pselect (void)
  {
    if (TLS_argument_count < 3) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 4) {
      too_many_arguments();
      return;
    }
    if (TLS_result_count != 4) {
      result_count_mismatch();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    NODE *read_descriptors = TLS_arguments[0];
    NODE *write_descriptors = TLS_arguments[1];
    NODE *except_descriptors = TLS_arguments[2];
    double timeout = 0.0;
    struct timespec timeout_data;
    struct timespec *timeout_ptr = NULL;

    if (
      TLS_argument_count > 3 &&
      (TLS_arguments[3])->type != std_types__undefined.type
    ) {
      if (!to_double(TLS_arguments[3], &timeout)) return;
      if (timeout < 0.0) timeout = 0.0;
      timeout_data.tv_sec = timeout;
      timeout_data.tv_nsec = 1000000000*(timeout-floor(timeout));
      timeout_ptr = &timeout_data;
    }
    long read_descriptor_count, write_descriptor_count, except_descriptor_count;
    fd_set read_set, write_set, except_set;
    int last_fd = 0;
    if (!initialize_fd_set(
    	&read_set, read_descriptors, &read_descriptor_count, &last_fd)) return;
    if (!initialize_fd_set(
    	&write_set, write_descriptors, &write_descriptor_count, &last_fd)) return;
    if (!initialize_fd_set(
    	&except_set, except_descriptors, &except_descriptor_count, &last_fd)) return;
    int ret;
    int caught_hup = false;
    int caught_kill = false;
    int caught_usr1 = false;
    int caught_usr2 = false;
    int chld_changed_state = false;
    int win_changed_size = false;
    if (event__mode != EM__REPLAY) {
      sigset_t set;
      sigprocmask(0, NULL, &set);
      sigdelset(&set, SIGHUP);
      sigdelset(&set, SIGUSR1);
      sigdelset(&set, SIGUSR2);
      sigdelset(&set, SIGCHLD);
      sigdelset(&set, SIGWINCH);
      retry:;
      ret = pselect(last_fd+1, &read_set, &write_set, &except_set, timeout_ptr, &set);
      if (ret < 0 && errno == EINTR) {
	if (caught_sighup) {
	  caught_sighup = false;
	  caught_hup = true;
	} else if (caught_sigusr1) {
	  caught_sigusr1 = false;
	  caught_usr1 = true;
	} else if (caught_sigusr2) {
	  caught_sigusr2 = false;
	  caught_usr2 = true;
	} else if (child_changed_state) {
	  child_changed_state = false;
	  chld_changed_state = true;
	} else if (window_changed_size) {
	  window_changed_size = false;
	  win_changed_size = true;
	} else {
	  goto retry;
	}
      }
      if (event__mode == EM__RECORD) {
        record__event("pselect");
        store__integer(ret);
        store__integer(caught_hup);
        store__integer(caught_kill);
        store__integer(caught_usr1);
        store__integer(caught_usr2);
        store__integer(chld_changed_state);
        store__integer(win_changed_size);
        end__record();
      }
    } else {
      replay__event("pselect");
      retrieve__integer(&ret);
      retrieve__integer(&caught_hup);
      retrieve__integer(&caught_kill);
      retrieve__integer(&caught_usr1);
      retrieve__integer(&caught_usr2);
      retrieve__integer(&chld_changed_state);
      retrieve__integer(&win_changed_size);
    }
    //   store__integer(read_count);
    //   store__integer(write_count);
    //   store__integer(except_count);
    //   store__int_array(descriptors, descriptor_count);
    if (ret == -1 && errno != EINTR) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"PSELECT FAILED", errno, 0, NULL);
      return;
    }
    NODE *signals = (NODE *)&std__empty_list;
    int read_count = 0;
    int write_count = 0;
    int except_count = 0;
    if (ret > 0) { // success
      int fd;
      for (fd = 0; fd <= last_fd; ++fd) {
	if (FD_ISSET(fd, &read_set)) ++read_count;
	if (FD_ISSET(fd, &write_set)) ++write_count;
	if (FD_ISSET(fd, &except_set)) ++except_count;
      }
      if (read_count != read_descriptor_count) {
	if (read_count == 0) {
	  read_descriptors = (NODE *)&std__empty_list;
	} else {
	  read_descriptors =
	    create_descriptor_list(
	      &read_set, read_count,
	      read_descriptors, read_descriptor_count);
	}
      }
      if (write_count != write_descriptor_count) {
	if (write_count == 0) {
	  write_descriptors = (NODE *)&std__empty_list;
	} else {
	  write_descriptors =
	    create_descriptor_list(
	      &write_set, write_count,
	      write_descriptors, write_descriptor_count);
	}
      }
      if (except_count != except_descriptor_count) {
	if (except_count == 0) {
	  except_descriptors = (NODE *)&std__empty_list;
	} else {
	  except_descriptors =
	    create_descriptor_list(
	      &except_set, except_count,
	      except_descriptors, except_descriptor_count);
	}
      }
    } else {
      read_descriptors = (NODE *)&std__empty_list;
      write_descriptors = (NODE *)&std__empty_list;
      except_descriptors = (NODE *)&std__empty_list;
    }
    int signal_count =
      caught_hup+caught_kill+caught_usr1+caught_usr2+
      chld_changed_state+win_changed_size;
    if (signal_count > 0) {
      LIST_DATA *data =
	allocate_large(sizeof(LIST_DATA)+signal_count*sizeof(NODE *));
      data->size = signal_count;
      data->length = signal_count;
      int n = 0;
      if (caught_hup) {
	data->items[n++] = (NODE *)&std__SIGHUP;
      }
      if (caught_usr1) {
	data->items[n++] = (NODE *)&std__SIGUSR1;
      }
      signals = create__std_types__list(0, signal_count, data);
      if (caught_usr2) {
	data->items[n++] = (NODE *)&std__SIGUSR2;
      }
      if (chld_changed_state) {
	data->items[n++] = (NODE *)&std__SIGCHLD;
      }
      if (win_changed_size) {
	data->items[n++] = (NODE *)&std__SIGWINCH;
      }
      signals = create__std_types__list(0, signal_count, data);
    }
    TLS_argument_count = 4;;
    TLS_arguments[0] = signals;
    TLS_arguments[1] = read_descriptors;
    TLS_arguments[2] = write_descriptors;
    TLS_arguments[3] = except_descriptors;
    {
      return;
    }
  }

static void entry__std__do_not_close (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int fd;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &fd)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = fcntl(fd, F_GETFD);
      } while (result == -1 && errno == EINTR);
      if (result != -1) {
	int flags = result&~FD_CLOEXEC;
	do {
	  result = fcntl(fd, F_SETFD, flags);
	} while (result == -1 && errno == EINTR);
      }
      if (event__mode == EM__RECORD) {
        if (result == 0) {
          successful__action("do_not_close");
        } else {
          failed__action("do_not_close");
          store__integer(result);
          end__record();
        }
      }
    } else {
      if (replay__action("do_not_close")) {
        retrieve__integer(&result);
      } else {
        result = 0;
      }
      report__event("do_not_close");
      print__integer(fd);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"DO_NO_CLOSE FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__waitpid (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int status;
    int result;
    int pid;
    if (!process_id_to_int(TLS_arguments[0], &pid)) return;
    if (event__mode != EM__REPLAY) {
      do {
	result = waitpid(pid, &status, WNOHANG);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("waitpid");
        store__integer(result);
        store__integer(status);
        end__record();
      }
    } else {
      replay__event("waitpid");
      retrieve__integer(&result);
      retrieve__integer(&status);
      report__event("waitpid");
      print__integer(result);
      print__integer(status);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
      "WAIT FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 2;
      TLS_arguments[0] = process_id_from_int(result);
      TLS_arguments[1] = from_int(status);
    }
  }

static void entry__std__open_unix_socket (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *filename = NULL;
    int result;
    int sock;
    struct sockaddr_un addr;
    if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
    if (event__mode != EM__REPLAY) {
      sock = socket(AF_UNIX, SOCK_STREAM, 0);
      if (sock == -1) goto error;
      memset(&addr, 0, sizeof(struct sockaddr_un));
      addr.sun_family = AF_UNIX;
      strcpy(addr.sun_path, filename);
      do {
	result = connect(sock, (const struct sockaddr *)&addr, sizeof(addr));
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("open_tcp_socket");
        store__integer(sock);
        end__record();
      }
    } else {
      replay__event("open_tcp_socket");
      retrieve__integer(&sock);
      report__event("open_tcp_socket");
      print__c_string(filename);
      print__integer(sock);
      end__report();
    }
    if (result == -1) {
      error:
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"OPEN SOCKET FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(sock));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(filename);
  }

static void entry__std__send_file_descriptor (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int sock;
    int fd;
    char *message = NULL;
    int result;
    if (!file_descriptor_to_int(TLS_arguments[0], &sock)) return;
    if ((TLS_arguments[1])->type != std_types__octet_string.type) {
      invalid_arguments();
      return;
    }
    if (!file_descriptor_to_int(TLS_arguments[2], &fd)) return;
    struct iovec iov;
    struct msghdr msg;
    struct cmsghdr *cmsg;
    char cmsgbuf[CMSG_SPACE(sizeof(int))];
    iov.iov_base =
      TLS_arguments[1]->octet_string.data->buffer+TLS_arguments[1]->octet_string.offset;
    iov.iov_len = TLS_arguments[1]->octet_string.length;
    memset(&msg, 0, sizeof(struct msghdr));
    msg.msg_iov = &iov;
    msg.msg_iovlen = 1;
    msg.msg_control = cmsgbuf;
    msg.msg_controllen = sizeof(cmsgbuf);
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof(int));
    *((int *)CMSG_DATA(cmsg)) = fd;
    if (event__mode != EM__REPLAY) {
      do {
	result = sendmsg(sock, &msg, 0);
      } while (result == -1 && errno == EINTR);
      if (event__mode == EM__RECORD) {
        record__event("send_file_descriptor");
        store__integer(result);
        end__record();
      }
    } else {
      replay__event("send_file_descriptor");
      retrieve__integer(&result);
      report__event("send_file_descriptor");
      print__integer(sock);
      print__c_string(message);
      print__integer(fd);
      print__integer(result);
      end__report();
    }
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"SEND FILE DESCRIPTOR FAILED", errno, 0, NULL);
    } else {
      TLS_argument_count = 0;
    }
  }

static void entry__std__open_tcp_client_socket (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    char *uri = NULL;
    int port_no;
    int no_delay = false;
    int result;
    int sock;
    struct hostent *server;
    struct sockaddr_in addr;
    if (!to_c_string(TLS_arguments[0], &uri)) goto cleanup;
    if (!to_int(TLS_arguments[1], &port_no)) goto cleanup;
    if (TLS_argument_count == 3) {
      if (!to_bool(TLS_arguments[2], &no_delay)) return;
    }
    if (event__mode != EM__REPLAY) {
      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock == -1) goto error;
      int flags = fcntl(sock, F_GETFL, 0);
      if (flags == -1) goto error;
      if (fcntl(sock, F_SETFL, flags|O_NONBLOCK) == -1) goto error;
      if (no_delay) {
	int opt = 1;
	if (
	  setsockopt(sock, IPPROTO_TCP, TCP_NODELAY, &opt, sizeof(opt)) == -1
	) {
	  goto error;
	}
      }
      server = gethostbyname(uri);
      if (!server) goto error;
      memset(&addr, 0, sizeof(addr));
      addr.sin_family = AF_INET;
      addr.sin_port = htons(port_no);
      memcpy(&addr.sin_addr.s_addr,server->h_addr,server->h_length);
      do {
	result = connect(sock, (const struct sockaddr *)&addr, sizeof(addr));
      } while (result == -1 && errno == EINTR);
      if (result == -1 && errno == EINPROGRESS) result = 0;
      if (result == 0) {
	result = fcntl(sock, F_SETFL, flags);
      }
      if (event__mode == EM__RECORD) {
        record__event("open_tcp_client_socket");
        store__integer(sock);
        end__record();
      }
    } else {
      replay__event("open_tcp_client_socket");
      retrieve__integer(&sock);
      report__event("open_tcp_client_socket");
      print__c_string(uri);
      print__integer(port_no);
      print__integer(sock);
      end__report();
    }
    if (result == -1) {
      error:
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"OPEN_TCP_CLIENT_SOCKET FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(sock));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
    cleanup:
    deallocate_memory(uri);
  }

static void entry__std__open_tcp_server_socket (void)
  {
    if (TLS_argument_count < 2) {
      too_few_arguments();
      return;
    }
    if (TLS_argument_count > 3) {
      too_many_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int port_no;
    int backlog_count;
    int do_reuse = false;
    int sock;
    int result;
    struct sockaddr_in addr;
    if (!to_int(TLS_arguments[0], &port_no)) return;
    if (!to_int(TLS_arguments[1], &backlog_count)) return;
    if (TLS_argument_count == 3) {
      if (!to_bool(TLS_arguments[2], &do_reuse)) return;
    }
    if (event__mode != EM__REPLAY) {
      sock = socket(AF_INET, SOCK_STREAM, 0);
      if (sock == -1) goto error;
      if (do_reuse) {
	int opt = 1;
	if (
	  setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) == -1
	) {
	  goto error;
	}
      }
      addr.sin_family = AF_INET;
      addr.sin_addr.s_addr = htonl(INADDR_ANY);
      addr.sin_port = htons(port_no);
      if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) goto error;
      if (listen(sock, backlog_count) == -1) goto error;
      if (event__mode == EM__RECORD) {
        record__event("open_tcp_server_socket");
        store__integer(sock);
        end__record();
      }
    } else {
      replay__event("open_tcp_server_socket");
      retrieve__integer(&sock);
      report__event("open_tcp_server_socket");
      print__integer(port_no);
      print__integer(backlog_count);
      print__integer(sock);
      end__report();
    }
    if (result == -1) {
      error:
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"OPEN_TCP_SERVER_SOCKET FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(sock));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__accept (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int sock;
    int result;
    int conn;
    if (!file_descriptor_to_int(TLS_arguments[0], &sock)) return;
    if (event__mode != EM__REPLAY) {
      do {
	conn = accept(sock, NULL, 0);
      } while (conn == -1 && errno == EINTR);
      if (conn == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "ACCEPT FAILED", errno, 0, NULL);
      }
      if (event__mode == EM__RECORD) {
        record__event("accept");
        store__integer(conn);
        end__record();
      }
    } else {
      replay__event("accept");
      retrieve__integer(&conn);
      report__event("accept");
      print__integer(sock);
      print__integer(conn);
      end__report();
    }
    if (conn != -1) {
      {
        NODE *result__node = (NODE *)(file_descriptor_from_int(conn));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
    }
  }

static void entry__std__is_listening (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    int sock;
    if (!file_descriptor_to_int(TLS_arguments[0], &sock)) return;
    int result;
    int does_listen;
    socklen_t len = sizeof(does_listen);
    result = getsockopt(sock, SOL_SOCKET, SO_ACCEPTCONN, &does_listen, &len);
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std__IO_ERROR-1],
	"GETSOCKOPT FAILED", errno, 0, NULL);
    } else {
      {
        NODE *result__node = (NODE *)(from_bool(does_listen ? true : false));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
        return;
      }
    }
  }

static void entry__std__get_first_mac_address (void)
  {
    if (TLS_argument_count != 0) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    #ifndef __CYGWIN__
      struct ifaddrs *addrs, *ifa;
      getifaddrs(&addrs);
      for (ifa = addrs; ifa != NULL; ifa = ifa->ifa_next) {
	if (ifa->ifa_addr == NULL) continue;
	if (ifa->ifa_addr->sa_family != AF_PACKET) continue;
	if (ifa->ifa_name[0] == 'l' && ifa->ifa_name[1] == 'o') continue;
	struct sockaddr_ll *sdl = (struct sockaddr_ll *)ifa->ifa_addr;
	NODE *result = from_latin_1_string(
	  ((struct sockaddr_ll *)ifa->ifa_addr)->sll_addr, 6);
	freeifaddrs(addrs);
	{
	  NODE *result__node = (NODE *)(result);
	  TLS_arguments[0] = result__node;
	  TLS_argument_count = 1;
	  return;
	}
      }
      freeifaddrs(addrs);
    #endif
    {
      NODE *result__node = (NODE *)(&std_types__undefined);
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__shared_memory__std__size_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(from_long(TLS_arguments[0]->shared_memory.size));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__shared_memory__std__file_descriptor_of (void)
  {
    if (TLS_argument_count != 1) {
      invalid_arguments();
      return;
    }
    {
      NODE *result__node = (NODE *)(file_descriptor_from_int(TLS_arguments[0]->shared_memory.fd));
      TLS_arguments[0] = result__node;
      TLS_argument_count = 1;
      return;
    }
  }

static void entry__std_types__shared_memory__std__write_at (void)
  {
    if (TLS_argument_count != 3) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    long position;
    if (!to_long(TLS_arguments[1], &position)) return;
    if ((TLS_arguments[2])->type != std_types__octet_string.type) {
      invalid_arguments();
      return;
    }
    long length = TLS_arguments[2]->octet_string.length;
    if (position < 1 || position+length-1 > TLS_arguments[0]->shared_memory.size) {
      {
        create_error_message(
          module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
          "Invalid offset or length!", 0, 0, NULL);
        return;
      }
      return;
    }
    memcpy(
      TLS_arguments[0]->shared_memory.buf+position-1,
      TLS_arguments[2]->octet_string.data->buffer+TLS_arguments[2]->octet_string.offset,
      length);
    {
      TLS_argument_count = 0;
      return;
    }
  }

static void entry__std__create_shared_memory (void)
  {
    if (TLS_argument_count != 2) {
      invalid_arguments();
      return;
    }
    if (TLS_deny_io) {
      missing_io_access_rights();
      return;
    }
    #ifdef __ANDROID__
      {
        create_error_message(
          module__builtin.constants_base[unique__std__RUNTIME_ERROR-1],
          "Shared memory is not supported on Android!", 0, 0, NULL);
        return;
      }
    #else
      char *filename = NULL;
      long size;
      int fd;
      if (!to_c_string(TLS_arguments[0], &filename)) goto cleanup;
      if (!to_long(TLS_arguments[1], &size)) goto cleanup;
      fd = shm_open(filename, O_RDWR|O_CREAT|O_TRUNC|O_EXCL, 0600);
      if (fd == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "SHM_OPEN FAILED", errno, 0, NULL);
	goto cleanup;
      }
      if (ftruncate(fd, size) == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "FTRUNCATE FAILED", errno, 0, NULL);
	goto cleanup;
      }
      void *buf = mmap(NULL, size, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);
      if (buf == MAP_FAILED) {
	create_error_message(
	  module__builtin.constants_base[unique__std__IO_ERROR-1],
	  "MMAP FAILED", errno, 0, NULL);
	goto cleanup;
      }
      {
        NODE *result__node = (NODE *)(create__std_types__shared_memory(fd, size, buf));
        TLS_arguments[0] = result__node;
        TLS_argument_count = 1;
      }
      cleanup:
      deallocate_memory(filename);
    #endif
  }

static FUNKY_NAMESPACE defined_namespaces[] = {
  {"builtin_types", 1, 0},
  {"debug", 1, 0},
  {"std", 1, 0},
  {"std_types", 1, 0}
};

static FUNKY_CONSTANT constants_table[] = {
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__array__std__dimension_count_of}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__boolean_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__boolean_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__boolean_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__boolean_array__std__bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__boolean_array__std__bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__boolean_array__std__bit_xor}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__boolean_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_boolean_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__boolean_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__boolean_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__character_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__character_array__std__equal}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__character_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_character_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__character_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int8_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int8_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int8_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int8_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__int8_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_int8_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int8_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int8_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint8_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint8_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint8_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint8_array__std__bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint8_array__std__bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint8_array__std__bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint8_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__uint8_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_uint8_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint8_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint8_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int16_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int16_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int16_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int16_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__int16_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_int16_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int16_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int16_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint16_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint16_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint16_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint16_array__std__bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint16_array__std__bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint16_array__std__bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint16_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__uint16_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_uint16_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint16_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint16_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int32_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int32_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int32_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int32_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__int32_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_int32_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int32_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int32_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint32_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint32_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint32_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint32_array__std__bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint32_array__std__bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint32_array__std__bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint32_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__uint32_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_uint32_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint32_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint32_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int64_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int64_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int64_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__int64_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__int64_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_int64_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__int64_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__int64_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint64_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint64_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint64_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint64_array__std__bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint64_array__std__bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint64_array__std__bit_xor}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__uint64_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__uint64_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_uint64_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__uint64_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__uint64_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__float32_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__float32_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__float32_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__float32_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__float32_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_float32_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__float32_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__float32_array__std__range}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__float64_array__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__float64_array__std__dimension_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__float64_array__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__float64_array__std__times}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__float64_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__initialized_float64_array}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__float64_array__std__create_empty_array}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__float64_array__std__range}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__pass}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__result_count}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__true__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__false__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__c_function__std__parameter_count_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__character}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__character__std__plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__character__std__minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__character__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__character__std__less}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__to_string}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__width_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__from_unix_time}},
  {FLT_C_FUNCTION, 6, {.func = entry__std__date_and_time}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__year_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__month_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__day_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__day_of_week_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__hour_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__minute_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__second_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__time_shift_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__date_and_time__std__seconds_since_epoch}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__date_and_time__std__plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__date_and_time__std__minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__date_and_time__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__date_and_time__std__less}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__current_time}},
  {FLT_C_FUNCTION, 0, {.func = entry__debug__current_time}},
  {FLT_C_FUNCTION, -1, {.func = entry__debug__string}},
  {FLT_C_FUNCTION, 1, {.func = entry__debug__write}},
  {FLT_C_FUNCTION, -1, {.func = entry__debug__dump_object}},
  {FLT_C_FUNCTION, 0, {.func = entry__debug__has_io_access_rights}},
  {FLT_C_FUNCTION, -1, {.func = entry__debug__exit}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__error_check}},
  {FLT_C_FUNCTION, 0, {.func = entry__debug__total_garbage_collections}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__installation_prefix}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__package_version}},
  {FLT_UNIQUE, 0, {.str_8 = "std::IO_ERROR"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::RUNTIME_ERROR"}},
  {FLT_UNIQUE, 0, {.str_8 = "std::APPLICATION_ERROR"}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error__std__error_category_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error__std__error_message_text_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error__std__error_details_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error__std__errno_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error__std__failed_attribute_of}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__error}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__exec}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__create_process}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__function__std__parameter_count_of}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__function__std__new}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__list}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__is_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__is_not_empty}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__list__std__push}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__drop}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__pop}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__peek}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__list__std__append}},
  {FLT_C_FUNCTION, 3, {.func = entry__std_types__list__std__range}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__list__std__spread}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__negate}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__negative_integer__std__negate}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__negate}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__times}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__times}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__negative_integer__std__to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__to_integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__floor}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__ceil}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__round}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__negative_integer__std__to_string}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__to_string}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__to_string}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__over}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__over}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__div}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__div}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__mod}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__mod}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__negative_integer__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__ln}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__negative_integer__std__ln}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__ln}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__exp}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__negative_integer__std__exp}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__real__std__exp}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__real}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__integer}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__sqrt}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__pow}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__positive_integer__std__exit}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__real__std__plus}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__real__std__minus}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__real__std__times}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__real__std__over}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__real__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__less}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__negative_integer__std__less}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__real__std__less}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__shift_left}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__shift_right}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__bit_and}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__bit_or}},
  {FLT_C_FUNCTION, 2, {.func = entry__builtin_types__positive_integer__std__bit_xor}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__sin}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__cos}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__tan}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__asin}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__acos}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__atan}},
  {FLT_C_FUNCTION, 1, {.func = entry__debug__object_type}},
  {FLT_C_FUNCTION, 1, {.func = entry__debug__object_attributes}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__object__std__new}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__file_type__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_type__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__file_type}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_type__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__file_descriptor__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_descriptor__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__file_descriptor}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_descriptor__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__signal_number__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__signal_number__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__signal_number}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__signal_number__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__shutdown_type__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__shutdown_type__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__shutdown_type}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__shutdown_type__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__seek_type__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__seek_type__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__seek_type}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__seek_type__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__device_id__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__device_id__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__device_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__device_id__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__directory__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__directory__std__hash}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__group_id__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__group_id__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__group_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__group_id__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__inode_number__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__inode_number__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__inode_number}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__inode_number__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__process_id__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__process_id__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__process_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__process_id__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__user_id__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__user_id__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__user_id}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__user_id__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__error_number__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error_number__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__error_number}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__error_number__std__to_integer}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__access}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__chdir}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__chmod}},
  {FLT_C_FUNCTION, 3, {.func = entry__std__chown}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__chroot}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_descriptor__std__close}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__closedir}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__dup2}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__fstat}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__fsync}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getcwd}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__getenv}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getegid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__geteuid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getgid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__gethostname}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getlogin}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getpid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getppid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__getpwuid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__getsid}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__getuid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__isatty}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__kill}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__link}},
  {FLT_C_FUNCTION, 3, {.func = entry__std__lseek}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__mkdir}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__mkfifo}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__open}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__opendir}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__file_descriptor__std__read}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__readdir}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__realpath}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__rename}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__sethostname}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__shutdown}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__stat}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__strerror}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__wait}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__file_descriptor__std__write}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__umask}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__unlink}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__shm_unlink}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__usleep}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__wide_string__std__length_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__is_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__is_not_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__wide_string__std__is_empty}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__wide_string__std__is_not_empty}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__octet_string__std__push}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__wide_string__std__push}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__octet_string__std__append}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__wide_string__std__append}},
  {FLT_C_FUNCTION, 3, {.func = entry__std_types__octet_string__std__range}},
  {FLT_C_FUNCTION, 3, {.func = entry__std_types__wide_string__std__range}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__wide_string__std__hash}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__octet_string__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__wide_string__std__equal}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__octet_string__std__less}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__wide_string__std__less}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__width_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__wide_string__std__width_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__from_utf8}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__octet_string__std__to_utf8}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__wide_string__std__to_utf8}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_descriptor__std__get_terminal_attributes}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__file_descriptor__std__set_terminal_attributes}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__terminal_attributes__std__backspace_character_of}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__use_canonical_mode}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__echo_characters}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__echo_new_lines}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__enable_xon_xoff_for_input}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__enable_xon_xoff_for_output}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__restart_output_on_any_character}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__ignore_cr_on_input}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__generate_signals}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__map_cr_to_lf_on_input}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__hangup_on_close}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__map_lf_to_crlf_on_output}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__minimum_characters_for_canoncial_read}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__timeout_for_reads}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__input_speed}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__terminal_attributes__std__output_speed}},
  {FLT_C_FUNCTION, -1, {.func = entry__std_types__tuple__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple2__std__to_list}},
  {FLT_C_FUNCTION, 3, {.func = entry__builtin_types__tuple2__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple3__std__to_list}},
  {FLT_C_FUNCTION, 4, {.func = entry__builtin_types__tuple3__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple4__std__to_list}},
  {FLT_C_FUNCTION, 5, {.func = entry__builtin_types__tuple4__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple5__std__to_list}},
  {FLT_C_FUNCTION, 6, {.func = entry__builtin_types__tuple5__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple6__std__to_list}},
  {FLT_C_FUNCTION, 7, {.func = entry__builtin_types__tuple6__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple7__std__to_list}},
  {FLT_C_FUNCTION, 8, {.func = entry__builtin_types__tuple7__std__typed_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__builtin_types__tuple8__std__to_list}},
  {FLT_C_FUNCTION, 9, {.func = entry__builtin_types__tuple8__std__typed_tuple}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__tuple}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__tuple_or_error}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__new_tuple}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__to_upper_case}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_an_upper_case_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__to_lower_case}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_a_lower_case_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__character__std__to_title_case}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_a_title_case_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_a_letter_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_a_whitespace_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_a_zero_width_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_a_wide_character}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__unique_item__std__to_string}},
  {FLT_C_FUNCTION, 2, {.func = entry__std_types__unique_item__std__equal}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__unique_item__std__hash}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__unique_item}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__file_descriptor__std__get_terminal_size}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__exitstatus}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__pselect}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__do_not_close}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__waitpid}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__open_unix_socket}},
  {FLT_C_FUNCTION, 3, {.func = entry__std__send_file_descriptor}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__open_tcp_client_socket}},
  {FLT_C_FUNCTION, -1, {.func = entry__std__open_tcp_server_socket}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__accept}},
  {FLT_C_FUNCTION, 1, {.func = entry__std__is_listening}},
  {FLT_C_FUNCTION, 0, {.func = entry__std__get_first_mac_address}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__shared_memory__std__size_of}},
  {FLT_C_FUNCTION, 1, {.func = entry__std_types__shared_memory__std__file_descriptor_of}},
  {FLT_C_FUNCTION, 3, {.func = entry__std_types__shared_memory__std__write_at}},
  {FLT_C_FUNCTION, 2, {.func = entry__std__create_shared_memory}}
};

static INTERNAL_METHOD std_types__array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(ARRAY)}},
  {FIM_COLLECT, {std_types__array___collect}},
  {FIM_DEBUG_STRING, {std_types__array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__array__attributes[] = {
  {var_std__create_empty_array, func__std_types__array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__array__std__dimension_count_of},
  {var_std__length_of, func__std_types__array__std__length_of},
  {var_std__range, func__std_types__array__std__range}
};

static INTERNAL_METHOD std_types__boolean_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(BOOLEAN_ARRAY)}},
  {FIM_COLLECT, {std_types__boolean_array___collect}},
  {FIM_DEBUG_STRING, {std_types__boolean_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__boolean_array__attributes[] = {
  {var_std__bit_and, func__std_types__boolean_array__std__bit_and},
  {var_std__bit_or, func__std_types__boolean_array__std__bit_or},
  {var_std__bit_xor, func__std_types__boolean_array__std__bit_xor},
  {var_std__create_empty_array, func__std_types__boolean_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__boolean_array__std__dimension_count_of},
  {var_std__equal, func__std_types__boolean_array__std__equal},
  {var_std__length_of, func__std_types__boolean_array__std__length_of},
  {var_std__range, func__std_types__boolean_array__std__range}
};

static INTERNAL_METHOD std_types__character_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(CHARACTER_ARRAY)}},
  {FIM_COLLECT, {std_types__character_array___collect}},
  {FIM_DEBUG_STRING, {std_types__character_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__character_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__character_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__character_array__std__dimension_count_of},
  {var_std__equal, func__std_types__character_array__std__equal},
  {var_std__length_of, func__std_types__character_array__std__length_of},
  {var_std__range, func__std_types__character_array__std__range}
};

static INTERNAL_METHOD std_types__int8_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT8_ARRAY)}},
  {FIM_COLLECT, {std_types__int8_array___collect}},
  {FIM_DEBUG_STRING, {std_types__int8_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__int8_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__int8_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__int8_array__std__dimension_count_of},
  {var_std__equal, func__std_types__int8_array__std__equal},
  {var_std__length_of, func__std_types__int8_array__std__length_of},
  {var_std__range, func__std_types__int8_array__std__range},
  {var_std__times, func__std_types__int8_array__std__times}
};

static INTERNAL_METHOD std_types__uint8_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT8_ARRAY)}},
  {FIM_COLLECT, {std_types__uint8_array___collect}},
  {FIM_DEBUG_STRING, {std_types__uint8_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__uint8_array__attributes[] = {
  {var_std__bit_and, func__std_types__uint8_array__std__bit_and},
  {var_std__bit_or, func__std_types__uint8_array__std__bit_or},
  {var_std__bit_xor, func__std_types__uint8_array__std__bit_xor},
  {var_std__create_empty_array, func__std_types__uint8_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__uint8_array__std__dimension_count_of},
  {var_std__equal, func__std_types__uint8_array__std__equal},
  {var_std__length_of, func__std_types__uint8_array__std__length_of},
  {var_std__range, func__std_types__uint8_array__std__range},
  {var_std__times, func__std_types__uint8_array__std__times}
};

static INTERNAL_METHOD std_types__int16_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT16_ARRAY)}},
  {FIM_COLLECT, {std_types__int16_array___collect}},
  {FIM_DEBUG_STRING, {std_types__int16_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__int16_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__int16_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__int16_array__std__dimension_count_of},
  {var_std__equal, func__std_types__int16_array__std__equal},
  {var_std__length_of, func__std_types__int16_array__std__length_of},
  {var_std__range, func__std_types__int16_array__std__range},
  {var_std__times, func__std_types__int16_array__std__times}
};

static INTERNAL_METHOD std_types__uint16_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT16_ARRAY)}},
  {FIM_COLLECT, {std_types__uint16_array___collect}},
  {FIM_DEBUG_STRING, {std_types__uint16_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__uint16_array__attributes[] = {
  {var_std__bit_and, func__std_types__uint16_array__std__bit_and},
  {var_std__bit_or, func__std_types__uint16_array__std__bit_or},
  {var_std__bit_xor, func__std_types__uint16_array__std__bit_xor},
  {var_std__create_empty_array, func__std_types__uint16_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__uint16_array__std__dimension_count_of},
  {var_std__equal, func__std_types__uint16_array__std__equal},
  {var_std__length_of, func__std_types__uint16_array__std__length_of},
  {var_std__range, func__std_types__uint16_array__std__range},
  {var_std__times, func__std_types__uint16_array__std__times}
};

static INTERNAL_METHOD std_types__int32_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT32_ARRAY)}},
  {FIM_COLLECT, {std_types__int32_array___collect}},
  {FIM_DEBUG_STRING, {std_types__int32_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__int32_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__int32_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__int32_array__std__dimension_count_of},
  {var_std__equal, func__std_types__int32_array__std__equal},
  {var_std__length_of, func__std_types__int32_array__std__length_of},
  {var_std__range, func__std_types__int32_array__std__range},
  {var_std__times, func__std_types__int32_array__std__times}
};

static INTERNAL_METHOD std_types__uint32_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT32_ARRAY)}},
  {FIM_COLLECT, {std_types__uint32_array___collect}},
  {FIM_DEBUG_STRING, {std_types__uint32_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__uint32_array__attributes[] = {
  {var_std__bit_and, func__std_types__uint32_array__std__bit_and},
  {var_std__bit_or, func__std_types__uint32_array__std__bit_or},
  {var_std__bit_xor, func__std_types__uint32_array__std__bit_xor},
  {var_std__create_empty_array, func__std_types__uint32_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__uint32_array__std__dimension_count_of},
  {var_std__equal, func__std_types__uint32_array__std__equal},
  {var_std__length_of, func__std_types__uint32_array__std__length_of},
  {var_std__range, func__std_types__uint32_array__std__range},
  {var_std__times, func__std_types__uint32_array__std__times}
};

static INTERNAL_METHOD std_types__int64_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INT64_ARRAY)}},
  {FIM_COLLECT, {std_types__int64_array___collect}},
  {FIM_DEBUG_STRING, {std_types__int64_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__int64_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__int64_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__int64_array__std__dimension_count_of},
  {var_std__equal, func__std_types__int64_array__std__equal},
  {var_std__length_of, func__std_types__int64_array__std__length_of},
  {var_std__range, func__std_types__int64_array__std__range},
  {var_std__times, func__std_types__int64_array__std__times}
};

static INTERNAL_METHOD std_types__uint64_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UINT64_ARRAY)}},
  {FIM_COLLECT, {std_types__uint64_array___collect}},
  {FIM_DEBUG_STRING, {std_types__uint64_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__uint64_array__attributes[] = {
  {var_std__bit_and, func__std_types__uint64_array__std__bit_and},
  {var_std__bit_or, func__std_types__uint64_array__std__bit_or},
  {var_std__bit_xor, func__std_types__uint64_array__std__bit_xor},
  {var_std__create_empty_array, func__std_types__uint64_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__uint64_array__std__dimension_count_of},
  {var_std__equal, func__std_types__uint64_array__std__equal},
  {var_std__length_of, func__std_types__uint64_array__std__length_of},
  {var_std__range, func__std_types__uint64_array__std__range},
  {var_std__times, func__std_types__uint64_array__std__times}
};

static INTERNAL_METHOD std_types__float32_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FLOAT32_ARRAY)}},
  {FIM_COLLECT, {std_types__float32_array___collect}},
  {FIM_DEBUG_STRING, {std_types__float32_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__float32_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__float32_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__float32_array__std__dimension_count_of},
  {var_std__equal, func__std_types__float32_array__std__equal},
  {var_std__length_of, func__std_types__float32_array__std__length_of},
  {var_std__range, func__std_types__float32_array__std__range},
  {var_std__times, func__std_types__float32_array__std__times}
};

static INTERNAL_METHOD std_types__float64_array__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FLOAT64_ARRAY)}},
  {FIM_COLLECT, {std_types__float64_array___collect}},
  {FIM_DEBUG_STRING, {std_types__float64_array___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__float64_array__attributes[] = {
  {var_std__create_empty_array, func__std_types__float64_array__std__create_empty_array},
  {var_std__dimension_count_of, func__std_types__float64_array__std__dimension_count_of},
  {var_std__equal, func__std_types__float64_array__std__equal},
  {var_std__length_of, func__std_types__float64_array__std__length_of},
  {var_std__range, func__std_types__float64_array__std__range},
  {var_std__times, func__std_types__float64_array__std__times}
};

static INTERNAL_METHOD std_types__true__internal_methods[] = {
  {FIM_TO_BOOL, {std_types__true___to_bool}},
  {FIM_DEBUG_STRING, {std_types__true___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__true__attributes[] = {
  {var_std__equal, func__std_types__true__std__equal}
};

static INTERNAL_METHOD std_types__false__internal_methods[] = {
  {FIM_TO_BOOL, {std_types__false___to_bool}},
  {FIM_DEBUG_STRING, {std_types__false___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__false__attributes[] = {
  {var_std__equal, func__std_types__false__std__equal}
};

static INTERNAL_METHOD c_function__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(C_FUNCTION)}},
  {FIM_COLLECT, {c_function___collect}},
  {FIM_DEBUG_STRING, {c_function___debug_string}}
};

static ATTRIBUTE_DEFINITION c_function__attributes[] = {
  {var_std__parameter_count_of, func__c_function__std__parameter_count_of}
};

static INTERNAL_METHOD std_types__character__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(CHARACTER)}},
  {FIM_COLLECT, {std_types__character___collect}},
  {FIM_TO_UCHAR32, {std_types__character___to_uchar32}},
  {FIM_DEBUG_STRING, {std_types__character___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__character__attributes[] = {
  {var_std__equal, func__std_types__character__std__equal},
  {var_std__hash, func__std_types__character__std__hash},
  {var_std__less, func__std_types__character__std__less},
  {var_std__minus, func__std_types__character__std__minus},
  {var_std__plus, func__std_types__character__std__plus},
  {var_std__to_integer, func__std_types__character__std__to_integer},
  {var_std__to_lower_case, func__std_types__character__std__to_lower_case},
  {var_std__to_string, func__std_types__character__std__to_string},
  {var_std__to_title_case, func__std_types__character__std__to_title_case},
  {var_std__to_upper_case, func__std_types__character__std__to_upper_case},
  {var_std__width_of, func__std_types__character__std__width_of}
};

static INTERNAL_METHOD std_types__date_and_time__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(DATE_AND_TIME)}},
  {FIM_COLLECT, {std_types__date_and_time___collect}},
  {FIM_DEBUG_STRING, {std_types__date_and_time___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__date_and_time__attributes[] = {
  {var_std__day_of, func__std_types__date_and_time__std__day_of},
  {var_std__day_of_week_of, func__std_types__date_and_time__std__day_of_week_of},
  {var_std__equal, func__std_types__date_and_time__std__equal},
  {var_std__hour_of, func__std_types__date_and_time__std__hour_of},
  {var_std__less, func__std_types__date_and_time__std__less},
  {var_std__minus, func__std_types__date_and_time__std__minus},
  {var_std__minute_of, func__std_types__date_and_time__std__minute_of},
  {var_std__month_of, func__std_types__date_and_time__std__month_of},
  {var_std__plus, func__std_types__date_and_time__std__plus},
  {var_std__second_of, func__std_types__date_and_time__std__second_of},
  {var_std__seconds_since_epoch, func__std_types__date_and_time__std__seconds_since_epoch},
  {var_std__time_shift_of, func__std_types__date_and_time__std__time_shift_of},
  {var_std__year_of, func__std_types__date_and_time__std__year_of}
};

static INTERNAL_METHOD std_types__error__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(ERROR)}},
  {FIM_COLLECT, {std_types__error___collect}},
  {FIM_DEBUG_STRING, {std_types__error___debug_string}},
  {FIM_TO_INT8, {propagate_error}},
  {FIM_TO_INT16, {propagate_error}},
  {FIM_TO_INT32, {propagate_error}},
  {FIM_TO_INT64, {propagate_error}},
  {FIM_TO_UINT8, {propagate_error}},
  {FIM_TO_UINT16, {propagate_error}},
  {FIM_TO_UINT32, {propagate_error}},
  {FIM_TO_UINT64, {propagate_error}},
  {FIM_TO_UCHAR32, {propagate_error}},
  {FIM_TO_BOOL, {propagate_error}},
  {FIM_TO_INT, {propagate_error}},
  {FIM_TO_UINT, {propagate_error}},
  {FIM_TO_LONG, {propagate_error}},
  {FIM_TO_ULONG, {propagate_error}},
  {FIM_TO_FLOAT, {propagate_error}},
  {FIM_TO_DOUBLE, {propagate_error}},
  {FIM_TO_C_STRING, {propagate_error}},
  {FIM_TO_OCTETS, {propagate_error}},
  {FIM_GET_ITEM_OF, {propagate_error}},
  {FIM_LENGTH_OF, {propagate_error}},
  {FIM_UNFOLD, {propagate_error}}
};

static ATTRIBUTE_DEFINITION std_types__error__attributes[] = {
  {var_std__errno_of, func__std_types__error__std__errno_of},
  {var_std__error_category_of, func__std_types__error__std__error_category_of},
  {var_std__error_details_of, func__std_types__error__std__error_details_of},
  {var_std__error_message_text_of, func__std_types__error__std__error_message_text_of},
  {var_std__failed_attribute_of, func__std_types__error__std__failed_attribute_of}
};

static INTERNAL_METHOD std_types__object__internal_methods[] = {
  {FIM_TO_INT8, {std_types__object___to_int8}},
  {FIM_TO_INT16, {std_types__object___to_int16}},
  {FIM_TO_INT32, {std_types__object___to_int32}},
  {FIM_TO_INT64, {std_types__object___to_int64}},
  {FIM_TO_UINT8, {std_types__object___to_uint8}},
  {FIM_TO_UINT16, {std_types__object___to_uint16}},
  {FIM_TO_UINT32, {std_types__object___to_uint32}},
  {FIM_TO_UINT64, {std_types__object___to_uint64}},
  {FIM_TO_UCHAR32, {std_types__object___to_uchar32}},
  {FIM_TO_BOOL, {std_types__object___to_bool}},
  {FIM_TO_INT, {std_types__object___to_int}},
  {FIM_TO_UINT, {std_types__object___to_uint}},
  {FIM_TO_LONG, {std_types__object___to_long}},
  {FIM_TO_ULONG, {std_types__object___to_ulong}},
  {FIM_TO_FLOAT, {std_types__object___to_float}},
  {FIM_TO_DOUBLE, {std_types__object___to_double}},
  {FIM_TO_C_STRING, {std_types__object___to_c_string}},
  {FIM_TO_OCTETS, {std_types__object___to_octets}},
  {FIM_GET_ITEM_OF, {std_types__object___get_item_of}},
  {FIM_LENGTH_OF, {std_types__object___length_of}},
  {FIM_UNFOLD, {std_types__object___unfold}},
  {FIM_COLLECT, {std_types__object___collect}},
  {FIM_DEBUG_STRING, {std_types__object___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__object__attributes[] = {
  {var_std__new, func__std_types__object__std__new}
};

static INTERNAL_METHOD std_types__undefined__internal_methods[] = {
  {FIM_TO_INT8, {std_types__undefined___to_int8}},
  {FIM_TO_INT16, {std_types__undefined___to_int16}},
  {FIM_TO_INT32, {std_types__undefined___to_int32}},
  {FIM_TO_INT64, {std_types__undefined___to_int64}},
  {FIM_TO_UINT8, {std_types__undefined___to_uint8}},
  {FIM_TO_UINT16, {std_types__undefined___to_uint16}},
  {FIM_TO_UINT32, {std_types__undefined___to_uint32}},
  {FIM_TO_UINT64, {std_types__undefined___to_uint64}},
  {FIM_TO_UCHAR32, {std_types__undefined___to_uchar32}},
  {FIM_TO_BOOL, {std_types__undefined___to_bool}},
  {FIM_TO_INT, {std_types__undefined___to_int}},
  {FIM_TO_UINT, {std_types__undefined___to_uint}},
  {FIM_TO_LONG, {std_types__undefined___to_long}},
  {FIM_TO_ULONG, {std_types__undefined___to_ulong}},
  {FIM_TO_FLOAT, {std_types__undefined___to_float}},
  {FIM_TO_DOUBLE, {std_types__undefined___to_double}},
  {FIM_TO_C_STRING, {std_types__undefined___to_c_string}},
  {FIM_TO_OCTETS, {std_types__undefined___to_octets}},
  {FIM_GET_ITEM_OF, {std_types__undefined___get_item_of}},
  {FIM_LENGTH_OF, {std_types__undefined___length_of}},
  {FIM_UNFOLD, {std_types__undefined___unfold}},
  {FIM_COLLECT, {std_types__undefined___collect}},
  {FIM_DEBUG_STRING, {std_types__undefined___debug_string}}
};

static INTERNAL_METHOD std_types__function__internal_methods[] = {
  {FIM_DEBUG_STRING, {std_types__function___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__function__attributes[] = {
  {var_std__new, func__std_types__function__std__new},
  {var_std__parameter_count_of, func__std_types__function__std__parameter_count_of}
};

static INTERNAL_METHOD std_types__list__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(LIST)}},
  {FIM_COLLECT, {std_types__list___collect}},
  {FIM_DEBUG_STRING, {std_types__list___debug_string}},
  {FIM_GET_ITEM_OF, {std_types__list___get_item_of}},
  {FIM_UNFOLD, {std_types__list___unfold}},
  {FIM_LENGTH_OF, {std_types__list___length_of}}
};

static ATTRIBUTE_DEFINITION std_types__list__attributes[] = {
  {var_std__append, func__std_types__list__std__append},
  {var_std__drop, func__std_types__list__std__drop},
  {var_std__is_empty, func__std_types__list__std__is_empty},
  {var_std__is_not_empty, func__std_types__list__std__is_not_empty},
  {var_std__length_of, func__std_types__list__std__length_of},
  {var_std__peek, func__std_types__list__std__peek},
  {var_std__pop, func__std_types__list__std__pop},
  {var_std__push, func__std_types__list__std__push},
  {var_std__range, func__std_types__list__std__range},
  {var_std__spread, func__std_types__list__std__spread}
};

static INTERNAL_METHOD std_types__integer__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INTEGER)}},
  {FIM_COLLECT, {std_types__integer___collect}}
};

static INTERNAL_METHOD builtin_types__positive_integer__internal_methods[] = {
  {FIM_DEBUG_STRING, {builtin_types__positive_integer___debug_string}},
  {FIM_TO_DOUBLE, {builtin_types__positive_integer___to_double}},
  {FIM_TO_FLOAT, {builtin_types__positive_integer___to_float}},
  {FIM_TO_INT, {builtin_types__positive_integer___to_int}},
  {FIM_TO_LONG, {builtin_types__positive_integer___to_long}},
  {FIM_TO_UINT, {builtin_types__positive_integer___to_uint}},
  {FIM_TO_ULONG, {builtin_types__positive_integer___to_ulong}},
  {FIM_TO_INT8, {builtin_types__positive_integer___to_int8}},
  {FIM_TO_INT16, {builtin_types__positive_integer___to_int16}},
  {FIM_TO_INT32, {builtin_types__positive_integer___to_int32}},
  {FIM_TO_INT64, {builtin_types__positive_integer___to_int64}},
  {FIM_TO_UINT8, {builtin_types__positive_integer___to_uint8}},
  {FIM_TO_UINT16, {builtin_types__positive_integer___to_uint16}},
  {FIM_TO_UINT32, {builtin_types__positive_integer___to_uint32}},
  {FIM_TO_UINT64, {builtin_types__positive_integer___to_uint64}}
};

static ATTRIBUTE_DEFINITION builtin_types__positive_integer__attributes[] = {
  {var_std__bit_and, func__builtin_types__positive_integer__std__bit_and},
  {var_std__bit_or, func__builtin_types__positive_integer__std__bit_or},
  {var_std__bit_xor, func__builtin_types__positive_integer__std__bit_xor},
  {var_std__div, func__builtin_types__positive_integer__std__div},
  {var_std__equal, func__builtin_types__positive_integer__std__equal},
  {var_std__exit, func__builtin_types__positive_integer__std__exit},
  {var_std__exp, func__builtin_types__positive_integer__std__exp},
  {var_std__hash, func__builtin_types__positive_integer__std__hash},
  {var_std__less, func__builtin_types__positive_integer__std__less},
  {var_std__ln, func__builtin_types__positive_integer__std__ln},
  {var_std__minus, func__builtin_types__positive_integer__std__minus},
  {var_std__mod, func__builtin_types__positive_integer__std__mod},
  {var_std__negate, func__builtin_types__positive_integer__std__negate},
  {var_std__over, func__builtin_types__positive_integer__std__over},
  {var_std__plus, func__builtin_types__positive_integer__std__plus},
  {var_std__shift_left, func__builtin_types__positive_integer__std__shift_left},
  {var_std__shift_right, func__builtin_types__positive_integer__std__shift_right},
  {var_std__times, func__builtin_types__positive_integer__std__times},
  {var_std__to_integer, func__builtin_types__positive_integer__std__to_integer},
  {var_std__to_string, func__builtin_types__positive_integer__std__to_string}
};

static INTERNAL_METHOD builtin_types__negative_integer__internal_methods[] = {
  {FIM_DEBUG_STRING, {builtin_types__negative_integer___debug_string}},
  {FIM_TO_DOUBLE, {builtin_types__negative_integer___to_double}},
  {FIM_TO_FLOAT, {builtin_types__negative_integer___to_float}},
  {FIM_TO_INT, {builtin_types__negative_integer___to_int}},
  {FIM_TO_LONG, {builtin_types__negative_integer___to_long}},
  {FIM_TO_INT8, {builtin_types__negative_integer___to_int8}},
  {FIM_TO_INT16, {builtin_types__negative_integer___to_int16}},
  {FIM_TO_INT32, {builtin_types__negative_integer___to_int32}},
  {FIM_TO_INT64, {builtin_types__negative_integer___to_int64}}
};

static ATTRIBUTE_DEFINITION builtin_types__negative_integer__attributes[] = {
  {var_std__div, func__builtin_types__negative_integer__std__div},
  {var_std__equal, func__builtin_types__negative_integer__std__equal},
  {var_std__exp, func__builtin_types__negative_integer__std__exp},
  {var_std__hash, func__builtin_types__negative_integer__std__hash},
  {var_std__less, func__builtin_types__negative_integer__std__less},
  {var_std__ln, func__builtin_types__negative_integer__std__ln},
  {var_std__minus, func__builtin_types__negative_integer__std__minus},
  {var_std__mod, func__builtin_types__negative_integer__std__mod},
  {var_std__negate, func__builtin_types__negative_integer__std__negate},
  {var_std__over, func__builtin_types__negative_integer__std__over},
  {var_std__plus, func__builtin_types__negative_integer__std__plus},
  {var_std__times, func__builtin_types__negative_integer__std__times},
  {var_std__to_integer, func__builtin_types__negative_integer__std__to_integer},
  {var_std__to_string, func__builtin_types__negative_integer__std__to_string}
};

static INTERNAL_METHOD std_types__real__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(REAL)}},
  {FIM_COLLECT, {std_types__real___collect}},
  {FIM_DEBUG_STRING, {std_types__real___debug_string}},
  {FIM_TO_DOUBLE, {std_types__real___to_double}},
  {FIM_TO_FLOAT, {std_types__real___to_float}}
};

static ATTRIBUTE_DEFINITION std_types__real__attributes[] = {
  {var_std__ceil, func__std_types__real__std__ceil},
  {var_std__equal, func__std_types__real__std__equal},
  {var_std__exp, func__std_types__real__std__exp},
  {var_std__floor, func__std_types__real__std__floor},
  {var_std__hash, func__std_types__real__std__hash},
  {var_std__less, func__std_types__real__std__less},
  {var_std__ln, func__std_types__real__std__ln},
  {var_std__minus, func__std_types__real__std__minus},
  {var_std__negate, func__std_types__real__std__negate},
  {var_std__over, func__std_types__real__std__over},
  {var_std__plus, func__std_types__real__std__plus},
  {var_std__round, func__std_types__real__std__round},
  {var_std__times, func__std_types__real__std__times},
  {var_std__to_integer, func__std_types__real__std__to_integer},
  {var_std__to_string, func__std_types__real__std__to_string}
};

static INTERNAL_METHOD std_types__file_type__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FILE_TYPE)}},
  {FIM_COLLECT, {std_types__file_type___collect}},
  {FIM_DEBUG_STRING, {std_types__file_type___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__file_type__attributes[] = {
  {var_std__equal, func__std_types__file_type__std__equal},
  {var_std__hash, func__std_types__file_type__std__hash},
  {var_std__to_integer, func__std_types__file_type__std__to_integer}
};

static INTERNAL_METHOD std_types__file_descriptor__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(FILE_DESCRIPTOR)}},
  {FIM_COLLECT, {std_types__file_descriptor___collect}},
  {FIM_DEBUG_STRING, {std_types__file_descriptor___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__file_descriptor__attributes[] = {
  {var_std__close, func__std_types__file_descriptor__std__close},
  {var_std__equal, func__std_types__file_descriptor__std__equal},
  {var_std__get_terminal_attributes, func__std_types__file_descriptor__std__get_terminal_attributes},
  {var_std__get_terminal_size, func__std_types__file_descriptor__std__get_terminal_size},
  {var_std__hash, func__std_types__file_descriptor__std__hash},
  {var_std__read, func__std_types__file_descriptor__std__read},
  {var_std__set_terminal_attributes, func__std_types__file_descriptor__std__set_terminal_attributes},
  {var_std__to_integer, func__std_types__file_descriptor__std__to_integer},
  {var_std__write, func__std_types__file_descriptor__std__write}
};

static INTERNAL_METHOD std_types__signal_number__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(SIGNAL_NUMBER)}},
  {FIM_COLLECT, {std_types__signal_number___collect}},
  {FIM_DEBUG_STRING, {std_types__signal_number___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__signal_number__attributes[] = {
  {var_std__equal, func__std_types__signal_number__std__equal},
  {var_std__hash, func__std_types__signal_number__std__hash},
  {var_std__to_integer, func__std_types__signal_number__std__to_integer}
};

static INTERNAL_METHOD std_types__shutdown_type__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(SHUTDOWN_TYPE)}},
  {FIM_COLLECT, {std_types__shutdown_type___collect}},
  {FIM_DEBUG_STRING, {std_types__shutdown_type___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__shutdown_type__attributes[] = {
  {var_std__equal, func__std_types__shutdown_type__std__equal},
  {var_std__hash, func__std_types__shutdown_type__std__hash},
  {var_std__to_integer, func__std_types__shutdown_type__std__to_integer}
};

static INTERNAL_METHOD std_types__seek_type__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(SEEK_TYPE)}},
  {FIM_COLLECT, {std_types__seek_type___collect}},
  {FIM_DEBUG_STRING, {std_types__seek_type___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__seek_type__attributes[] = {
  {var_std__equal, func__std_types__seek_type__std__equal},
  {var_std__hash, func__std_types__seek_type__std__hash},
  {var_std__to_integer, func__std_types__seek_type__std__to_integer}
};

static INTERNAL_METHOD std_types__device_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(DEVICE_ID)}},
  {FIM_COLLECT, {std_types__device_id___collect}},
  {FIM_DEBUG_STRING, {std_types__device_id___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__device_id__attributes[] = {
  {var_std__equal, func__std_types__device_id__std__equal},
  {var_std__hash, func__std_types__device_id__std__hash},
  {var_std__to_integer, func__std_types__device_id__std__to_integer}
};

static INTERNAL_METHOD std_types__directory__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(DIRECTORY)}},
  {FIM_COLLECT, {std_types__directory___collect}},
  {FIM_DEBUG_STRING, {std_types__directory___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__directory__attributes[] = {
  {var_std__equal, func__std_types__directory__std__equal},
  {var_std__hash, func__std_types__directory__std__hash}
};

static INTERNAL_METHOD std_types__group_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(GROUP_ID)}},
  {FIM_COLLECT, {std_types__group_id___collect}},
  {FIM_DEBUG_STRING, {std_types__group_id___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__group_id__attributes[] = {
  {var_std__equal, func__std_types__group_id__std__equal},
  {var_std__hash, func__std_types__group_id__std__hash},
  {var_std__to_integer, func__std_types__group_id__std__to_integer}
};

static INTERNAL_METHOD std_types__inode_number__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(INODE_NUMBER)}},
  {FIM_COLLECT, {std_types__inode_number___collect}},
  {FIM_DEBUG_STRING, {std_types__inode_number___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__inode_number__attributes[] = {
  {var_std__equal, func__std_types__inode_number__std__equal},
  {var_std__hash, func__std_types__inode_number__std__hash},
  {var_std__to_integer, func__std_types__inode_number__std__to_integer}
};

static INTERNAL_METHOD std_types__process_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(PROCESS_ID)}},
  {FIM_COLLECT, {std_types__process_id___collect}},
  {FIM_DEBUG_STRING, {std_types__process_id___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__process_id__attributes[] = {
  {var_std__equal, func__std_types__process_id__std__equal},
  {var_std__hash, func__std_types__process_id__std__hash},
  {var_std__to_integer, func__std_types__process_id__std__to_integer}
};

static INTERNAL_METHOD std_types__user_id__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(USER_ID)}},
  {FIM_COLLECT, {std_types__user_id___collect}},
  {FIM_DEBUG_STRING, {std_types__user_id___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__user_id__attributes[] = {
  {var_std__equal, func__std_types__user_id__std__equal},
  {var_std__hash, func__std_types__user_id__std__hash},
  {var_std__to_integer, func__std_types__user_id__std__to_integer}
};

static INTERNAL_METHOD std_types__error_number__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(ERROR_NUMBER)}},
  {FIM_COLLECT, {std_types__error_number___collect}},
  {FIM_DEBUG_STRING, {std_types__error_number___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__error_number__attributes[] = {
  {var_std__equal, func__std_types__error_number__std__equal},
  {var_std__hash, func__std_types__error_number__std__hash},
  {var_std__to_integer, func__std_types__error_number__std__to_integer}
};

static ATTRIBUTE_DEFINITION std_types__passwd__attributes[] = {
  {-var_std__group_id_of, -var_std_types__undefined},
  {-var_std__home_directory_of, -var_std_types__undefined},
  {-var_std__password_of, -var_std_types__undefined},
  {-var_std__shell_of, -var_std_types__undefined},
  {-var_std__user_id_of, -var_std_types__undefined},
  {-var_std__user_information_of, -var_std_types__undefined},
  {-var_std__username_of, -var_std_types__undefined}
};

static ATTRIBUTE_DEFINITION std_types__stat__attributes[] = {
  {-var_std__access_time_of, -var_std_types__undefined},
  {-var_std__block_count_of, -var_std_types__undefined},
  {-var_std__block_size_of, -var_std_types__undefined},
  {-var_std__device_of, -var_std_types__undefined},
  {-var_std__group_id_of, -var_std_types__undefined},
  {-var_std__inode_number_of, -var_std_types__undefined},
  {-var_std__link_count_of, -var_std_types__undefined},
  {-var_std__mode_of, -var_std_types__undefined},
  {-var_std__modification_time_of, -var_std_types__undefined},
  {-var_std__root_device_of, -var_std_types__undefined},
  {-var_std__size_of, -var_std_types__undefined},
  {-var_std__status_change_time_of, -var_std_types__undefined},
  {-var_std__type_of, -var_std_types__undefined},
  {-var_std__user_id_of, -var_std_types__undefined}
};

static ATTRIBUTE_DEFINITION std_types__dirent__attributes[] = {
  {-var_std__inode_number_of, -var_std_types__undefined},
  {-var_std__name_of, -var_std_types__undefined},
  {-var_std__type_of, -var_std_types__undefined}
};

static INTERNAL_METHOD std_types__octet_string__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(OCTET_STRING)}},
  {FIM_COLLECT, {std_types__octet_string___collect}},
  {FIM_DEBUG_STRING, {std_types__octet_string___debug_string}},
  {FIM_GET_ITEM_OF, {std_types__octet_string___get_item_of}},
  {FIM_TO_C_STRING, {std_types__octet_string___to_c_string}},
  {FIM_TO_OCTETS, {std_types__octet_string___to_octets}},
  {FIM_LENGTH_OF, {std_types__octet_string___length_of}}
};

static ATTRIBUTE_DEFINITION std_types__octet_string__attributes[] = {
  {var_std__append, func__std_types__octet_string__std__append},
  {var_std__equal, func__std_types__octet_string__std__equal},
  {var_std__from_utf8, func__std_types__octet_string__std__from_utf8},
  {var_std__hash, func__std_types__octet_string__std__hash},
  {var_std__is_empty, func__std_types__octet_string__std__is_empty},
  {var_std__is_not_empty, func__std_types__octet_string__std__is_not_empty},
  {var_std__length_of, func__std_types__octet_string__std__length_of},
  {var_std__less, func__std_types__octet_string__std__less},
  {var_std__push, func__std_types__octet_string__std__push},
  {var_std__range, func__std_types__octet_string__std__range},
  {var_std__to_utf8, func__std_types__octet_string__std__to_utf8},
  {var_std__width_of, func__std_types__octet_string__std__width_of}
};

static INTERNAL_METHOD std_types__wide_string__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(WIDE_STRING)}},
  {FIM_COLLECT, {std_types__wide_string___collect}},
  {FIM_DEBUG_STRING, {std_types__wide_string___debug_string}},
  {FIM_GET_ITEM_OF, {std_types__wide_string___get_item_of}},
  {FIM_LENGTH_OF, {std_types__wide_string___length_of}}
};

static ATTRIBUTE_DEFINITION std_types__wide_string__attributes[] = {
  {var_std__append, func__std_types__wide_string__std__append},
  {var_std__equal, func__std_types__wide_string__std__equal},
  {var_std__hash, func__std_types__wide_string__std__hash},
  {var_std__is_empty, func__std_types__wide_string__std__is_empty},
  {var_std__is_not_empty, func__std_types__wide_string__std__is_not_empty},
  {var_std__length_of, func__std_types__wide_string__std__length_of},
  {var_std__less, func__std_types__wide_string__std__less},
  {var_std__push, func__std_types__wide_string__std__push},
  {var_std__range, func__std_types__wide_string__std__range},
  {var_std__to_utf8, func__std_types__wide_string__std__to_utf8},
  {var_std__width_of, func__std_types__wide_string__std__width_of}
};

static INTERNAL_METHOD std_types__terminal_attributes__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TERMINAL_ATTRIBUTES)}},
  {FIM_COLLECT, {std_types__terminal_attributes___collect}},
  {FIM_DEBUG_STRING, {std_types__terminal_attributes___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__terminal_attributes__attributes[] = {
  {var_std__backspace_character_of, func__std_types__terminal_attributes__std__backspace_character_of},
  {var_std__echo_characters, func__std_types__terminal_attributes__std__echo_characters},
  {var_std__echo_new_lines, func__std_types__terminal_attributes__std__echo_new_lines},
  {var_std__enable_xon_xoff_for_input, func__std_types__terminal_attributes__std__enable_xon_xoff_for_input},
  {var_std__enable_xon_xoff_for_output, func__std_types__terminal_attributes__std__enable_xon_xoff_for_output},
  {var_std__generate_signals, func__std_types__terminal_attributes__std__generate_signals},
  {var_std__hangup_on_close, func__std_types__terminal_attributes__std__hangup_on_close},
  {var_std__ignore_cr_on_input, func__std_types__terminal_attributes__std__ignore_cr_on_input},
  {var_std__input_speed, func__std_types__terminal_attributes__std__input_speed},
  {var_std__map_cr_to_lf_on_input, func__std_types__terminal_attributes__std__map_cr_to_lf_on_input},
  {var_std__map_lf_to_crlf_on_output, func__std_types__terminal_attributes__std__map_lf_to_crlf_on_output},
  {var_std__minimum_characters_for_canoncial_read, func__std_types__terminal_attributes__std__minimum_characters_for_canoncial_read},
  {var_std__output_speed, func__std_types__terminal_attributes__std__output_speed},
  {var_std__restart_output_on_any_character, func__std_types__terminal_attributes__std__restart_output_on_any_character},
  {var_std__timeout_for_reads, func__std_types__terminal_attributes__std__timeout_for_reads},
  {var_std__use_canonical_mode, func__std_types__terminal_attributes__std__use_canonical_mode}
};

static ATTRIBUTE_DEFINITION std_types__tuple__attributes[] = {
  {var_std__typed_tuple, func__std_types__tuple__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple2__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE2)}},
  {FIM_COLLECT, {builtin_types__tuple2___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple2___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple2__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple2__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple2__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple3__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE3)}},
  {FIM_COLLECT, {builtin_types__tuple3___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple3___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple3__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple3__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple3__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple4__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE4)}},
  {FIM_COLLECT, {builtin_types__tuple4___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple4___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple4__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple4__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple4__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple5__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE5)}},
  {FIM_COLLECT, {builtin_types__tuple5___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple5___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple5__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple5__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple5__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple6__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE6)}},
  {FIM_COLLECT, {builtin_types__tuple6___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple6___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple6__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple6__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple6__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple7__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE7)}},
  {FIM_COLLECT, {builtin_types__tuple7___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple7___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple7__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple7__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple7__std__typed_tuple}
};

static INTERNAL_METHOD builtin_types__tuple8__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(TUPLE8)}},
  {FIM_COLLECT, {builtin_types__tuple8___collect}},
  {FIM_DEBUG_STRING, {builtin_types__tuple8___debug_string}}
};

static ATTRIBUTE_DEFINITION builtin_types__tuple8__attributes[] = {
  {var_std__to_list, func__builtin_types__tuple8__std__to_list},
  {var_std__typed_tuple, func__builtin_types__tuple8__std__typed_tuple}
};

static INTERNAL_METHOD std_types__unique_item__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(UNIQUE_ITEM)}},
  {FIM_COLLECT, {std_types__unique_item___collect}},
  {FIM_DEBUG_STRING, {std_types__unique_item___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__unique_item__attributes[] = {
  {var_std__equal, func__std_types__unique_item__std__equal},
  {var_std__hash, func__std_types__unique_item__std__hash},
  {var_std__to_string, func__std_types__unique_item__std__to_string}
};

static INTERNAL_METHOD std_types__shared_memory__internal_methods[] = {
  {FIM_SIZE, {.size = sizeof(SHARED_MEMORY)}},
  {FIM_COLLECT, {std_types__shared_memory___collect}},
  {FIM_DEBUG_STRING, {std_types__shared_memory___debug_string}}
};

static ATTRIBUTE_DEFINITION std_types__shared_memory__attributes[] = {
  {var_std__file_descriptor_of, func__std_types__shared_memory__std__file_descriptor_of},
  {var_std__size_of, func__std_types__shared_memory__std__size_of},
  {var_std__write_at, func__std_types__shared_memory__std__write_at}
};

static FUNKY_VARIABLE variables_table[] = {
  {
    FOT_POLYMORPHIC, 0, 0,
    "new\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "plus\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "minus\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "times\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "over\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "div\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "mod\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "negate\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "floor\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "ceil\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "round\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "ln\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "exp\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "equal\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "less\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "shift_left\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "shift_right\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "bit_and\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "bit_or\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "bit_xor\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "parameter_count_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_string\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_integer\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_real\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_number\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_lower_case\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_upper_case\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_title_case\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "is_empty\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "is_not_empty\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "length_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "dimension_count_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "width_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "height_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "hash\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "push\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "pop\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "peek\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "drop\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "put\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "get\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "append\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "range\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "spread\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_list\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "exit\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "from_utf8\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "read\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "write\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "close\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "flush\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 0,
    "generic_array\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__generic_array}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "create_empty_array\000std", NULL,
    {.has_a_setter = true}
  },
  {
    FOT_TYPE, 0, 4,
    "array\000std_types", std_types__array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__array__internal_methods,
    {(NODE *)&std_types__array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "array\000std", NULL,
    {.const_idx = func__std__array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_array\000std", NULL,
    {.const_idx = func__std__initialized_array}
  },
  {
    FOT_TYPE, 0, 8,
    "boolean_array\000std_types", std_types__boolean_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__boolean_array__internal_methods,
    {(NODE *)&std_types__boolean_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "boolean_array\000std", NULL,
    {.const_idx = func__std__boolean_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_boolean_array\000std", NULL,
    {.const_idx = func__std__initialized_boolean_array}
  },
  {
    FOT_TYPE, 0, 5,
    "character_array\000std_types", std_types__character_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__character_array__internal_methods,
    {(NODE *)&std_types__character_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "character_array\000std", NULL,
    {.const_idx = func__std__character_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_character_array\000std", NULL,
    {.const_idx = func__std__initialized_character_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int8_array\000std_types", std_types__int8_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__int8_array__internal_methods,
    {(NODE *)&std_types__int8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int8_array\000std", NULL,
    {.const_idx = func__std__int8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int8_array\000std", NULL,
    {.const_idx = func__std__initialized_int8_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint8_array\000std_types", std_types__uint8_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__uint8_array__internal_methods,
    {(NODE *)&std_types__uint8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint8_array\000std", NULL,
    {.const_idx = func__std__uint8_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint8_array\000std", NULL,
    {.const_idx = func__std__initialized_uint8_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int16_array\000std_types", std_types__int16_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__int16_array__internal_methods,
    {(NODE *)&std_types__int16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int16_array\000std", NULL,
    {.const_idx = func__std__int16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int16_array\000std", NULL,
    {.const_idx = func__std__initialized_int16_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint16_array\000std_types", std_types__uint16_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__uint16_array__internal_methods,
    {(NODE *)&std_types__uint16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint16_array\000std", NULL,
    {.const_idx = func__std__uint16_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint16_array\000std", NULL,
    {.const_idx = func__std__initialized_uint16_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int32_array\000std_types", std_types__int32_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__int32_array__internal_methods,
    {(NODE *)&std_types__int32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int32_array\000std", NULL,
    {.const_idx = func__std__int32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int32_array\000std", NULL,
    {.const_idx = func__std__initialized_int32_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint32_array\000std_types", std_types__uint32_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__uint32_array__internal_methods,
    {(NODE *)&std_types__uint32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint32_array\000std", NULL,
    {.const_idx = func__std__uint32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint32_array\000std", NULL,
    {.const_idx = func__std__initialized_uint32_array}
  },
  {
    FOT_TYPE, 0, 6,
    "int64_array\000std_types", std_types__int64_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__int64_array__internal_methods,
    {(NODE *)&std_types__int64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "int64_array\000std", NULL,
    {.const_idx = func__std__int64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_int64_array\000std", NULL,
    {.const_idx = func__std__initialized_int64_array}
  },
  {
    FOT_TYPE, 0, 9,
    "uint64_array\000std_types", std_types__uint64_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__uint64_array__internal_methods,
    {(NODE *)&std_types__uint64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "uint64_array\000std", NULL,
    {.const_idx = func__std__uint64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_uint64_array\000std", NULL,
    {.const_idx = func__std__initialized_uint64_array}
  },
  {
    FOT_TYPE, 0, 6,
    "float32_array\000std_types", std_types__float32_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__float32_array__internal_methods,
    {(NODE *)&std_types__float32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "float32_array\000std", NULL,
    {.const_idx = func__std__float32_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_float32_array\000std", NULL,
    {.const_idx = func__std__initialized_float32_array}
  },
  {
    FOT_TYPE, 0, 6,
    "float64_array\000std_types", std_types__float64_array__attributes,
    {"generic_array\000std_types"},
    {.methods_count = 3}, 0,
    std_types__float64_array__internal_methods,
    {(NODE *)&std_types__float64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "float64_array\000std", NULL,
    {.const_idx = func__std__float64_array}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "initialized_float64_array\000std", NULL,
    {.const_idx = func__std__initialized_float64_array}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXIT_SUCCESS\000std", NULL,
    {"positive_integer\000builtin_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EXIT_SUCCESS}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXIT_FAILURE\000std", NULL,
    {"positive_integer\000builtin_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EXIT_FAILURE}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "pass\000std", NULL,
    {.const_idx = func__std__pass}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "result_count\000std", NULL,
    {.const_idx = func__std__result_count}
  },
  {
    FOT_TYPE, 0, 1,
    "true\000std_types", std_types__true__attributes,
    {"object\000std_types"},
    {.methods_count = 2}, 0,
    std_types__true__internal_methods,
    {(NODE *)&std_types__true}
  },
  {
    FOT_TYPE, 0, 1,
    "false\000std_types", std_types__false__attributes,
    {"object\000std_types"},
    {.methods_count = 2}, 0,
    std_types__false__internal_methods,
    {(NODE *)&std_types__false}
  },
  {
    FOT_TYPE, 0, 1,
    "c_function\000", c_function__attributes,
    {"function\000std_types"},
    {.methods_count = 3}, 0,
    c_function__internal_methods,
    {(NODE *)&c_function}
  },
  {
    FOT_TYPE, 0, 11,
    "character\000std_types", std_types__character__attributes,
    {"object\000std_types"},
    {.methods_count = 4}, 0,
    std_types__character__internal_methods,
    {(NODE *)&std_types__character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "character\000std", NULL,
    {.const_idx = func__std__character}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "year_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "month_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "day_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "day_of_week_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "hour_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "minute_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "second_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "time_shift_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "seconds_since_epoch\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 13,
    "date_and_time\000std_types", std_types__date_and_time__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__date_and_time__internal_methods,
    {(NODE *)&std_types__date_and_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "from_unix_time\000std", NULL,
    {.const_idx = func__std__from_unix_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "date_and_time\000std", NULL,
    {.const_idx = func__std__date_and_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "current_time\000std", NULL,
    {.const_idx = func__std__current_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "current_time\000debug", NULL,
    {.const_idx = func__debug__current_time}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "string\000debug", NULL,
    {.const_idx = func__debug__string}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "write\000debug", NULL,
    {.const_idx = func__debug__write}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "dump_object\000debug", NULL,
    {.const_idx = func__debug__dump_object}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "has_io_access_rights\000debug", NULL,
    {.const_idx = func__debug__has_io_access_rights}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "exit\000debug", NULL,
    {.const_idx = func__debug__exit}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "error_check\000std", NULL,
    {.const_idx = func__std__error_check}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "total_garbage_collections\000debug", NULL,
    {.const_idx = func__debug__total_garbage_collections}
  },
  {
    FOT_OBJECT, 0, 0,
    "program_name\000std", NULL,
    {"octet_string\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__program_name}
  },
  {
    FOT_OBJECT, 0, 0,
    "command_line_arguments\000std", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__command_line_arguments}
  },
  {
    FOT_OBJECT, 0, 0,
    "environment_variables\000std", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__environment_variables}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "installation_prefix\000std", NULL,
    {.const_idx = func__std__installation_prefix}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "package_version\000std", NULL,
    {.const_idx = func__std__package_version}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "IO_ERROR\000std", NULL,
    {.const_idx = unique__std__IO_ERROR}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "RUNTIME_ERROR\000std", NULL,
    {.const_idx = unique__std__RUNTIME_ERROR}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "APPLICATION_ERROR\000std", NULL,
    {.const_idx = unique__std__APPLICATION_ERROR}
  },
  {
    FOT_TYPE, 0, 5,
    "error\000std_types", std_types__error__attributes,
    {NULL},
    {.methods_count = 24}, 0,
    std_types__error__internal_methods,
    {(NODE *)&std_types__error}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "error_category_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "error_message_text_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "error_details_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "errno_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "failed_attribute_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "error\000std", NULL,
    {.const_idx = func__std__error}
  },
  {
    FOT_TYPE, 0, 1,
    "object\000std_types", std_types__object__attributes,
    {NULL},
    {.methods_count = 23}, 0,
    std_types__object__internal_methods,
    {(NODE *)&std_types__object}
  },
  {
    FOT_TYPE, 0, 0,
    "undefined\000std_types", NULL,
    {NULL},
    {.methods_count = 23}, 0,
    std_types__undefined__internal_methods,
    {(NODE *)&std_types__undefined}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "exec\000std", NULL,
    {.const_idx = func__std__exec}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "create_process\000std", NULL,
    {.const_idx = func__std__create_process}
  },
  {
    FOT_TYPE, 0, 2,
    "function\000std_types", std_types__function__attributes,
    {"object\000std_types"},
    {.methods_count = 1}, 0,
    std_types__function__internal_methods,
    {(NODE *)&std_types__function}
  },
  {
    FOT_TYPE, 0, 0,
    "tabular_function\000", NULL,
    {"function\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&tabular_function}
  },
  {
    FOT_OBJECT, 0, 0,
    "key_value_pair\000std_types", NULL,
    {"tuple2\000builtin_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__key_value_pair}
  },
  {
    FOT_TYPE, 0, 0,
    "generic_list\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__generic_list}
  },
  {
    FOT_TYPE, 0, 10,
    "list\000std_types", std_types__list__attributes,
    {"generic_list\000std_types"},
    {.methods_count = 6}, 0,
    std_types__list__internal_methods,
    {(NODE *)&std_types__list}
  },
  {
    FOT_OBJECT, 0, 0,
    "empty_list\000std", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__empty_list}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "list\000std", NULL,
    {.const_idx = func__std__list}
  },
  {
    FOT_TYPE, 0, 0,
    "number\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__number}
  },
  {
    FOT_TYPE, 0, 0,
    "integer\000std_types", NULL,
    {"number\000std_types"},
    {.methods_count = 2}, 0,
    std_types__integer__internal_methods,
    {(NODE *)&std_types__integer}
  },
  {
    FOT_TYPE, 0, 20,
    "positive_integer\000builtin_types", builtin_types__positive_integer__attributes,
    {"integer\000std_types"},
    {.methods_count = 15}, 0,
    builtin_types__positive_integer__internal_methods,
    {(NODE *)&builtin_types__positive_integer}
  },
  {
    FOT_TYPE, 0, 14,
    "negative_integer\000builtin_types", builtin_types__negative_integer__attributes,
    {"integer\000std_types"},
    {.methods_count = 9}, 0,
    builtin_types__negative_integer__internal_methods,
    {(NODE *)&builtin_types__negative_integer}
  },
  {
    FOT_TYPE, 0, 15,
    "real\000std_types", std_types__real__attributes,
    {"number\000std_types"},
    {.methods_count = 5}, 0,
    std_types__real__internal_methods,
    {(NODE *)&std_types__real}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "real\000std", NULL,
    {.const_idx = func__std__real}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "integer\000std", NULL,
    {.const_idx = func__std__integer}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "sqrt\000std", NULL,
    {.const_idx = func__std__sqrt}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "pow\000std", NULL,
    {.const_idx = func__std__pow}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "sin\000std", NULL,
    {.const_idx = func__std__sin}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "cos\000std", NULL,
    {.const_idx = func__std__cos}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "tan\000std", NULL,
    {.const_idx = func__std__tan}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "asin\000std", NULL,
    {.const_idx = func__std__asin}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "acos\000std", NULL,
    {.const_idx = func__std__acos}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "atan\000std", NULL,
    {.const_idx = func__std__atan}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "object_type\000debug", NULL,
    {.const_idx = func__debug__object_type}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "object_attributes\000debug", NULL,
    {.const_idx = func__debug__object_attributes}
  },
  {
    FOT_TYPE, 0, 0,
    "polymorphic_function\000std_types", NULL,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__polymorphic_function}
  },
  {
    FOT_TYPE, 0, 0,
    "polymorphic_function_with_setter\000std_types", NULL,
    {"polymorphic_function\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__polymorphic_function_with_setter}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "subtype_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_OBJECT, 0, 0,
    "BLOCK_DEVICE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__BLOCK_DEVICE}
  },
  {
    FOT_OBJECT, 0, 0,
    "CHARACTER_DEVICE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__CHARACTER_DEVICE}
  },
  {
    FOT_OBJECT, 0, 0,
    "DIRECTORY\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__DIRECTORY}
  },
  {
    FOT_OBJECT, 0, 0,
    "NAMED_PIPE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__NAMED_PIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SYMBOLIC_LINK\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SYMBOLIC_LINK}
  },
  {
    FOT_OBJECT, 0, 0,
    "REGULAR_FILE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__REGULAR_FILE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SOCKET\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SOCKET}
  },
  {
    FOT_OBJECT, 0, 0,
    "UNKNOWN_FILE_TYPE\000std", NULL,
    {"file_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__UNKNOWN_FILE_TYPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "STDIN_FILENO\000std", NULL,
    {"file_descriptor\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__STDIN_FILENO}
  },
  {
    FOT_OBJECT, 0, 0,
    "STDOUT_FILENO\000std", NULL,
    {"file_descriptor\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__STDOUT_FILENO}
  },
  {
    FOT_OBJECT, 0, 0,
    "STDERR_FILENO\000std", NULL,
    {"file_descriptor\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__STDERR_FILENO}
  },
  {
    FOT_OBJECT, 0, 0,
    "SHUT_RD\000std", NULL,
    {"shutdown_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SHUT_RD}
  },
  {
    FOT_OBJECT, 0, 0,
    "SHUT_WR\000std", NULL,
    {"shutdown_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SHUT_WR}
  },
  {
    FOT_OBJECT, 0, 0,
    "SHUT_RDWR\000std", NULL,
    {"shutdown_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SHUT_RDWR}
  },
  {
    FOT_OBJECT, 0, 0,
    "SEEK_SET\000std", NULL,
    {"seek_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SEEK_SET}
  },
  {
    FOT_OBJECT, 0, 0,
    "SEEK_CUR\000std", NULL,
    {"seek_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SEEK_CUR}
  },
  {
    FOT_OBJECT, 0, 0,
    "SEEK_END\000std", NULL,
    {"seek_type\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SEEK_END}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOERR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOERR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPERM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EPERM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOENT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOENT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESRCH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESRCH}
  },
  {
    FOT_OBJECT, 0, 0,
    "EINTR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EINTR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EIO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EIO}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENXIO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENXIO}
  },
  {
    FOT_OBJECT, 0, 0,
    "E2BIG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__E2BIG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOEXEC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOEXEC}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADF\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADF}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECHILD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECHILD}
  },
  {
    FOT_OBJECT, 0, 0,
    "EAGAIN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EAGAIN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOMEM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOMEM}
  },
  {
    FOT_OBJECT, 0, 0,
    "EACCES\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EACCES}
  },
  {
    FOT_OBJECT, 0, 0,
    "EFAULT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EFAULT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTBLK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTBLK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBUSY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBUSY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EEXIST\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EEXIST}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXDEV\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EXDEV}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENODEV\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENODEV}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTDIR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTDIR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EISDIR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EISDIR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EINVAL\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EINVAL}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENFILE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENFILE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMFILE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EMFILE}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTTY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTTY}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETXTBSY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ETXTBSY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EFBIG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EFBIG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSPC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOSPC}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESPIPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EROFS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EROFS}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMLINK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EMLINK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPIPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDOM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EDOM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ERANGE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ERANGE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDEADLK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EDEADLK}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENAMETOOLONG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENAMETOOLONG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOLCK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOLCK}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSYS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOSYS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTEMPTY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTEMPTY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EILSEQ\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EILSEQ}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELOOP\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELOOP}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOMSG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOMSG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EIDRM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EIDRM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECHRNG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECHRNG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL2NSYNC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EL2NSYNC}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL3HLT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EL3HLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL3RST\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EL3RST}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELNRNG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELNRNG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EUNATCH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EUNATCH}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOCSI\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOCSI}
  },
  {
    FOT_OBJECT, 0, 0,
    "EL2HLT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EL2HLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADR}
  },
  {
    FOT_OBJECT, 0, 0,
    "EXFULL\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EXFULL}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOANO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOANO}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADRQC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADRQC}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADSLT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADSLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBFONT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBFONT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSTR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOSTR}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENODATA\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENODATA}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETIME\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ETIME}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOSR\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOSR}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENONET\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENONET}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOPKG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOPKG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EREMOTE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EREMOTE}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOLINK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOLINK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EADV\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EADV}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESRMNT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESRMNT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECOMM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECOMM}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPROTO\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EPROTO}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMULTIHOP\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EMULTIHOP}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDOTDOT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EDOTDOT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADMSG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADMSG}
  },
  {
    FOT_OBJECT, 0, 0,
    "EOVERFLOW\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EOVERFLOW}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTUNIQ\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTUNIQ}
  },
  {
    FOT_OBJECT, 0, 0,
    "EBADFD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EBADFD}
  },
  {
    FOT_OBJECT, 0, 0,
    "EREMCHG\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EREMCHG}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBACC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELIBACC}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBBAD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELIBBAD}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBSCN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELIBSCN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBMAX\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELIBMAX}
  },
  {
    FOT_OBJECT, 0, 0,
    "ELIBEXEC\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ELIBEXEC}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESTRPIPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESTRPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EUSERS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EUSERS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTSOCK\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTSOCK}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDESTADDRREQ\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EDESTADDRREQ}
  },
  {
    FOT_OBJECT, 0, 0,
    "EMSGSIZE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EMSGSIZE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPROTOTYPE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EPROTOTYPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOPROTOOPT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOPROTOOPT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPROTONOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EPROTONOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESOCKTNOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESOCKTNOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EOPNOTSUPP\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EOPNOTSUPP}
  },
  {
    FOT_OBJECT, 0, 0,
    "EPFNOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EPFNOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EAFNOSUPPORT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EAFNOSUPPORT}
  },
  {
    FOT_OBJECT, 0, 0,
    "EADDRINUSE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EADDRINUSE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EADDRNOTAVAIL\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EADDRNOTAVAIL}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENETDOWN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENETDOWN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENETUNREACH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENETUNREACH}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENETRESET\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENETRESET}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECONNABORTED\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECONNABORTED}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECONNRESET\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECONNRESET}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOBUFS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOBUFS}
  },
  {
    FOT_OBJECT, 0, 0,
    "EISCONN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EISCONN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTCONN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTCONN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESHUTDOWN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESHUTDOWN}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETOOMANYREFS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ETOOMANYREFS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ETIMEDOUT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ETIMEDOUT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECONNREFUSED\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECONNREFUSED}
  },
  {
    FOT_OBJECT, 0, 0,
    "EHOSTDOWN\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EHOSTDOWN}
  },
  {
    FOT_OBJECT, 0, 0,
    "EHOSTUNREACH\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EHOSTUNREACH}
  },
  {
    FOT_OBJECT, 0, 0,
    "EALREADY\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EALREADY}
  },
  {
    FOT_OBJECT, 0, 0,
    "EINPROGRESS\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EINPROGRESS}
  },
  {
    FOT_OBJECT, 0, 0,
    "ESTALE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ESTALE}
  },
  {
    FOT_OBJECT, 0, 0,
    "EDQUOT\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EDQUOT}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOMEDIUM\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOMEDIUM}
  },
  {
    FOT_OBJECT, 0, 0,
    "ECANCELED\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ECANCELED}
  },
  {
    FOT_OBJECT, 0, 0,
    "EOWNERDEAD\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__EOWNERDEAD}
  },
  {
    FOT_OBJECT, 0, 0,
    "ENOTRECOVERABLE\000std", NULL,
    {"error_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__ENOTRECOVERABLE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGHUP\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGHUP}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGINT\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGINT}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGQUIT\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGQUIT}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGILL\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGILL}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGTRAP\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGTRAP}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGABRT\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGABRT}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGIOT\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGIOT}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGBUS\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGBUS}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGFPE\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGFPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGKILL\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGKILL}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGUSR1\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGUSR1}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGSEGV\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGSEGV}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGUSR2\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGUSR2}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGPIPE\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGPIPE}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGALRM\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGALRM}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGTERM\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGTERM}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGSTKFLT\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGSTKFLT}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGCHLD\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGCHLD}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGCONT\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGCONT}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGSTOP\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGSTOP}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGTSTP\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGTSTP}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGTTIN\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGTTIN}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGTTOU\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGTTOU}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGURG\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGURG}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGXCPU\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGXCPU}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGXFSZ\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGXFSZ}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGVTALRM\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGVTALRM}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGPROF\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGPROF}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGWINCH\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGWINCH}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGIO\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGIO}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGPWR\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGPWR}
  },
  {
    FOT_OBJECT, 0, 0,
    "SIGSYS\000std", NULL,
    {"signal_number\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__SIGSYS}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "access_time_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "block_count_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "block_size_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "device_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "group_id_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "home_directory_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "inode_number_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "link_count_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "mode_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "modification_time_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "name_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "password_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "root_device_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "shell_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "size_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "status_change_time_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "type_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "user_id_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "user_information_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "username_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 3,
    "file_type\000std_types", std_types__file_type__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__file_type__internal_methods,
    {(NODE *)&std_types__file_type}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "file_type\000std", NULL,
    {.const_idx = func__std__file_type}
  },
  {
    FOT_TYPE, 0, 9,
    "file_descriptor\000std_types", std_types__file_descriptor__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__file_descriptor__internal_methods,
    {(NODE *)&std_types__file_descriptor}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "file_descriptor\000std", NULL,
    {.const_idx = func__std__file_descriptor}
  },
  {
    FOT_TYPE, 0, 3,
    "signal_number\000std_types", std_types__signal_number__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__signal_number__internal_methods,
    {(NODE *)&std_types__signal_number}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "signal_number\000std", NULL,
    {.const_idx = func__std__signal_number}
  },
  {
    FOT_TYPE, 0, 3,
    "shutdown_type\000std_types", std_types__shutdown_type__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__shutdown_type__internal_methods,
    {(NODE *)&std_types__shutdown_type}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "shutdown_type\000std", NULL,
    {.const_idx = func__std__shutdown_type}
  },
  {
    FOT_TYPE, 0, 3,
    "seek_type\000std_types", std_types__seek_type__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__seek_type__internal_methods,
    {(NODE *)&std_types__seek_type}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "seek_type\000std", NULL,
    {.const_idx = func__std__seek_type}
  },
  {
    FOT_TYPE, 0, 3,
    "device_id\000std_types", std_types__device_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__device_id__internal_methods,
    {(NODE *)&std_types__device_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "device_id\000std", NULL,
    {.const_idx = func__std__device_id}
  },
  {
    FOT_TYPE, 0, 2,
    "directory\000std_types", std_types__directory__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__directory__internal_methods,
    {(NODE *)&std_types__directory}
  },
  {
    FOT_TYPE, 0, 3,
    "group_id\000std_types", std_types__group_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__group_id__internal_methods,
    {(NODE *)&std_types__group_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "group_id\000std", NULL,
    {.const_idx = func__std__group_id}
  },
  {
    FOT_TYPE, 0, 3,
    "inode_number\000std_types", std_types__inode_number__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__inode_number__internal_methods,
    {(NODE *)&std_types__inode_number}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "inode_number\000std", NULL,
    {.const_idx = func__std__inode_number}
  },
  {
    FOT_TYPE, 0, 3,
    "process_id\000std_types", std_types__process_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__process_id__internal_methods,
    {(NODE *)&std_types__process_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "process_id\000std", NULL,
    {.const_idx = func__std__process_id}
  },
  {
    FOT_TYPE, 0, 3,
    "user_id\000std_types", std_types__user_id__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__user_id__internal_methods,
    {(NODE *)&std_types__user_id}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "user_id\000std", NULL,
    {.const_idx = func__std__user_id}
  },
  {
    FOT_TYPE, 0, 3,
    "error_number\000std_types", std_types__error_number__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__error_number__internal_methods,
    {(NODE *)&std_types__error_number}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "error_number\000std", NULL,
    {.const_idx = func__std__error_number}
  },
  {
    FOT_TYPE, 0, 7,
    "passwd\000std_types", std_types__passwd__attributes,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__passwd}
  },
  {
    FOT_TYPE, 0, 14,
    "stat\000std_types", std_types__stat__attributes,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__stat}
  },
  {
    FOT_TYPE, 0, 3,
    "dirent\000std_types", std_types__dirent__attributes,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__dirent}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "access\000std", NULL,
    {.const_idx = func__std__access}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chdir\000std", NULL,
    {.const_idx = func__std__chdir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chmod\000std", NULL,
    {.const_idx = func__std__chmod}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chown\000std", NULL,
    {.const_idx = func__std__chown}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "chroot\000std", NULL,
    {.const_idx = func__std__chroot}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "closedir\000std", NULL,
    {.const_idx = func__std__closedir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "dup2\000std", NULL,
    {.const_idx = func__std__dup2}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "fstat\000std", NULL,
    {.const_idx = func__std__fstat}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "fsync\000std", NULL,
    {.const_idx = func__std__fsync}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getcwd\000std", NULL,
    {.const_idx = func__std__getcwd}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getenv\000std", NULL,
    {.const_idx = func__std__getenv}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getegid\000std", NULL,
    {.const_idx = func__std__getegid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "geteuid\000std", NULL,
    {.const_idx = func__std__geteuid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getgid\000std", NULL,
    {.const_idx = func__std__getgid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "gethostname\000std", NULL,
    {.const_idx = func__std__gethostname}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getlogin\000std", NULL,
    {.const_idx = func__std__getlogin}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getpid\000std", NULL,
    {.const_idx = func__std__getpid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getppid\000std", NULL,
    {.const_idx = func__std__getppid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getpwuid\000std", NULL,
    {.const_idx = func__std__getpwuid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getsid\000std", NULL,
    {.const_idx = func__std__getsid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "getuid\000std", NULL,
    {.const_idx = func__std__getuid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "isatty\000std", NULL,
    {.const_idx = func__std__isatty}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "kill\000std", NULL,
    {.const_idx = func__std__kill}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "link\000std", NULL,
    {.const_idx = func__std__link}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "lseek\000std", NULL,
    {.const_idx = func__std__lseek}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "mkdir\000std", NULL,
    {.const_idx = func__std__mkdir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "mkfifo\000std", NULL,
    {.const_idx = func__std__mkfifo}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open\000std", NULL,
    {.const_idx = func__std__open}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "opendir\000std", NULL,
    {.const_idx = func__std__opendir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "readdir\000std", NULL,
    {.const_idx = func__std__readdir}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "realpath\000std", NULL,
    {.const_idx = func__std__realpath}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "rename\000std", NULL,
    {.const_idx = func__std__rename}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "sethostname\000std", NULL,
    {.const_idx = func__std__sethostname}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "shutdown\000std", NULL,
    {.const_idx = func__std__shutdown}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "stat\000std", NULL,
    {.const_idx = func__std__stat}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "strerror\000std", NULL,
    {.const_idx = func__std__strerror}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "wait\000std", NULL,
    {.const_idx = func__std__wait}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "umask\000std", NULL,
    {.const_idx = func__std__umask}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "unlink\000std", NULL,
    {.const_idx = func__std__unlink}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "shm_unlink\000std", NULL,
    {.const_idx = func__std__shm_unlink}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "usleep\000std", NULL,
    {.const_idx = func__std__usleep}
  },
  {
    FOT_OBJECT, 0, 0,
    "sequence\000std_types", NULL,
    {"list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__sequence}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "to_utf8\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 0,
    "string\000std_types", NULL,
    {"generic_list\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__string}
  },
  {
    FOT_TYPE, 0, 12,
    "octet_string\000std_types", std_types__octet_string__attributes,
    {"string\000std_types"},
    {.methods_count = 7}, 0,
    std_types__octet_string__internal_methods,
    {(NODE *)&std_types__octet_string}
  },
  {
    FOT_TYPE, 0, 11,
    "wide_string\000std_types", std_types__wide_string__attributes,
    {"string\000std_types"},
    {.methods_count = 5}, 0,
    std_types__wide_string__internal_methods,
    {(NODE *)&std_types__wide_string}
  },
  {
    FOT_OBJECT, 0, 0,
    "empty_string\000std", NULL,
    {"octet_string\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std__empty_string}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "get_terminal_attributes\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "set_terminal_attributes\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "backspace_character_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "use_canonical_mode\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "echo_characters\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "echo_new_lines\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "enable_xon_xoff_for_input\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "enable_xon_xoff_for_output\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "restart_output_on_any_character\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "ignore_cr_on_input\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "generate_signals\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "map_cr_to_lf_on_input\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "hangup_on_close\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "map_lf_to_crlf_on_output\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "minimum_characters_for_canoncial_read\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "timeout_for_reads\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "input_speed\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "output_speed\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 16,
    "terminal_attributes\000std_types", std_types__terminal_attributes__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__terminal_attributes__internal_methods,
    {(NODE *)&std_types__terminal_attributes}
  },
  {
    FOT_TYPE, 0, 1,
    "tuple\000std_types", std_types__tuple__attributes,
    {"object\000std_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__tuple}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "typed_tuple\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple2\000builtin_types", builtin_types__tuple2__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple2__internal_methods,
    {(NODE *)&builtin_types__tuple2}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple3\000builtin_types", builtin_types__tuple3__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple3__internal_methods,
    {(NODE *)&builtin_types__tuple3}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple4\000builtin_types", builtin_types__tuple4__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple4__internal_methods,
    {(NODE *)&builtin_types__tuple4}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple5\000builtin_types", builtin_types__tuple5__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple5__internal_methods,
    {(NODE *)&builtin_types__tuple5}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple6\000builtin_types", builtin_types__tuple6__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple6__internal_methods,
    {(NODE *)&builtin_types__tuple6}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple7\000builtin_types", builtin_types__tuple7__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple7__internal_methods,
    {(NODE *)&builtin_types__tuple7}
  },
  {
    FOT_TYPE, 0, 2,
    "tuple8\000builtin_types", builtin_types__tuple8__attributes,
    {"tuple\000std_types"},
    {.methods_count = 3}, 0,
    builtin_types__tuple8__internal_methods,
    {(NODE *)&builtin_types__tuple8}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "tuple\000std", NULL,
    {.const_idx = func__std__tuple}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "tuple_or_error\000std", NULL,
    {.const_idx = func__std__tuple_or_error}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "new_tuple\000std", NULL,
    {.const_idx = func__std__new_tuple}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_an_upper_case_letter_character\000std", NULL,
    {.const_idx = func__std__is_an_upper_case_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_lower_case_letter_character\000std", NULL,
    {.const_idx = func__std__is_a_lower_case_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_title_case_letter_character\000std", NULL,
    {.const_idx = func__std__is_a_title_case_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_letter_character\000std", NULL,
    {.const_idx = func__std__is_a_letter_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_whitespace_character\000std", NULL,
    {.const_idx = func__std__is_a_whitespace_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_zero_width_character\000std", NULL,
    {.const_idx = func__std__is_a_zero_width_character}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_a_wide_character\000std", NULL,
    {.const_idx = func__std__is_a_wide_character}
  },
  {
    FOT_TYPE, 0, 3,
    "unique_item\000std_types", std_types__unique_item__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__unique_item__internal_methods,
    {(NODE *)&std_types__unique_item}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "unique_item\000std", NULL,
    {.const_idx = func__std__unique_item}
  },
  {
    FOT_OBJECT, 0, 0,
    "value_range\000std_types", NULL,
    {"tuple2\000builtin_types"},
    {.methods_count = 0}, 0,
    NULL,
    {(NODE *)&std_types__value_range}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "get_terminal_size\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "exitstatus\000std", NULL,
    {.const_idx = func__std__exitstatus}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "pselect\000std", NULL,
    {.const_idx = func__std__pselect}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "do_not_close\000std", NULL,
    {.const_idx = func__std__do_not_close}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "waitpid\000std", NULL,
    {.const_idx = func__std__waitpid}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open_unix_socket\000std", NULL,
    {.const_idx = func__std__open_unix_socket}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "send_file_descriptor\000std", NULL,
    {.const_idx = func__std__send_file_descriptor}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open_tcp_client_socket\000std", NULL,
    {.const_idx = func__std__open_tcp_client_socket}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "open_tcp_server_socket\000std", NULL,
    {.const_idx = func__std__open_tcp_server_socket}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "accept\000std", NULL,
    {.const_idx = func__std__accept}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "is_listening\000std", NULL,
    {.const_idx = func__std__is_listening}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "get_first_mac_address\000std", NULL,
    {.const_idx = func__std__get_first_mac_address}
  },
  {
    FOT_TYPE, 0, 3,
    "shared_memory\000std_types", std_types__shared_memory__attributes,
    {"object\000std_types"},
    {.methods_count = 3}, 0,
    std_types__shared_memory__internal_methods,
    {(NODE *)&std_types__shared_memory}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "file_descriptor_of\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_POLYMORPHIC, 0, 0,
    "write_at\000std", NULL,
    {.has_a_setter = false}
  },
  {
    FOT_INITIALIZED, 0, 0,
    "create_shared_memory\000std", NULL,
    {.const_idx = func__std__create_shared_memory}
  }
};

FUNKY_MODULE module__builtin = {
  "_builtin",
  "_builtin",
  0, 0,
  4, 0,
  420, 486,
  NULL,
  defined_namespaces, NULL,
  constants_table, variables_table
};

BUILTIN_FUNCTION_NAME builtin_function_names[479] = {
  {std_types__generic_array___type, "std_types::generic_array/_type"},
  {std_types__array___type, "std_types::array/_type"},
  {entry__std_types__array__std__length_of, "std_types::array/length_of"},
  {entry__std_types__array__std__dimension_count_of, "std_types::array/dimension_count_of"},
  {entry__std__array, "std::array"},
  {entry__std__initialized_array, "std::initialized_array"},
  {entry__std_types__array__std__create_empty_array, "std_types::array/create_empty_array"},
  {entry__std_types__array__std__range, "std_types::array/range"},
  {std_types__boolean_array___type, "std_types::boolean_array/_type"},
  {entry__std_types__boolean_array__std__length_of, "std_types::boolean_array/length_of"},
  {entry__std_types__boolean_array__std__dimension_count_of, "std_types::boolean_array/dimension_count_of"},
  {entry__std_types__boolean_array__std__equal, "std_types::boolean_array/equal"},
  {entry__std_types__boolean_array__std__bit_and, "std_types::boolean_array/bit_and"},
  {entry__std_types__boolean_array__std__bit_or, "std_types::boolean_array/bit_or"},
  {entry__std_types__boolean_array__std__bit_xor, "std_types::boolean_array/bit_xor"},
  {entry__std__boolean_array, "std::boolean_array"},
  {entry__std__initialized_boolean_array, "std::initialized_boolean_array"},
  {entry__std_types__boolean_array__std__create_empty_array, "std_types::boolean_array/create_empty_array"},
  {entry__std_types__boolean_array__std__range, "std_types::boolean_array/range"},
  {std_types__character_array___type, "std_types::character_array/_type"},
  {entry__std_types__character_array__std__length_of, "std_types::character_array/length_of"},
  {entry__std_types__character_array__std__dimension_count_of, "std_types::character_array/dimension_count_of"},
  {entry__std_types__character_array__std__equal, "std_types::character_array/equal"},
  {entry__std__character_array, "std::character_array"},
  {entry__std__initialized_character_array, "std::initialized_character_array"},
  {entry__std_types__character_array__std__create_empty_array, "std_types::character_array/create_empty_array"},
  {entry__std_types__character_array__std__range, "std_types::character_array/range"},
  {std_types__int8_array___type, "std_types::int8_array/_type"},
  {entry__std_types__int8_array__std__length_of, "std_types::int8_array/length_of"},
  {entry__std_types__int8_array__std__dimension_count_of, "std_types::int8_array/dimension_count_of"},
  {entry__std_types__int8_array__std__equal, "std_types::int8_array/equal"},
  {entry__std_types__int8_array__std__times, "std_types::int8_array/times"},
  {entry__std__int8_array, "std::int8_array"},
  {entry__std__initialized_int8_array, "std::initialized_int8_array"},
  {entry__std_types__int8_array__std__create_empty_array, "std_types::int8_array/create_empty_array"},
  {entry__std_types__int8_array__std__range, "std_types::int8_array/range"},
  {std_types__uint8_array___type, "std_types::uint8_array/_type"},
  {entry__std_types__uint8_array__std__length_of, "std_types::uint8_array/length_of"},
  {entry__std_types__uint8_array__std__dimension_count_of, "std_types::uint8_array/dimension_count_of"},
  {entry__std_types__uint8_array__std__equal, "std_types::uint8_array/equal"},
  {entry__std_types__uint8_array__std__bit_and, "std_types::uint8_array/bit_and"},
  {entry__std_types__uint8_array__std__bit_or, "std_types::uint8_array/bit_or"},
  {entry__std_types__uint8_array__std__bit_xor, "std_types::uint8_array/bit_xor"},
  {entry__std_types__uint8_array__std__times, "std_types::uint8_array/times"},
  {entry__std__uint8_array, "std::uint8_array"},
  {entry__std__initialized_uint8_array, "std::initialized_uint8_array"},
  {entry__std_types__uint8_array__std__create_empty_array, "std_types::uint8_array/create_empty_array"},
  {entry__std_types__uint8_array__std__range, "std_types::uint8_array/range"},
  {std_types__int16_array___type, "std_types::int16_array/_type"},
  {entry__std_types__int16_array__std__length_of, "std_types::int16_array/length_of"},
  {entry__std_types__int16_array__std__dimension_count_of, "std_types::int16_array/dimension_count_of"},
  {entry__std_types__int16_array__std__equal, "std_types::int16_array/equal"},
  {entry__std_types__int16_array__std__times, "std_types::int16_array/times"},
  {entry__std__int16_array, "std::int16_array"},
  {entry__std__initialized_int16_array, "std::initialized_int16_array"},
  {entry__std_types__int16_array__std__create_empty_array, "std_types::int16_array/create_empty_array"},
  {entry__std_types__int16_array__std__range, "std_types::int16_array/range"},
  {std_types__uint16_array___type, "std_types::uint16_array/_type"},
  {entry__std_types__uint16_array__std__length_of, "std_types::uint16_array/length_of"},
  {entry__std_types__uint16_array__std__dimension_count_of, "std_types::uint16_array/dimension_count_of"},
  {entry__std_types__uint16_array__std__equal, "std_types::uint16_array/equal"},
  {entry__std_types__uint16_array__std__bit_and, "std_types::uint16_array/bit_and"},
  {entry__std_types__uint16_array__std__bit_or, "std_types::uint16_array/bit_or"},
  {entry__std_types__uint16_array__std__bit_xor, "std_types::uint16_array/bit_xor"},
  {entry__std_types__uint16_array__std__times, "std_types::uint16_array/times"},
  {entry__std__uint16_array, "std::uint16_array"},
  {entry__std__initialized_uint16_array, "std::initialized_uint16_array"},
  {entry__std_types__uint16_array__std__create_empty_array, "std_types::uint16_array/create_empty_array"},
  {entry__std_types__uint16_array__std__range, "std_types::uint16_array/range"},
  {std_types__int32_array___type, "std_types::int32_array/_type"},
  {entry__std_types__int32_array__std__length_of, "std_types::int32_array/length_of"},
  {entry__std_types__int32_array__std__dimension_count_of, "std_types::int32_array/dimension_count_of"},
  {entry__std_types__int32_array__std__equal, "std_types::int32_array/equal"},
  {entry__std_types__int32_array__std__times, "std_types::int32_array/times"},
  {entry__std__int32_array, "std::int32_array"},
  {entry__std__initialized_int32_array, "std::initialized_int32_array"},
  {entry__std_types__int32_array__std__create_empty_array, "std_types::int32_array/create_empty_array"},
  {entry__std_types__int32_array__std__range, "std_types::int32_array/range"},
  {std_types__uint32_array___type, "std_types::uint32_array/_type"},
  {entry__std_types__uint32_array__std__length_of, "std_types::uint32_array/length_of"},
  {entry__std_types__uint32_array__std__dimension_count_of, "std_types::uint32_array/dimension_count_of"},
  {entry__std_types__uint32_array__std__equal, "std_types::uint32_array/equal"},
  {entry__std_types__uint32_array__std__bit_and, "std_types::uint32_array/bit_and"},
  {entry__std_types__uint32_array__std__bit_or, "std_types::uint32_array/bit_or"},
  {entry__std_types__uint32_array__std__bit_xor, "std_types::uint32_array/bit_xor"},
  {entry__std_types__uint32_array__std__times, "std_types::uint32_array/times"},
  {entry__std__uint32_array, "std::uint32_array"},
  {entry__std__initialized_uint32_array, "std::initialized_uint32_array"},
  {entry__std_types__uint32_array__std__create_empty_array, "std_types::uint32_array/create_empty_array"},
  {entry__std_types__uint32_array__std__range, "std_types::uint32_array/range"},
  {std_types__int64_array___type, "std_types::int64_array/_type"},
  {entry__std_types__int64_array__std__length_of, "std_types::int64_array/length_of"},
  {entry__std_types__int64_array__std__dimension_count_of, "std_types::int64_array/dimension_count_of"},
  {entry__std_types__int64_array__std__equal, "std_types::int64_array/equal"},
  {entry__std_types__int64_array__std__times, "std_types::int64_array/times"},
  {entry__std__int64_array, "std::int64_array"},
  {entry__std__initialized_int64_array, "std::initialized_int64_array"},
  {entry__std_types__int64_array__std__create_empty_array, "std_types::int64_array/create_empty_array"},
  {entry__std_types__int64_array__std__range, "std_types::int64_array/range"},
  {std_types__uint64_array___type, "std_types::uint64_array/_type"},
  {entry__std_types__uint64_array__std__length_of, "std_types::uint64_array/length_of"},
  {entry__std_types__uint64_array__std__dimension_count_of, "std_types::uint64_array/dimension_count_of"},
  {entry__std_types__uint64_array__std__equal, "std_types::uint64_array/equal"},
  {entry__std_types__uint64_array__std__bit_and, "std_types::uint64_array/bit_and"},
  {entry__std_types__uint64_array__std__bit_or, "std_types::uint64_array/bit_or"},
  {entry__std_types__uint64_array__std__bit_xor, "std_types::uint64_array/bit_xor"},
  {entry__std_types__uint64_array__std__times, "std_types::uint64_array/times"},
  {entry__std__uint64_array, "std::uint64_array"},
  {entry__std__initialized_uint64_array, "std::initialized_uint64_array"},
  {entry__std_types__uint64_array__std__create_empty_array, "std_types::uint64_array/create_empty_array"},
  {entry__std_types__uint64_array__std__range, "std_types::uint64_array/range"},
  {std_types__float32_array___type, "std_types::float32_array/_type"},
  {entry__std_types__float32_array__std__length_of, "std_types::float32_array/length_of"},
  {entry__std_types__float32_array__std__dimension_count_of, "std_types::float32_array/dimension_count_of"},
  {entry__std_types__float32_array__std__equal, "std_types::float32_array/equal"},
  {entry__std_types__float32_array__std__times, "std_types::float32_array/times"},
  {entry__std__float32_array, "std::float32_array"},
  {entry__std__initialized_float32_array, "std::initialized_float32_array"},
  {entry__std_types__float32_array__std__create_empty_array, "std_types::float32_array/create_empty_array"},
  {entry__std_types__float32_array__std__range, "std_types::float32_array/range"},
  {std_types__float64_array___type, "std_types::float64_array/_type"},
  {entry__std_types__float64_array__std__length_of, "std_types::float64_array/length_of"},
  {entry__std_types__float64_array__std__dimension_count_of, "std_types::float64_array/dimension_count_of"},
  {entry__std_types__float64_array__std__equal, "std_types::float64_array/equal"},
  {entry__std_types__float64_array__std__times, "std_types::float64_array/times"},
  {entry__std__float64_array, "std::float64_array"},
  {entry__std__initialized_float64_array, "std::initialized_float64_array"},
  {entry__std_types__float64_array__std__create_empty_array, "std_types::float64_array/create_empty_array"},
  {entry__std_types__float64_array__std__range, "std_types::float64_array/range"},
  {entry__std__pass, "std::pass"},
  {entry__std__result_count, "std::result_count"},
  {std_types__true___type, "std_types::true/_type"},
  {entry__std_types__true__std__equal, "std_types::true/equal"},
  {std_types__false___type, "std_types::false/_type"},
  {entry__std_types__false__std__equal, "std_types::false/equal"},
  {c_function___type, "c_function/_type"},
  {entry__c_function__std__parameter_count_of, "c_function/parameter_count_of"},
  {std_types__character___type, "std_types::character/_type"},
  {entry__std__character, "std::character"},
  {entry__std_types__character__std__plus, "std_types::character/plus"},
  {entry__std_types__character__std__minus, "std_types::character/minus"},
  {entry__std_types__character__std__equal, "std_types::character/equal"},
  {entry__std_types__character__std__less, "std_types::character/less"},
  {entry__std_types__character__std__hash, "std_types::character/hash"},
  {entry__std_types__character__std__to_string, "std_types::character/to_string"},
  {entry__std_types__character__std__to_integer, "std_types::character/to_integer"},
  {entry__std_types__character__std__width_of, "std_types::character/width_of"},
  {std_types__date_and_time___type, "std_types::date_and_time/_type"},
  {entry__std__from_unix_time, "std::from_unix_time"},
  {entry__std__date_and_time, "std::date_and_time"},
  {entry__std_types__date_and_time__std__year_of, "std_types::date_and_time/year_of"},
  {entry__std_types__date_and_time__std__month_of, "std_types::date_and_time/month_of"},
  {entry__std_types__date_and_time__std__day_of, "std_types::date_and_time/day_of"},
  {entry__std_types__date_and_time__std__day_of_week_of, "std_types::date_and_time/day_of_week_of"},
  {entry__std_types__date_and_time__std__hour_of, "std_types::date_and_time/hour_of"},
  {entry__std_types__date_and_time__std__minute_of, "std_types::date_and_time/minute_of"},
  {entry__std_types__date_and_time__std__second_of, "std_types::date_and_time/second_of"},
  {entry__std_types__date_and_time__std__time_shift_of, "std_types::date_and_time/time_shift_of"},
  {entry__std_types__date_and_time__std__seconds_since_epoch, "std_types::date_and_time/seconds_since_epoch"},
  {entry__std_types__date_and_time__std__plus, "std_types::date_and_time/plus"},
  {entry__std_types__date_and_time__std__minus, "std_types::date_and_time/minus"},
  {entry__std_types__date_and_time__std__equal, "std_types::date_and_time/equal"},
  {entry__std_types__date_and_time__std__less, "std_types::date_and_time/less"},
  {entry__std__current_time, "std::current_time"},
  {entry__debug__current_time, "debug::current_time"},
  {entry__debug__string, "debug::string"},
  {entry__debug__write, "debug::write"},
  {entry__debug__dump_object, "debug::dump_object"},
  {entry__debug__has_io_access_rights, "debug::has_io_access_rights"},
  {entry__debug__exit, "debug::exit"},
  {entry__std__error_check, "std::error_check"},
  {entry__debug__total_garbage_collections, "debug::total_garbage_collections"},
  {entry__std__installation_prefix, "std::installation_prefix"},
  {entry__std__package_version, "std::package_version"},
  {std_types__error___type, "std_types::error/_type"},
  {entry__std_types__error__std__error_category_of, "std_types::error/error_category_of"},
  {entry__std_types__error__std__error_message_text_of, "std_types::error/error_message_text_of"},
  {entry__std_types__error__std__error_details_of, "std_types::error/error_details_of"},
  {entry__std_types__error__std__errno_of, "std_types::error/errno_of"},
  {entry__std_types__error__std__failed_attribute_of, "std_types::error/failed_attribute_of"},
  {entry__std__error, "std::error"},
  {entry__std__exec, "std::exec"},
  {entry__std__create_process, "std::create_process"},
  {std_types__function___type, "std_types::function/_type"},
  {tabular_function___type, "tabular_function/_type"},
  {entry__std_types__function__std__parameter_count_of, "std_types::function/parameter_count_of"},
  {entry__std_types__function__std__new, "std_types::function/new"},
  {std_types__generic_list___type, "std_types::generic_list/_type"},
  {std_types__list___type, "std_types::list/_type"},
  {entry__std__list, "std::list"},
  {entry__std_types__list__std__length_of, "std_types::list/length_of"},
  {entry__std_types__list__std__is_empty, "std_types::list/is_empty"},
  {entry__std_types__list__std__is_not_empty, "std_types::list/is_not_empty"},
  {entry__std_types__list__std__push, "std_types::list/push"},
  {entry__std_types__list__std__drop, "std_types::list/drop"},
  {entry__std_types__list__std__pop, "std_types::list/pop"},
  {entry__std_types__list__std__peek, "std_types::list/peek"},
  {entry__std_types__list__std__append, "std_types::list/append"},
  {entry__std_types__list__std__range, "std_types::list/range"},
  {entry__std_types__list__std__spread, "std_types::list/spread"},
  {std_types__number___type, "std_types::number/_type"},
  {std_types__integer___type, "std_types::integer/_type"},
  {builtin_types__positive_integer___type, "builtin_types::positive_integer/_type"},
  {builtin_types__negative_integer___type, "builtin_types::negative_integer/_type"},
  {std_types__real___type, "std_types::real/_type"},
  {entry__builtin_types__positive_integer__std__negate, "builtin_types::positive_integer/negate"},
  {entry__builtin_types__negative_integer__std__negate, "builtin_types::negative_integer/negate"},
  {entry__std_types__real__std__negate, "std_types::real/negate"},
  {entry__builtin_types__positive_integer__std__times, "builtin_types::positive_integer/times"},
  {entry__builtin_types__negative_integer__std__times, "builtin_types::negative_integer/times"},
  {entry__builtin_types__positive_integer__std__to_integer, "builtin_types::positive_integer/to_integer"},
  {entry__builtin_types__negative_integer__std__to_integer, "builtin_types::negative_integer/to_integer"},
  {entry__std_types__real__std__to_integer, "std_types::real/to_integer"},
  {entry__std_types__real__std__floor, "std_types::real/floor"},
  {entry__std_types__real__std__ceil, "std_types::real/ceil"},
  {entry__std_types__real__std__round, "std_types::real/round"},
  {entry__builtin_types__negative_integer__std__to_string, "builtin_types::negative_integer/to_string"},
  {entry__builtin_types__positive_integer__std__to_string, "builtin_types::positive_integer/to_string"},
  {entry__std_types__real__std__to_string, "std_types::real/to_string"},
  {entry__builtin_types__positive_integer__std__over, "builtin_types::positive_integer/over"},
  {entry__builtin_types__negative_integer__std__over, "builtin_types::negative_integer/over"},
  {entry__builtin_types__positive_integer__std__div, "builtin_types::positive_integer/div"},
  {entry__builtin_types__negative_integer__std__div, "builtin_types::negative_integer/div"},
  {entry__builtin_types__positive_integer__std__mod, "builtin_types::positive_integer/mod"},
  {entry__builtin_types__negative_integer__std__mod, "builtin_types::negative_integer/mod"},
  {entry__builtin_types__positive_integer__std__hash, "builtin_types::positive_integer/hash"},
  {entry__builtin_types__negative_integer__std__hash, "builtin_types::negative_integer/hash"},
  {entry__std_types__real__std__hash, "std_types::real/hash"},
  {entry__builtin_types__positive_integer__std__ln, "builtin_types::positive_integer/ln"},
  {entry__builtin_types__negative_integer__std__ln, "builtin_types::negative_integer/ln"},
  {entry__std_types__real__std__ln, "std_types::real/ln"},
  {entry__builtin_types__positive_integer__std__exp, "builtin_types::positive_integer/exp"},
  {entry__builtin_types__negative_integer__std__exp, "builtin_types::negative_integer/exp"},
  {entry__std_types__real__std__exp, "std_types::real/exp"},
  {entry__std__real, "std::real"},
  {entry__std__integer, "std::integer"},
  {entry__std__sqrt, "std::sqrt"},
  {entry__std__pow, "std::pow"},
  {entry__builtin_types__positive_integer__std__exit, "builtin_types::positive_integer/exit"},
  {entry__builtin_types__positive_integer__std__plus, "builtin_types::positive_integer/plus"},
  {entry__builtin_types__negative_integer__std__plus, "builtin_types::negative_integer/plus"},
  {entry__std_types__real__std__plus, "std_types::real/plus"},
  {entry__builtin_types__positive_integer__std__minus, "builtin_types::positive_integer/minus"},
  {entry__builtin_types__negative_integer__std__minus, "builtin_types::negative_integer/minus"},
  {entry__std_types__real__std__minus, "std_types::real/minus"},
  {entry__std_types__real__std__times, "std_types::real/times"},
  {entry__std_types__real__std__over, "std_types::real/over"},
  {entry__builtin_types__positive_integer__std__equal, "builtin_types::positive_integer/equal"},
  {entry__builtin_types__negative_integer__std__equal, "builtin_types::negative_integer/equal"},
  {entry__std_types__real__std__equal, "std_types::real/equal"},
  {entry__builtin_types__positive_integer__std__less, "builtin_types::positive_integer/less"},
  {entry__builtin_types__negative_integer__std__less, "builtin_types::negative_integer/less"},
  {entry__std_types__real__std__less, "std_types::real/less"},
  {entry__builtin_types__positive_integer__std__shift_left, "builtin_types::positive_integer/shift_left"},
  {entry__builtin_types__positive_integer__std__shift_right, "builtin_types::positive_integer/shift_right"},
  {entry__builtin_types__positive_integer__std__bit_and, "builtin_types::positive_integer/bit_and"},
  {entry__builtin_types__positive_integer__std__bit_or, "builtin_types::positive_integer/bit_or"},
  {entry__builtin_types__positive_integer__std__bit_xor, "builtin_types::positive_integer/bit_xor"},
  {entry__std__sin, "std::sin"},
  {entry__std__cos, "std::cos"},
  {entry__std__tan, "std::tan"},
  {entry__std__asin, "std::asin"},
  {entry__std__acos, "std::acos"},
  {entry__std__atan, "std::atan"},
  {std_types__object___type, "std_types::object/_type"},
  {entry__debug__object_type, "debug::object_type"},
  {entry__debug__object_attributes, "debug::object_attributes"},
  {entry__std_types__object__std__new, "std_types::object/new"},
  {std_types__polymorphic_function___type, "std_types::polymorphic_function/_type"},
  {std_types__polymorphic_function_with_setter___type, "std_types::polymorphic_function_with_setter/_type"},
  {std_types__file_type___type, "std_types::file_type/_type"},
  {entry__std_types__file_type__std__equal, "std_types::file_type/equal"},
  {entry__std_types__file_type__std__hash, "std_types::file_type/hash"},
  {entry__std__file_type, "std::file_type"},
  {entry__std_types__file_type__std__to_integer, "std_types::file_type/to_integer"},
  {std_types__file_descriptor___type, "std_types::file_descriptor/_type"},
  {entry__std_types__file_descriptor__std__equal, "std_types::file_descriptor/equal"},
  {entry__std_types__file_descriptor__std__hash, "std_types::file_descriptor/hash"},
  {entry__std__file_descriptor, "std::file_descriptor"},
  {entry__std_types__file_descriptor__std__to_integer, "std_types::file_descriptor/to_integer"},
  {std_types__signal_number___type, "std_types::signal_number/_type"},
  {entry__std_types__signal_number__std__equal, "std_types::signal_number/equal"},
  {entry__std_types__signal_number__std__hash, "std_types::signal_number/hash"},
  {entry__std__signal_number, "std::signal_number"},
  {entry__std_types__signal_number__std__to_integer, "std_types::signal_number/to_integer"},
  {std_types__shutdown_type___type, "std_types::shutdown_type/_type"},
  {entry__std_types__shutdown_type__std__equal, "std_types::shutdown_type/equal"},
  {entry__std_types__shutdown_type__std__hash, "std_types::shutdown_type/hash"},
  {entry__std__shutdown_type, "std::shutdown_type"},
  {entry__std_types__shutdown_type__std__to_integer, "std_types::shutdown_type/to_integer"},
  {std_types__seek_type___type, "std_types::seek_type/_type"},
  {entry__std_types__seek_type__std__equal, "std_types::seek_type/equal"},
  {entry__std_types__seek_type__std__hash, "std_types::seek_type/hash"},
  {entry__std__seek_type, "std::seek_type"},
  {entry__std_types__seek_type__std__to_integer, "std_types::seek_type/to_integer"},
  {std_types__device_id___type, "std_types::device_id/_type"},
  {entry__std_types__device_id__std__equal, "std_types::device_id/equal"},
  {entry__std_types__device_id__std__hash, "std_types::device_id/hash"},
  {entry__std__device_id, "std::device_id"},
  {entry__std_types__device_id__std__to_integer, "std_types::device_id/to_integer"},
  {std_types__directory___type, "std_types::directory/_type"},
  {entry__std_types__directory__std__equal, "std_types::directory/equal"},
  {entry__std_types__directory__std__hash, "std_types::directory/hash"},
  {std_types__group_id___type, "std_types::group_id/_type"},
  {entry__std_types__group_id__std__equal, "std_types::group_id/equal"},
  {entry__std_types__group_id__std__hash, "std_types::group_id/hash"},
  {entry__std__group_id, "std::group_id"},
  {entry__std_types__group_id__std__to_integer, "std_types::group_id/to_integer"},
  {std_types__inode_number___type, "std_types::inode_number/_type"},
  {entry__std_types__inode_number__std__equal, "std_types::inode_number/equal"},
  {entry__std_types__inode_number__std__hash, "std_types::inode_number/hash"},
  {entry__std__inode_number, "std::inode_number"},
  {entry__std_types__inode_number__std__to_integer, "std_types::inode_number/to_integer"},
  {std_types__process_id___type, "std_types::process_id/_type"},
  {entry__std_types__process_id__std__equal, "std_types::process_id/equal"},
  {entry__std_types__process_id__std__hash, "std_types::process_id/hash"},
  {entry__std__process_id, "std::process_id"},
  {entry__std_types__process_id__std__to_integer, "std_types::process_id/to_integer"},
  {std_types__user_id___type, "std_types::user_id/_type"},
  {entry__std_types__user_id__std__equal, "std_types::user_id/equal"},
  {entry__std_types__user_id__std__hash, "std_types::user_id/hash"},
  {entry__std__user_id, "std::user_id"},
  {entry__std_types__user_id__std__to_integer, "std_types::user_id/to_integer"},
  {std_types__error_number___type, "std_types::error_number/_type"},
  {entry__std_types__error_number__std__equal, "std_types::error_number/equal"},
  {entry__std_types__error_number__std__hash, "std_types::error_number/hash"},
  {entry__std__error_number, "std::error_number"},
  {entry__std_types__error_number__std__to_integer, "std_types::error_number/to_integer"},
  {std_types__passwd___type, "std_types::passwd/_type"},
  {std_types__stat___type, "std_types::stat/_type"},
  {std_types__dirent___type, "std_types::dirent/_type"},
  {entry__std__access, "std::access"},
  {entry__std__chdir, "std::chdir"},
  {entry__std__chmod, "std::chmod"},
  {entry__std__chown, "std::chown"},
  {entry__std__chroot, "std::chroot"},
  {entry__std_types__file_descriptor__std__close, "std_types::file_descriptor/close"},
  {entry__std__closedir, "std::closedir"},
  {entry__std__dup2, "std::dup2"},
  {entry__std__fstat, "std::fstat"},
  {entry__std__fsync, "std::fsync"},
  {entry__std__getcwd, "std::getcwd"},
  {entry__std__getenv, "std::getenv"},
  {entry__std__getegid, "std::getegid"},
  {entry__std__geteuid, "std::geteuid"},
  {entry__std__getgid, "std::getgid"},
  {entry__std__gethostname, "std::gethostname"},
  {entry__std__getlogin, "std::getlogin"},
  {entry__std__getpid, "std::getpid"},
  {entry__std__getppid, "std::getppid"},
  {entry__std__getpwuid, "std::getpwuid"},
  {entry__std__getsid, "std::getsid"},
  {entry__std__getuid, "std::getuid"},
  {entry__std__isatty, "std::isatty"},
  {entry__std__kill, "std::kill"},
  {entry__std__link, "std::link"},
  {entry__std__lseek, "std::lseek"},
  {entry__std__mkdir, "std::mkdir"},
  {entry__std__mkfifo, "std::mkfifo"},
  {entry__std__open, "std::open"},
  {entry__std__opendir, "std::opendir"},
  {entry__std_types__file_descriptor__std__read, "std_types::file_descriptor/read"},
  {entry__std__readdir, "std::readdir"},
  {entry__std__realpath, "std::realpath"},
  {entry__std__rename, "std::rename"},
  {entry__std__sethostname, "std::sethostname"},
  {entry__std__shutdown, "std::shutdown"},
  {entry__std__stat, "std::stat"},
  {entry__std__strerror, "std::strerror"},
  {entry__std__wait, "std::wait"},
  {entry__std_types__file_descriptor__std__write, "std_types::file_descriptor/write"},
  {entry__std__umask, "std::umask"},
  {entry__std__unlink, "std::unlink"},
  {entry__std__shm_unlink, "std::shm_unlink"},
  {entry__std__usleep, "std::usleep"},
  {std_types__string___type, "std_types::string/_type"},
  {std_types__octet_string___type, "std_types::octet_string/_type"},
  {std_types__wide_string___type, "std_types::wide_string/_type"},
  {entry__std_types__octet_string__std__length_of, "std_types::octet_string/length_of"},
  {entry__std_types__wide_string__std__length_of, "std_types::wide_string/length_of"},
  {entry__std_types__octet_string__std__is_empty, "std_types::octet_string/is_empty"},
  {entry__std_types__octet_string__std__is_not_empty, "std_types::octet_string/is_not_empty"},
  {entry__std_types__wide_string__std__is_empty, "std_types::wide_string/is_empty"},
  {entry__std_types__wide_string__std__is_not_empty, "std_types::wide_string/is_not_empty"},
  {entry__std_types__octet_string__std__push, "std_types::octet_string/push"},
  {entry__std_types__wide_string__std__push, "std_types::wide_string/push"},
  {entry__std_types__octet_string__std__append, "std_types::octet_string/append"},
  {entry__std_types__wide_string__std__append, "std_types::wide_string/append"},
  {entry__std_types__octet_string__std__range, "std_types::octet_string/range"},
  {entry__std_types__wide_string__std__range, "std_types::wide_string/range"},
  {entry__std_types__octet_string__std__hash, "std_types::octet_string/hash"},
  {entry__std_types__wide_string__std__hash, "std_types::wide_string/hash"},
  {entry__std_types__octet_string__std__equal, "std_types::octet_string/equal"},
  {entry__std_types__wide_string__std__equal, "std_types::wide_string/equal"},
  {entry__std_types__octet_string__std__less, "std_types::octet_string/less"},
  {entry__std_types__wide_string__std__less, "std_types::wide_string/less"},
  {entry__std_types__octet_string__std__width_of, "std_types::octet_string/width_of"},
  {entry__std_types__wide_string__std__width_of, "std_types::wide_string/width_of"},
  {entry__std_types__octet_string__std__from_utf8, "std_types::octet_string/from_utf8"},
  {entry__std_types__octet_string__std__to_utf8, "std_types::octet_string/to_utf8"},
  {entry__std_types__wide_string__std__to_utf8, "std_types::wide_string/to_utf8"},
  {std_types__terminal_attributes___type, "std_types::terminal_attributes/_type"},
  {entry__std_types__file_descriptor__std__get_terminal_attributes, "std_types::file_descriptor/get_terminal_attributes"},
  {entry__std_types__file_descriptor__std__set_terminal_attributes, "std_types::file_descriptor/set_terminal_attributes"},
  {entry__std_types__terminal_attributes__std__backspace_character_of, "std_types::terminal_attributes/backspace_character_of"},
  {entry__std_types__terminal_attributes__std__use_canonical_mode, "std_types::terminal_attributes/use_canonical_mode"},
  {entry__std_types__terminal_attributes__std__echo_characters, "std_types::terminal_attributes/echo_characters"},
  {entry__std_types__terminal_attributes__std__echo_new_lines, "std_types::terminal_attributes/echo_new_lines"},
  {entry__std_types__terminal_attributes__std__enable_xon_xoff_for_input, "std_types::terminal_attributes/enable_xon_xoff_for_input"},
  {entry__std_types__terminal_attributes__std__enable_xon_xoff_for_output, "std_types::terminal_attributes/enable_xon_xoff_for_output"},
  {entry__std_types__terminal_attributes__std__restart_output_on_any_character, "std_types::terminal_attributes/restart_output_on_any_character"},
  {entry__std_types__terminal_attributes__std__ignore_cr_on_input, "std_types::terminal_attributes/ignore_cr_on_input"},
  {entry__std_types__terminal_attributes__std__generate_signals, "std_types::terminal_attributes/generate_signals"},
  {entry__std_types__terminal_attributes__std__map_cr_to_lf_on_input, "std_types::terminal_attributes/map_cr_to_lf_on_input"},
  {entry__std_types__terminal_attributes__std__hangup_on_close, "std_types::terminal_attributes/hangup_on_close"},
  {entry__std_types__terminal_attributes__std__map_lf_to_crlf_on_output, "std_types::terminal_attributes/map_lf_to_crlf_on_output"},
  {entry__std_types__terminal_attributes__std__minimum_characters_for_canoncial_read, "std_types::terminal_attributes/minimum_characters_for_canoncial_read"},
  {entry__std_types__terminal_attributes__std__timeout_for_reads, "std_types::terminal_attributes/timeout_for_reads"},
  {entry__std_types__terminal_attributes__std__input_speed, "std_types::terminal_attributes/input_speed"},
  {entry__std_types__terminal_attributes__std__output_speed, "std_types::terminal_attributes/output_speed"},
  {std_types__tuple___type, "std_types::tuple/_type"},
  {entry__std_types__tuple__std__typed_tuple, "std_types::tuple/typed_tuple"},
  {builtin_types__tuple2___type, "builtin_types::tuple2/_type"},
  {entry__builtin_types__tuple2__std__to_list, "builtin_types::tuple2/to_list"},
  {entry__builtin_types__tuple2__std__typed_tuple, "builtin_types::tuple2/typed_tuple"},
  {builtin_types__tuple3___type, "builtin_types::tuple3/_type"},
  {entry__builtin_types__tuple3__std__to_list, "builtin_types::tuple3/to_list"},
  {entry__builtin_types__tuple3__std__typed_tuple, "builtin_types::tuple3/typed_tuple"},
  {builtin_types__tuple4___type, "builtin_types::tuple4/_type"},
  {entry__builtin_types__tuple4__std__to_list, "builtin_types::tuple4/to_list"},
  {entry__builtin_types__tuple4__std__typed_tuple, "builtin_types::tuple4/typed_tuple"},
  {builtin_types__tuple5___type, "builtin_types::tuple5/_type"},
  {entry__builtin_types__tuple5__std__to_list, "builtin_types::tuple5/to_list"},
  {entry__builtin_types__tuple5__std__typed_tuple, "builtin_types::tuple5/typed_tuple"},
  {builtin_types__tuple6___type, "builtin_types::tuple6/_type"},
  {entry__builtin_types__tuple6__std__to_list, "builtin_types::tuple6/to_list"},
  {entry__builtin_types__tuple6__std__typed_tuple, "builtin_types::tuple6/typed_tuple"},
  {builtin_types__tuple7___type, "builtin_types::tuple7/_type"},
  {entry__builtin_types__tuple7__std__to_list, "builtin_types::tuple7/to_list"},
  {entry__builtin_types__tuple7__std__typed_tuple, "builtin_types::tuple7/typed_tuple"},
  {builtin_types__tuple8___type, "builtin_types::tuple8/_type"},
  {entry__builtin_types__tuple8__std__to_list, "builtin_types::tuple8/to_list"},
  {entry__builtin_types__tuple8__std__typed_tuple, "builtin_types::tuple8/typed_tuple"},
  {entry__std__tuple, "std::tuple"},
  {entry__std__tuple_or_error, "std::tuple_or_error"},
  {entry__std__new_tuple, "std::new_tuple"},
  {std_types__undefined___type, "std_types::undefined/_type"},
  {entry__std_types__character__std__to_upper_case, "std_types::character/to_upper_case"},
  {entry__std__is_an_upper_case_letter_character, "std::is_an_upper_case_letter_character"},
  {entry__std_types__character__std__to_lower_case, "std_types::character/to_lower_case"},
  {entry__std__is_a_lower_case_letter_character, "std::is_a_lower_case_letter_character"},
  {entry__std_types__character__std__to_title_case, "std_types::character/to_title_case"},
  {entry__std__is_a_title_case_letter_character, "std::is_a_title_case_letter_character"},
  {entry__std__is_a_letter_character, "std::is_a_letter_character"},
  {entry__std__is_a_whitespace_character, "std::is_a_whitespace_character"},
  {entry__std__is_a_zero_width_character, "std::is_a_zero_width_character"},
  {entry__std__is_a_wide_character, "std::is_a_wide_character"},
  {std_types__unique_item___type, "std_types::unique_item/_type"},
  {entry__std_types__unique_item__std__to_string, "std_types::unique_item/to_string"},
  {entry__std_types__unique_item__std__equal, "std_types::unique_item/equal"},
  {entry__std_types__unique_item__std__hash, "std_types::unique_item/hash"},
  {entry__std__unique_item, "std::unique_item"},
  {entry__std_types__file_descriptor__std__get_terminal_size, "std_types::file_descriptor/get_terminal_size"},
  {entry__std__exitstatus, "std::exitstatus"},
  {entry__std__pselect, "std::pselect"},
  {entry__std__do_not_close, "std::do_not_close"},
  {entry__std__waitpid, "std::waitpid"},
  {entry__std__open_unix_socket, "std::open_unix_socket"},
  {entry__std__send_file_descriptor, "std::send_file_descriptor"},
  {entry__std__open_tcp_client_socket, "std::open_tcp_client_socket"},
  {entry__std__open_tcp_server_socket, "std::open_tcp_server_socket"},
  {entry__std__accept, "std::accept"},
  {entry__std__is_listening, "std::is_listening"},
  {entry__std__get_first_mac_address, "std::get_first_mac_address"},
  {std_types__shared_memory___type, "std_types::shared_memory/_type"},
  {entry__std_types__shared_memory__std__size_of, "std_types::shared_memory/size_of"},
  {entry__std_types__shared_memory__std__file_descriptor_of, "std_types::shared_memory/file_descriptor_of"},
  {entry__std_types__shared_memory__std__write_at, "std_types::shared_memory/write_at"},
  {entry__std__create_shared_memory, "std::create_shared_memory"}
};

const char *internal_method_names[] = {
  "size",
  "type_no",
  "collect",
  "to_int8",
  "to_int16",
  "to_int32",
  "to_int64",
  "to_uint8",
  "to_uint16",
  "to_uint32",
  "to_uint64",
  "to_uchar32",
  "to_bool",
  "to_int",
  "to_uint",
  "to_long",
  "to_ulong",
  "to_float",
  "to_double",
  "to_c_string",
  "to_octets",
  "get_item_of",
  "length_of",
  "unfold",
  "debug_string"
};
