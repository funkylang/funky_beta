#
  This file was automatically generated by the script
  "tuples_autogen.sim" - do not edit!

#
  Copyright (C) 2022 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Topic: Tuples, Collections

TYPE std_types::tuple -> std_types::object
  #
    the prototype object for all tuples

    Topic: Collections

METHOD std_types::tuple/_type
  {
    RUNTIME_ERROR("Attempt to call the tuple prototype object as a function!")
  }

POLY std::typed_tuple

METHOD std_types::tuple/typed_tuple
  #
    clones the specified tuple and replace its contents

    The first argument is used as a prototype which supplies the methods for
    the newly created tuple. All items of the prototype tuple are replaced
    with the specified items. You must supply as many items as the prototype
    tuple contains.

    Arguments:
      prototype # the prototype for the new list
      first_item
      ...
      last_item

    See also: list
  {
    RUNTIME_ERROR("Attempt to clone the tuple prototype object!")
  }

FUNCTION NODE *create_tuple
  #
    To be used from the runtime linker only!

    This function returns a partially uninitialized object!
  (
    long count
  )
  {
    switch (count) {
      case 2:
	return CREATE(builtin_types::tuple2, NULL, NULL);
      case 3:
	return CREATE(builtin_types::tuple3, NULL, NULL, NULL);
      case 4:
	return CREATE(builtin_types::tuple4, NULL, NULL, NULL, NULL);
      case 5:
	return CREATE(builtin_types::tuple5, NULL, NULL, NULL, NULL, NULL);
      case 6:
	return CREATE(builtin_types::tuple6, NULL, NULL, NULL, NULL, NULL, NULL);
      case 7:
	return CREATE(builtin_types::tuple7, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
      case 8:
	return CREATE(builtin_types::tuple8, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
      default:
	unrecoverable_error("Invalid tuple element count!");
    }
  }

FUNCTION void set_tuple_item
  #
    To be used from the runtime linker only!

    The index is zero based!

    This function does a destructive update!
  (
    NODE *tuple,
    long idx,
    NODE *value
  )
  {
    ((NODE **)((SIMPLE_NODE *)tuple+1))[idx] = value;
  }

TYPE builtin_types::tuple2 -> std_types::tuple
  NODE *node_0
  NODE *node_1

METHOD builtin_types::tuple2/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = (NODE *)&std_types::undefined;
      case 7: ARGUMENTS(6) = (NODE *)&std_types::undefined;
      case 6: ARGUMENTS(5) = (NODE *)&std_types::undefined;
      case 5: ARGUMENTS(4) = (NODE *)&std_types::undefined;
      case 4: ARGUMENTS(3) = (NODE *)&std_types::undefined;
      case 3: ARGUMENTS(2) = (NODE *)&std_types::undefined;
      case 2: ARGUMENTS(1) = MYSELF->tuple2.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple2.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple2/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 2 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple2.node_0;
      for (i = 0; i < 2; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple2/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+2*sizeof(NODE *));
    data->size = 2;
    data->length = 2;
    data->items[0] = self->tuple2.node_0;
    data->items[1] = self->tuple2.node_1;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 2, data))
  }

METHOD builtin_types::tuple2/typed_tuple
  {
    CHECK_ARGUMENTS(3)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple2,
	ARGUMENTS(1),
	ARGUMENTS(2)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

TYPE builtin_types::tuple3 -> std_types::tuple
  NODE *node_0
  NODE *node_1
  NODE *node_2

METHOD builtin_types::tuple3/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = (NODE *)&std_types::undefined;
      case 7: ARGUMENTS(6) = (NODE *)&std_types::undefined;
      case 6: ARGUMENTS(5) = (NODE *)&std_types::undefined;
      case 5: ARGUMENTS(4) = (NODE *)&std_types::undefined;
      case 4: ARGUMENTS(3) = (NODE *)&std_types::undefined;
      case 3: ARGUMENTS(2) = MYSELF->tuple3.node_2;
      case 2: ARGUMENTS(1) = MYSELF->tuple3.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple3.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple3/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 3 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple3.node_0;
      for (i = 0; i < 3; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple3/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+3*sizeof(NODE *));
    data->size = 3;
    data->length = 3;
    data->items[0] = self->tuple3.node_0;
    data->items[1] = self->tuple3.node_1;
    data->items[2] = self->tuple3.node_2;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 3, data))
  }

METHOD builtin_types::tuple3/typed_tuple
  {
    CHECK_ARGUMENTS(4)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple3,
	ARGUMENTS(1),
	ARGUMENTS(2),
	ARGUMENTS(3)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

TYPE builtin_types::tuple4 -> std_types::tuple
  NODE *node_0
  NODE *node_1
  NODE *node_2
  NODE *node_3

METHOD builtin_types::tuple4/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = (NODE *)&std_types::undefined;
      case 7: ARGUMENTS(6) = (NODE *)&std_types::undefined;
      case 6: ARGUMENTS(5) = (NODE *)&std_types::undefined;
      case 5: ARGUMENTS(4) = MYSELF->tuple4.node_3;
      case 4: ARGUMENTS(3) = MYSELF->tuple4.node_3;
      case 3: ARGUMENTS(2) = MYSELF->tuple4.node_2;
      case 2: ARGUMENTS(1) = MYSELF->tuple4.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple4.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple4/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 4 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple4.node_0;
      for (i = 0; i < 4; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple4/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+4*sizeof(NODE *));
    data->size = 4;
    data->length = 4;
    data->items[0] = self->tuple4.node_0;
    data->items[1] = self->tuple4.node_1;
    data->items[2] = self->tuple4.node_2;
    data->items[3] = self->tuple4.node_3;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 4, data))
  }

METHOD builtin_types::tuple4/typed_tuple
  {
    CHECK_ARGUMENTS(5)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple4,
	ARGUMENTS(1),
	ARGUMENTS(2),
	ARGUMENTS(3),
	ARGUMENTS(4)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

TYPE builtin_types::tuple5 -> std_types::tuple
  NODE *node_0
  NODE *node_1
  NODE *node_2
  NODE *node_3
  NODE *node_4

METHOD builtin_types::tuple5/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = (NODE *)&std_types::undefined;
      case 7: ARGUMENTS(6) = (NODE *)&std_types::undefined;
      case 6: ARGUMENTS(5) = MYSELF->tuple5.node_4;
      case 5: ARGUMENTS(4) = MYSELF->tuple5.node_4;
      case 4: ARGUMENTS(3) = MYSELF->tuple5.node_3;
      case 3: ARGUMENTS(2) = MYSELF->tuple5.node_2;
      case 2: ARGUMENTS(1) = MYSELF->tuple5.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple5.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple5/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 5 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple5.node_0;
      for (i = 0; i < 5; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple5/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+5*sizeof(NODE *));
    data->size = 5;
    data->length = 5;
    data->items[0] = self->tuple5.node_0;
    data->items[1] = self->tuple5.node_1;
    data->items[2] = self->tuple5.node_2;
    data->items[3] = self->tuple5.node_3;
    data->items[4] = self->tuple5.node_4;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 5, data))
  }

METHOD builtin_types::tuple5/typed_tuple
  {
    CHECK_ARGUMENTS(6)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple5,
	ARGUMENTS(1),
	ARGUMENTS(2),
	ARGUMENTS(3),
	ARGUMENTS(4),
	ARGUMENTS(5)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

TYPE builtin_types::tuple6 -> std_types::tuple
  NODE *node_0
  NODE *node_1
  NODE *node_2
  NODE *node_3
  NODE *node_4
  NODE *node_5

METHOD builtin_types::tuple6/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = (NODE *)&std_types::undefined;
      case 7: ARGUMENTS(6) = (NODE *)&std_types::undefined;
      case 6: ARGUMENTS(5) = MYSELF->tuple6.node_5;
      case 5: ARGUMENTS(4) = MYSELF->tuple6.node_4;
      case 4: ARGUMENTS(3) = MYSELF->tuple6.node_3;
      case 3: ARGUMENTS(2) = MYSELF->tuple6.node_2;
      case 2: ARGUMENTS(1) = MYSELF->tuple6.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple6.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple6/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 6 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple6.node_0;
      for (i = 0; i < 6; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple6/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+6*sizeof(NODE *));
    data->size = 6;
    data->length = 6;
    data->items[0] = self->tuple6.node_0;
    data->items[1] = self->tuple6.node_1;
    data->items[2] = self->tuple6.node_2;
    data->items[3] = self->tuple6.node_3;
    data->items[4] = self->tuple6.node_4;
    data->items[5] = self->tuple6.node_5;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 6, data))
  }

METHOD builtin_types::tuple6/typed_tuple
  {
    CHECK_ARGUMENTS(7)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple6,
	ARGUMENTS(1),
	ARGUMENTS(2),
	ARGUMENTS(3),
	ARGUMENTS(4),
	ARGUMENTS(5),
	ARGUMENTS(6)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

TYPE builtin_types::tuple7 -> std_types::tuple
  NODE *node_0
  NODE *node_1
  NODE *node_2
  NODE *node_3
  NODE *node_4
  NODE *node_5
  NODE *node_6

METHOD builtin_types::tuple7/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = (NODE *)&std_types::undefined;
      case 7: ARGUMENTS(6) = MYSELF->tuple7.node_6;
      case 6: ARGUMENTS(5) = MYSELF->tuple7.node_5;
      case 5: ARGUMENTS(4) = MYSELF->tuple7.node_4;
      case 4: ARGUMENTS(3) = MYSELF->tuple7.node_3;
      case 3: ARGUMENTS(2) = MYSELF->tuple7.node_2;
      case 2: ARGUMENTS(1) = MYSELF->tuple7.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple7.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple7/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 7 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple7.node_0;
      for (i = 0; i < 7; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple7/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+7*sizeof(NODE *));
    data->size = 7;
    data->length = 7;
    data->items[0] = self->tuple7.node_0;
    data->items[1] = self->tuple7.node_1;
    data->items[2] = self->tuple7.node_2;
    data->items[3] = self->tuple7.node_3;
    data->items[4] = self->tuple7.node_4;
    data->items[5] = self->tuple7.node_5;
    data->items[6] = self->tuple7.node_6;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 7, data))
  }

METHOD builtin_types::tuple7/typed_tuple
  {
    CHECK_ARGUMENTS(8)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple7,
	ARGUMENTS(1),
	ARGUMENTS(2),
	ARGUMENTS(3),
	ARGUMENTS(4),
	ARGUMENTS(5),
	ARGUMENTS(6),
	ARGUMENTS(7)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

TYPE builtin_types::tuple8 -> std_types::tuple
  NODE *node_0
  NODE *node_1
  NODE *node_2
  NODE *node_3
  NODE *node_4
  NODE *node_5
  NODE *node_6
  NODE *node_7

METHOD builtin_types::tuple8/_type
  {
    CHECK_ARGUMENTS(0)
    MIN_RESULTS(1)
    MAX_RESULTS(8)
    START_ARGUMENTS(RESULT_COUNT)
    switch (RESULT_COUNT) {
      case 8: ARGUMENTS(7) = MYSELF->tuple8.node_7;
      case 7: ARGUMENTS(6) = MYSELF->tuple8.node_6;
      case 6: ARGUMENTS(5) = MYSELF->tuple8.node_5;
      case 5: ARGUMENTS(4) = MYSELF->tuple8.node_4;
      case 4: ARGUMENTS(3) = MYSELF->tuple8.node_3;
      case 3: ARGUMENTS(2) = MYSELF->tuple8.node_2;
      case 2: ARGUMENTS(1) = MYSELF->tuple8.node_1;
      case 1: ARGUMENTS(0) = MYSELF->tuple8.node_0;
    }
    RETURN
  }

METHOD long builtin_types::tuple8/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    /*NODE *subtype = get_attribute(node, poly_idx__std__subtype_of);
    if (CONTAINS_AN_ATTRIBUTE_VALUE(subtype)) {
      subtype = RETRIEVE_ATTRIBUTE_VALUE(subtype);
      if (TYPEOF(subtype) == TYPE(std_types::undefined)) {
	subtype = NULL;
      }
    } else {
      subtype = NULL;
    }*/
    long n, len;
    if (max_depth <= 1) {
      /*if (subtype) {
	n = 0;
	if (indent < 0) {
	  if (buf) *buf++ = ' ';
	  ++n;
	}
	n += print(&buf, "<tuple-");
	len = debug_string(subtype, 0, max_depth, buf);
	--len; // remove trailing newline
	if (buf) buf += len;
	n += len;
	n += print(&buf, ">\n");
	return n;
      } else {*/
	return debug_print(indent, buf, "<tuple of 8 items>");
      /*}*/
    } else {
      long i;
      n = debug_print_head(&indent, &buf, "tuple");
      /*if (subtype) {
	// replace the trailing newline with a hyphen
	if (buf) buf[-1] = '-';
	len = debug_string(subtype, 0, max_depth, buf);
	if (buf) buf += len;
	n += len;
      }*/
      const char *contents_indent = indent_to_string(indent);
      NODE **node_p = &node->tuple8.node_0;
      for (i = 0; i < 8; ++i) {
	n += print(&buf, contents_indent);
	len = debug_string(node_p[i], indent, max_depth-1, buf);
	if (buf) buf += len;
	n += len;
      }
      return n;
    }
  }

METHOD builtin_types::tuple8/to_list
  {
    CHECK_ARGUMENTS(1)
    NODE *self = ARGUMENTS(0);
    LIST_DATA *data = allocate(sizeof(LIST_DATA)+8*sizeof(NODE *));
    data->size = 8;
    data->length = 8;
    data->items[0] = self->tuple8.node_0;
    data->items[1] = self->tuple8.node_1;
    data->items[2] = self->tuple8.node_2;
    data->items[3] = self->tuple8.node_3;
    data->items[4] = self->tuple8.node_4;
    data->items[5] = self->tuple8.node_5;
    data->items[6] = self->tuple8.node_6;
    data->items[7] = self->tuple8.node_7;
    RETURN_SINGLE_RESULT(CREATE(std_types::list, 0, 8, data))
  }

METHOD builtin_types::tuple8/typed_tuple
  {
    CHECK_ARGUMENTS(9)
    NODE *prototype = ARGUMENTS(0);
    NODE *clone =
      CREATE(
	builtin_types::tuple8,
	ARGUMENTS(1),
	ARGUMENTS(2),
	ARGUMENTS(3),
	ARGUMENTS(4),
	ARGUMENTS(5),
	ARGUMENTS(6),
	ARGUMENTS(7),
	ARGUMENTS(8)
      );
    clone->attributes = prototype->attributes;
    RETURN_SINGLE_RESULT(clone)
  }

FUNCTION std::tuple
  #
    constructs a tuple from the specified arguments
  {
    MIN_ARGUMENTS(2)
    MAX_ARGUMENTS(8)
    switch (ARGUMENT_COUNT) {
      case 2:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple2,
	    ARGUMENTS(0),
	    ARGUMENTS(1)
	  )
	)
      case 3:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple3,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2)
	  )
	)
      case 4:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple4,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3)
	  )
	)
      case 5:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple5,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4)
	  )
	)
      case 6:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple6,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4),
	    ARGUMENTS(5)
	  )
	)
      case 7:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple7,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4),
	    ARGUMENTS(5),
	    ARGUMENTS(6)
	  )
	)
      case 8:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple8,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4),
	    ARGUMENTS(5),
	    ARGUMENTS(6),
	    ARGUMENTS(7)
	  )
	)
    }
  }

FUNCTION std::tuple_or_error
  #
    constructs a tuple from the specified arguments

    If any of the arguments is an error object then this error object (the
    leftmost one in case there is more than one) is returned instead of the
    tuple.
  {
    MIN_ARGUMENTS(2)
    MAX_ARGUMENTS(8)
    int i;
    for (i = 0; i < ARGUMENT_COUNT; ++i) {
      if (TYPEOF(ARGUMENTS(i)) == TYPE(std_types::error))
	RETURN_SINGLE_RESULT(ARGUMENTS(i))
    }
    switch (ARGUMENT_COUNT) {
      case 2:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple2,
	    ARGUMENTS(0),
	    ARGUMENTS(1)
	  )
	)
      case 3:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple3,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2)
	  )
	)
      case 4:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple4,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3)
	  )
	)
      case 5:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple5,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4)
	  )
	)
      case 6:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple6,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4),
	    ARGUMENTS(5)
	  )
	)
      case 7:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple7,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4),
	    ARGUMENTS(5),
	    ARGUMENTS(6)
	  )
	)
      case 8:
	RETURN_SINGLE_RESULT(
	  CREATE(builtin_types::tuple8,
	    ARGUMENTS(0),
	    ARGUMENTS(1),
	    ARGUMENTS(2),
	    ARGUMENTS(3),
	    ARGUMENTS(4),
	    ARGUMENTS(5),
	    ARGUMENTS(6),
	    ARGUMENTS(7)
	  )
	)
    }
  }

FUNCTION std::new_tuple
  #
    constructs a tuple with specified type and fields

    This function should be used for deserialization only!
  {
    CHECK_ARGUMENTS(2)
    NODE *prototype = ARGUMENTS(0);
    NODE *list = ARGUMENTS(1);
    if (TYPEOF(list) != TYPE(std_types::list)) INVALID_ARGUMENTS
    long offset = list->list.offset;
    long length = list->list.length;
    if (length < 2) {
      RUNTIME_ERROR("tuple_from_list - TOO FEW ITEMS")
      return;
    } else if (length > 8) {
      RUNTIME_ERROR("tuple_from_list - TOO MANY ITEMS")
      return;
    }
    LIST_DATA *data = list->list.data;
    NODE *tuple;
    switch (length) {
      case 2:
	tuple =
	  CREATE(builtin_types::tuple2,
	    data->items[offset+0],
	    data->items[offset+1]
	  );
	break;
      case 3:
	tuple =
	  CREATE(builtin_types::tuple3,
	    data->items[offset+0],
	    data->items[offset+1],
	    data->items[offset+2]
	  );
	break;
      case 4:
	tuple =
	  CREATE(builtin_types::tuple4,
	    data->items[offset+0],
	    data->items[offset+1],
	    data->items[offset+2],
	    data->items[offset+3]
	  );
	break;
      case 5:
	tuple =
	  CREATE(builtin_types::tuple5,
	    data->items[offset+0],
	    data->items[offset+1],
	    data->items[offset+2],
	    data->items[offset+3],
	    data->items[offset+4]
	  );
	break;
      case 6:
	tuple =
	  CREATE(builtin_types::tuple6,
	    data->items[offset+0],
	    data->items[offset+1],
	    data->items[offset+2],
	    data->items[offset+3],
	    data->items[offset+4],
	    data->items[offset+5]
	  );
	break;
      case 7:
	tuple =
	  CREATE(builtin_types::tuple7,
	    data->items[offset+0],
	    data->items[offset+1],
	    data->items[offset+2],
	    data->items[offset+3],
	    data->items[offset+4],
	    data->items[offset+5],
	    data->items[offset+6]
	  );
	break;
      case 8:
	tuple =
	  CREATE(builtin_types::tuple8,
	    data->items[offset+0],
	    data->items[offset+1],
	    data->items[offset+2],
	    data->items[offset+3],
	    data->items[offset+4],
	    data->items[offset+5],
	    data->items[offset+6],
	    data->items[offset+7]
	  );
	break;
    }
    if (TYPEOF(prototype) != TYPE(std_types::tuple)) {
      // std_types::tuple is generic and cannot be used!
      tuple->attributes = prototype->attributes;
    }
    RETURN_SINGLE_RESULT(tuple)
  }
