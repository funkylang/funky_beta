
#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Topics: Arrays, Collections

TYPE std_types::generic_array -> std_types::object
  #
    the prototype object for all kind of arrays

    Topic: Collections

    See also: std_types::array, std_types::boolean_array,
	      std_types::character_array, std_types::int8_array,
	      std_types::uint8_array, std_types::int16_array,
	      std_types::uint16_array, std_types::int32_array,
	      std_types::uint32_array, std_types::int64_array,
	      std_types::uint64_array, std_types::float32_array,
	      std_types::float64_array

METHOD std_types::generic_array/_type
  {
    RUNTIME_ERROR(
      "Attempt to call the generic array prototype object as a function!")
  }

RECORD ARRAY_INFO
  long dimension_count
  long dimensions[]

RECORD DIMENSION_INFO
  long first_index
  long width

RECORD ARRAY_VIEW
  long dimension_count
  DIMENSION_INFO dimensions[]

RECORD ARRAY_UPDATES
  long size
  long length
  char buffer[]

ATTR std::create_empty_array

CODE
  static ARRAY_VIEW *create_array_view
    (
      int dimension_count
    )
    {
      ARRAY_VIEW *view =
	allocate(ALLOCATION_SIZE(
	  sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
      view->dimension_count = dimension_count;
      for (int i = 0; i < dimension_count; ++i) {
	long dimension;
	if (!to_long(ARGUMENTS(i), &dimension)) return NULL;
	if (dimension < 1) {
	  invalid_arguments();
	  return NULL;
	}
	view->dimensions[i].first_index = 0;
	view->dimensions[i].width = dimension;
      }
      return view;
    }

  static ARRAY_VIEW *create_new_array_view
    (
      ARRAY_VIEW *view
    )
    {
      int dimension_count = view->dimension_count;
      ARRAY_VIEW *new_view =
	allocate(ALLOCATION_SIZE(
	  sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
      new_view->dimension_count = dimension_count;
      for (int i = 0; i < dimension_count; ++i) {
	new_view->dimensions[i].first_index = 0;
	new_view->dimensions[i].width = view->dimensions[i].width;
      }
      return new_view;
    }

  static ARRAY_DATA *create_array_info_and_data
    (
      ARRAY_VIEW *view,
      int item_size
    )
    {
      int dimension_count = view->dimension_count;
      ARRAY_INFO *info =
	allocate(
	  ALLOCATION_SIZE(sizeof(ARRAY_INFO)+dimension_count*sizeof(long)));
      info->dimension_count = dimension_count;
      long size = 1;
      for (int i = dimension_count-1; i >= 0; --i) {
	info->dimensions[i] = size;
	size *= view->dimensions[i].width;
      }
      ARRAY_DATA *data =
	allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
      data->info = info;
      data->size = size;
      return data;
    }

  static ARRAY_DATA *create_array_data
    (
      ARRAY_INFO *info,
      long size,
      int item_size
    )
    {
      ARRAY_DATA *data =
	allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
      data->info = info;
      data->size = size;
      return data;
    }

  static void *copy_array
    (
      ARRAY_VIEW *source_view,
      ARRAY_DATA *source_data,
      long source_offset,
      int i,
      int item_size,
      void *destination
    )
    {
      int dimension_count = source_view->dimension_count;
      long first_index = source_view->dimensions[i].first_index;
      long width = source_view->dimensions[i].width;
      if (i == dimension_count-1) {
	// last dimension
	source_offset += first_index;
	memcpy(
	  destination,
	  (char *)source_data->items+source_offset*item_size,
	  width*item_size);
	return (char *)destination+width*item_size;
      } else {
	long dimension = source_data->info->dimensions[i];
	source_offset += first_index*dimension;
	while (--width >= 0) {
	  destination = copy_array(
	    source_view, source_data, source_offset, i+1, item_size,
	    destination);
	  source_offset += dimension;
	}
	return destination;
      }
    }

  static ARRAY_DATA *new_array_data
    (
      ARRAY_INFO *info,
      int item_size
    )
    {
      int dimension_count = info->dimension_count;
      long size = info->dimensions[0];
      for (int i = 1; i < dimension_count; ++i) {
	size *= info->dimensions[i];
      }
      ARRAY_DATA *data =
	allocate_large(ALLOCATION_SIZE(sizeof(ARRAY_DATA)+size*item_size));
      data->info = info;
      data->size = size;
      return data;
    }

  static ARRAY_VIEW *create_sub_view
    (
      ARRAY_VIEW *view
    )
    {
      int dimension_count = view->dimension_count;
      ARRAY_VIEW *sub_view =
	allocate(ALLOCATION_SIZE(
	  sizeof(ARRAY_VIEW)+dimension_count*sizeof(DIMENSION_INFO)));
      sub_view->dimension_count = dimension_count;
      int i;
      for (i = 0; i < dimension_count; ++i) {
	NODE *argument = ARGUMENTS(1+i);
	if (TYPEOF(argument) != TYPE(std_types::value_range)) {
	  invalid_arguments();
	  return NULL;
	}
	long first;
	long last;
	if (
	  !to_long(argument->tuple2.node_0, &first) ||
	  !to_long(argument->tuple2.node_1, &last)
	) {
	  invalid_arguments();
	  return NULL;
	}
	if (first < 0) {
	  first += view->dimensions[i].width;
	} else {
	  --first;
	}

	if (last < 0) {
	  last += view->dimensions[i].width;
	} else {
	  --last;
	}
	if (
	  first < 0 || first >= view->dimensions[i].width ||
	  last < 0 || last >= view->dimensions[i].width ||
	  first > last
	) {
	  invalid_arguments();
	  return NULL;
	}
	sub_view->dimensions[i].first_index =
	  view->dimensions[i].first_index+first;
	sub_view->dimensions[i].width = last-first+1;
      }
      return sub_view;
    }

  static void *add_update
    (
      ARRAY *node,
      long item_size
    )
    {
      long length = node->updates_length;
      ARRAY_UPDATES *updates = node->updates;
      if (length == 0) {
	long size = ALLOCATION_SIZE(item_size);
	updates = allocate_large(sizeof(ARRAY_UPDATES)+size);
	updates->size = size;
	updates->length = length+item_size;
      } else if (
	length != node->updates->length ||
	length+item_size > node->updates->size
      ) {
	long size = ALLOCATION_SIZE(sizeof(ARRAY_UPDATES)+2*length+item_size);
	updates = allocate_large(size);
	updates->size = size;
	memcpy(updates->buffer, node->updates->buffer, length);
      }
      updates->length = length+item_size;
      ARRAY *new_node = allocate(sizeof(ARRAY));
      new_node->type = node->type;
      new_node->attributes = node->attributes;
      new_node->updates_length = length+item_size;
      new_node->data = node->data;
      new_node->view = node->view;
      new_node->updates = updates;
      return new_node;
    }

  static long compute_array_read_offset
    (
      NODE *array,
      ARRAY_INFO *info,
      ARRAY_VIEW *view
    )
    {
      long offset = 0;
      int i = 0;
      long idx;
      next:
      if (!to_long(ARGUMENTS(i), &idx)) return -1;
      if (idx < 0) {
	idx += view->dimensions[i].width;
      } else {
	--idx;
      }
      if (idx < 0 || idx >= view->dimensions[i].width) {
	invalid_index(array);
	return -1;
      }
      idx += view->dimensions[i].first_index;
      offset += idx*info->dimensions[i];
      if (++i >= view->dimension_count) return offset;
      goto next;
    }

  static long compute_array_write_offset
    (
      NODE *array,
      ARRAY_INFO *info,
      ARRAY_VIEW *view
    )
    {
      long offset = 0;
      int i = 0;
      long idx;
      next:
      if (!to_long(ARGUMENTS(i), &idx)) return -1;
      if (idx < 0) {
	idx += view->dimensions[i].width;
      } else {
	--idx;
      }
      if (idx < 0 || idx >= view->dimensions[i].width) {
	invalid_index(array);
	return -1;
      }
      offset += idx;
      if (++i >= view->dimension_count) return offset;
      offset *= view->dimensions[i].width;
      goto next;
    }

  static long array_debug_string
    (
      ARRAY_INFO *info,
      ARRAY_VIEW *view,
      int indent,
      char *buf,
      const char *typename
    )
    {
      char type[1024];
      char *p = type;
      print(&p, "<%s_array(", typename);
      int i;
      int dimension_count = view->dimension_count;
      for (i = 0; i < dimension_count; ++i) {
	if (i) *p++ = ' ';
	print(&p,
	  "%d..%d",
	  view->dimensions[i].first_index+1,
	  view->dimensions[i].first_index+view->dimensions[i].width
	);
      }
      *p++ = ')';
      *p++ = '>';
      *p = 0;
      return debug_print(indent, buf, type);
    }

  static int equal_array_type
    (
      NODE *left,
      NODE *right
    )
    {
      if (TYPEOF(left) != TYPEOF(right)) {
	error:
	invalid_arguments();
	return false;
      }
      ARRAY_VIEW *left_view = ((ARRAY *)left)->view;
      ARRAY_VIEW *right_view = ((ARRAY *)right)->view;
      if (
	left_view->dimension_count != right_view->dimension_count
      ) goto error;
      int i;
      for (i = 0; i < left_view->dimension_count; ++i) {
	if (
	  left_view->dimensions[i].width != right_view->dimensions[i].width
	) goto error;
      }
      return true;
    }

#######
# ARRAY OF OBJECTS
#

RECORD ARRAY_DATA
  ARRAY_INFO *info
  long size
  NODE *items[]

UNION UPDATE_ARRAY_DATA/SET_VALUE
  long offset
  NODE *value

TYPE std_types::array -> std_types::generic_array
  #
    an array of objects

    Topic: Collections

    See also: std_types::boolean_array, std_types::character_array,
	      std_types::int8_array, std_types::uint8_array,
	      std_types::int16_array, std_types::uint16_array,
	      std_types::int32_array, std_types::uint32_array,
	      std_types::int64_array, std_types::uint64_array,
	      std_types::float32_array, std_types::float64_array

  long updates_length
  ARRAY_VIEW *view
  ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static ARRAY_DATA *apply_array_updates(ARRAY *node)
    {
      ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(NODE *));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(NODE *), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::array/_type
  {
    ARRAY_DATA *data = MYSELF->array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_array_updates((ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->array.view);
      if (offset < 0) return;
      NODE *value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(value);
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->array.view);
      if (offset < 0) return;
      NODE *value;
      value = ARGUMENTS(dimension_count);
      long length = MYSELF->array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_ARRAY_DATA_SET_VALUE));
      UPDATE_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_ARRAY_DATA_SET_VALUE *)
	(MYSELF->array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->array.data->info, node->array.view,
      indent, buf, "");
  }

METHOD std_types::array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    ARRAY_DATA *data = ARGUMENTS(0)->array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

FUNCTION std::array
  #
    constructs an empty array

    See also: std_types::array/create_empty_array, std::initialized_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types::undefined;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, view, data, NULL))
  }

FUNCTION std::initialized_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::array, std_types::array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    NODE *initial_value;
    initial_value = ARGUMENTS(ARGUMENT_COUNT-1);
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, view, data, NULL))
  }

METHOD std_types::array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    ARRAY_DATA *data = (ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->array.data->info,
	ARGUMENTS(0)->array.data->size, sizeof(NODE *));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = (NODE *)&std_types::undefined;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0,
      ARGUMENTS(0)->array.view, data, NULL))
  }

METHOD std_types::array/range
  #
    creates a new array with the elements in the given ranges
  {
    ARRAY *array = (ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    ARRAY_DATA *data = apply_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::array, 0, view, data, NULL))
  }

#######
# ARRAY OF BOOLEAN VALUES
#

RECORD BOOLEAN_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int items[]

UNION UPDATE_BOOLEAN_ARRAY_DATA/SET_VALUE
  long offset
  int value

TYPE std_types::boolean_array -> std_types::generic_array
  # an array of boolean values
  long updates_length
  ARRAY_VIEW *view
  BOOLEAN_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static BOOLEAN_ARRAY_DATA *apply_boolean_array_updates(BOOLEAN_ARRAY *node)
    {
      BOOLEAN_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (BOOLEAN_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(int));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(int), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::boolean_array/_type
  {
    BOOLEAN_ARRAY_DATA *data = MYSELF->boolean_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_boolean_array_updates((BOOLEAN_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->boolean_array.view);
      if (offset < 0) return;
      int value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_bool(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->boolean_array.view);
      if (offset < 0) return;
      int value;
      CHECK(to_bool(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->boolean_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE));
      UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_BOOLEAN_ARRAY_DATA_SET_VALUE *)
	(MYSELF->boolean_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::boolean_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->boolean_array.data->info, node->boolean_array.view,
      indent, buf, "boolean");
  }

METHOD std_types::boolean_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->boolean_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::boolean_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    BOOLEAN_ARRAY_DATA *data = ARGUMENTS(0)->boolean_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::boolean_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int)*left->size) == 0)
  }
METHOD std_types::boolean_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0,
      ARGUMENTS(0)->boolean_array.view, data, NULL))
  }

METHOD std_types::boolean_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left =
      apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right =
      apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0,
      ARGUMENTS(0)->boolean_array.view, data, NULL))
  }

METHOD std_types::boolean_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    BOOLEAN_ARRAY_DATA *left = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(0));
    BOOLEAN_ARRAY_DATA *right = apply_boolean_array_updates((BOOLEAN_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    BOOLEAN_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(BOOLEAN_ARRAY_DATA)+size*sizeof(int)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0,
      ARGUMENTS(0)->boolean_array.view, data, NULL))
  }

FUNCTION std::boolean_array
  #
    constructs an empty array

    See also: std_types::boolean_array/create_empty_array,
	      std::initialized_boolean_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_boolean_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::boolean_array, std_types::boolean_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    int initial_value;
    CHECK(to_bool(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, view, data, NULL))
  }

METHOD std_types::boolean_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    BOOLEAN_ARRAY_DATA *data = (BOOLEAN_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->boolean_array.data->info,
	ARGUMENTS(0)->boolean_array.data->size, sizeof(int));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = false;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0,
      ARGUMENTS(0)->boolean_array.view, data, NULL))
  }

METHOD std_types::boolean_array/range
  #
    creates a new array with the elements in the given ranges
  {
    BOOLEAN_ARRAY *array = (BOOLEAN_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    BOOLEAN_ARRAY_DATA *data = apply_boolean_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::boolean_array, 0, view, data, NULL))
  }

#######
# ARRAY OF CHARACTERS
#

RECORD CHARACTER_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint32_t items[]

UNION UPDATE_CHARACTER_ARRAY_DATA/SET_VALUE
  long offset
  uint32_t value

TYPE std_types::character_array -> std_types::generic_array
  # an array of characters
  long updates_length
  ARRAY_VIEW *view
  CHARACTER_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static CHARACTER_ARRAY_DATA *apply_character_array_updates(CHARACTER_ARRAY *node)
    {
      CHARACTER_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (CHARACTER_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(uint32_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(uint32_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::character_array/_type
  {
    CHARACTER_ARRAY_DATA *data = MYSELF->character_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_character_array_updates((CHARACTER_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->character_array.view);
      if (offset < 0) return;
      uint32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uchar32(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->character_array.view);
      if (offset < 0) return;
      uint32_t value;
      CHECK(to_uchar32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->character_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE));
      UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_CHARACTER_ARRAY_DATA_SET_VALUE *)
	(MYSELF->character_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::character_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->character_array.data->info, node->character_array.view,
      indent, buf, "uchar32");
  }

METHOD std_types::character_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->character_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::character_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    CHARACTER_ARRAY_DATA *data = ARGUMENTS(0)->character_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::character_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    CHARACTER_ARRAY_DATA *left = apply_character_array_updates((CHARACTER_ARRAY *)ARGUMENTS(0));
    CHARACTER_ARRAY_DATA *right = apply_character_array_updates((CHARACTER_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint32_t)*left->size) == 0)
  }

FUNCTION std::character_array
  #
    constructs an empty array

    See also: std_types::character_array/create_empty_array,
	      std::initialized_character_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_character_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::character_array, std_types::character_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    uint32_t initial_value;
    CHECK(to_uchar32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, view, data, NULL))
  }

METHOD std_types::character_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    CHARACTER_ARRAY_DATA *data = (CHARACTER_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->character_array.data->info,
	ARGUMENTS(0)->character_array.data->size, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0,
      ARGUMENTS(0)->character_array.view, data, NULL))
  }

METHOD std_types::character_array/range
  #
    creates a new array with the elements in the given ranges
  {
    CHARACTER_ARRAY *array = (CHARACTER_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    CHARACTER_ARRAY_DATA *data = apply_character_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::character_array, 0, view, data, NULL))
  }

#######
# ARRAY OF SIGNED 8-BIT NUMBERS
#

RECORD INT8_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int8_t items[]

UNION UPDATE_INT8_ARRAY_DATA/SET_VALUE
  long offset
  int8_t value

TYPE std_types::int8_array -> std_types::generic_array
  # an array of signed 8-bit numbers
  long updates_length
  ARRAY_VIEW *view
  INT8_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT8_ARRAY_DATA *apply_int8_array_updates(INT8_ARRAY *node)
    {
      INT8_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (INT8_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(int8_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(int8_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int8_array/_type
  {
    INT8_ARRAY_DATA *data = MYSELF->int8_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int8_array_updates((INT8_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->int8_array.view);
      if (offset < 0) return;
      int8_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int8(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->int8_array.view);
      if (offset < 0) return;
      int8_t value;
      CHECK(to_int8(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int8_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT8_ARRAY_DATA_SET_VALUE));
      UPDATE_INT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT8_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int8_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int8_array.data->info, node->int8_array.view,
      indent, buf, "int8");
  }

METHOD std_types::int8_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int8_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int8_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT8_ARRAY_DATA *data = ARGUMENTS(0)->int8_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int8_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)ARGUMENTS(0));
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int8_t)*left->size) == 0)
  }

CODE
  static long int8_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      INT8_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      INT8_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += int8_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::int8_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    INT8_ARRAY_DATA *left = apply_int8_array_updates((INT8_ARRAY *)ARGUMENTS(0));
    INT8_ARRAY_DATA *right = apply_int8_array_updates((INT8_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_long(
	int8_array_scalar_product(
	  ARGUMENTS(0)->int8_array.view, left, 0,
	  ARGUMENTS(1)->int8_array.view, right, 0,
	  0)))
  }

FUNCTION std::int8_array
  #
    constructs an empty array

    See also: std_types::int8_array/create_empty_array,
	      std::initialized_int8_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_int8_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int8_array, std_types::int8_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    int8_t initial_value;
    CHECK(to_int8(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, view, data, NULL))
  }

METHOD std_types::int8_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT8_ARRAY_DATA *data = (INT8_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->int8_array.data->info,
	ARGUMENTS(0)->int8_array.data->size, sizeof(int8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0,
      ARGUMENTS(0)->int8_array.view, data, NULL))
  }

METHOD std_types::int8_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT8_ARRAY *array = (INT8_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT8_ARRAY_DATA *data = apply_int8_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int8_array, 0, view, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 8-BIT NUMBERS
#

RECORD UINT8_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint8_t items[]

UNION UPDATE_UINT8_ARRAY_DATA/SET_VALUE
  long offset
  uint8_t value

TYPE std_types::uint8_array -> std_types::generic_array
  # an array of unsigned 8-bit numbers
  long updates_length
  ARRAY_VIEW *view
  UINT8_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT8_ARRAY_DATA *apply_uint8_array_updates(UINT8_ARRAY *node)
    {
      UINT8_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (UINT8_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(uint8_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(uint8_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint8_array/_type
  {
    UINT8_ARRAY_DATA *data = MYSELF->uint8_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint8_array_updates((UINT8_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->uint8_array.view);
      if (offset < 0) return;
      uint8_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint8(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->uint8_array.view);
      if (offset < 0) return;
      uint8_t value;
      CHECK(to_uint8(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint8_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT8_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT8_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT8_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint8_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint8_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint8_array.data->info, node->uint8_array.view,
      indent, buf, "uint8");
  }

METHOD std_types::uint8_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint8_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint8_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT8_ARRAY_DATA *data = ARGUMENTS(0)->uint8_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint8_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint8_t)*left->size) == 0)
  }
METHOD std_types::uint8_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0,
      ARGUMENTS(0)->uint8_array.view, data, NULL))
  }

METHOD std_types::uint8_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left =
      apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right =
      apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0,
      ARGUMENTS(0)->uint8_array.view, data, NULL))
  }

METHOD std_types::uint8_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT8_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT8_ARRAY_DATA)+size*sizeof(uint8_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0,
      ARGUMENTS(0)->uint8_array.view, data, NULL))
  }

CODE
  static unsigned long uint8_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      UINT8_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      UINT8_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      unsigned long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += uint8_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::uint8_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT8_ARRAY_DATA *left = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(0));
    UINT8_ARRAY_DATA *right = apply_uint8_array_updates((UINT8_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_ulong(
	uint8_array_scalar_product(
	  ARGUMENTS(0)->uint8_array.view, left, 0,
	  ARGUMENTS(1)->uint8_array.view, right, 0,
	  0)))
  }

FUNCTION std::uint8_array
  #
    constructs an empty array

    See also: std_types::uint8_array/create_empty_array,
	      std::initialized_uint8_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_uint8_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint8_array, std_types::uint8_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    uint8_t initial_value;
    CHECK(to_uint8(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, view, data, NULL))
  }

METHOD std_types::uint8_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT8_ARRAY_DATA *data = (UINT8_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->uint8_array.data->info,
	ARGUMENTS(0)->uint8_array.data->size, sizeof(uint8_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0,
      ARGUMENTS(0)->uint8_array.view, data, NULL))
  }

METHOD std_types::uint8_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT8_ARRAY *array = (UINT8_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT8_ARRAY_DATA *data = apply_uint8_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint8_array, 0, view, data, NULL))
  }

#######
# ARRAY OF SIGNED 16-BIT NUMBERS
#

RECORD INT16_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int16_t items[]

UNION UPDATE_INT16_ARRAY_DATA/SET_VALUE
  long offset
  int16_t value

TYPE std_types::int16_array -> std_types::generic_array
  # an array of signed 16-bit numbers
  long updates_length
  ARRAY_VIEW *view
  INT16_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT16_ARRAY_DATA *apply_int16_array_updates(INT16_ARRAY *node)
    {
      INT16_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (INT16_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(int16_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(int16_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int16_array/_type
  {
    INT16_ARRAY_DATA *data = MYSELF->int16_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int16_array_updates((INT16_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->int16_array.view);
      if (offset < 0) return;
      int16_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int16(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->int16_array.view);
      if (offset < 0) return;
      int16_t value;
      CHECK(to_int16(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int16_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT16_ARRAY_DATA_SET_VALUE));
      UPDATE_INT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT16_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int16_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int16_array.data->info, node->int16_array.view,
      indent, buf, "int16");
  }

METHOD std_types::int16_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int16_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int16_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT16_ARRAY_DATA *data = ARGUMENTS(0)->int16_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int16_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)ARGUMENTS(0));
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int16_t)*left->size) == 0)
  }

CODE
  static long int16_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      INT16_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      INT16_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += int16_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::int16_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    INT16_ARRAY_DATA *left = apply_int16_array_updates((INT16_ARRAY *)ARGUMENTS(0));
    INT16_ARRAY_DATA *right = apply_int16_array_updates((INT16_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_long(
	int16_array_scalar_product(
	  ARGUMENTS(0)->int16_array.view, left, 0,
	  ARGUMENTS(1)->int16_array.view, right, 0,
	  0)))
  }

FUNCTION std::int16_array
  #
    constructs an empty array

    See also: std_types::int16_array/create_empty_array,
	      std::initialized_int16_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_int16_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int16_array, std_types::int16_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    int16_t initial_value;
    CHECK(to_int16(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, view, data, NULL))
  }

METHOD std_types::int16_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT16_ARRAY_DATA *data = (INT16_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->int16_array.data->info,
	ARGUMENTS(0)->int16_array.data->size, sizeof(int16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0,
      ARGUMENTS(0)->int16_array.view, data, NULL))
  }

METHOD std_types::int16_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT16_ARRAY *array = (INT16_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT16_ARRAY_DATA *data = apply_int16_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int16_array, 0, view, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 16-BIT NUMBERS
#

RECORD UINT16_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint16_t items[]

UNION UPDATE_UINT16_ARRAY_DATA/SET_VALUE
  long offset
  uint16_t value

TYPE std_types::uint16_array -> std_types::generic_array
  # an array of unsigned 16-bit numbers
  long updates_length
  ARRAY_VIEW *view
  UINT16_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT16_ARRAY_DATA *apply_uint16_array_updates(UINT16_ARRAY *node)
    {
      UINT16_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (UINT16_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(uint16_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(uint16_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint16_array/_type
  {
    UINT16_ARRAY_DATA *data = MYSELF->uint16_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint16_array_updates((UINT16_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->uint16_array.view);
      if (offset < 0) return;
      uint16_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint16(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->uint16_array.view);
      if (offset < 0) return;
      uint16_t value;
      CHECK(to_uint16(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint16_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT16_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT16_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT16_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint16_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint16_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint16_array.data->info, node->uint16_array.view,
      indent, buf, "uint16");
  }

METHOD std_types::uint16_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint16_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint16_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT16_ARRAY_DATA *data = ARGUMENTS(0)->uint16_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint16_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint16_t)*left->size) == 0)
  }
METHOD std_types::uint16_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0,
      ARGUMENTS(0)->uint16_array.view, data, NULL))
  }

METHOD std_types::uint16_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left =
      apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right =
      apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0,
      ARGUMENTS(0)->uint16_array.view, data, NULL))
  }

METHOD std_types::uint16_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT16_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT16_ARRAY_DATA)+size*sizeof(uint16_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0,
      ARGUMENTS(0)->uint16_array.view, data, NULL))
  }

CODE
  static unsigned long uint16_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      UINT16_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      UINT16_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      unsigned long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += uint16_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::uint16_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT16_ARRAY_DATA *left = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(0));
    UINT16_ARRAY_DATA *right = apply_uint16_array_updates((UINT16_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_ulong(
	uint16_array_scalar_product(
	  ARGUMENTS(0)->uint16_array.view, left, 0,
	  ARGUMENTS(1)->uint16_array.view, right, 0,
	  0)))
  }

FUNCTION std::uint16_array
  #
    constructs an empty array

    See also: std_types::uint16_array/create_empty_array,
	      std::initialized_uint16_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_uint16_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint16_array, std_types::uint16_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    uint16_t initial_value;
    CHECK(to_uint16(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, view, data, NULL))
  }

METHOD std_types::uint16_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT16_ARRAY_DATA *data = (UINT16_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->uint16_array.data->info,
	ARGUMENTS(0)->uint16_array.data->size, sizeof(uint16_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0,
      ARGUMENTS(0)->uint16_array.view, data, NULL))
  }

METHOD std_types::uint16_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT16_ARRAY *array = (UINT16_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT16_ARRAY_DATA *data = apply_uint16_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint16_array, 0, view, data, NULL))
  }

#######
# ARRAY OF SIGNED 32-BIT NUMBERS
#

RECORD INT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int32_t items[]

UNION UPDATE_INT32_ARRAY_DATA/SET_VALUE
  long offset
  int32_t value

TYPE std_types::int32_array -> std_types::generic_array
  # an array of signed 32-bit numbers
  long updates_length
  ARRAY_VIEW *view
  INT32_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT32_ARRAY_DATA *apply_int32_array_updates(INT32_ARRAY *node)
    {
      INT32_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (INT32_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(int32_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(int32_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int32_array/_type
  {
    INT32_ARRAY_DATA *data = MYSELF->int32_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int32_array_updates((INT32_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->int32_array.view);
      if (offset < 0) return;
      int32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int32(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->int32_array.view);
      if (offset < 0) return;
      int32_t value;
      CHECK(to_int32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int32_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT32_ARRAY_DATA_SET_VALUE));
      UPDATE_INT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT32_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int32_array.data->info, node->int32_array.view,
      indent, buf, "int32");
  }

METHOD std_types::int32_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int32_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int32_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT32_ARRAY_DATA *data = ARGUMENTS(0)->int32_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)ARGUMENTS(0));
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int32_t)*left->size) == 0)
  }

CODE
  static long int32_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      INT32_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      INT32_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += int32_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::int32_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    INT32_ARRAY_DATA *left = apply_int32_array_updates((INT32_ARRAY *)ARGUMENTS(0));
    INT32_ARRAY_DATA *right = apply_int32_array_updates((INT32_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_long(
	int32_array_scalar_product(
	  ARGUMENTS(0)->int32_array.view, left, 0,
	  ARGUMENTS(1)->int32_array.view, right, 0,
	  0)))
  }

FUNCTION std::int32_array
  #
    constructs an empty array

    See also: std_types::int32_array/create_empty_array,
	      std::initialized_int32_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_int32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int32_array, std_types::int32_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    int32_t initial_value;
    CHECK(to_int32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, view, data, NULL))
  }

METHOD std_types::int32_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT32_ARRAY_DATA *data = (INT32_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->int32_array.data->info,
	ARGUMENTS(0)->int32_array.data->size, sizeof(int32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0,
      ARGUMENTS(0)->int32_array.view, data, NULL))
  }

METHOD std_types::int32_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT32_ARRAY *array = (INT32_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT32_ARRAY_DATA *data = apply_int32_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int32_array, 0, view, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 32-BIT NUMBERS
#

RECORD UINT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint32_t items[]

UNION UPDATE_UINT32_ARRAY_DATA/SET_VALUE
  long offset
  uint32_t value

TYPE std_types::uint32_array -> std_types::generic_array
  # an array of unsigned 32-bit numbers
  long updates_length
  ARRAY_VIEW *view
  UINT32_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT32_ARRAY_DATA *apply_uint32_array_updates(UINT32_ARRAY *node)
    {
      UINT32_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (UINT32_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(uint32_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(uint32_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint32_array/_type
  {
    UINT32_ARRAY_DATA *data = MYSELF->uint32_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint32_array_updates((UINT32_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->uint32_array.view);
      if (offset < 0) return;
      uint32_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint32(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->uint32_array.view);
      if (offset < 0) return;
      uint32_t value;
      CHECK(to_uint32(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint32_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT32_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT32_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint32_array.data->info, node->uint32_array.view,
      indent, buf, "uint32");
  }

METHOD std_types::uint32_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint32_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint32_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT32_ARRAY_DATA *data = ARGUMENTS(0)->uint32_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint32_t)*left->size) == 0)
  }
METHOD std_types::uint32_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0,
      ARGUMENTS(0)->uint32_array.view, data, NULL))
  }

METHOD std_types::uint32_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left =
      apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right =
      apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0,
      ARGUMENTS(0)->uint32_array.view, data, NULL))
  }

METHOD std_types::uint32_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT32_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT32_ARRAY_DATA)+size*sizeof(uint32_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0,
      ARGUMENTS(0)->uint32_array.view, data, NULL))
  }

CODE
  static unsigned long uint32_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      UINT32_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      UINT32_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      unsigned long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += uint32_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::uint32_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT32_ARRAY_DATA *left = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(0));
    UINT32_ARRAY_DATA *right = apply_uint32_array_updates((UINT32_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_ulong(
	uint32_array_scalar_product(
	  ARGUMENTS(0)->uint32_array.view, left, 0,
	  ARGUMENTS(1)->uint32_array.view, right, 0,
	  0)))
  }

FUNCTION std::uint32_array
  #
    constructs an empty array

    See also: std_types::uint32_array/create_empty_array,
	      std::initialized_uint32_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_uint32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint32_array, std_types::uint32_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    uint32_t initial_value;
    CHECK(to_uint32(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, view, data, NULL))
  }

METHOD std_types::uint32_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT32_ARRAY_DATA *data = (UINT32_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->uint32_array.data->info,
	ARGUMENTS(0)->uint32_array.data->size, sizeof(uint32_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0,
      ARGUMENTS(0)->uint32_array.view, data, NULL))
  }

METHOD std_types::uint32_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT32_ARRAY *array = (UINT32_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT32_ARRAY_DATA *data = apply_uint32_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint32_array, 0, view, data, NULL))
  }

#######
# ARRAY OF SIGNED 64-BIT NUMBERS
#

RECORD INT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  int64_t items[]

UNION UPDATE_INT64_ARRAY_DATA/SET_VALUE
  long offset
  int64_t value

TYPE std_types::int64_array -> std_types::generic_array
  # an array of signed 64-bit numbers
  long updates_length
  ARRAY_VIEW *view
  INT64_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static INT64_ARRAY_DATA *apply_int64_array_updates(INT64_ARRAY *node)
    {
      INT64_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (INT64_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(int64_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(int64_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_INT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::int64_array/_type
  {
    INT64_ARRAY_DATA *data = MYSELF->int64_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_int64_array_updates((INT64_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->int64_array.view);
      if (offset < 0) return;
      int64_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_int64(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->int64_array.view);
      if (offset < 0) return;
      int64_t value;
      CHECK(to_int64(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->int64_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_INT64_ARRAY_DATA_SET_VALUE));
      UPDATE_INT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_INT64_ARRAY_DATA_SET_VALUE *)
	(MYSELF->int64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::int64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->int64_array.data->info, node->int64_array.view,
      indent, buf, "int64");
  }

METHOD std_types::int64_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->int64_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::int64_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT64_ARRAY_DATA *data = ARGUMENTS(0)->int64_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::int64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)ARGUMENTS(0));
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(int64_t)*left->size) == 0)
  }

CODE
  static long int64_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      INT64_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      INT64_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += int64_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::int64_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    INT64_ARRAY_DATA *left = apply_int64_array_updates((INT64_ARRAY *)ARGUMENTS(0));
    INT64_ARRAY_DATA *right = apply_int64_array_updates((INT64_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_long(
	int64_array_scalar_product(
	  ARGUMENTS(0)->int64_array.view, left, 0,
	  ARGUMENTS(1)->int64_array.view, right, 0,
	  0)))
  }

FUNCTION std::int64_array
  #
    constructs an empty array

    See also: std_types::int64_array/create_empty_array,
	      std::initialized_int64_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_int64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::int64_array, std_types::int64_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    int64_t initial_value;
    CHECK(to_int64(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, view, data, NULL))
  }

METHOD std_types::int64_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    INT64_ARRAY_DATA *data = (INT64_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->int64_array.data->info,
	ARGUMENTS(0)->int64_array.data->size, sizeof(int64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0,
      ARGUMENTS(0)->int64_array.view, data, NULL))
  }

METHOD std_types::int64_array/range
  #
    creates a new array with the elements in the given ranges
  {
    INT64_ARRAY *array = (INT64_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    INT64_ARRAY_DATA *data = apply_int64_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::int64_array, 0, view, data, NULL))
  }

#######
# ARRAY OF UNSIGNED 64-BIT NUMBERS
#

RECORD UINT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  uint64_t items[]

UNION UPDATE_UINT64_ARRAY_DATA/SET_VALUE
  long offset
  uint64_t value

TYPE std_types::uint64_array -> std_types::generic_array
  # an array of unsigned 64-bit numbers
  long updates_length
  ARRAY_VIEW *view
  UINT64_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static UINT64_ARRAY_DATA *apply_uint64_array_updates(UINT64_ARRAY *node)
    {
      UINT64_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (UINT64_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(uint64_t));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(uint64_t), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::uint64_array/_type
  {
    UINT64_ARRAY_DATA *data = MYSELF->uint64_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_uint64_array_updates((UINT64_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->uint64_array.view);
      if (offset < 0) return;
      uint64_t value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_uint64(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->uint64_array.view);
      if (offset < 0) return;
      uint64_t value;
      CHECK(to_uint64(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->uint64_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_UINT64_ARRAY_DATA_SET_VALUE));
      UPDATE_UINT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_UINT64_ARRAY_DATA_SET_VALUE *)
	(MYSELF->uint64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::uint64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->uint64_array.data->info, node->uint64_array.view,
      indent, buf, "uint64");
  }

METHOD std_types::uint64_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->uint64_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::uint64_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT64_ARRAY_DATA *data = ARGUMENTS(0)->uint64_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::uint64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(uint64_t)*left->size) == 0)
  }
METHOD std_types::uint64_array/bit_and
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] & right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0,
      ARGUMENTS(0)->uint64_array.view, data, NULL))
  }

METHOD std_types::uint64_array/bit_or
  #
    implements the *or* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left =
      apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right =
      apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] | right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0,
      ARGUMENTS(0)->uint64_array.view, data, NULL))
  }

METHOD std_types::uint64_array/bit_xor
  #
    implements the *xor* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    long size = left->size;
    UINT64_ARRAY_DATA *data =
      allocate_large(
	ALLOCATION_SIZE(sizeof(UINT64_ARRAY_DATA)+size*sizeof(uint64_t)));
    long i;
    for (i = 0; i < size; ++i) {
      data->items[i] = left->items[i] ^ right->items[i];
    }
    data->info = left->info;
    data->size = size;
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0,
      ARGUMENTS(0)->uint64_array.view, data, NULL))
  }

CODE
  static unsigned long uint64_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      UINT64_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      UINT64_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      unsigned long result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += uint64_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::uint64_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    UINT64_ARRAY_DATA *left = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(0));
    UINT64_ARRAY_DATA *right = apply_uint64_array_updates((UINT64_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_ulong(
	uint64_array_scalar_product(
	  ARGUMENTS(0)->uint64_array.view, left, 0,
	  ARGUMENTS(1)->uint64_array.view, right, 0,
	  0)))
  }

FUNCTION std::uint64_array
  #
    constructs an empty array

    See also: std_types::uint64_array/create_empty_array,
	      std::initialized_uint64_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_uint64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::uint64_array, std_types::uint64_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    uint64_t initial_value;
    CHECK(to_uint64(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, view, data, NULL))
  }

METHOD std_types::uint64_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    UINT64_ARRAY_DATA *data = (UINT64_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->uint64_array.data->info,
	ARGUMENTS(0)->uint64_array.data->size, sizeof(uint64_t));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0,
      ARGUMENTS(0)->uint64_array.view, data, NULL))
  }

METHOD std_types::uint64_array/range
  #
    creates a new array with the elements in the given ranges
  {
    UINT64_ARRAY *array = (UINT64_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    UINT64_ARRAY_DATA *data = apply_uint64_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::uint64_array, 0, view, data, NULL))
  }

#######
# ARRAY OF 32-BIT FLOATING POINT NUMBERS
#

RECORD FLOAT32_ARRAY_DATA
  ARRAY_INFO *info
  long size
  float items[]

UNION UPDATE_FLOAT32_ARRAY_DATA/SET_VALUE
  long offset
  float value

TYPE std_types::float32_array -> std_types::generic_array
  # an array of 32-bit floating point numbers
  long updates_length
  ARRAY_VIEW *view
  FLOAT32_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static FLOAT32_ARRAY_DATA *apply_float32_array_updates(FLOAT32_ARRAY *node)
    {
      FLOAT32_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (FLOAT32_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(float));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(float), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::float32_array/_type
  {
    FLOAT32_ARRAY_DATA *data = MYSELF->float32_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_float32_array_updates((FLOAT32_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->float32_array.view);
      if (offset < 0) return;
      float value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_float(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->float32_array.view);
      if (offset < 0) return;
      float value;
      CHECK(to_float(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->float32_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_FLOAT32_ARRAY_DATA_SET_VALUE *)
	(MYSELF->float32_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::float32_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float32_array.data->info, node->float32_array.view,
      indent, buf, "float32");
  }

METHOD std_types::float32_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->float32_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::float32_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT32_ARRAY_DATA *data = ARGUMENTS(0)->float32_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::float32_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)ARGUMENTS(0));
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(float)*left->size) == 0)
  }

CODE
  static double float32_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      FLOAT32_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      FLOAT32_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      double result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += float32_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::float32_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    FLOAT32_ARRAY_DATA *left = apply_float32_array_updates((FLOAT32_ARRAY *)ARGUMENTS(0));
    FLOAT32_ARRAY_DATA *right = apply_float32_array_updates((FLOAT32_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_double(
	float32_array_scalar_product(
	  ARGUMENTS(0)->float32_array.view, left, 0,
	  ARGUMENTS(1)->float32_array.view, right, 0,
	  0)))
  }

FUNCTION std::float32_array
  #
    constructs an empty array

    See also: std_types::float32_array/create_empty_array,
	      std::initialized_float32_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_float32_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::float32_array, std_types::float32_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    float initial_value;
    CHECK(to_float(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, view, data, NULL))
  }

METHOD std_types::float32_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT32_ARRAY_DATA *data = (FLOAT32_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->float32_array.data->info,
	ARGUMENTS(0)->float32_array.data->size, sizeof(float));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0,
      ARGUMENTS(0)->float32_array.view, data, NULL))
  }

METHOD std_types::float32_array/range
  #
    creates a new array with the elements in the given ranges
  {
    FLOAT32_ARRAY *array = (FLOAT32_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT32_ARRAY_DATA *data = apply_float32_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::float32_array, 0, view, data, NULL))
  }

#######
# ARRAY OF 64-BIT FLOATING POINT NUMBERS
#

RECORD FLOAT64_ARRAY_DATA
  ARRAY_INFO *info
  long size
  double items[]

UNION UPDATE_FLOAT64_ARRAY_DATA/SET_VALUE
  long offset
  double value

TYPE std_types::float64_array -> std_types::generic_array
  # an array of 64-bit floating point numbers
  long updates_length
  ARRAY_VIEW *view
  FLOAT64_ARRAY_DATA *data
  ARRAY_UPDATES *updates

CODE
  static FLOAT64_ARRAY_DATA *apply_float64_array_updates(FLOAT64_ARRAY *node)
    {
      FLOAT64_ARRAY_DATA *data = node->data;
      if (node->updates_length > 0) {
	ARRAY_VIEW *view = create_new_array_view(node->view);
	data = (FLOAT64_ARRAY_DATA *)
	  create_array_info_and_data(view, sizeof(double));
	// copy items
	copy_array(
	  node->view, (ARRAY_DATA *)node->data, 0, 0,
	  sizeof(double), data->items);
	// apply updates
	char *update = node->updates->buffer;
	char *end_p = update+node->updates_length;
	while (update < end_p) {
	  switch (*(TAG *)update) {
	    case SET_VALUE:;
	      UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *set_value = (void *)update;
	      data->items[set_value->offset] = set_value->value;
	      update += sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE);
	      break;
	  }
	}
	node->updates_length = 0;
	node->view = view;
	node->data = data;
	node->updates = NULL;
      }
      return data;
    }

METHOD std_types::float64_array/_type
  {
    FLOAT64_ARRAY_DATA *data = MYSELF->float64_array.data;
    int dimension_count = data->info->dimension_count;
    MIN_ARGUMENTS(dimension_count)
    MAX_ARGUMENTS(dimension_count+1)
    if (ARGUMENT_COUNT == dimension_count) {
      // get item
      data = apply_float64_array_updates((FLOAT64_ARRAY *)MYSELF);
      // info and view could have been updated!
      long offset = compute_array_read_offset(
	MYSELF, data->info, MYSELF->float64_array.view);
      if (offset < 0) return;
      double value;
      value = data->items[offset];
      RETURN_SINGLE_RESULT(from_double(value));
    } else {
      // set item
      long offset = compute_array_write_offset(
	MYSELF, data->info, MYSELF->float64_array.view);
      if (offset < 0) return;
      double value;
      CHECK(to_double(ARGUMENTS(dimension_count), &value))
      long length = MYSELF->float64_array.updates_length;
      MYSELF =
	add_update(
	  (ARRAY *)MYSELF, sizeof(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE));
      UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *update =
	(UPDATE_FLOAT64_ARRAY_DATA_SET_VALUE *)
	(MYSELF->float64_array.updates->buffer+length);
      update->tag = SET_VALUE;
      update->offset = offset;
      update->value = value;
      RETURN_SINGLE_RESULT(MYSELF)
    }
  }

METHOD long std_types::float64_array/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return array_debug_string(
      node->float64_array.data->info, node->float64_array.view,
      indent, buf, "float64");
  }

METHOD std_types::float64_array/length_of
  #
    implements the *length_of* operation

    An extra argument can be supplied to specify the dimension to query.

    This argument can be omitted, if the array is one-dimensional.
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_RESULTS(1)
    ARRAY_VIEW *view = ARGUMENTS(0)->float64_array.view;
    int dimension = 1;
    if (ARGUMENT_COUNT == 2) {
      CHECK(to_int(ARGUMENTS(1), &dimension))
      if (dimension < 1 || dimension > view->dimension_count) {
	invalid_dimension(ARGUMENTS(0));
	return;
      }
    }
    RETURN_SINGLE_RESULT(from_long(view->dimensions[dimension-1].width))
  }

METHOD std_types::float64_array/dimension_count_of
  #
    implements the *dimension_count_of* operation
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT64_ARRAY_DATA *data = ARGUMENTS(0)->float64_array.data;
    RETURN_SINGLE_RESULT(from_long(data->info->dimension_count))
  }

METHOD std_types::float64_array/equal
  #
    implements the *equal* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_TRUE
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0))) RETURN_FALSE
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)ARGUMENTS(0));
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)ARGUMENTS(1));
    RETURN_BOOLEAN(
      memcmp(
	left->items, right->items,sizeof(double)*left->size) == 0)
  }

CODE
  static double float64_array_scalar_product
    (
      ARRAY_VIEW *left_view,
      FLOAT64_ARRAY_DATA *left_data,
      long left_offset,
      ARRAY_VIEW *right_view,
      FLOAT64_ARRAY_DATA *right_data,
      long right_offset,
      int i
    )
    {
      int dimension_count = left_view->dimension_count;
      long first_left_index = left_view->dimensions[i].first_index;
      long first_right_index = right_view->dimensions[i].first_index;
      long width = left_view->dimensions[i].width;
      double result = 0;
      if (i == dimension_count-1) {
	// last dimension
	left_offset += first_left_index;
	right_offset += first_right_index;
	while (--width >= 0) {
	  result +=
	    left_data->items[left_offset++] *
	    right_data->items[right_offset++];
	}
      } else {
	long left_dimension = left_data->info->dimensions[0];
	long right_dimension = right_data->info->dimensions[0];
	left_offset += first_left_index*left_dimension;
	right_offset += first_right_index*right_dimension;
	while (--width >= 0) {
	  result += float64_array_scalar_product(
	    left_view, left_data, left_offset,
	    right_view, right_data, right_offset, i+1);
	  left_offset += left_dimension;
	  right_offset += right_dimension;
	}
      }
      return result;
    }

METHOD std_types::float64_array/times
  #
    implements the *and* operation
  {
    CHECK_ARGUMENTS(2)
    CHECK_RESULTS(1)
    if (ARGUMENTS(1) == ARGUMENTS(0)) RETURN_SINGLE_RESULT(ARGUMENTS(0))
    if (!equal_array_type(ARGUMENTS(1), ARGUMENTS(0)))
      INVALID_ARGUMENTS
    FLOAT64_ARRAY_DATA *left = apply_float64_array_updates((FLOAT64_ARRAY *)ARGUMENTS(0));
    FLOAT64_ARRAY_DATA *right = apply_float64_array_updates((FLOAT64_ARRAY *)ARGUMENTS(1));
    RETURN_SINGLE_RESULT(
      from_double(
	float64_array_scalar_product(
	  ARGUMENTS(0)->float64_array.view, left, 0,
	  ARGUMENTS(1)->float64_array.view, right, 0,
	  0)))
  }

FUNCTION std::float64_array
  #
    constructs an empty array

    See also: std_types::float64_array/create_empty_array,
	      std::initialized_float64_array
  {
    MIN_ARGUMENTS(1)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, view, data, NULL))
  }

FUNCTION std::initialized_float64_array
  #
    constructs an initialized array

    The last argument specifies the initial value for all array items.

    See also: std::float64_array, std_types::float64_array/create_empty_array
  {
    MIN_ARGUMENTS(2)
    ARRAY_VIEW *view = create_array_view(ARGUMENT_COUNT-1);
    if (!view) return;
    double initial_value;
    CHECK(to_double(ARGUMENTS(ARGUMENT_COUNT-1), &initial_value))
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_info_and_data(view, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = initial_value;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, view, data, NULL))
  }

METHOD std_types::float64_array/create_empty_array
  #
    creates an empty new array based on the given template array
  {
    CHECK_ARGUMENTS(1)
    CHECK_RESULTS(1)
    FLOAT64_ARRAY_DATA *data = (FLOAT64_ARRAY_DATA *)
      create_array_data(ARGUMENTS(0)->float64_array.data->info,
	ARGUMENTS(0)->float64_array.data->size, sizeof(double));
    if (!data) return;
    int i;
    for (i = 0; i < data->size; ++i) {
      data->items[i] = 0;
    }
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0,
      ARGUMENTS(0)->float64_array.view, data, NULL))
  }

METHOD std_types::float64_array/range
  #
    creates a new array with the elements in the given ranges
  {
    FLOAT64_ARRAY *array = (FLOAT64_ARRAY *)ARGUMENTS(0);
    int dimension_count = array->view->dimension_count;
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(1+dimension_count)
    ARRAY_VIEW *view = create_sub_view(array->view);
    if (!view) return;
    FLOAT64_ARRAY_DATA *data = apply_float64_array_updates(array);
    RETURN_SINGLE_RESULT(CREATE(std_types::float64_array, 0, view, data, NULL))
  }
