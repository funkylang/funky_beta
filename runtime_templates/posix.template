#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

# Topic: POSIX

INCLUDE dirent.h

OBJECT std::BLOCK_DEVICE -> std_types::file_type
  {DT_BLK}

OBJECT std::CHARACTER_DEVICE -> std_types::file_type
  {DT_CHR}

OBJECT std::DIRECTORY -> std_types::file_type
  {DT_DIR}

OBJECT std::NAMED_PIPE -> std_types::file_type
  {DT_FIFO}

OBJECT std::SYMBOLIC_LINK -> std_types::file_type
  {DT_LNK}

OBJECT std::REGULAR_FILE -> std_types::file_type
  {DT_REG}

OBJECT std::SOCKET -> std_types::file_type
  {DT_SOCK}

OBJECT std::UNKNOWN_FILE_TYPE -> std_types::file_type
  {DT_UNKNOWN}

OBJECT std::STDIN_FILENO -> std_types::file_descriptor
  {STDIN_FILENO}

OBJECT std::STDOUT_FILENO -> std_types::file_descriptor
  {STDOUT_FILENO}

OBJECT std::STDERR_FILENO -> std_types::file_descriptor
  {STDERR_FILENO}

OBJECT std::SHUT_RD -> std_types::shutdown_type
  {SHUT_RD}

OBJECT std::SHUT_WR -> std_types::shutdown_type
  {SHUT_WR}

OBJECT std::SHUT_RDWR -> std_types::shutdown_type
  {SHUT_RDWR}

OBJECT std::SEEK_SET -> std_types::seek_type
  {SEEK_SET}

OBJECT std::SEEK_CUR -> std_types::seek_type
  {SEEK_CUR}

OBJECT std::SEEK_END -> std_types::seek_type
  {SEEK_END}

OBJECT std::ENOERR -> std_types::error_number
  {0}

OBJECT std::EPERM -> std_types::error_number
  {EPERM}

OBJECT std::ENOENT -> std_types::error_number
  {ENOENT}

OBJECT std::ESRCH -> std_types::error_number
  {ESRCH}

OBJECT std::EINTR -> std_types::error_number
  {EINTR}

OBJECT std::EIO -> std_types::error_number
  {EIO}

OBJECT std::ENXIO -> std_types::error_number
  {ENXIO}

OBJECT std::E2BIG -> std_types::error_number
  {E2BIG}

OBJECT std::ENOEXEC -> std_types::error_number
  {ENOEXEC}

OBJECT std::EBADF -> std_types::error_number
  {EBADF}

OBJECT std::ECHILD -> std_types::error_number
  {ECHILD}

OBJECT std::EAGAIN -> std_types::error_number
  {EAGAIN}

OBJECT std::ENOMEM -> std_types::error_number
  {ENOMEM}

OBJECT std::EACCES -> std_types::error_number
  {EACCES}

OBJECT std::EFAULT -> std_types::error_number
  {EFAULT}

OBJECT std::ENOTBLK -> std_types::error_number
  {ENOTBLK}

OBJECT std::EBUSY -> std_types::error_number
  {EBUSY}

OBJECT std::EEXIST -> std_types::error_number
  {EEXIST}

OBJECT std::EXDEV -> std_types::error_number
  {EXDEV}

OBJECT std::ENODEV -> std_types::error_number
  {ENODEV}

OBJECT std::ENOTDIR -> std_types::error_number
  {ENOTDIR}

OBJECT std::EISDIR -> std_types::error_number
  {EISDIR}

OBJECT std::EINVAL -> std_types::error_number
  {EINVAL}

OBJECT std::ENFILE -> std_types::error_number
  {ENFILE}

OBJECT std::EMFILE -> std_types::error_number
  {EMFILE}

OBJECT std::ENOTTY -> std_types::error_number
  {ENOTTY}

OBJECT std::ETXTBSY -> std_types::error_number
  {ETXTBSY}

OBJECT std::EFBIG -> std_types::error_number
  {EFBIG}

OBJECT std::ENOSPC -> std_types::error_number
  {ENOSPC}

OBJECT std::ESPIPE -> std_types::error_number
  {ESPIPE}

OBJECT std::EROFS -> std_types::error_number
  {EROFS}

OBJECT std::EMLINK -> std_types::error_number
  {EMLINK}

OBJECT std::EPIPE -> std_types::error_number
  {EPIPE}

OBJECT std::EDOM -> std_types::error_number
  {EDOM}

OBJECT std::ERANGE -> std_types::error_number
  {ERANGE}

OBJECT std::EDEADLK -> std_types::error_number
  {EDEADLK}

OBJECT std::ENAMETOOLONG -> std_types::error_number
  {ENAMETOOLONG}

OBJECT std::ENOLCK -> std_types::error_number
  {ENOLCK}

OBJECT std::ENOSYS -> std_types::error_number
  {ENOSYS}

OBJECT std::ENOTEMPTY -> std_types::error_number
  {ENOTEMPTY}

OBJECT std::EILSEQ -> std_types::error_number
  {EILSEQ}

OBJECT std::ELOOP -> std_types::error_number
  {ELOOP}

OBJECT std::ENOMSG -> std_types::error_number
  {ENOMSG}

OBJECT std::EIDRM -> std_types::error_number
  {EIDRM}

OBJECT std::ECHRNG -> std_types::error_number
  {ECHRNG}

OBJECT std::EL2NSYNC -> std_types::error_number
  {EL2NSYNC}

OBJECT std::EL3HLT -> std_types::error_number
  {EL3HLT}

OBJECT std::EL3RST -> std_types::error_number
  {EL3RST}

OBJECT std::ELNRNG -> std_types::error_number
  {ELNRNG}

OBJECT std::EUNATCH -> std_types::error_number
  {EUNATCH}

OBJECT std::ENOCSI -> std_types::error_number
  {ENOCSI}

OBJECT std::EL2HLT -> std_types::error_number
  {EL2HLT}

OBJECT std::EBADE -> std_types::error_number
  {EBADE}

OBJECT std::EBADR -> std_types::error_number
  {EBADR}

OBJECT std::EXFULL -> std_types::error_number
  {EXFULL}

OBJECT std::ENOANO -> std_types::error_number
  {ENOANO}

OBJECT std::EBADRQC -> std_types::error_number
  {EBADRQC}

OBJECT std::EBADSLT -> std_types::error_number
  {EBADSLT}

OBJECT std::EBFONT -> std_types::error_number
  {EBFONT}

OBJECT std::ENOSTR -> std_types::error_number
  {ENOSTR}

OBJECT std::ENODATA -> std_types::error_number
  {ENODATA}

OBJECT std::ETIME -> std_types::error_number
  {ETIME}

OBJECT std::ENOSR -> std_types::error_number
  {ENOSR}

OBJECT std::ENONET -> std_types::error_number
  {ENONET}

OBJECT std::ENOPKG -> std_types::error_number
  {ENOPKG}

OBJECT std::EREMOTE -> std_types::error_number
  {EREMOTE}

OBJECT std::ENOLINK -> std_types::error_number
  {ENOLINK}

OBJECT std::EADV -> std_types::error_number
  {EADV}

OBJECT std::ESRMNT -> std_types::error_number
  {ESRMNT}

OBJECT std::ECOMM -> std_types::error_number
  {ECOMM}

OBJECT std::EPROTO -> std_types::error_number
  {EPROTO}

OBJECT std::EMULTIHOP -> std_types::error_number
  {EMULTIHOP}

OBJECT std::EDOTDOT -> std_types::error_number
  {EDOTDOT}

OBJECT std::EBADMSG -> std_types::error_number
  {EBADMSG}

OBJECT std::EOVERFLOW -> std_types::error_number
  {EOVERFLOW}

OBJECT std::ENOTUNIQ -> std_types::error_number
  {ENOTUNIQ}

OBJECT std::EBADFD -> std_types::error_number
  {EBADFD}

OBJECT std::EREMCHG -> std_types::error_number
  {EREMCHG}

OBJECT std::ELIBACC -> std_types::error_number
  {ELIBACC}

OBJECT std::ELIBBAD -> std_types::error_number
  {ELIBBAD}

OBJECT std::ELIBSCN -> std_types::error_number
  {ELIBSCN}

OBJECT std::ELIBMAX -> std_types::error_number
  {ELIBMAX}

OBJECT std::ELIBEXEC -> std_types::error_number
  {ELIBEXEC}

OBJECT std::ESTRPIPE -> std_types::error_number
  {ESTRPIPE}

OBJECT std::EUSERS -> std_types::error_number
  {EUSERS}

OBJECT std::ENOTSOCK -> std_types::error_number
  {ENOTSOCK}

OBJECT std::EDESTADDRREQ -> std_types::error_number
  {EDESTADDRREQ}

OBJECT std::EMSGSIZE -> std_types::error_number
  {EMSGSIZE}

OBJECT std::EPROTOTYPE -> std_types::error_number
  {EPROTOTYPE}

OBJECT std::ENOPROTOOPT -> std_types::error_number
  {ENOPROTOOPT}

OBJECT std::EPROTONOSUPPORT -> std_types::error_number
  {EPROTONOSUPPORT}

OBJECT std::ESOCKTNOSUPPORT -> std_types::error_number
  {ESOCKTNOSUPPORT}

OBJECT std::EOPNOTSUPP -> std_types::error_number
  {EOPNOTSUPP}

OBJECT std::EPFNOSUPPORT -> std_types::error_number
  {EPFNOSUPPORT}

OBJECT std::EAFNOSUPPORT -> std_types::error_number
  {EAFNOSUPPORT}

OBJECT std::EADDRINUSE -> std_types::error_number
  {EADDRINUSE}

OBJECT std::EADDRNOTAVAIL -> std_types::error_number
  {EADDRNOTAVAIL}

OBJECT std::ENETDOWN -> std_types::error_number
  {ENETDOWN}

OBJECT std::ENETUNREACH -> std_types::error_number
  {ENETUNREACH}

OBJECT std::ENETRESET -> std_types::error_number
  {ENETRESET}

OBJECT std::ECONNABORTED -> std_types::error_number
  {ECONNABORTED}

OBJECT std::ECONNRESET -> std_types::error_number
  {ECONNRESET}

OBJECT std::ENOBUFS -> std_types::error_number
  {ENOBUFS}

OBJECT std::EISCONN -> std_types::error_number
  {EISCONN}

OBJECT std::ENOTCONN -> std_types::error_number
  {ENOTCONN}

OBJECT std::ESHUTDOWN -> std_types::error_number
  {ESHUTDOWN}

OBJECT std::ETOOMANYREFS -> std_types::error_number
  {ETOOMANYREFS}

OBJECT std::ETIMEDOUT -> std_types::error_number
  {ETIMEDOUT}

OBJECT std::ECONNREFUSED -> std_types::error_number
  {ECONNREFUSED}

OBJECT std::EHOSTDOWN -> std_types::error_number
  {EHOSTDOWN}

OBJECT std::EHOSTUNREACH -> std_types::error_number
  {EHOSTUNREACH}

OBJECT std::EALREADY -> std_types::error_number
  {EALREADY}

OBJECT std::EINPROGRESS -> std_types::error_number
  {EINPROGRESS}

OBJECT std::ESTALE -> std_types::error_number
  {ESTALE}

OBJECT std::EDQUOT -> std_types::error_number
  {EDQUOT}

OBJECT std::ENOMEDIUM -> std_types::error_number
  {ENOMEDIUM}

OBJECT std::ECANCELED -> std_types::error_number
  {ECANCELED}

OBJECT std::EOWNERDEAD -> std_types::error_number
  {EOWNERDEAD}

OBJECT std::ENOTRECOVERABLE -> std_types::error_number
  {ENOTRECOVERABLE}

POLY std::access_time_of
POLY std::block_count_of
POLY std::block_size_of
POLY std::device_of
POLY std::group_id_of
POLY std::home_directory_of
POLY std::inode_number_of
POLY std::link_count_of
POLY std::mode_of
POLY std::modification_time_of
POLY std::name_of
POLY std::password_of
POLY std::root_device_of
POLY std::shell_of
POLY std::size_of
POLY std::status_change_time_of
POLY std::type_of
POLY std::user_id_of
POLY std::user_information_of
POLY std::username_of

TYPE std_types::file_type -> std_types::object
  int value

METHOD std_types::file_type/_type
  {
    RUNTIME_ERROR("Attempt to call a file type as a function!")
  }

METHOD long std_types::file_type/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<file_type %d>", node->file_type.value);
  }

CODE
  static int file_type_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::file_type)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->file_type.value;
	return true;
      }
    }

CODE
  static NODE *file_type_from_int
    (
      int value
    )
    {
      return create__std_types___file_type(value);
    }

METHOD std_types::file_type/equal
  #
    compares two file types for equality

    Parameters:
      left: a file type
      right: a file type

    Result:
      success  # true if the two file types are equal

    Topic: POSIX

    See also: std_types::file_type, std_types::file_type/hash

    Example:

      opendir! $dir "/bin"
      loop:
	readdir! $entry dir
	if
	  entry.is_an_error
	  break
	  :
	    if
	      type_of(entry) == SYMBOLIC_LINK: # check file type
		println! name_of(entry)
		next!
	      next

    Output:

      texosquery
      lzip-compressor
      a2ping
      ...
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::file_type))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->file_type.value ==
	  ARGUMENTS(1)->file_type.value))
    RETURN_FALSE
  }

METHOD std_types::file_type/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->file_type.value;
    hash += 4243007357u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::file_type
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___file_type(value))
  }

METHOD std_types::file_type/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->file_type.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }

TYPE std_types::file_descriptor -> std_types::object
  int value

METHOD std_types::file_descriptor/_type
  {
    RUNTIME_ERROR("Attempt to call a file descriptor as a function!")
  }

METHOD long std_types::file_descriptor/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<file_descriptor %d>", node->file_descriptor.value);
  }

CODE
  static int file_descriptor_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::file_descriptor)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->file_descriptor.value;
	return true;
      }
    }

CODE
  static NODE *file_descriptor_from_int
    (
      int value
    )
    {
      return create__std_types___file_descriptor(value);
    }

METHOD std_types::file_descriptor/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::file_descriptor))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->file_descriptor.value ==
	  ARGUMENTS(1)->file_descriptor.value))
    RETURN_FALSE
  }

METHOD std_types::file_descriptor/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->file_descriptor.value;
    hash += 1659535014u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::file_descriptor
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___file_descriptor(value))
  }

METHOD std_types::file_descriptor/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->file_descriptor.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }


TYPE std_types::shutdown_type -> std_types::object
  int value

METHOD std_types::shutdown_type/_type
  {
    RUNTIME_ERROR("Attempt to call a shutdown type as a function!")
  }

METHOD long std_types::shutdown_type/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<shutdown_type %d>", node->shutdown_type.value);
  }

CODE
  static int shutdown_type_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::shutdown_type)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->shutdown_type.value;
	return true;
      }
    }

CODE
  static NODE *shutdown_type_from_int
    (
      int value
    )
    {
      return create__std_types___shutdown_type(value);
    }

METHOD std_types::shutdown_type/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::shutdown_type))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->shutdown_type.value ==
	  ARGUMENTS(1)->shutdown_type.value))
    RETURN_FALSE
  }

METHOD std_types::shutdown_type/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->shutdown_type.value;
    hash += 1037657925u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::shutdown_type
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___shutdown_type(value))
  }

METHOD std_types::shutdown_type/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->shutdown_type.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }

TYPE std_types::seek_type -> std_types::object
  int value

METHOD std_types::seek_type/_type
  {
    RUNTIME_ERROR("Attempt to call a seek type as a function!")
  }

METHOD long std_types::seek_type/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<seek_type %d>", node->seek_type.value);
  }

CODE
  static int seek_type_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::seek_type)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->seek_type.value;
	return true;
      }
    }

CODE
  static NODE *seek_type_from_int
    (
      int value
    )
    {
      return create__std_types___seek_type(value);
    }

METHOD std_types::seek_type/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::seek_type))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->seek_type.value == ARGUMENTS(1)->seek_type.value))
    RETURN_FALSE
  }

METHOD std_types::seek_type/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->seek_type.value;
    hash += 49284017u;
    hash *= 783461037;
    hash ^= hash >> 21 | hash << 11;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::seek_type
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___seek_type(value))
  }

METHOD std_types::seek_type/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->seek_type.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }

TYPE std_types::device_id -> std_types::object
  unsigned long value

METHOD std_types::device_id/_type
  {
    RUNTIME_ERROR("Attempt to call a device id as a function!")
  }

METHOD long std_types::device_id/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<device_id %d>", node->device_id.value);
  }

CODE
  static int device_id_to_ulong
    (
      NODE *node,
      unsigned long *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::device_id)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->device_id.value;
	return true;
      }
    }

CODE
  static NODE *device_id_from_ulong
    (
      unsigned long value
    )
    {
      return create__std_types___device_id(value);
    }

METHOD std_types::device_id/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::device_id))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->device_id.value ==
	  ARGUMENTS(1)->device_id.value))
    RETURN_FALSE
  }

METHOD std_types::device_id/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->device_id.value;
    hash += 1532833290u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::device_id
  {
    CHECK_ARGUMENTS(1)
    unsigned long value;
    if (!(to_ulong(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___device_id(value))
  }

METHOD std_types::device_id/to_integer
  {
    CHECK_ARGUMENTS(1)
    unsigned long value = ARGUMENTS(0)->device_id.value;
    RETURN_SINGLE_RESULT(from_ulong(value))
  }


TYPE std_types::directory -> std_types::object
  void * value

METHOD std_types::directory/_type
  {
    RUNTIME_ERROR("Attempt to call a directory as a function!")
  }

METHOD long std_types::directory/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<directory %d>", node->directory.value);
  }

CODE
  static int directory_to_ptr
    (
      NODE *node,
      void * *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::directory)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->directory.value;
	return true;
      }
    }

CODE
  static NODE *directory_from_ptr
    (
      void * value
    )
    {
      return create__std_types___directory(value);
    }

METHOD std_types::directory/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::directory))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->directory.value ==
	  ARGUMENTS(1)->directory.value))
    RETURN_FALSE
  }

METHOD std_types::directory/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = (uint32_t)(long)ARGUMENTS(0)->directory.value;
    hash += 835235593u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

TYPE std_types::group_id -> std_types::object
  int value

METHOD std_types::group_id/_type
  {
    RUNTIME_ERROR("Attempt to call a group id as a function!")
  }

METHOD long std_types::group_id/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<group_id %d>", node->group_id.value);
  }

CODE
  static int group_id_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::group_id)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->group_id.value;
	return true;
      }
    }

CODE
  static NODE *group_id_from_int
    (
      int value
    )
    {
      return create__std_types___group_id(value);
    }

METHOD std_types::group_id/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::group_id))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->group_id.value ==
	  ARGUMENTS(1)->group_id.value))
    RETURN_FALSE
  }

METHOD std_types::group_id/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->group_id.value;
    hash += 1390477003u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::group_id
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___group_id(value))
  }

METHOD std_types::group_id/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->group_id.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }


TYPE std_types::inode_number -> std_types::object
  unsigned long value

METHOD std_types::inode_number/_type
  {
    RUNTIME_ERROR("Attempt to call a inode number as a function!")
  }

METHOD long std_types::inode_number/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<inode_number %d>", node->inode_number.value);
  }

CODE
  static int inode_number_to_ulong
    (
      NODE *node,
      unsigned long *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::inode_number)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->inode_number.value;
	return true;
      }
    }

CODE
  static NODE *inode_number_from_ulong
    (
      unsigned long value
    )
    {
      return create__std_types___inode_number(value);
    }

METHOD std_types::inode_number/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::inode_number))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->inode_number.value ==
	  ARGUMENTS(1)->inode_number.value))
    RETURN_FALSE
  }

METHOD std_types::inode_number/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->inode_number.value;
    hash += 524255112u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::inode_number
  {
    CHECK_ARGUMENTS(1)
    unsigned long value;
    if (!(to_ulong(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___inode_number(value))
  }

METHOD std_types::inode_number/to_integer
  {
    CHECK_ARGUMENTS(1)
    unsigned long value = ARGUMENTS(0)->inode_number.value;
    RETURN_SINGLE_RESULT(from_ulong(value))
  }

TYPE std_types::process_id -> std_types::object
  int value

METHOD std_types::process_id/_type
  {
    RUNTIME_ERROR("Attempt to call a process id as a function!")
  }

METHOD long std_types::process_id/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<process_id %d>", node->process_id.value);
  }

CODE
  static int process_id_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::process_id)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->process_id.value;
	return true;
      }
    }

CODE
  static NODE *process_id_from_int
    (
      int value
    )
    {
      return create__std_types___process_id(value);
    }

METHOD std_types::process_id/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::process_id))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->process_id.value ==
	  ARGUMENTS(1)->process_id.value))
    RETURN_FALSE
  }

METHOD std_types::process_id/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->process_id.value;
    hash += 3109630881u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::process_id
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___process_id(value))
  }

METHOD std_types::process_id/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->process_id.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }


TYPE std_types::user_id -> std_types::object
  int value

METHOD std_types::user_id/_type
  {
    RUNTIME_ERROR("Attempt to call a user id as a function!")
  }

METHOD long std_types::user_id/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<user_id %d>", node->user_id.value);
  }

CODE
  static int user_id_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::user_id)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->user_id.value;
	return true;
      }
    }

CODE
  static NODE *user_id_from_int
    (
      int value
    )
    {
      return create__std_types___user_id(value);
    }

METHOD std_types::user_id/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::user_id))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->user_id.value ==
	  ARGUMENTS(1)->user_id.value))
    RETURN_FALSE
  }

METHOD std_types::user_id/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->user_id.value;
    hash += 4053581900u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::user_id
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___user_id(value))
  }

METHOD std_types::user_id/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->user_id.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }


TYPE std_types::error_number -> std_types::object
  int value

METHOD std_types::error_number/_type
  {
    RUNTIME_ERROR("Attempt to call a error number as a function!")
  }

METHOD long std_types::error_number/_debug_string
  (
    NODE *node,
    int indent,
    int max_depth,
    char *buf
  )
  {
    return debug_print(
      indent, buf, "<error_number %d>", node->error_number.value);
  }

CODE
  static int error_number_to_int
    (
      NODE *node,
      int *result_p
    )
    {
      if (TYPEOF(node) != TYPE(std_types::error_number)) {
	invalid_arguments();
	return false;
      } else {
	*result_p = node->error_number.value;
	return true;
      }
    }

CODE
  static NODE *error_number_from_int
    (
      int value
    )
    {
      return create__std_types___error_number(value);
    }

METHOD std_types::error_number/equal
  {
    CHECK_ARGUMENTS(2)
    if (TYPEOF(ARGUMENTS(1)) == TYPE(std_types::error_number))
      RETURN_SINGLE_RESULT(
	from_bool(
	  ARGUMENTS(0)->error_number.value ==
	  ARGUMENTS(1)->error_number.value))
    RETURN_FALSE
  }

METHOD std_types::error_number/hash
  {
    CHECK_ARGUMENTS(1)
    uint32_t hash = ARGUMENTS(0)->error_number.value;
    hash += 1056763753u;
    hash *= 1893456841;
    hash ^= hash >> 19 | hash << 13;
    RETURN_SINGLE_RESULT(from_uint32(hash));
  }

FUNCTION std::error_number
  {
    CHECK_ARGUMENTS(1)
    int value;
    if (!(to_int(ARGUMENTS(0), &value))) return;
    RETURN_SINGLE_RESULT(create__std_types___error_number(value))
  }

METHOD std_types::error_number/to_integer
  {
    CHECK_ARGUMENTS(1)
    int value = ARGUMENTS(0)->error_number.value;
    RETURN_SINGLE_RESULT(from_int(value))
  }


TYPE std_types::passwd -> std_types::object

ATTRIBUTE std_types::passwd.username_of
ATTRIBUTE std_types::passwd.password_of
ATTRIBUTE std_types::passwd.user_id_of
ATTRIBUTE std_types::passwd.group_id_of
ATTRIBUTE std_types::passwd.user_information_of
ATTRIBUTE std_types::passwd.home_directory_of
ATTRIBUTE std_types::passwd.shell_of

METHOD std_types::passwd/_type
  {
    RUNTIME_ERROR("Attempt to call a passwd as a function!")
  }

TYPE std_types::stat -> std_types::object

ATTRIBUTE std_types::stat.device_of
ATTRIBUTE std_types::stat.inode_number_of
ATTRIBUTE std_types::stat.type_of
ATTRIBUTE std_types::stat.mode_of
ATTRIBUTE std_types::stat.link_count_of
ATTRIBUTE std_types::stat.user_id_of
ATTRIBUTE std_types::stat.group_id_of
ATTRIBUTE std_types::stat.root_device_of
ATTRIBUTE std_types::stat.size_of
ATTRIBUTE std_types::stat.block_size_of
ATTRIBUTE std_types::stat.block_count_of
ATTRIBUTE std_types::stat.access_time_of
ATTRIBUTE std_types::stat.modification_time_of
ATTRIBUTE std_types::stat.status_change_time_of

METHOD std_types::stat/_type
  {
    RUNTIME_ERROR("Attempt to call a stat as a function!")
  }

TYPE std_types::dirent -> std_types::object

ATTRIBUTE std_types::dirent.inode_number_of
ATTRIBUTE std_types::dirent.type_of
ATTRIBUTE std_types::dirent.name_of

METHOD std_types::dirent/_type
  {
    RUNTIME_ERROR("Attempt to call a dirent as a function!")
  }

FUNCTION std::access
  #
    checks access permissions for a file

    Parameters:
      filename: the name of the file
      mode: the access mode

    Result:
      ok # true, if the access is granted; otherwise false

    The mode is a string containing the following characters:

    'r': check read permission
    'w': check write permission
    'x': check execute permission

    This function needs I/O-access rights.

    Topic: POSIX

    See also: std::chmod, std::chown

    Example:

      # check if a file is readable
      access! $ok "myfile.txt" "r"
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    char *mode_str;
    int mode;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    if (!to_c_string(ARGUMENTS(1), &mode_str)) goto cleanup;
    mode = 0;
    for(int i = 0; mode_str[i]; i++) {
      switch(mode_str[i]) {
	case 'r':
	  mode |= R_OK;
	  break;
	case 'w':
	  mode |= W_OK;
	  break;
	case 'x':
	  mode |= X_OK;
	  break;
	default:
	  create_error_message(
	    module__builtin.constants_base[unique__std___RUNTIME_ERROR-1],
	    "ACCESS: INVALID MODE", 0, 0, NULL);
	  goto cleanup;
      }
    }
    ACTION(access)
      result = access(filename, mode);
    INFO
      C_STRING(filename)
      C_STRING(mode_str)
      INT(result)
    DATA
      INT(result)
    END
    if (result == 0) {
      PREPARE_SINGLE_RESULT(&std_types::true)
    } else {
      if (errno == EACCES) {
	PREPARE_SINGLE_RESULT(&std_types::false)
      } else {
	create_error_message(
	  module__builtin.constants_base[unique__std___IO_ERROR-1],
	  "ACCESS FAILED", errno, 0, NULL);
      }
    }
    cleanup:
    deallocate_memory(filename);
    deallocate_memory(mode_str);
  }

FUNCTION std::chdir
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *pathname = NULL;
    int result;
    if (!to_c_string(ARGUMENTS(0), &pathname)) goto cleanup;
    ACTION(chdir)
      result = chdir(pathname);
    INFO
      C_STRING(pathname)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHDIR FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(pathname);
  }

FUNCTION std::chmod
  #
    changes the mode of the specified file

    Parameters:
      filename: the name of the file for which the mode is to be changed
      mode: the new mode

    This function needs I/O-access rights.

    The mode is written as an ASCII-string like it is displayed by the *ls*
    command.

    The first three letters specify the permissions for the owner of the file,
    the next three letters specify the permissions for the group of the file,
    and the last three letters specify the permissions for all other users.

    Each letter group is interpreted as follows:

    The first letter specifies the read permission. It can be one of the
    following characters:

    r: read permission is granted
    -: read permission is not granted

    The second letter specifies the write permission. It can be one of the
    following characters:

    w: write permission is granted
    -: write permission is not granted

    The third letter specifies the execute permission. It can be one of the
    following characters:

    x: execute permission is granted
    -: execute permission is not granted

    Instead of 'x' the following letters can be used:

    s (owner and group): additionally sets the SUID respektively SGID bit
    S (owner and group): only sets the SUID respektively SGID bit
    t (other): additionally sets the sticky bit
    T (other): only sets the sticky bit

    Topic: POSIX

    See also: std::chown

    Example:

      # make a file readable and executable for everyone
      chmod! "myfile.txt" "r-xr-xr-x"
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    int mode;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    if (!mode_to_int(ARGUMENTS(1), &mode)) goto cleanup;
    ACTION(chmod)
      result = chmod(filename, mode);
    INFO
      C_STRING(filename)
      INT(mode)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHMOD FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::chown
  {
    CHECK_ARGUMENTS(3)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    int owner;
    int group;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    if (!user_id_to_int(ARGUMENTS(1), &owner)) goto cleanup;
    if (!group_id_to_int(ARGUMENTS(2), &group)) goto cleanup;
    ACTION(chown)
      result = chown(filename, owner, group);
    INFO
      C_STRING(filename)
      INT(owner)
      INT(group)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHOWN FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::chroot
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *pathname = NULL;
    int result;
    if (!to_c_string(ARGUMENTS(0), &pathname)) goto cleanup;
    ACTION(chroot)
      result = chroot(pathname);
    INFO
      C_STRING(pathname)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CHROOT FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(pathname);
  }

METHOD std_types::file_descriptor/close
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int fd = ARGUMENTS(0)->file_descriptor.value;
    int result;
    ACTION(close)
      do {
	result = close(fd);
      } while (result == -1 && errno == EINTR);
    INFO
      INT(fd)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CLOSE FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
  }

FUNCTION std::closedir
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    void *dir = NULL;
    int result;
    if (!directory_to_ptr(ARGUMENTS(0), &dir)) return;
    ACTION(closedir)
      result = closedir(dir);
    INFO
      PTR(dir)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"CLOSEDIR FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
  }

FUNCTION std::dup2
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    int old_fd;
    int new_fd;
    int result;
    if (!file_descriptor_to_int(ARGUMENTS(0), &old_fd)) return;
    if (!file_descriptor_to_int(ARGUMENTS(1), &new_fd)) return;
    ACTION(dup2)
      do {
	result = dup2(old_fd, new_fd);
      } while (result == -1 && errno == EINTR);
    INFO
      INT(old_fd)
      INT(new_fd)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"DUP2 FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
  }

FUNCTION std::fstat
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int fd;
    struct stat statbuf;
    int result;
    if (!file_descriptor_to_int(ARGUMENTS(0), &fd)) return;
    EVENT(fstat)
      result = fstat(fd, &statbuf);
    INFO
      INT(fd)
      INT(result)
      MEMORY(&statbuf, sizeof(statbuf))
    DATA
      INT(result)
      MEMORY(&statbuf, sizeof(statbuf))
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"FSTAT FAILED", errno, 0, NULL);
    } else {
      NODE *node__device_of = device_id_from_ulong(statbuf.st_dev);
      NODE *node__inode_number_of = inode_number_from_ulong(statbuf.st_ino);
      NODE *node__type_of = file_type_from_int(statbuf.st_mode >> 12);
      NODE *node__mode_of = mode_from_int(statbuf.st_mode);
      NODE *node__link_count_of = from_int(statbuf.st_nlink);
      NODE *node__user_id_of = user_id_from_int(statbuf.st_uid);
      NODE *node__group_id_of = group_id_from_int(statbuf.st_gid);
      NODE *node__root_device_of = device_id_from_ulong(statbuf.st_rdev);
      NODE *node__size_of = from_long(statbuf.st_size);
      NODE *node__block_size_of = from_long(statbuf.st_blksize);
      NODE *node__block_count_of = from_long(statbuf.st_blocks);
      NODE *node_access_time_of =
	CREATE(
	  std_types::date_and_time,
	  statbuf.st_atim.tv_sec, statbuf.st_atim.tv_nsec);
      NODE *node_modification_time_of =
	CREATE(
	  std_types::date_and_time,
	  statbuf.st_mtim.tv_sec, statbuf.st_mtim.tv_nsec);
      NODE *node_status_change_time_of =
	CREATE(
	  std_types::date_and_time,
	  statbuf.st_ctim.tv_sec, statbuf.st_ctim.tv_nsec);
      NODE *node = clone_object_and_attributes((NODE *)&std_types::stat);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___mode_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__mode_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___link_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__link_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___root_device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__root_device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___block_size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___access_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_access_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___modification_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_modification_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___status_change_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_status_change_time_of));
      PREPARE_SINGLE_RESULT(node)
    }
  }

FUNCTION std::fsync
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int fd;
    int result;
    if (!file_descriptor_to_int(ARGUMENTS(0), &fd)) return;
    ACTION(fsync)
      result = fsync(fd);
    INFO
      INT(fd)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"FSYNC FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
  }

FUNCTION std::getcwd
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    uint8_t static_buf[1024];
    uint8_t *buf = NULL;
    size_t size;
    char *result = NULL;
    EVENT(getcwd)
      buf = static_buf;
      size = 1024;
      retry:
      result = getcwd((char *)buf, size);
      if (buf == static_buf) buf = NULL;
      if (errno == ERANGE) {
	size += size;
	buf = reallocate_memory(buf, size);
	goto retry;
      }
    INFO
      C_STRING(result)
    DATA
      C_STRING(result)
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETCWD FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_c_string(result))
    }
    deallocate_memory(buf);
  }

FUNCTION std::getenv
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *var_name = NULL;
    char *result = NULL;
    if (!to_c_string(ARGUMENTS(0), &var_name)) goto cleanup;
    EVENT(getenv)
      result = getenv(var_name);
    INFO
      C_STRING(var_name)
      C_STRING(result)
    DATA
      C_STRING(result)
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETENV FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_c_string(result))
    }
    cleanup:
    deallocate_memory(var_name);
  }

FUNCTION std::getegid
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int result;
    EVENT(getegid)
      result = getegid();
    INFO
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(group_id_from_int(result))
  }

FUNCTION std::geteuid
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int result;
    EVENT(geteuid)
      result = geteuid();
    INFO
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(user_id_from_int(result))
  }

FUNCTION std::getgid
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int result;
    EVENT(getgid)
      result = getgid();
    INFO
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(group_id_from_int(result))
  }

FUNCTION std::gethostname
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    char buf[HOST_NAME_MAX+1];
    int result;
    EVENT(gethostname)
      result = gethostname(buf, sizeof(buf));
    INFO
      MEMORY(buf, result)
    DATA
      MEMORY(buf, result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETHOSTNAME FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_c_string(buf))
    }
  }

FUNCTION std::getlogin
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    char *result = NULL;
    EVENT(getlogin)
      result = getlogin();
    INFO
      C_STRING(result)
    DATA
      C_STRING(result)
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETLOGIN FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_c_string(result))
    }
  }

FUNCTION std::getpid
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int result;
    EVENT(getpid)
      result = getpid();
    INFO
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(process_id_from_int(result))
  }

FUNCTION std::getppid
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int result;
    EVENT(getppid)
      result = getppid();
    INFO
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(process_id_from_int(result))
  }

FUNCTION std::getpwuid
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int uid;
    struct passwd *result = NULL;
    if (!user_id_to_int(ARGUMENTS(0), &uid)) return;
    EVENT(getpwuid)
      do {
	result = getpwuid(uid);
      } while (result == NULL && errno == EINTR);
    INFO
      INT(uid)
      MEMORY(&result, sizeof(result))
    DATA
      MEMORY(&result, sizeof(result))
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETPWUID FAILED", errno, 0, NULL);
    } else {
      NODE *node__username_of = from_c_string(result->pw_name);
      NODE *node__password_of = from_c_string(result->pw_passwd);
      NODE *node__user_id_of = user_id_from_int(result->pw_uid);
      NODE *node__group_id_of = group_id_from_int(result->pw_gid);
      NODE *node__user_information_of = from_c_string(result->pw_gecos);
      NODE *node__home_directory_of = from_c_string(result->pw_dir);
      NODE *node__shell_of = from_c_string(result->pw_shell);
      NODE *node = clone_object_and_attributes((NODE *)&std_types::passwd);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___username_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__username_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___password_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__password_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___user_information_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_information_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___home_directory_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__home_directory_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___shell_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__shell_of));
      PREPARE_SINGLE_RESULT(node)
    }
  }

FUNCTION std::getsid
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int pid;
    int result;
    if (!process_id_to_int(ARGUMENTS(0), &pid)) return;
    EVENT(getsid)
      result = getsid(pid);
    INFO
      INT(pid)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"GETSID FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(process_id_from_int(result))
    }
  }

FUNCTION std::getuid
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int result;
    EVENT(getuid)
      result = getuid();
    INFO
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(user_id_from_int(result))
  }

FUNCTION std::isatty
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int fd;
    if (!file_descriptor_to_int(ARGUMENTS(0), &fd)) return;
    int result;
    EVENT(isatty)
      result = isatty(fd);
    INFO
      INT(fd)
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(from_bool(result))
  }

FUNCTION std::link
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    char *old_path;
    char *new_path;
    if (!to_c_string(ARGUMENTS(0), &old_path)) return;
    if (!to_c_string(ARGUMENTS(1), &new_path)) {
      deallocate_memory(old_path);
      return;
    }
    EVENT(link)
      if (link(old_path, new_path) == -1) {
	create_error_message(
	  module__builtin.constants_base[unique__std___IO_ERROR-1],
	  "LINK FAILED", errno, 0, NULL);
      } else {
	PREPARE_NO_RESULT
      }
    INFO
      C_STRING(old_path)
      C_STRING(new_path)
    DATA
      C_STRING(old_path)
      C_STRING(new_path)
    END
    deallocate_memory(old_path);
    deallocate_memory(new_path);
  }

FUNCTION std::lseek
  {
    CHECK_ARGUMENTS(3)
    CHECK_IO_ACCESS_RIGHTS
    int fd;
    long offset;
    int whence;
    if (!file_descriptor_to_int(ARGUMENTS(0), &fd)) return;
    if (!to_long(ARGUMENTS(1), &offset)) return;
    if (!seek_type_to_int(ARGUMENTS(2), &whence)) return;
    off_t result;
    EVENT(lseek)
      result = lseek(fd, offset, whence);
    INFO
      INT(fd)
      LONG(offset)
      INT(whence)
      LONG(result)
    DATA
      INT(fd)
      LONG(offset)
      INT(whence)
      LONG(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"LSEEK FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_long(result))
    }
  }

FUNCTION std::mkdir
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    char *pathname = NULL;
    int mode = 0755;
    int result;
    if (!to_c_string(ARGUMENTS(0), &pathname)) goto cleanup;
    if (ARGUMENT_COUNT >= 2 && !mode_to_int(ARGUMENTS(1), &mode)) goto cleanup;
    ACTION(mkdir)
      result = mkdir(pathname, mode);
    INFO
      C_STRING(pathname)
      INT(mode)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"MKDIR FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(pathname);
  }

FUNCTION std::mkfifo
  #
    creates a FIFO

    Parameters:
      pathname: the path of the FIFO to create
      mode: the mode of the FIFO (default: ""rw-r--r--")

    The optional mode parameter is a string of the form "rwxrwxrwx". The
    default value is "rw-r--r--".

    This function needs I/O-access rights.

    Topic: POSIX

    See also: std::mkdir

    Example:

      mkfifo! "test_fifo" "rw-rw----"
  {
    MIN_ARGUMENTS(1)
    MAX_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    int mode = 0644;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    if (ARGUMENT_COUNT >= 2 && !mode_to_int(ARGUMENTS(1), &mode)) goto cleanup;
    ACTION(mkfifo)
      result = mkfifo(filename, mode);
    INFO
      C_STRING(filename)
      INT(mode)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"MKFIFO FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::open
  #
    opens a file

    Parameters:
      pathname: the path of the file to open
      flags: whether to open the file for reading, writing or appending
      mode: the mode of the file (default: "rw-r--r--")

    Result:
      fd: a file descriptor

    On success a valid file handle is returned, on failure an appropriate
    error-object is returned.

    Possible flag combinations:

    r:  Open a file for reading only.

    r+: Open a file for reading and writing.

    w:  Create a new or truncate an existing file and open it for writing only.

    w+: Create a new or truncate an existing file and open it for reading and
	writing.

    a:  Create a new or open an existing file. The current file position is
	initially at the end of the file. The file is opened for writing only.

    a+: Create a new or open an existing file. The current file position is
	initially at the end of the file. The file is opened for reading and
	writing.

    The optional mode parameter is a string of the form "rwxrwxrwx". The
    default value is "rw-r--r--".

    This function needs I/O-access rights.

    Topic: POSIX

    See also: std::close, std::read, std::write, std::fsync

    Example:

      open! $fd "test.txt" "w+"
      write! $bytes_written fd "Hello, World!"
      on bytes_written.is_an_error: Error! "Failed to write to file!"
      close! fd
  {
    MIN_ARGUMENTS(2)
    MAX_ARGUMENTS(3)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    int flags;
    int mode = 0644;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    if (!flags_to_int(ARGUMENTS(1), &flags)) goto cleanup;
    if (ARGUMENT_COUNT >= 3 && !mode_to_int(ARGUMENTS(2), &mode)) goto cleanup;
    EVENT(open)
      do {
	result = open(filename, flags, mode);
      } while (result == -1 && errno == EINTR);
    INFO
      C_STRING(filename)
      INT(flags)
      INT(mode)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"OPEN FAILED", errno, 0, ARGUMENTS(0));
    } else {
      PREPARE_SINGLE_RESULT(file_descriptor_from_int(result))
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::opendir
  #
    opens a directory stream

    Parameters:
      pathname: the path of the directory to open

    Result:
      dir: a directory stream

    On success a <std_types::directory> is returned, on failure an appropriate
    error-object is returned.

    This function needs I/O-access rights.

    Topic: POSIX

    See also: std::closedir, std::readdir

    Example:

      opendir! $dir "/bin"
      loop:
	readdir! $entry dir
	if
	  entry.is_an_error
	  break
	  :
	    if
	      type_of(entry) == SYMBOLIC_LINK: # check file type
		println! name_of(entry)
		next!
	      next

    Output:

      texosquery
      lzip-compressor
      a2ping
      ...
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *name = NULL;
    void *result = NULL;
    if (!to_c_string(ARGUMENTS(0), &name)) goto cleanup;
    EVENT(opendir)
      result = opendir(name);
    INFO
      C_STRING(name)
      PTR(result)
    DATA
      PTR(result)
    END
    if (!result) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"OPENDIR FAILED", errno, 0, ARGUMENTS(0));
    } else {
      PREPARE_SINGLE_RESULT(directory_from_ptr(result))
    }
    cleanup:
    deallocate_memory(name);
  }

METHOD std_types::file_descriptor/read
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    int fd = ARGUMENTS(0)->file_descriptor.value;
    uint8_t *buf = NULL;
    size_t size;
    ssize_t result;
    if (!to_ulong(ARGUMENTS(1), (unsigned long *)&size)) goto cleanup;
    buf = allocate_memory(size);
    EVENT(read)
      do {
	result = read(fd, (char *)buf, size);
      } while (result == -1 && errno == EINTR);
    INFO
      INT(fd)
      ULONG(size)
      MEMORY(buf, result)
    DATA
      MEMORY(buf, result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"READ FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_latin_1_string(buf, result))
    }
    cleanup:
    deallocate_memory(buf);
  }

FUNCTION std::readdir
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    void *dir = NULL;
    struct dirent *result = NULL;
    if (!directory_to_ptr(ARGUMENTS(0), &dir)) return;
    EVENT(readdir)
      result = readdir(dir);
    INFO
      PTR(dir)
      MEMORY(&result, sizeof(result))
    DATA
      MEMORY(&result, sizeof(result))
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"READDIR FAILED", errno, 0, NULL);
    } else {
      NODE *node__inode_number_of = inode_number_from_ulong(result->d_ino);
      NODE *node__type_of = file_type_from_int(result->d_type);
      NODE *node__name_of = from_c_string(result->d_name);
      NODE *node = clone_object_and_attributes((NODE *)&std_types::dirent);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___name_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__name_of));
      PREPARE_SINGLE_RESULT(node)
    }
  }

FUNCTION std::realpath
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    char *resolved_name = NULL;
    char *result = NULL;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    EVENT(realpath)
      result = realpath(filename, resolved_name);
    INFO
      C_STRING(filename)
      C_STRING(result)
    DATA
      C_STRING(result)
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"REALPATH FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_c_string(result))
    }
    cleanup:
    deallocate_memory(filename);
    deallocate_memory(resolved_name);
    free(result);
  }

FUNCTION std::rename
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    char *old_filename = NULL;
    char *new_filename = NULL;
    int result;
    if (!to_c_string(ARGUMENTS(0), &old_filename)) goto cleanup;
    if (!to_c_string(ARGUMENTS(1), &new_filename)) goto cleanup;
    ACTION(rename)
      result = rename(old_filename, new_filename);
    INFO
      C_STRING(old_filename)
      C_STRING(new_filename)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"RENAME FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(old_filename);
    deallocate_memory(new_filename);
  }

FUNCTION std::sethostname
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    uint8_t *buf = NULL;
    size_t size;
    int result;
    if (
      !to_octets(ARGUMENTS(1),
      (const uint8_t **)&buf, (long *)&size)) goto cleanup;
    ACTION(sethostname)
      do {
	result = sethostname((char *)buf, size);
      } while (result == -1 && errno == EINTR);
    INFO
      MEMORY(buf, size)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SETHOSTNAME FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(buf);
  }

FUNCTION std::shutdown
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    int fd;
    int how;
    int result;
    if (!file_descriptor_to_int(ARGUMENTS(0), &fd)) return;
    if (!shutdown_type_to_int(ARGUMENTS(1), &how)) return;
    ACTION(shutdown)
      result = shutdown(fd, how);
    INFO
      INT(fd)
      INT(how)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SHUTDOWN FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
  }

FUNCTION std::stat
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    struct stat statbuf;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    EVENT(stat)
      result = stat(filename, &statbuf);
    INFO
      C_STRING(filename)
      INT(result)
      MEMORY(&statbuf, sizeof(statbuf))
    DATA
      INT(result)
      MEMORY(&statbuf, sizeof(statbuf))
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"STAT FAILED", errno, 0, ARGUMENTS(0));
    } else {
      NODE *node__device_of = device_id_from_ulong(statbuf.st_dev);
      NODE *node__inode_number_of = inode_number_from_ulong(statbuf.st_ino);
      NODE *node__type_of = file_type_from_int(statbuf.st_mode >> 12);
      NODE *node__mode_of = mode_from_int(statbuf.st_mode);
      NODE *node__link_count_of = from_int(statbuf.st_nlink);
      NODE *node__user_id_of = user_id_from_int(statbuf.st_uid);
      NODE *node__group_id_of = group_id_from_int(statbuf.st_gid);
      NODE *node__root_device_of = device_id_from_ulong(statbuf.st_rdev);
      NODE *node__size_of = from_long(statbuf.st_size);
      NODE *node__block_size_of = from_long(statbuf.st_blksize);
      NODE *node__block_count_of = from_long(statbuf.st_blocks);
      NODE *node_access_time_of =
	CREATE(
	  std_types::date_and_time,
	  statbuf.st_atim.tv_sec, statbuf.st_atim.tv_nsec);
      NODE *node_modification_time_of =
	CREATE(
	  std_types::date_and_time,
	  statbuf.st_mtim.tv_sec, statbuf.st_mtim.tv_nsec);
      NODE *node_status_change_time_of =
	CREATE(
	  std_types::date_and_time,
	  statbuf.st_ctim.tv_sec, statbuf.st_ctim.tv_nsec);
      NODE *node = clone_object_and_attributes((NODE *)&std_types::stat);
      update_start_p = node_p;
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___inode_number_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__inode_number_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___type_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__type_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___mode_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__mode_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___link_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__link_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___user_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__user_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___group_id_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__group_id_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___root_device_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__root_device_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___block_size_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_size_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___block_count_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node__block_count_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___access_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_access_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___modification_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_modification_time_of));
      redefine_attribute(
	node->attributes,
	variables_table[var_no__std___status_change_time_of-FIRST_VAR].poly_idx,
	MAKE_ATTRIBUTE_VALUE(node_status_change_time_of));
      PREPARE_SINGLE_RESULT(node)
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::strerror
  {
    CHECK_ARGUMENTS(1)
    int errnum;
    char *result = NULL;
    if (!error_number_to_int(ARGUMENTS(0), &errnum)) return;
    EVENT(strerror)
      result = strerror(errnum);
    INFO
      INT(errnum)
      C_STRING(result)
    DATA
      C_STRING(result)
    END
    if (result == NULL) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"STRERROR FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_c_string(result))
    }
  }

FUNCTION std::wait
  {
    CHECK_ARGUMENTS(0)
    CHECK_IO_ACCESS_RIGHTS
    int status;
    int result;
    EVENT(wait)
      do {
	result = wait(&status);
      } while (result == -1 && errno == EINTR);
    INFO
      INT(result)
      INT(status)
    DATA
      INT(result)
      INT(status)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"WAIT FAILED", errno, 0, NULL);
    } else {
      START_ARGUMENTS(2)
      ARGUMENTS(0) = process_id_from_int(result);
      ARGUMENTS(1) = from_int(status);
    }
  }

METHOD std_types::file_descriptor/write
  {
    CHECK_ARGUMENTS(2)
    CHECK_IO_ACCESS_RIGHTS
    int fd = ARGUMENTS(0)->file_descriptor.value;
    uint8_t *buf = NULL;
    size_t size;
    ssize_t result;
    if (
      !to_octets(ARGUMENTS(1),
      (const uint8_t **)&buf, (long *)&size)) goto cleanup;
    EVENT(write)
      do {
	result = write(fd, (char *)buf, size);
      } while (result == -1 && errno == EINTR);
    INFO
      INT(fd)
      MEMORY(buf, size)
      LONG(result)
    DATA
      LONG(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"WRITE FAILED", errno, 0, NULL);
    } else {
      PREPARE_SINGLE_RESULT(from_long(result))
    }
    cleanup:
    deallocate_memory(buf);
  }

FUNCTION std::umask
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    int mask;
    int result;
    if (!mode_to_int(ARGUMENTS(0), &mask)) return;
    EVENT(umask)
      result = umask(mask);
    INFO
      INT(mask)
      INT(result)
    DATA
      INT(result)
    END
    PREPARE_SINGLE_RESULT(mode_from_int(result))
  }

FUNCTION std::unlink
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    ACTION(unlink)
      result = unlink(filename);
    INFO
      C_STRING(filename)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"UNLINK FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::shm_unlink
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    char *filename = NULL;
    int result;
    if (!to_c_string(ARGUMENTS(0), &filename)) goto cleanup;
    ACTION(shm_unlink)
      result = shm_unlink(filename);
    INFO
      C_STRING(filename)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SHM_UNLINK FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
    cleanup:
    deallocate_memory(filename);
  }

FUNCTION std::usleep
  {
    CHECK_ARGUMENTS(1)
    CHECK_IO_ACCESS_RIGHTS
    unsigned int microseconds;
    int result;
    if (!to_uint(ARGUMENTS(0), &microseconds)) return;
    EVENT(usleep)
      result = usleep(microseconds);
    INFO
      UINT(microseconds)
      INT(result)
    DATA
      INT(result)
    END
    if (result == -1) {
      create_error_message(
	module__builtin.constants_base[unique__std___IO_ERROR-1],
	"SLEEP FAILED", errno, 0, NULL);
    } else {
      PREPARE_NO_RESULT
    }
  }
