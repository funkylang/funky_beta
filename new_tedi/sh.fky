#
  Copyright (C) 2025 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License, version 2, or
  (at your option) version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files GPLv2.txt and GLPv3.txt or
  http://www.gnu.org/licenses/gpl-2.0.html
  http://www.gnu.org/licenses/gpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

<using std-2.0>
<using tedi>

<allow unused>

!context_help_functions(SH) sh_context_help

$ORANGE '@0xff8800;'

$is_a_builtin_command
  hash_set
    "alias"
    "bg"
    "bind"
    "break"
    "builtin"
    "cd"
    "command"
    "compgen"
    "complete"
    "compopt"
    "continue"
    "declare"
    "dirs"
    "disown"
    "echo"
    "enable"
    "eval"
    "exec"
    "exit"
    "export"
    "false"
    "fc"
    "fg"
    "getopts"
    "hash"
    "help"
    "history"
    "jobs"
    "kill"
    "let"
    "local"
    "logout"
    "popd"
    "printf"
    "pushd"
    "pwd"
    "read"
    "readonly"
    "return"
    "set"
    "shift"
    "shopt"
    "source"
    "suspend"
    "test"
    "times"
    "trap"
    "true"
    "type"
    "typeset"
    "ulimit"
    "umask"
    "unalias"
    "unset"
    "wait"

$is_a_builtin_keyword
  hash_set
    "case"
    "coproc"
    "do"
    "done"
    "elif"
    "else"
    "esac"
    "fi"
    "function"
    "for"
    "if"
    "in"
    "select"
    "then"
    "time"
    "until"
    "while"
    "{"
    "}"
    "[["
    "]]"
    "!"

$shell_commands_of ()

$tedi_types::symbol_info
  .shell_commands_of undefined

$tedi_types::sh_page tedi_types::page
  .screens_of empty_list

$command_plugin std_types::object

$command_plugin/initialize: (_id io)
  log &io "
    retrieving shell commands
  run io retrieve_shell_commands_action split(environment("PATH") ':')

push &plugins command_plugin

!page_constructors("sh") create_sh_page
!page_constructors("#!/bin/bash") create_sh_page
!page_constructors("#!/bin/sh") create_sh_page

$create_sh_page: (io state lines filename)
  $page
    prepare
      tedi_types::sh_page
	.lines_of lines
	.kind_of SH
	.filename_of filename
	.commands_of commands_of(configuration_of(state))
      state
      undefined
  -> io state page

$tedi_types::sh_page/prepare: (page state line_range)
  if
    line_range.is_undefined:
      prepare_tedi_page page state line_range
    :
      !symbol_info symbol_info_of(state)
      line_range $from $to
      min &to height_of(page)
      $screens screens_of(page)
      $last length_of(screens)
      if
	to <= last
	-> page
	:
	  $new_screens create_screens(page last+1 to)
	  append screens &new_screens
	  -> page(.screens_of new_screens)

$empty_stack list(NORMAL)

$tedi_types::sh_page/repair_screens: (page till from length)
  $lines lines_of(page)
  $entries screens_of(page)
  $n length_of(entries)
  loop !till !length: # search for start of a logical line
    if
      till > 0 && lines(till).is_defined && second(entries(till)).is_empty:
	dec &till
	inc &length
	next
      -> till length
  if
    n <= till
    -> page
    :
      if
	from > n
	-> page(.screens_of range(entries 1 till))
	:
	  $start range(entries 1 till)
	  if
	    length > 0:
	      $new_entries create_screens(page till+1 till+length)
	      $real_length length_of(new_entries)
	      plus &from real_length-length
	      if
		&&
		  from <= n
		  equals
		    second(new_entries(-1))
		    if
		      from > 1
		      -> second(entries(from-1))
		      -> empty_stack
		->
		  page
		    .screens_of
		      append(start new_entries range(entries from -1))
		-> page(.screens_of append(start new_entries))
	    :
	      $old_stack second(entries(from-1))
	      $new_stack
		if
		  till > 0
		  -> second(entries(till))
		  -> empty_stack
	      if
		new_stack .equals. old_stack
		-> page(.screens_of append(start range(entries from -1)))
		-> page(.screens_of start)

$equals: (left right)
  if
    length_of(left) == length_of(right):
      for_each left
	: (idx item)
	  if
	    item == right(idx)
	    next
	    -> false
	-> true
    -> false

$create_screens: (page first last)
  $lines lines_of(page)
  $template_screen template_screen_of(page)
  $empty_line create_text_screen(template_screen "")
  $created_screens empty_list
  $first_line_no first
  loop:
    if
      first_line_no > 1:
	$line lines(first_line_no-1)
	if
	  line.is_defined && text_of(line)(-1) == '\':
	    dec &first_line_no
	    next
	  create
      create

  $create:
    $stack
      if
	first_line_no > 1
	-> second(screens_of(page)(first_line_no-1))
	-> empty_stack
    $n length_of(lines)
    $line_no first_line_no
    loop:
      if
	line_no <= last:
	  $line lines(line_no)
	  if
	    lines(line_no).is_defined:
	      create_sh_line $screens &stack template_screen
		range(lines line_no -1)
	      append &created_screens screens
	      #debug::print "@(length_of(screens)): "
	      #debug::println text_of(lines(line_no))
	      plus &line_no length_of(screens)
	      next
	    :
	      push &created_screens tuple(empty_line stack)
	      inc &line_no
	      next
	-> created_screens

$tedi_types::sh_page/: (page^ idx)
  screens_of(page)(idx) $screen
  decorate page idx screen

$RETRIEVE_SHELL_COMMANDS .

$retrieve_shell_commands_action: (io paths)
  $shell_commands empty_hash_set
  for_each paths
    : (path)
      directory! $entries path
      if
	entries.is_an_error
	next
	:
	  for_each entries
	    : (entry)
	      if
		type_of(entry) == REGULAR_FILE:
		  !shell_commands(name_of(entry)) true
		  next!
		next
	    next
    -> io tuple(JOB_COMPLETED RETRIEVE_SHELL_COMMANDS shell_commands)

$RETRIEVE_SHELL_COMMANDS/job_completed: (_self io state shell_commands _context)
  !state.symbol_info_of.shell_commands_of shell_commands
  -> io state

$sh_context_help: (io state x y lines _info)
  $shell_commands shell_commands_of(symbol_info_of(state))
  $identifier get_identifier_at_xy(x y lines)
  if
    identifier.is_defined:
      if
	is_a_builtin_command(identifier):
	  call &io GET_HELP "bash" list("-c" "help @(identifier)") identifier
	  -> io state
	:
	  if
	    shell_commands(identifier):
	      call &io GET_HELP "man" list(identifier) identifier
	      -> io state
	    -> io state
    -> io state

$GET_HELP .

$GET_HELP/job_completed: (_self io state output topic)
  output $out $_err
  from_utf8 &out
  $lines split_into_indented_lines(out false tedi_types::line)
  $page create_page_from_text(lines state topic)
  !page.info_of.do_show_right_margin_of false
  create_window &state.window_manager_of
    CONTENT = page
    TITLE = topic
    USE_CURSOR
  -> io state

$GET_HELP/job_failed: (_self io state _error topic)
  show_error_message &state "
    failed to retrieve help text for "@(topic)"
  -> io state

$get_identifier_at_xy: (x y lines)
  $line lines(y)
  if
    line.is_undefined
    -> undefined
    :
      $text text_of(line)
      $indent indent_of(line)
      if
	x <= indent || x > indent+width_of(text)
	-> undefined
	:
	  $pos get_position(text x-indent)
	  $chr text(pos)
	  if
	    chr.is_a_letter || chr.is_a_digit || chr == '_':
	      $start pos
	      $end pos
	      loop:
		if
		  &&
		    start > 1
		    ||
		      text(start-1).is_a_letter
		      text(start-1).is_a_digit
		      text(start-1) == '_'
		  :
		    dec &start
		    next
		  :
		    loop:
		      if
			&&
			  end < length_of(text)
			  ||
			    text(end+1).is_a_letter
			    text(end+1).is_a_digit
			    text(end+1) == '_'
			:
			  inc &end
			  next
			-> range(text start end)
	    -> undefined

$attributes
  hash_table
    NORMAL = tuple(BLACK NORMAL)
    '#' = tuple('@0x00a000;' ITALIC)
    '`' = tuple('@0xe0a000;' NORMAL)
    '@quot;' = tuple(BLUE ITALIC)
    '@apos;' = tuple(DARK_CYAN ITALIC)

$tedi::create_sh_line: (stack template_screen lines)
  $shell_commands shell_commands_of(symbol_info)
  $idx 1
  $screens empty_list
  loop:
    $line lines(idx)
    $indent indent_of(line)
    $text text_of(line)
    $screen create_screen(template_screen indent+width_of(text) 1)
    $x indent+1
    $s 1
    $n length_of(text)
    $i 1
    case stack(-1)
      '@quot;', '@apos;':
	check_line
      '\':
	range &stack 1 -2
	check_line
      :
	check_for_command check_line

    $check_line:
      loop:
	if
	  i > n:
	    draw:
	      $mode stack(-1)
	      update_if mode == '$' || mode == '#' &stack -> range(stack 1 -2)
	      push &screens tuple(screen stack)
	      -> screens stack
	  :
	    $chr text(i)
	    $mode stack(-1)
	    case chr
	      '#':
		case mode
		  '@quot;', '@apos;':
		    inc &i
		    next
		  :
		    draw:
		      inc &i
		      push &stack chr
		      next
	      '@quot;':
		case mode
		  '@quot;':
		    inc &i
		    draw:
		      range &stack 1 -2
		      next
		  '#':
		    inc &i
		    next
		  :
		    draw:
		      inc &i
		      push &stack chr
		      next
	      '@apos;':
		case mode
		  '@quot;', '#':
		    inc &i
		    next
		  '@apos;':
		    inc &i
		    draw:
		      range &stack 1 -2
		      next
		  :
		    draw:
		      inc &i
		      push &stack chr
		      next
	      '`':
		find_first $pos $_item stack : (item) -> item == '`'
		if
		  pos.is_defined: # within a backquoted expression
		    draw:
		      inc &i
		      range &stack 1 pos # remove stacked modifiers
		      draw:
			range &stack 1 pos-1 # remove '`'
			next
		  :
		    if
		      mode == '#':
			inc &i
			next
		      :
			draw:
			  inc &i
			  push &stack chr
			  check_for_command next
	      '$':
		case mode
		  '@apos;', '#':
		    inc &i
		    next
		  :
		    if
		      i < n:
			draw:
			  inc &i
			  handle_parameter next
			#case get_next_character(i+1)
			  'a'..'z', 'A'..'Z', '_':
			    draw:
			      inc &i
			      handle_variable ITALIC next
			  '0'..'9', '*', '@@', '#', '?', '-', '$', '!':
			    draw:
			      inc &i
			      handle_character ITALIC MAGENTA next
			  '{':
			    inc &i
			    get_next_character(i)
			    get_identifier $symbol &i
			    debug::dump `symbol
			    inc &i
			    next
			  :
			    inc &i
			    next
		      :
			inc &i
			next

		#$get_next_character: (curr_i)
		  $c text(curr_i)
		  if
		    c == '\':
		      if
			curr_i < n
			-> c
			:
			  inc &idx
			  !line lines(idx)
			  if
			    indent_of(line) == 0:
			      !text text_of(line)
			      !n length_of(text)
			      -> get_next_character(1)
			    -> undefined
		    -> c
	      '|':
		case mode
		  '@apos;', '@quot;', '#':
		    inc &i
		    next
		  :
		    draw:
		      draw_symbol chr BOLD '@0xc000ff;':
			inc &i
			!s i
			check_for_command next
	      '\':
		case mode
		  '@apos;', '#':
		    inc &i
		    next
		  :
		    draw:
		      draw_symbol "\" BOLD '@0xc000ff;':
			if
			  i == n:
			    push &screens tuple(screen empty_list)
			    if
			      idx < length_of(lines) && lines(idx+1).is_defined:
				inc &idx
				!line lines(idx)
				!indent indent_of(line)
				!text text_of(line)
				!screen
				  create_screen
				    template_screen indent+width_of(text) 1
				!x indent+1
				!s 1
				!n length_of(text)
				!i 1
				next
			      -> screens stack
			  :
			    inc &i
			    !s i
			    if
			      i > n:
				push &stack chr
				next
			      :
				inc &i
				next
	      'a'..'z', 'A'..'Z', '0'..'9', '_':
		inc &i
		next
	      :
		case mode
		  '$':
		    draw:
		      inc &i
		      range &stack 1 -2
		      next
		  :
		    inc &i
		    next

    $check_for_command: (continuation)
      $found_assignment false
      $symbol ""
      $cmd_idx idx
      loop
	:
	  if
	    i <= n && text(i) == ' ':
	      inc &i
	      next
	    break
	:
	  draw:
	    $cmd_text text
	    $within_single_quotes false
	    $within_double_quotes false
	    loop
	      :
		if
		  i > n
		  break
		  :
		    $chr cmd_text(i)
		    case chr
		      ' ', '#', '(', ')':
			if
			  within_single_quotes || within_double_quotes:
			    push &symbol chr
			    inc &i
			    next
			  break
		      '`':
			if
			  within_single_quotes:
			    push &symbol chr
			    inc &i
			    next
			  break
		      '@apos;':
			if
			  within_double_quotes:
			    push &symbol chr
			    inc &i
			    next
			  :
			    not &within_single_quotes
			    inc &i
			    next
		      '@quot;':
			if
			  within_single_quotes:
			    push &symbol chr
			    inc &i
			    next
			  :
			    not &within_double_quotes
			    inc &i
			    next
		      '=':
			!found_assignment true
			break
		      '\':
			if
			  i < n:
			    inc &i
			    !chr cmd_text(i)
			    push &symbol chr
			    inc &i
			    next
			  :
			    if
			      cmd_idx < length_of(lines):
				$next_line lines(cmd_idx+1)
				if
				  &&
				    next_line.is_defined
				    indent_of(next_line) == 0
				  :
				    inc &cmd_idx
				    !cmd_text text_of(next_line)
				    !i 1
				    !n length_of(cmd_text)
				    next
				  break
			      break
		      :
			push &symbol chr
			inc &i
			next
	      :
		if
		  symbol.is_empty
		  continuation
		  lookup

      $lookup:
	$text_attributes NORMAL
	$colour BLACK
	if
	  found_assignment:
	    if
	      symbol.is_an_identifier:
		!colour
		  if
		    environment(symbol).is_defined
		    -> ORANGE
		    -> MAGENTA
		draw_command
	      :
		!text_attributes BOLD
		!colour RED
		draw_command
	  :
	    !text_attributes BOLD
	    if
	      is_a_builtin_keyword(symbol):
		!colour '@0xb000b0;'
		draw_command
	      :
		if
		  is_a_builtin_command(symbol):
		    !colour '@0x903090;'
		    draw_command
		  :
		    if
		      shell_commands(symbol):
			!colour '@0x806000;'
			draw_command
		      draw_command

	$draw_command:
	  if
	    cmd_idx > idx:
	      draw_symbol range(text s -1) text_attributes colour:
		loop
		  :
		    push &screens tuple(screen empty_list)
		    inc &idx
		    !line lines(idx)
		    if
		      idx == cmd_idx
		      break
		      :
			$line_indent indent_of(line)
			$line_text text_of(line)
			!screen
			  create_screen
			    template_screen line_indent+width_of(line_text) 1
			!x line_indent+1
			draw_symbol line_text text_attributes colour next
		  :
		    !indent indent_of(line)
		    !text text_of(line)
		    !screen
		      create_screen
			template_screen indent+width_of(text) 1
		    !x indent+1
		    !n length_of(text)
		    draw_symbol range(text 1 i-1) text_attributes colour
		      continuation
	    :
	      $symbol_text range(text s i-1)
	      draw_symbol symbol_text text_attributes colour continuation

    $draw_symbol: (symbol text_attributes draw_colour continuation)
      set_draw_colour &screen draw_colour
      set_text_attributes &screen text_attributes
      draw_text &screen x 1 symbol
      plus &x width_of(symbol)
      !s i
      continuation

    $draw: (continuation)
      if
	i > s:
	  attributes(stack(-1)) $draw_colour $text_attributes
	  set_draw_colour &screen draw_colour
	  set_text_attributes &screen text_attributes
	  $part range(text s i-1)
	  draw_text &screen x 1 part
	  plus &x width_of(part)
	  !s i
	  continuation
	continuation

    $handle_parameter: (continuation)
      $symbol ""
      $orig_text text
      $orig_i i
      $id_idx idx
      $expansion_chr undefined
      loop
	:
	  if
	    i > n:
	      break
	    :
	      $chr text(i)
	      if
		symbol.is_empty:
		  case chr
		    '0'..'9', '*', '@@', '#', '?', '-', '$', '!':
		      push &symbol chr
		      inc &i
		      break
		    '{':
		      push &symbol chr
		      inc &i
		      next
		    check_character
		:
		  if
		    symbol == "{":
		      case chr
			'0'..'9', '*', '@@', '#', '?', '-', '$', '!':
			  push &symbol chr
			  inc &i
			  next
			check_character
		    check_character

	      $check_character:
		cond
		  -> chr.is_an_identifier_character:
		    push &symbol chr
		    inc &i
		    next
		  -> chr.is_an_expansion_character:
		    !expansion_chr chr
		    inc &i
		    break
		  -> true:
		    if
		      chr == '\' && i == n && id_idx < length_of(lines):
			$next_line lines(id_idx+1)
			if
			  next_line.is_defined && indent_of(next_line) == 0:
			    inc &id_idx
			    !text text_of(next_line)
			    !i 1
			    !n length_of(text)
			    next
			  break
		      :
			if
			  chr == '}' && symbol .has_prefix. '{':
			    push &symbol chr
			    inc &i
			    break
			  break
	:
	  if
	    symbol.is_empty:
	      !text orig_text
	      !i orig_i
	      !n length_of(text)
	      continuation
	    :
	      $text_attributes ITALIC
	      if !symbol !text_attributes $colour
		symbol .has_prefix. '{':
		  if
		    expansion_chr.is_defined
		    -> range(symbol 2 -1) text_attributes undefined
		    :
		      if
			symbol(-1) == '}'
			-> range(symbol 2 -2) text_attributes undefined
			-> symbol text_attributes|BOLD RED
		-> symbol text_attributes undefined
	      update_if colour.is_undefined &colour:
		if
		  environment(symbol).is_defined
		  -> ORANGE
		  -> MAGENTA
	      if
		idx < id_idx:
		  !text orig_text
		  draw_symbol range(text s -1) text_attributes colour:
		    loop
		      :
			push &screens tuple(screen empty_list)
			inc &idx
			!line lines(idx)
			if
			  idx == id_idx
			  break
			  :
			    $line_indent indent_of(line)
			    $line_text text_of(line)
			    !screen
			      create_screen
				template_screen
				line_indent+width_of(line_text) 1
			    !x line_indent+1
			    draw_symbol line_text text_attributes colour next
		      :
			!indent indent_of(line)
			!text text_of(line)
			!screen
			  create_screen
			    template_screen indent+width_of(text) 1
			!x indent+1
			!s 1
			!n length_of(text)
			draw_identifier
		draw_identifier

	      $draw_identifier:
		draw_symbol range(text s i-1) text_attributes colour continuation

    $handle_character: (text_attributes draw_colour continuation)
      $chr text(i)
      if
	chr == '\': # must be at a line end
	  draw_symbol range(text s -1) text_attributes draw_colour:
	    push &screens tuple(screen stack)
	    inc &idx
	    !line lines(idx)
	    !indent indent_of(line)
	    !text text_of(line)
	    !screen
	      create_screen
		template_screen indent+width_of(text) 1
	    !x indent+1
	    !s 1
	    !n length_of(text)
	    !i 1
	    handle_character text_attributes draw_colour continuation
	:
	  inc &i
	  draw_symbol range(text s i-1) text_attributes draw_colour continuation

$is_an_identifier_character: (chr)
  -> chr.is_a_letter || chr.is_a_digit || chr == '_'

$is_an_expansion_character hash_set(':' '-' '#' '/' '^' ',' '@@')

$is_an_identifier: (str)
  ->
    &&
      str(1).is_a_letter || str(1) == '_'
      all_of(range(str 2 -1) is_an_identifier_character)
