<!doctype html>
<html>
<head>
<title>Collections</title>
<link rel="stylesheet" href="../style.css">
</head>
<body>
<div>
<a class="Button" href="../index.html">Home</a> <a class="Button" href="../manual.html">Manual</a> <a class="Button" href="index.html">Topics</a> <a class="Button" href="../symbols/type_index.html">Types</a> <a class="Button" href="../symbols/function_index.html">Functions</a> <a class="Button" href="../symbols/objects_index.html">Objects</a> <a class="Button" href="../symbols/constants_index.html">Constants</a> <a class="Button" href="../symbols/index.html">All</a>
</div>
<h1>Collections</h1>
<h2>Description</h2>
<p>There are several kinds of collections</p>
<ul>
<li>tuples
</ul>
<ul>
<li>lists
</ul>
<ul>
<li>sets
</ul>
<ul>
<li>bags
</ul>
<ul>
<li>tables
</ul>
<p>Sets, bags and tables come in several variants, that offer specific features.</p>
<p>Collections have type functions that allow retrieving and "updating" individual elements in the collection.</p>
<p>When a collection is "updated" a new collection is created where the element is changed. The original collection is not changed.</p>
<h2>Related topics</h2>
<table>
<tr>
  <td><a href="Tuples.html">Tuples</a></td>
</tr>
<tr>
  <td><a href="Lists.html">Lists</a></td>
</tr>
<tr>
  <td><a href="Sets.html">Sets</a></td>
</tr>
<tr>
  <td><a href="Bags.html">Bags</a></td>
</tr>
<tr>
  <td><a href="Tables.html">Tables</a></td>
</tr>
</table>
<h2>Types</h2>
<table>
<tr>
  <td><a href="../symbols/std_types__array.html">std_types::array</a></td>
  <td class="description">an array of objects</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__association_list.html">std_types::association_list</a></td>
  <td class="description">a very primitive kind of a table</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__avl_table.html">std_types::avl_table</a></td>
  <td class="description">the prototype object for all AVL-based tables</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__binary_table.html">std_types::binary_table</a></td>
  <td class="description">a table based on binary trees</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__collection.html">std_types::collection</a></td>
  <td class="description">the prototype object for all kinds of collections</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__generic_array.html">std_types::generic_array</a></td>
  <td class="description">the prototype object for all kind of arrays</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__generic_list.html">std_types::generic_list</a></td>
  <td class="description">the prototype object for all kind of lists (including strings)</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__hash_bag.html">std_types::hash_bag</a></td>
  <td class="description">the prototype object for all hash-based bags</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__hash_set.html">std_types::hash_set</a></td>
  <td class="description">a set for fast random access</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__hash_table.html">std_types::hash_table</a></td>
  <td class="description">a table for fast random access of items</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__insert_order_set.html">std_types::insert_order_set</a></td>
  <td class="description">the prototype object for all insert-order sets</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__insert_order_table.html">std_types::insert_order_table</a></td>
  <td class="description">the prototype object for all insert-order tables</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__key_order_set.html">std_types::key_order_set</a></td>
  <td class="description">a set which items are stored in key-order</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__key_order_table.html">std_types::key_order_table</a></td>
  <td class="description">a table which items are stored in key-order</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__lb2_table.html">std_types::lb2_table</a></td>
  <td class="description">the prototype object for all left-balanced 2-3-4-trees</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__list.html">std_types::list</a></td>
  <td class="description">an ordered, enumerated sequence of items</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__sequence.html">std_types::sequence</a></td>
  <td class="description">the prototype object for all sequences</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__set.html">std_types::set</a></td>
  <td class="description">the prototype object for all kinds of sets</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__string.html">std_types::string</a></td>
  <td class="description">the prototype object for all strings</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__table.html">std_types::table</a></td>
  <td class="description">the prototype object for all tables</td>
</tr>
<tr>
  <td><a href="../symbols/std_types__tuple.html">std_types::tuple</a></td>
  <td class="description">the prototype object for all tuples</td>
</tr>
</table>
<h2>Functions</h2>
<table>
<tr>
  <td><a href="../symbols/std__add.html">std::add</a></td>
  <td class="description">add some items to a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__all_of.html">std::all_of</a></td>
  <td class="description">checks whether all items of a collection pass the specified test</td>
</tr>
<tr>
  <td><a href="../symbols/std__any_of.html">std::any_of</a></td>
  <td class="description">checks whether at least one item of a collection passes the specified test</td>
</tr>
<tr>
  <td><a href="../symbols/std__append.html">std::append</a></td>
  <td class="description">appends two or more collections to form a single collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__append_or_error.html">std::append_or_error</a></td>
  <td class="description">append two collections</td>
</tr>
<tr>
  <td><a href="../symbols/std__before.html">std::before</a></td>
  <td class="description">returns the substring before the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__behind.html">std::behind</a></td>
  <td class="description">returns the substring behind the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__contains.html">std::contains</a></td>
  <td class="description">checks whether a collection contains the specified item or not</td>
</tr>
<tr>
  <td><a href="../symbols/std__count.html">std::count</a></td>
  <td class="description">counts items in a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__difference.html">std::difference</a></td>
  <td class="description">computes the difference of two collections</td>
</tr>
<tr>
  <td><a href="../symbols/std__drop.html">std::drop</a></td>
  <td class="description">remove the last item of a collection without returning it</td>
</tr>
<tr>
  <td><a href="../symbols/std__dup.html">std::dup</a></td>
  <td class="description">creates a concatenation of <i>n</i> copies of the specified collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__empty_collection_of.html">std::empty_collection_of</a></td>
  <td class="description">returns an empty collection of the appropriate type</td>
</tr>
<tr>
  <td><a href="../symbols/std__filter.html">std::filter</a></td>
  <td class="description">returns a collection containing all the items that fullfill the</td>
</tr>
<tr>
  <td><a href="../symbols/std__find_first.html">std::find_first</a></td>
  <td class="description">returns the first item of a collection that fullfills the condition</td>
</tr>
<tr>
  <td><a href="../symbols/std__first_item_of.html">std::first_item_of</a></td>
  <td class="description">returns the first item of a non-empty collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__first_key_of.html">std::first_key_of</a></td>
  <td class="description">returns the first key of a non-empty collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__flatten.html">std::flatten</a></td>
  <td class="description">flattens a collection (probably a list)</td>
</tr>
<tr>
  <td><a href="../symbols/std__for_each.html">std::for_each</a></td>
  <td class="description">iterates over all items of a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__from.html">std::from</a></td>
  <td class="description">returns the substring starting with the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__from_base64.html">std::from_base64</a></td>
  <td class="description">converts a base64 string to a string</td>
</tr>
<tr>
  <td><a href="../symbols/std__has_prefix.html">std::has_prefix</a></td>
  <td class="description">checks whether the first argument has the second argument as a prefix</td>
</tr>
<tr>
  <td><a href="../symbols/std__in.html">std::in</a></td>
  <td class="description">checks whether an element is contained in a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__intersection.html">std::intersection</a></td>
  <td class="description">compute the intersection of two collections</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_a_hash_set.html">std::is_a_hash_set</a></td>
  <td class="description">checks if an object is a hash set</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_a_key_order_set.html">std::is_a_key_order_set</a></td>
  <td class="description">checks if an object is a key-order set</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_a_key_value_pair.html">std::is_a_key_value_pair</a></td>
  <td class="description">checks if an object is a key-value-pair</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_a_set.html">std::is_a_set</a></td>
  <td class="description">checks if an object is a set</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_a_table.html">std::is_a_table</a></td>
  <td class="description">checks if an object is a table</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_a_value_range.html">std::is_a_value_range</a></td>
  <td class="description">checks if an object is a value range</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_an_association_list.html">std::is_an_association_list</a></td>
  <td class="description">checks if an object is an association list</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_empty.html">std::is_empty</a></td>
  <td class="description">checks whether a collection contains any items</td>
</tr>
<tr>
  <td><a href="../symbols/std__is_not_empty.html">std::is_not_empty</a></td>
  <td class="description">checks whether a collection contains at least one item</td>
</tr>
<tr>
  <td><a href="../symbols/std__keys_of.html">std::keys_of</a></td>
  <td class="description">returns a list of all keys of the specified collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__last_item_of.html">std::last_item_of</a></td>
  <td class="description">returns the last item of a non-empty collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__last_key_of.html">std::last_key_of</a></td>
  <td class="description">returns the last key of a non-empty collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__length_of.html">std::length_of</a></td>
  <td class="description">returns the number of items within a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__map.html">std::map</a></td>
  <td class="description">applies a function to all items of a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__map_or_error.html">std::map_or_error</a></td>
  <td class="description">appliies a function to all items of a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__map_reduce.html">std::map_reduce</a></td>
  <td class="description">combines a map and a reduce operation into a single operation</td>
</tr>
<tr>
  <td><a href="../symbols/std__map_reduce_columns.html">std::map_reduce_columns</a></td>
  <td class="description">applies a map and a reduce function to each column of a table</td>
</tr>
<tr>
  <td><a href="../symbols/std__map_reduce_rows.html">std::map_reduce_rows</a></td>
  <td class="description">applies a map and a reduce function to each row of a table</td>
</tr>
<tr>
  <td><a href="../symbols/std__merge.html">std::merge</a></td>
  <td class="description">merges two collections</td>
</tr>
<tr>
  <td><a href="../symbols/std__neutral_element_of.html">std::neutral_element_of</a></td>
  <td class="description">returns the neutral element for the type of its argument</td>
</tr>
<tr>
  <td><a href="../symbols/std__new.html">std::new</a></td>
  <td class="description">creates a new collection with inherited attributes</td>
</tr>
<tr>
  <td><a href="../symbols/std__next_item_of.html">std::next_item_of</a></td>
  <td class="description">returns the next item after the specified item</td>
</tr>
<tr>
  <td><a href="../symbols/std__next_key_of.html">std::next_key_of</a></td>
  <td class="description">returns the key after the specified key</td>
</tr>
<tr>
  <td><a href="../symbols/std__pad_left.html">std::pad_left</a></td>
  <td class="description">extends a string to the specified width</td>
</tr>
<tr>
  <td><a href="../symbols/std__pad_right.html">std::pad_right</a></td>
  <td class="description">extends a string to the specified width</td>
</tr>
<tr>
  <td><a href="../symbols/std__pad_top.html">std::pad_top</a></td>
  <td class="description">pads a collection with a specified value</td>
</tr>
<tr>
  <td><a href="../symbols/std__peek.html">std::peek</a></td>
  <td class="description">returns the last item of a collection without removing it</td>
</tr>
<tr>
  <td><a href="../symbols/std__previous_item_of.html">std::previous_item_of</a></td>
  <td class="description">returns the previous item before the specified item</td>
</tr>
<tr>
  <td><a href="../symbols/std__previous_key_of.html">std::previous_key_of</a></td>
  <td class="description">returns the key before the specified key</td>
</tr>
<tr>
  <td><a href="../symbols/std__range.html">std::range</a></td>
  <td class="description">returns a subrange of a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__reduce.html">std::reduce</a></td>
  <td class="description">compute a kind of sum from the items of a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__reduce_columns.html">std::reduce_columns</a></td>
  <td class="description">reduces the columns of a table</td>
</tr>
<tr>
  <td><a href="../symbols/std__reduce_rows.html">std::reduce_rows</a></td>
  <td class="description">reduces a list of lists (a table) row-wise</td>
</tr>
<tr>
  <td><a href="../symbols/std__remove.html">std::remove</a></td>
  <td class="description">removes some item(s) from a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__retrieve_first_item.html">std::retrieve_first_item</a></td>
  <td class="description">removes and returns the first item of a non-empty collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__retrieve_last_item.html">std::retrieve_last_item</a></td>
  <td class="description">returns and removes the last item of a non-empty collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__reverse.html">std::reverse</a></td>
  <td class="description">reverses the order of all items of a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__sort.html">std::sort</a></td>
  <td class="description">sorts a collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__subtype_of.html">std::subtype_of</a></td>
  <td class="description">defines a subtype of a tuple or a list</td>
</tr>
<tr>
  <td><a href="../symbols/std__to_base64.html">std::to_base64</a></td>
  <td class="description">converts a string to base64</td>
</tr>
<tr>
  <td><a href="../symbols/std__truncate.html">std::truncate</a></td>
  <td class="description">truncates a collection to the specified number of items</td>
</tr>
<tr>
  <td><a href="../symbols/std__truncate_before.html">std::truncate_before</a></td>
  <td class="description">returns the substring starting with the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__truncate_behind.html">std::truncate_behind</a></td>
  <td class="description">returns the substring ending with the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__truncate_from.html">std::truncate_from</a></td>
  <td class="description">returns the substring before the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__truncate_until.html">std::truncate_until</a></td>
  <td class="description">returns the substring behind the specified expression</td>
</tr>
<tr>
  <td><a href="../symbols/std__tuple.html">std::tuple</a></td>
  <td class="description">constructs a tuple from the specified arguments</td>
</tr>
<tr>
  <td><a href="../symbols/std__typed_tuple.html">std::typed_tuple</a></td>
  <td class="description">clones the specified tuple and replace its contents</td>
</tr>
<tr>
  <td><a href="../symbols/std__values_of.html">std::values_of</a></td>
  <td class="description">returns a list of all values of the specified collection</td>
</tr>
<tr>
  <td><a href="../symbols/std__zip.html">std::zip</a></td>
  <td class="description">merges two collections</td>
</tr>
</table>
<h2>Objects</h2>
<table>
<tr>
  <td><a href="../symbols/std__empty_association_list.html">std::empty_association_list</a></td>
  <td class="description">an empty association list</td>
</tr>
<tr>
  <td><a href="../symbols/std__empty_avl_table.html">std::empty_avl_table</a></td>
  <td class="description">an empty AVL-table</td>
</tr>
<tr>
  <td><a href="../symbols/std__empty_binary_table.html">std::empty_binary_table</a></td>
  <td class="description">an empty binary table</td>
</tr>
<tr>
  <td><a href="../symbols/std__empty_hash_table.html">std::empty_hash_table</a></td>
  <td class="description">an empty hash table</td>
</tr>
<tr>
  <td><a href="../symbols/std__empty_insert_order_table.html">std::empty_insert_order_table</a></td>
  <td class="description">an empty insert-order table</td>
</tr>
<tr>
  <td><a href="../symbols/std__empty_lb2_table.html">std::empty_lb2_table</a></td>
  <td class="description">an empty left-balanced binary tree</td>
</tr>
</table>
<div class="footer">(defined in <a href="../source/basic/types/collections/collection.fky">basic/types/collections/collection.fky</a>)</div>
</body>
</html>
