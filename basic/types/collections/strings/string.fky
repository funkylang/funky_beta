#
  Copyright (C) 2024 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Library General Public License, version 2, or
  (at your option) under the terms of the GNU Lesser General Public License,
  version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser (Library) General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files LGPLv2.txt and LGLPv3.txt or
  http://www.gnu.org/licenses/lgpl-2.0.html
  http://www.gnu.org/licenses/lgpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

#
  Topic: Strings

  Strings consist of zero or more characters.

  A character is a tagged unsigned 32-bit integer which can be used to represent
  a unicode code point. But they can also be used for representing other things
  like 24-bit colour codes.

  Strings are tagged lists of characters. The characters in a list can be
  accessed in a left to right manner using one based indices.

  They can also be accessed right to left if the indices are negative numbers.

  Example:

    $str "abc"
    println! str(1) # prints "a"
    println! str(-1) # prints "c"

  The subtype <std_types::octet_string> of <std_types::string> is used for
  binary data or storing utf8 encoded strings.

  In an *octet string* each character is encoded with only 8 bits.

  *Octect strings* are generated automatically if a string contains only 8-bit
  characters.

  Accessing a single character of a string using indexing is an O(1) operation.

  Strings, as everything else in Funky, are immutable. So "changing" a string in
  some way always results in a new string being created.

  This new string can use "structure sharing" with the original string to avoid
  unnecessary copying of data.

  Adding a character at the end of a string (<std::push>) is an accumulated O(1)
  operation if applied multiple times to the same string.

  Changing a single character in a string *can* be implemented as an accumulated
  O(1) operation if applied multiple times to the same string.

  The <std::append> method also tries to use structure sharing to avoid
  unnecessary copying of data.

  It's more efficient to append multiple strings in one go than to append them
  one by one.

  A string *range* is a substring of a string and is usually implementing using
  structure sharing. Creating a string range using <std::range> is an O(1)
  operation.

  The most basic string operations are builtin.

  Strings have a lot in common with <std_types::list>.

  Related topics: Lists

$std::to_sentence_case ()
  #
    converts a string to "Sentence case"

    Parameter:
      string # the string to convert

    Result:
      string # the converted string

    Topic: Strings

    See also: to_lower_case, to_upper_case

    Example:

      $str "this is a test."
      println! str.to_sentence_case

    Output:

      This is a test.

$std::is_a_string ()
  #
    tests if an object is a string

    Topic: Strings

$std::to_uint8_array ()
  #
    converts a string to an array of unsigned 8-bit integers

    Topic: Strings

$std_types::object.is_a_string false
  #
    by default, objects are not strings

    Topic: Objects, Strings

$std_types::string.is_a_string true
  #
    strings are strings

    Topic: Strings

$std::is_an_octet_string ()
  #
    tests if an object is an octet string

    Topic: Strings

$std_types::object.is_an_octet_string false
  #
    by default, objects are not octet strings

    Topic: Objects, Strings

$std_types::octet_string.is_an_octet_string true
  #
    octet strings are octet strings

    Topic: Strings

$std_types::string.neutral_element_of ""

$std_types::string/to_string:
  #
    returns its argument unaltered

    Topic: Strings

    See also: string
  (
    self # the string
  )
  -> self

$std::create_string:
  #
    returns the concatenation of all of the list's items converted to strings

    Topic: Strings

    See also: string

    Example:

      $arguments list(7 " x " 7 " = " 7*7 '@nl;')
      print! create_string(arguments)

    Output:

      7 x 7 = 49
  (
    arguments # a list of printable items
  )
  if
    arguments.is_empty
    -> ""
    : map_reduce arguments to_string append

$std::string:
  #
    returns the concatenation of all its arguments converted to strings

    Topic: Strings

    See also: create_string, to_string

    Example:

      $str string(7 " x " 7 " = " 7*7 '@nl;')
  (
    args*
  )
  create_string args

$std_types::string/put:
  #
    adds a character at the front of the string

    Topic: Strings

    See also: std_types::string/push, std_types::string/append

    Example:

      $str " big surprise"
      put &str 'a'
  (
    self # the string
    chr # the character to add
  )
  -> append(chr.to_string self)

$std_types::string/dup:
  #
    creates a string containing n copies of the specified string

    The function aims to duplicate the specified string in a smart way.

    Topic: Strings

    See also: spaces, tabs_and_spaces

    Example:

      $str "abc"
      $str_x_3 dup(str 3)
      println! str_x_3

    Output:

      abcabcabc
  (
    self # the string to duplicate
    n # the duplication count
  )
  case n
    0 -> ""
    1 -> self
    :
      $h n >> 1 # fails if <n> is not a positive integer
      $str dup(self h)
      if
	2*h == n:
	  string str str
	:
	  string str str self

$std_types::object/pad_left:
  #
    extends a string to the specified width

    This function creates a string representation of *expr* which is at least
    *n* characters long. If it would be shorter than it is padded to the left
    with the string pattern stored in *pad*.

    The default value for *pad* is a single space.

    Topic: Strings

    See also: pad_right

    Example:

      $str "123"
      $padded_str pad_left(str 5 "0")
      println! padded_str

    Output:

      00123
  (
    expr # the expression that is converted into a string
    n # the length of the resulting string
    pad = " " # the pattern used to fill up the string
  )
  $text expr.to_string
  $len length_of(text)
  if
    len < n:
      $pad_len length_of(pad)
      string range(dup(pad (n-len)+(pad_len-1) .div. pad_len) 1 n-len) text
    -> text

$std_types::object/pad_right:
  #
    extends a string to the specified width

    This function creates a string representation of *expr* which is at least
    *n* characters long. If it would be shorter than it is padded to the right
    with the string pattern stored in *pad*.

    The default value for *pad* is a single space.

    Topic: Strings

    See also: pad_left

    Example:

      $str "computer"
      $padded_str pad_right(str 10 '_')
      println! padded_str

    Output:

      computer__
  (
    expr # the expression that is converted into a string
    n # the length of the resulting string
    pad = " " # the pattern used to fill up the string
  )
  $text expr.to_string
  $len length_of(text)
  if
    len < n:
      $pad_len length_of(pad)
      string text range(dup(pad (n-len)+(pad_len-1) .div. pad_len) 1 n-len)
    -> text

$eighty_spaces "
  @;                                        @
  @;                                        @

$std::spaces:
  #
    returns the specified number of spaces

    Topic: Strings

    See also: tabs_and_spaces
  (
    n # the desired number of spaces
  )
  if
    n <= 80
    -> range(eighty_spaces 1 n)
    -> dup(" " n)

$nine_tabs_and_seven_spaces "@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;       "

$std::tabs_and_spaces:
  #
    returns a sequence of tabulator- and space-characters

    Topic: Strings

    See also: spaces
  (
    n # the desired display width
  )
  if
    n < 80
    -> range(nine_tabs_and_seven_spaces 10-(n >> 3) 9+(n & 7))
    -> string(dup("@ht;" n >> 3) spaces(n & 7))

$tabs "@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;"

$std::with_tabs:
  #
    replaces leading spaces with tab-characters

    Replaces sequences of 8 or more leading spaces with the apprpriate number
    of tabulator-characters and the remaining spaces.

    Topic: Strings

    See also: tabs_and_spaces
  (
    text # the text to be processed
  )
  $s 1
  $n length_of(text)
  $i 1
  $output ""
  $count 0
  loop:
    if
      i <= n:
	if
	  text(i) == ' ':
	    !i i+1
	    !count count+1
	    next
	  :
	    if
	      count >= 8:
		$tab_count count >> 3
		if
		  tab_count >= 1:
		    append &output range(text s i-(count+1))
		    append &output
		      if
			tab_count < 10
			-> range(tabs 1 tab_count)
			-> dup("@ht;" tab_count)
		    !s (i-count)+(tab_count << 3)
		    skip_line
		  skip_line
	      skip_line
      :
	if
	  s == 1
	  -> text
	  -> append(output range(text s -1))

  $skip_line:
    loop
      :
	if
	  i <= n && text(i) != '@nl;':
	    !i i+1
	    next
	  break
      :
	!i i+1
	!count 0
	next


$std_types::string/match:
  #
    matches the start of the stream with the string

    Result: the number of matched characters or <undefined> if the match fails

    Attempts to match the start of the stream with the specified string.

    If the match is successful the length of the string is returned.

    Otherwise <undefined> is returned.

    Topic: Strings

    See also: std_types::string/search
  (
    self # the string to match
    stream # the stream to match against
  )
  $rc result_count()
  $len length_of(self)
  if
    length_of(stream) >= len:
      if
	range(stream 1 len) == self:
	  if
	    rc == 1
	    -> len
	    -> len undefined
	fail
    fail

  $fail:
    if
      rc == 1
      -> undefined
      -> undefined undefined

$std_types::string/match_back:
  (
    self
    stream
  )
  $len length_of(self)
  if
    length_of(stream) >= len && range(stream -len -1) == self
    -> len
    -> undefined

$std_types::string/matches:
  #
    checks whether the string matches the specified expression

    Topic: Strings

    See also: std_types::string/match
  (
    self # the string to check
    expr # the expression to match
  )
  -> match(expr self) == length_of(self)

$std_types::string/search:
  #
    searches for the start of the string within the stream

    Attempts to find the start of the string within the stream. If the match
    is successful the found position (one based) and the length of the string
    is returned. Otherwise the returned values for the position and the length
    are <undefined>.

    If *nth* is specified then the nth occurence of the string is looked for.
    If there are not at least *n* matches for *expr* within *str* then the
    returned values for the position and the length are <undefined>.

    Topic: Strings

    See also: std_types::string/match
  (
    self # the string to search for
    stream # the stream to search in
    nth = 1 # search for the nth occurrence of *self* instead for the first one
  )
  $i undefined
  $length length_of(self)
  $offset length-1
  $n length_of(stream)-offset
  if
    nth < 0:
      !i n
      search_backwards
    :
      !i 1
      search_forwards

  $search_forwards:
    if
      i <= n
      :
	if
	  range(stream i i+offset) == self:
	    if
	      nth > 1:
		dec &nth
		plus &i length
		search_forwards
	      -> i length
	  :
	    inc &i
	    search_forwards
      -> undefined undefined

  $search_backwards:
    if
      i >= 1
      :
	if
	  range(stream i i+offset) == self:
	    if
	      nth < -1:
		inc &nth
		minus &i length
		search_backwards
	      -> i length
	  :
	    dec &i
	    search_backwards
      -> undefined undefined

$std_types::string/before:
  #
    returns the substring before the specified expression

    If the specified expression is found within the string the substring
    before the expression is returned. Otherwise the empty string is returned.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_from>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_from, string/behind, string/between, string/until

    Example:

      $identifier "std::before"
      $namespace identifier .before. "::"
      println! namespace

    Output:

      std

    Example:

      $identifier "std::before"
      $first_part identifier .before. '.'
      println! '[' first_part ']'

    Output:

      []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos-1)
    -> ""


$std_types::string/truncate_from:
  #
    returns the substring before the specified expression

    If the specified expression is found within the string the substring
    before the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/before>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/before, string/behind, string/between, string/until

    Example:

      $identifier "std::truncate_from"
      $namespace identifier .truncate_from. "::"
      println! namespace

    Output:

      std

    Example:

      $identifier "std::truncate_from"
      $first_part identifier .truncate_from. '.'
      println! '[' first_part ']'

    Output:

      [std::truncate_from]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos-1)
    -> str

$std_types::string/behind:
  #
    returns the substring after the specified expression

    If the specified expression is found within the string the substring
    after the expression is returned. Otherwise the empty string is returned.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_until>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_until, string/before, string/between, string/until

    Example:

      $identifier "std::behind"
      $name identifier .behind. "::"
      println! name

    Output:

      behind

    Example:

      $identifier "std::behind"
      $last_part identifier .behind. '.'
      println! '[' last_part ']'

    Output:

      []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str pos+len -1)
    -> ""

$std_types::string/truncate_until:
  #
    returns the substring behind the specified expression

    If the specified expression is found within the string the substring
    behind the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/behind>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/behind, string/before, string/between, string/until

    Example:

      $identifier "std::truncate_until"
      $name identifier .truncate_until. "::"
      println! name

    Output:

      truncate_until

    Example:

      $identifier "std::truncate_until"
      $last_part identifier .truncate_until. '.'
      println! '[' last_part ']'

    Output:

      [std::truncate_until]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str pos+len -1)
    -> str

$std_types::string/from:
  #
    returns the substring starting with the specified expression

    If the specified expression is found within the string the substring
    starting with the expression is returned. Otherwise the empty string is
    returned.

    If *nth* is specified then the nth occurence of the expression *expr* is
    looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_before>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_before, string/between, string/until, string/until

    Example:

      $identifier "std::from"
      $last_part identifier .from. "::"
      println! last_part

    Output:

      ::from

    Example:

      $identifier "std::from"
      $first_part identifier .from. '.'
      println! '[' first_part ']'

    Output:

      []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str pos -1)
    -> ""

$std_types::string/truncate_before:
  #
    returns the substring starting with the specified expression

    If the specified expression is found within the string the substring
    starting with the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr* is
    looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/from>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/from, string/between, string/until, string/until

    Example:

      $identifier "std::truncate_before"
      $last_part identifier .truncate_before. "::"
      println! last_part

    Output:

      ::truncate_before

    Example:

      $identifier "std::truncate_before"
      $first_part identifier .truncate_before. '.'
      println! '[' first_part ']'

    Output:

      [std::truncate_before]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str pos -1)
    -> str

$std_types::string/until:
  #
    returns the substring until (including) the specified expression

    If the specified expression is found within the string the substring
    until the expression is returned. Otherwise the empty string is returned.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_behind>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_behind, string/before, string/behind, string/from

    Example:

      $identifier "std::until"
      $first_part identifier .until. "::"
      println! first_part

    Output:

      std::

    Example:

      $identifier "std::until"
      $first_part identifier .until. '.'
      println! '<' first_part '>'

    Output:

      []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos+len-1)
    -> ""

$std_types::string/truncate_behind:
  #
    returns the substring until (including) the specified expression

    If the specified expression is found within the string the substring
    until the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/until>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/until, string/before, string/behind, string/from

    Example:

      $identifier "std::truncate_behind"
      $first_part identifier .truncate_behind. "::"
      println! first_part

    Output:

      std::

    Example:

      $identifier "std::truncate_behind"
      $first_part identifier .truncate_behind. '.'
      println! '[' first_part ']'

    Output:

      [std::truncate_behind]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos+len-1)
    -> str

$std_types::string/between:
  #
    returns the substring between two expressions

    If the specified expressions are found within the string the substring
    between the expressions is returned. Otherwise the empty string is
    returned.

    If *nth* is specified then the nth occurence of the first expression
    *expr_1* is looked for. If there are not at least *n* matches for
    *expr_1* within *str* then the empty string is returned.

    Topic: Strings

    See also: string/before, string/behind, string/until, string/from

    Example:

      $path "/home/user/"
      $user_name between(path "/" "/" 2)
      println! user_name

    Output:

      user
  (
    str # the input string
    expr_1 # the expression on the left hand side
    expr_2 # the expression on the right hand side
    nth = 1 # look for the nth occurrence of *expr_1* instead for the first one
  )
  -> behind(str expr_1 nth) .before. expr_2

$std_types::string/has_prefix:
  #
    checks whether the string has the specified prefix

    Topic: Strings

    See also: string/has_suffix, string/without_prefix, string/contains

    Example:

      $path "/home/user/"
      if
	path .has_prefix. "/home/":
	  println! "path starts with /home/"
	:
	  println! "path does not start with /home/"
  (
    self # the string to check
    prefix # the prefix to check for
  )
  -> match(prefix self).is_defined

$std_types::string/has_suffix:
  #
    checks whether the string has the specified suffix

    Topic: Strings

    See also: string/has_prefix, string/without_suffix, string/contains

    Example:

      $path "/home/user/"
      if
	path .has_suffix. '/':
	  println! "path ends with a slash"
	:
	  println! "path does not end with a slash"
  (
    self # the string to check
    suffix # the suffix to check for
  )
  -> match_back(suffix self).is_defined

$std_types::string/without_prefix:
  #
    returns the string without the specified prefix

    Checks whether the string has the specified prefix and if so returns
    the string without it. Otherwise the string is returned unaltered.

    Topic: Strings

    See also: string/without_suffix, string/has_prefix

    Example:

      $path "/home/user"
      $user_name path .without_prefix. "/home/"
      println! user_name

    Output:

      user
  (
    self # the string to process
    prefix # the prefix to remove
  )
  $n match(prefix self)
  if
    n.is_defined
    -> range(self n+1 -1)
    -> self

$std_types::string/without_suffix:
  #
    returns the string without the specified suffix

    Checks whether the string has the specified suffix and if so returns
    the string without it. Otherwise the string is returned unaltered.

    Topic: Strings

    See also: string/without_prefix, string/has_suffix

    Example:

      $path "/home/user"
      $base_dir path .without_suffix. "/user"
      println! base_dir

    Output:

      /home
  (
    self # the string to process
    suffix # the suffix to remove
  )
  $n match_back(suffix self)
  if
    n.is_defined
    -> range(self 1 -(n+1))
    -> self

$std_types::string/contains:
  #
    succeeds if the specified expression occurrs at least once within the string

    Returns <true> if the specified expression occurs at least once within the
    string.

    Returns <false> if the specified expression does not occur within the
    string.

    Topic: Strings

    See also: string/has_prefix, string/has_suffix

    Example:

      $path "/home/user/.bashrc"
      if
	path .contains. "/user/":
	  println! "path contains /user/"
	:
	  println! "path does not contain /user/"
  (
    self
    expr
  )
  search $pos $_len expr self
  -> pos.is_defined

$std::split:
  #
    splits a string into several parts and returns a list of these parts

    The separators are removed.

    Topic: Strings

    See also: string/join

    Example:

      $items split("a;b;c" ";")
      dump! `items

    Output:

      items: list <3>
	"a"
	"b"
	"c"

    Example:

      $items split("a;b;" ";")
      dump! `items

    Output:

      items: list <3>
	"a"
	"b"
	""
  (
    self
    separator = ' '
  )
  $rc result_count()
  if
    self.is_empty
    -> empty_list
    :
      $items empty_list
      loop:
	search $pos $len separator self
	if
	  pos.is_defined:
	    push &items range(self 1 pos-1)
	    range &self pos+len -1
	    next
	  :
	    push &items self
	    if
	      rc == 1
	      -> items
	      :
		spread items

$std::join:
  #
    concatenates the list items using the specified separator

    Returns a string which is the concatenation of all the list items
    separated by the specified separator.

    If the list is empty then the empty string is returned.

    Topic: Strings

    See also: string/split

    Example:

      $items list("a" "b" "c")
      $str join(items ";")
      println! str

    Output:

      a;b;c
  (
    items
    separator = " "
  )
  to_string &separator
  map_reduce
    items to_string
    : (left right) append left separator right
    ""

$std::trim:
  #
    removes leading and trailing whitespace

    Returns a string which is the specified string without any leading or
    trailing whitespace.

    Topic: Strings

    See also: string/trim_left, string/trim_right, string/normalize

    Example:

      $str "   text   "
      $trimmed_str trim(str)
      println! '*' trimmed_str '*'

    Output:

      *text*
  (
    self
    test = is_a_whitespace_character
  )
  $s 1
  $e length_of(self)
  loop:
    if
      s <= e && test(self(s)):
	inc &s
	next
      :
	loop:
	  if
	    e >= s && test(self(e)):
	      dec &e
	      next
	    :
	      range self s e

$std::trim_left:
  #
    removes leading whitespace

    Returns a string which is the specified string without any leading
    whitespace.

    Topic: Strings

    See also: string/trim, string/trim_right

    Example:

      $str "   text   "
      $trimmed_str trim_left(str)
      println! '*' trimmed_str '*'

    Output:

      *text   *
  (
    self
    test = is_a_whitespace_character
  )
  $s 1
  $e length_of(self)
  loop:
    if
      s <= e && test(self(s)):
	inc &s
	next
      :
	range self s e

$std::trim_right:
  #
    removes trailing whitespace

    Returns a string which is the specified string without any trailing
    whitespace.

    Topic: Strings

    See also: string/trim, string/trim_left

    Example:

      $str "   text   "
      $trimmed_str trim_right(str)
      println! '*' trimmed_str '*'

    Output:

      *   text*
  (
    self
    test = is_a_whitespace_character
  )
  $e length_of(self)
  loop:
    if
      e >= 1 && test(self(e)):
	dec &e
	next
      :
	range self 1 e

$std::normalize:
  #
    trims the string and replaces whitespace by a single space

    Returns a string which is the specified string without any leading or
    trailing whitespace and where all sequences of whitespace are replaced by
    a single space.

    Topic: Strings

    See also: string/trim

    Example:

      $str "   This    is    a     strange    text!   "
      $normalized_str normalize(str)
      println! '*' normalized_str '*'

    Output:

      *This is a strange text!*
  (
    self
  )
  $buf ""
  $e length_of(self)
  $i 0
  loop:
    loop
      :
	inc &i
	if
	  i > e
	  -> buf
	  :
	    if
	      self(i).is_a_whitespace_character
	      next
	      break
      :
	update_if buf.is_not_empty &buf -> push(buf ' ')
	$s i
	loop
	  :
	    inc &i
	    if
	      i > e
	      -> append(buf range(self s e))
	      :
		if
		  self(i).is_a_whitespace_character
		  break
		  next
	  :
	    append &buf range(self s i-1)
	    next

$std_types::octet_string/to_base64:
  #
    converts the octet string to base64

    Topic: Strings

    See also: from_base64

    Example:

      println! to_base64("Hello, world!")

    Output:

      SGVsbG8sIHdvcmxkIQ==
  (
    str # the octet string
  )
  $base64 ""
  loop:
    $len length_of(str)
    if
      len >= 3:
	append &base64 encode(range(str 1 3))
	range &str 4 -1
	next
      :
	if
	  len == 0
	  -> base64
	  :
	    append &str dup("@0;" 3-len)
	    append &base64 encode(str)
	    case len
	      1 -> append(range(base64 1 -3) "==")
	      2 -> push(range(base64 1 -2) '=')

  $encode: (three_octets)
    #  converts three octets to four base64 characters
    $bits
      |
	three_octets(1).to_integer << 16
	three_octets(2).to_integer << 8
	three_octets(3).to_integer
    $buf ""
    repeat 4
      :
	$value bits >> 18
	!bits (bits & 0x3ffff) << 6
	case value
	  0 .. 25:
	    push &buf 'A'+value
	    next
	  26 .. 51:
	    push &buf 'a'+(value-26)
	    next
	  52 .. 61:
	    push &buf '0'+(value-52)
	    next
	  62:
	    push &buf '+'
	    next
	  63:
	    push &buf '/'
	    next
      -> buf

$std_types::octet_string/from_base64:
  #
    converts the base64 string to an octet string

    If the base64 string is not valid or not a multiple of four characters
    long, then the special value <undefined> is returned.

    Topic: Strings

    See also: to_base64

    Example:

      println! from_base64("SGVsbG8sIHdvcmxkIQ==")

    Output:

      Hello, world!
  (
    str # the base64 string
  )
  $octets ""
  if
    (length_of(str) .mod. 4) != 0
    -> undefined
    :
      loop:
	if
	  str.is_empty
	  -> octets
	  :
	    $bits 0
	    from_to 1 4
	      : (i)
		$value decode(str(i))
		if
		  value.is_undefined
		  -> undefined
		  :
		    !bits (bits << 6) | value
		    next
	      :
		push &octets character(bits >> 16)
		push &octets character((bits >> 8) & 0xff)
		push &octets character(bits & 0xff)
		if
		  str(4) == '=':
		    if
		      str(3) == '='
		      -> range(octets 1 -3)
		      -> range(octets 1 -2)
		  :
		    range &str 5 -1
		    next

  $decode: (chr)
    # converts a base64 character to an integer
    case chr
      'A' .. 'Z' -> chr-'A'
      'a' .. 'z' -> chr-'a'+26
      '0' .. '9' -> chr-'0'+52
      '+' -> 62
      '/' -> 63
      '=' -> 0
      -> undefined

$std_types::octet_string/sha1:
  #
    calculates the sha1 hash of the octet string

    Topic: Strings

    Example:

      hexdump! sha1("Hello, world!")

    Output:

      00000000: 94 3a 70 2d 06 f3 45 99 ae e1 f8 da 8e f9 f7 29
      00000010: 60 31 d6 99
  (
    message # the octet string
  )
  # magic values

  $h0 0x67452301
  $h1 0xefcdab89
  $h2 0x98badcfe
  $h3 0x10325476
  $h4 0xc3d2e1f0

  $k0 0x5a827999
  $k1 0x6ed9eba1
  $k2 0x8f1bbcdc
  $k3 0xca62c1d6

  #
    pre-processing:

    * append the bit '1' to the message e.g. by adding 0x80 if message length is
      a multiple of 8 bits.

    * append 0 ≤ k < 512 bits '0', such that the resulting message length in
      bits is congruent to −64 ≡ 448 (mod 512)

    * append ml, the original message length in bits, as a 64-bit big-endian
      integer. Thus, the total length is a multiple of 512 bits.

  $len length_of(message)
  push &message '@0x80;'
  $pad_len 56-(len+1 .mod. 512)
  update_if pad_len < 0 &pad_len -> pad_len+64
  $pad_octets dup("@0;" pad_len)
  append &message pad_octets
  append &message big_endian_string_64(8*len)

  # process the message in successive 512-bit chunks:

  loop:
    if
      message.is_empty:
	string
	  big_endian_string_32(h0)
	  big_endian_string_32(h1)
	  big_endian_string_32(h2)
	  big_endian_string_32(h3)
	  big_endian_string_32(h4)
      :
	$w uint32_array(80)
	from_to 1 16
	  : (i)
	    !w(i)
	      |
		message(4*i-3).to_integer << 24
		message(4*i-2).to_integer << 16
		message(4*i-1).to_integer << 8
		message(4*i).to_integer
	    next
	  :
	    from_to 17 80
	      : (i)
		!w(i) w(i-3) ^ w(i-8) ^ w(i-14) ^ w(i-16) .rol32. 1
		next
	      main_loop

	$main_loop:
	  $a h0
	  $b h1
	  $c h2
	  $d h3
	  $e h4
	  from_to 1 80
	    : (i)
	      cond
		-> i <= 20: compute (b & c) | ((b ^ 0xffffffff) & d) k0
		-> i <= 40: compute (b ^ c ^ d) k1
		-> i <= 60: compute (b & c) | (b & d) | (c & d) k2
		-> true: compute (b ^ c ^ d) k3

	      $compute: (f k)
		$t ((a .rol32. 5) + f + e + k + w(i)) & 0xffffffff
		!e d
		!d c
		!c b .rol32. 30
		!b a
		!a t
		next
	    :
	      !h0 (h0+a) & 0xffffffff
	      !h1 (h1+b) & 0xffffffff
	      !h2 (h2+c) & 0xffffffff
	      !h3 (h3+d) & 0xffffffff
	      !h4 (h4+e) & 0xffffffff
	      range &message 65 -1
	      next

  $big_endian_string_64: (n)
    # converts a 64 bit integer to a big-endian octet string
    string
      character(n >> 56)
      character((n >> 48) & 0xff)
      character((n >> 40) & 0xff)
      character((n >> 32) & 0xff)
      character((n >> 24) & 0xff)
      character((n >> 16) & 0xff)
      character((n >> 8) & 0xff)
      character(n & 0xff)

  $big_endian_string_32: (n)
    # converts a 32 bit integer to a big-endian octet string
    string
      character(n >> 24)
      character((n >> 16) & 0xff)
      character((n >> 8) & 0xff)
      character(n & 0xff)

  $rol32: (n k) -> ((n << k) & 0xffffffff) | (n >> (32-k))

$std::parse_integer:
  #
    extracts an integer value from the start of the string

    Returns the unused part of the string as well as the extracted integer
    value.

    The function succeeds if the string starts with an integer literal in
    decimal, octal, hexadecimal or binary notation.

    If the function fails then the unaltered string and <undefined> are
    returned.

    Topic: Strings

    See also: string/parse_number, string/to_integer

    Example:

      $str "123abc"
      parse_integer &str $value
      println! "value: " value ", rest: " str

    Output:

      value: 123, rest: abc
  (
    self # the string to parse
  )
  $maybe_negated:
    if
      negate
      -> -value
      -> value

  $partial_match: (idx)
    if
      idx > 1
      -> range(self idx -1) maybe_negated()
      -> orig undefined

  $exhausted:
    if
      self.is_empty
      -> orig undefined
      -> "" maybe_negated()

  $orig self
  $negate self .has_prefix. '-'
  !self
    if
      negate
      -> range(self 2 -1)
      -> self
  $value 0
  cond
    -> self .has_prefix. "0b":
      range &self 3 -1
      for_each self
	: (idx chr)
	  case
	    chr
	    '0'..'1':
	      !value (value << 1)+(chr-'0')
	      next
	    :
	      partial_match idx
	exhausted
    -> self .has_prefix. "0o":
      range &self 3 -1
      for_each self
	: (idx chr)
	  case chr
	    '0'..'7':
	      !value (value << 3)+(chr-'0')
	      next
	    :
	      partial_match idx
	exhausted
    -> self .has_prefix. "0x":
      range &self 3 -1
      for_each self
	: (idx chr)
	  case chr
	    '0'..'9':
	      !value (value << 4)+(chr-'0')
	      next
	    'a'..'f':
	      !value (value << 4)+(chr-'a')+10
	      next
	    'A'..'F':
	      !value (value << 4)+(chr-'A')+10
	      next
	    :
	      partial_match idx
	exhausted
    -> true:
      for_each self
	: (idx chr)
	  case chr
	    '0'..'9':
	      !value 10*value+(chr-'0')
	      next
	    :
	      partial_match idx
	exhausted

$std::parse_number:
  #
    extracts a numeric value from the start of the string

    Returns the unused part of the string as well as the extracted numeric
    value (real or integer).

    The function succeeds if the string starts with a numeric literal in
    decimal, octal, hexadecimal or binary notation (integers only).

    If the function fails then the unaltered string and <undefined> are
    returned.

    Topic: Strings

    See also: string/parse_integer

    Example:

      $str "123.456abc"
      parse_number &str $value
      println! "value: " value ", rest: " str

    Output:

      value: 123.456, rest: abc
  (
    self # the string to parse
  )
  $i 1
  $n length_of(self)
  if
    i > n
    -> self undefined
    :
      $sign_chr self(1)
      update_if sign_chr == '-' || sign_chr == '+' &i -> i+1
      $sign
	if
	  sign_chr == '-'
	  -> -1
	  -> 1
      if
	self(i) == '0' && i+1 < n:
	  case self(i+1)
	    'b': parse_binary self i+2 sign
	    'o': parse_octal self i+2 sign
	    'x': parse_hex self i+2 sign
	    parse
	parse

  $parse:
    skip_one_ore_more_digits:
      if
	i > n return_integer
	:
	  case self(i)
	    '.':
	      !i i+1
	      skip_one_ore_more_digits:
		if
		  i > n
		  return_real
		  :
		    case self(i)
		      'e', 'E' handle_exponent
		      return_real
	    'e', 'E' handle_exponent
	    return_integer

    $skip_one_ore_more_digits: (cont)
      if
	i > n
	-> self undefined
	:
	  $digit self(i)
	  if
	    digit < '0' || digit > '9'
	    -> self undefined
	    :
	      loop:
		!i i+1
		if
		  i > n
		  cont
		  :
		    $next_digit self(i)
		    if
		      next_digit >= '0' && next_digit <= '9'
		      next
		      cont

    $handle_exponent:
      !i i+1
      if
	i > n
	-> self undefined
	:
	  $exp_sign_chr self(i)
	  update_if exp_sign_chr == '-' || exp_sign_chr == '+' &i -> i+1
	  skip_one_ore_more_digits return_real

    $return_integer -> range(self i -1) integer(range(self 1 i-1))

    $return_real -> range(self i -1) real(range(self 1 i-1))

$parse_binary: (str i sign)
  $n length_of(str)
  if
    i > n -> str undefined
    :
      $digit str(i)
      if
	digit < '0' || digit > '1'
	-> str undefined
	:
	  $value digit-'0'
	  loop:
	    !i i+1
	    if
	      i > n
	      -> "" value*sign
	      :
		$next_digit str(i)
		if
		  next_digit >= '0' && next_digit <= '1':
		    !value (value << 1)+(next_digit-'0')
		    next
		  -> range(str i -1) value*sign

$parse_octal: (str i sign)
  $n length_of(str)
  if
    i > n -> str undefined
    :
      $digit str(i)
      if
	digit < '0' || digit > '7'
	-> str undefined
	:
	  $value digit-'0'
	  loop:
	    !i i+1
	    if
	      i > n
	      -> "" value*sign
	      :
		$next_digit str(i)
		if
		  next_digit >= '0' && next_digit <= '7':
		    !value (value << 3)+(next_digit-'0')
		    next
		  -> range(str i -1) value*sign

$std::parse_hex:
  #
    extracts a hexadecimal value from the start of the string

    Returns the unused part of the string as well as the extracted numeric
    value.

    The function succeeds if the string starts with a hexadecimal literal.

    If the function fails then the unaltered string and <undefined> are
    returned.

    Optionally a start index (*i*) can be specified.

    Topic: Strings

    See also: string/parse_integer

    Example:

      $str "123abc---"
      parse_hex &str $value
      println! "value: " value ", rest: " str

    Output:

      value: 1194684, rest: ---
  (
    str # the string to parse
    i = 1 # the start index
    sign = 1
  )
  $n length_of(str)
  if
    i > n -> str undefined
    :
      $digit str(i)
      cond
	-> digit >= '0' && digit <= '9':
	  handle_more_digits digit-'0'
	-> digit >= 'a' && digit <= 'f':
	  handle_more_digits (digit-'a')+10
	-> digit >= 'A' && digit <= 'F':
	  handle_more_digits (digit-'A')+10
	-> true -> str undefined

      $handle_more_digits: (value)
	loop:
	  !i i+1
	  if
	    i > n
	    -> "" value*sign
	    :
	      $next_digit str(i)
	      cond
		-> next_digit >= '0' && next_digit <= '9':
		  !value (value << 4)+(next_digit-'0')
		  next
		-> next_digit >= 'a' && next_digit <= 'f':
		  !value (value << 4)+(next_digit-'a')+10
		  next
		-> next_digit >= 'A' && next_digit <= 'F':
		  !value (value << 4)+(next_digit-'A')+10
		  next
		-> true -> range(str i -1) value*sign

$std_types::string/to_integer:
  #
    converts the whole string into an integer value

    If the complete string can be converted into an integer then the
    resulting integer is returned.

    If the conversion fails or does not consume the complete string then
    <undefined> is returned.

    Topic: Strings

    See also: string/parse_integer

    Example:

      $str "123"
      $value str.to_integer
      println! "value: " value

    Output:

      value: 123

    Example:

      $str "123, 456"
      $value str.to_integer
      dump! `value

    Output:

      value: <undefined>
  (
    self # the string to convert
  )
  parse_integer &self $value
  if
    self == ""
    -> value
    -> undefined

$std_types::string/to_number:
  #
    converts the whole string into a number value

    If the complete string can be converted into a number then the
    resulting number (integer or real) is returned.

    If the conversion fails or does not consume the complete string then
    <undefined> is returned.

    Topic: Strings

    See also: string/to_integer, strint/parse_number

    Example:

      $str "123.456"
      $value str.to_number
      println! "value: " value

    Output:

      value: 123.456

    Example:

      $str "123.456, 789"
      $value str.to_number
      dump! `value

    Output:

      value: <undefined>
  (
    self # the string to convert
  )
  parse_number &self $value
  if
    self == ""
    -> value
    -> undefined

$std::map_characters:
  #
    applies a function to each character of the string

    The function returns a string that is the result of applying the
    specified function to each character of the string.

    Topic: Strings

    See also: to_upper_case, to_lower_case, to_title_case, map, map_reduce

    Example:

      $str "abc"
      $upper_case_str map_characters(str to_upper_case)
      println! upper_case_str

    Output:

      ABC
  (
    self # the string which characters will be mapped
    function # the function to apply to each character of the string
  )
  $map
    if
      parameter_count_of(function) == 2
      ->
	: (s e)
	  if
	    s < e:
	      $m (s+e) >> 1
	      append
		map(s m)
		map(m+1 e)
	    :
	      if
		s > e
		-> ""
		-> function(s self(s)).to_string
      ->
	: (s e)
	  if
	    s < e:
	      $m (s+e) >> 1
	      append
		map(s m)
		map(m+1 e)
	    :
	      if
		s > e
		-> ""
		-> function(self(s)).to_string

  map 1 length_of(self)

$std_types::string/to_upper_case:
  #
    returns the string converted to UPPER CASE

    Topic: Strings

    See also: to_lower_case, to_title_case, map_characters

    Example:

      $str "abc"
      $upper_case_str str.to_upper_case
      println! upper_case_str

    Output:

      ABC
  (
    self # the string to convert
  )
  map_characters self to_upper_case

$std_types::string/to_lower_case:
  #
    returns the string converted to lower case

    Topic: Strings

    See also: to_upper_case, to_title_case, map_characters

    Example:

      $str "ABC"
      $lower_case_str str.to_lower_case
      println! lower_case_str

    Output:

      abc
  (
    self # the string to convert
  )
  map_characters self to_lower_case

$std_types::string/to_title_case:
  #
    returns the string converted to "Title Case"

    Topic: Strings

    See also: to_sentence_case, to_upper_case, to_lower_case, map_characters

    Example:

      $str "this is a test"
      $title_case_str str.to_title_case
      println! title_case_str

    Output:

      This Is A Test
  (
    self # the string to convert
  )
  map_characters self: (idx chr)
    if
      idx > 1 && self(idx-1).is_a_letter_character
      -> chr.to_lower_case
      -> chr.to_title_case

$std_types::string/to_sentence_case:
  #
    converts the spefied string to "Sentence case"

    Topic: Strings

    See also: to_title_case

    Example:

      $str "this is a test."
      $sentence_case_str str.to_sentence_case
      println! sentence_case_str

    Output:

      This is s test.
  (
    self
  )
  map_characters self: (idx chr)
    if
      idx == 1 && self(idx).is_a_letter_character
      -> chr.to_title_case
      -> chr.to_lower_case

$std_types::string/to_wide: (str)
  map_characters str to_wide

$std::delete_all:
  #
    deletes all occurences of the specfified expressions

    This function deletes all occurences of the specified expressions from
    the string.

    Topic: Strings

    See also: replace_all

    Example:

      $str "abcabc"
      $str_without_b delete_all(str 'b')
      println! str_without_b

    Output:

      acac
  (
    text # the string to process
    expressions* # the expressions to delete
  )
  $delete_all: (txt)
    if
      txt.is_empty
      -> new_text
      :
	for_each expressions
	  : (expression)
	    $len match(expression txt)
	    if_not len.is_defined next:
	      delete_all range(txt len+1 -1)
	  :
	    push &new_text txt(1)
	    delete_all range(txt 2 -1)

  $new_text ""
  delete_all text

$std::replace_all:
  #
    replaces all occurences of the specified expressions

    This function replaces all occurences of the specified expressions with
    their corresponding replacement texts.

    Topic: Strings

    See also: replace_first, delete_all

    Example:

      $str "abcabc"
      $str_with_x replace_all(str 'b' = 'x')
      println! str_with_x

    Output:

      axcaxc
  (
    text # the string to process
    args* # the expressions and their replacements
  )
  $replace_all: (txt)
    if
      txt.is_empty
      -> new_text
      :
	for_each args
	  : (arg)
	    arg $expression $replacement
	    $len match(expression txt)
	    if_not len.is_defined next:
	      if
		replacement.is_a_string:
		  append &new_text replacement
		  replace_all range(txt len+1 -1)
		:
		  append &new_text replacement(range(txt 1 len))
		  replace_all range(txt len+1 -1)
	  :
	    push &new_text txt(1)
	    replace_all range(txt 2 -1)

  $new_text ""
  replace_all text

$std::replace_first:
  #
    replaces the first occurence of the specified expressions

    This function replaces the first occurence of the specified expressions
    with their corresponding replacement texts.

    Topic: Strings

    See also: replace_all

    Example:

      $str "abcabc"
      $str_with_x replace_first(str 'b' = 'x')
      println! str_with_x

    Output:

      axcabc
  (
    text # the string to process
    args* # the expressions and their replacements
  )
  $replace_first: (txt)
    if
      txt.is_empty
      -> new_text
      :
	for_each args
	  : (arg)
	    arg $expression $replacement
	    $len match(expression txt)
	    if_not
	      len.is_defined
	      next
	      :
		update_if_not replacement.is_a_string &replacement
		  -> replacement(range(txt 1 len))
		-> append(new_text replacement range(txt len+1 -1))
	  :
	    push &new_text txt(1)
	    replace_first range(txt 2 -1)

  $new_text ""
  replace_first text

$std::count_occurrences:
  #
    returns the number of occurences of the specified expression

    This function returns the number of occurences of the specified
    expression in the string.

    Topic: Strings

    Example:

      $str "abcabc"
      $occurrences count_occurrences(str 'b')
      println! occurrences

    Output:

      2
  (
    text # the string to process
    expr # the expression to count
  )
  $search_next: (txt count)
    if
      txt == ""
      -> count
      :
	$n match(expr txt)
	if
	  n.is_defined:
	    search_next range(txt n+1 -1) count+1
	  :
	    search_next range(txt 2 -1) count

  search_next text 0

$FORK_TEXT_THRESHOLD 300

# parallel version
  $std::split_into_lines: (text)
    $n length_of(text)
    split 1 n

    $split: (s e)
      if
	e+1-s > FORK_TEXT_THRESHOLD: # recurse to exploit parallel execution
	  $m (s+e) .div. 2
	  append split(s m) split(m+1 e)
	:
	  $lines empty_list
	  $ls
	    if
	      s == 1 || text(s-1) == '@nl;'
	      -> s # the current block starts at a line start
	      -> undefined # just skip the characters until the next line start
	  from_to s e
	    : (i)
	      if_not text(i) == '@nl;' next:
		if
		  ls.is_defined:
		    push &lines range(text ls i)
		    !ls i+1
		    next
		  :
		    !ls i+1
		    next
	    :
	      if
		ls.is_defined && ls <= e:
		  loop: # the last line extends into the next block
		    !e e+1
		    if
		      text(e) == '@nl;'
		      -> push(lines range(text ls e))
		      next
		-> lines

#serial version
$std::split_into_lines: (text)
  $lines empty_list
  $i 1
  $n length_of(text)
  $s i
  loop:
    if
      i > n
      ->
	if
	  s <= n
	  -> push(lines range(text s n))
	  -> lines
      :
	if
	  text(i) == '@nl;':
	    push &lines range(text s i)
	    !i i+1
	    !s i
	    next
	  :
	    !i i+1
	    next

$std::split_into_indented_lines:
  #
    splits a text into indented lines

    The result is a list of tuples with two fields:

    * indent

    * text_line

    The *text_line* still contains the trailing line feed but leading whitespace
    is removed.

    If a line does not contain any text (whitespace does not count as text) then
    the whole tuple is replaced with the special value <undefined>.

    Topic: Strings

    See also: split_into_lines, split_into_groups

    Example:

      $text "
	a
	  1
	  2
	  3
	b
	  4
	  5
      $lines split_into_indented_lines(text)
      dump! 3 lines

    Output:

      lines:
	list
	  tuple
	    0
	    "a@0xa;"
	  tuple
	    2
	    "1@0xa;"
	  tuple
	    2
	    "2@0xa;"
	  tuple
	    2
	    "3@0xa;"
	  tuple
	    0
	    "b@0xa;"
	  tuple
	    2
	    "4@0xa;"
	  tuple
	    2
	    "5@0xa;"
  (
    text # the string to process
  )
  $n length_of(text)
  split 1 n

  $split: (s e)
    if
      e+1-s > FORK_TEXT_THRESHOLD: # recurse to exploit parallel execution
	$m (s+e) .div. 2
	append split(s m) split(m+1 e)
      :
	$lines empty_list
	$ls
	  if
	    s == 1 || text(s-1) == '@nl;'
	    -> s # the current block starts at a line start
	    -> undefined # just skip the characters until the next line start
	from_to s e
	  : (i)
	    if_not text(i) == '@nl;' next:
	      if
		ls.is_defined:
		  push &lines create_line(ls i)
		  !ls i+1
		  next
		:
		  !ls i+1
		  next
	  :
	    if
	      ls.is_defined && ls <= e:
		loop: # the last line extends into the next block
		  !e e+1
		  if
		    text(e) == '@nl;'
		    -> push(lines create_line(ls e))
		    next
	      -> lines

  $create_line: (s e)
    $indent 0
    loop:
      if
	text(s) == '@ht;':
	  !indent indent+8
	  !s s+1
	  next
	:
	  if
	    text(s) == ' ':
	      !indent indent+1
	      !s s+1
	      next
	    :
	      $line_text range(text s e)
	      if
		line_text == "@nl;"
		-> undefined
		-> typed_tuple(std_types::line indent line_text)

$FORK_LINES_THRESHOLD 20
$VERY_LARGE_INDENT 9999

$std_types::line tuple(undefined undefined)
$std_types::line.subgroups_of undefined

$line_indent_of: (line)
  if
    line.is_defined
    -> first(line)
    -> undefined

$std::split_into_groups:
  #
    splits already indented lines into groups

    Returns a list of indented lines where each line has a *subgroups*-attribute
    which is itself a list of "indented lines".

    The division into subgroups is only done on the top-level! The subgroups
    do not contain any further subgroups.

    Topic: Strings

    See also: split_into_indented_lines

    Example:

      $text "
	a
	  1
	  2
	  3
	b
	  4
	  5
      $lines split_into_indented_lines(text)
      $groups split_into_groups(lines)
      dump! 3 `groups
      dump! 3 `subgroups_of(groups(1))

    Output:

      groups:
	list
	  tuple
	    0
	    "a@0xa;"
	  tuple
	    0
	    "b@0xa;"
      subgroups_of(groups(1)):
	list
	  tuple
	    2
	    "1@0xa;"
	  tuple
	    2
	    "2@0xa;"
	  tuple
	    2
	    "3@0xa;"
  (
    lines # the indented lines
    keep_empty_lines = false
  )
  $n length_of(lines)
  $fv 1 # first valid line
  loop:
    if
      fv <= n:
	$indent line_indent_of(lines(fv))
	if
	  indent.is_defined:
	    if
	      keep_empty_lines && fv > 1
	      -> append(dup(list(undefined) fv-1) split(fv n indent))
	      -> split(fv n indent)
	  :
	    !fv fv+1
	    next
      -> empty_list

  $split: (s e indent)
    if
      e+1-s > FORK_LINES_THRESHOLD: # recurse to exploit parallel execution
	$m (s+e) .div. 2
	append split(s m indent) split(m+1 e indent)
      :
	$groups empty_list
	$minimum_indent VERY_LARGE_INDENT
	$group_start undefined
	$group_end undefined
	from_to s e
	  : (i)
	    $current_indent line_indent_of(lines(i))
	    if
	      current_indent == indent:
		if
		  group_start.is_defined && group_start < i:
		    add_groups !groups group_end i
		    start_new_fragment_and_next i
		  :
		    start_new_fragment_and_next i
	      :
		update_if current_indent.is_defined &group_end -> i
		reduce_minimum_indent_and_next current_indent
	  :
	    if
	      group_start.is_defined:
		loop: # the last group extends into the next block
		  !e e+1
		  if
		    e > n
		    -> add_groups(group_end e)
		    :
		      $current_indent line_indent_of(lines(e))
		      if
			current_indent.is_defined && current_indent <= indent
			-> add_groups(group_end e)
			:
			  update_if current_indent.is_defined &group_end -> e
			  reduce_minimum_indent_and_next current_indent
	      -> groups

	$add_groups: (last curr_idx)
	  if
	    keep_empty_lines && curr_idx > last+1:
	      add !groups
	      append groups dup(list(undefined) curr_idx-last-1)
	    add

	  $add:
	    if
	      group_start == last
	      -> push(groups lines(group_start))
	      :
		if
		  minimum_indent == VERY_LARGE_INDENT
		  -> append(groups range(lines group_start last))
		  :
		    $head lines(group_start)
		    $subgroups range(lines group_start+1 last)
		    push groups head(.subgroups_of subgroups)

	$reduce_minimum_indent_and_next: (current_indent)
	  if
	    current_indent.is_defined && current_indent < minimum_indent:
	      !minimum_indent current_indent
	      next
	    next

	$start_new_fragment_and_next: (i)
	  !minimum_indent VERY_LARGE_INDENT
	  !group_start i
	  !group_end i
	  next

$std::wrap_words:
  #
    wraps a string consisting of words onto multiple lines

    The string is split into multiple lines according to the specified line
    width.

    The result is a list of lines.

    Topic: Strings

    See also: indented

    Example:

      $str "This is a very long string that should be wrapped onto multiple lines"
      $lines wrap_words(str 30)
      dump! 2 `lines

    Output:

      lines:
	list
	  "This is a very long string"
	  "that should be wrapped"
	  "onto multiple lines"
  (
    text # the string to wrap
    width # the desired line width
    _do_use_character_width = false
  )
  $lines empty_list
  $n length_of(text)
  $s 1 # start of line
  $b undefined # possible break position
  $i 0
  loop:
    inc &i
    if
      i > n:
	if
	  s > n
	  -> lines
	  -> push(lines range(text s n))
      :
	$chr text(i)
	case chr
	  '@nl;':
	    push &lines range(text s i-1)
	    !s i+1
	    !b undefined
	    next
	  :
	    if
	      chr == ' ':
		if
		  i-s == width: # break
		    push &lines range(text s i-1)
		    !s i+1
		    !b undefined
		    next
		  :
		    !b i
		    next
	      :
		if
		  i-s < width
		  next
		  :
		    if
		      b.is_defined: # wrap
			push &lines range(text s b-1)
			!s b+1
			!b undefined
			next
		      : # hard break
			push &lines range(text s i-1)
			!s i
			next

$std_types::string/serialize:
  #
    returns a string representation of the string

    Topic: Strings

    See also: deserialize

    Example:

      $str "Hello World"
      $serialized_str serialize(str)
      dump! `serialized_str

    Output:

      serialized_str: "@quot;Hello World@quot;@0xa;"
  (
    self
    indent = undefined
  )
  $str "@quot;"
  $s 1
  for_each self
    : (idx chr)
      if
	chr < '@0x20;' || chr > '@0x7e;' || chr == '"' || chr == '@@':
	  append &str range(self s idx-1)
	  append &str "@@@(chr.to_integer);"
	  !s idx+1
	  next
	next
    :
      append &str range(self s -1)
      append &str "@quot;@nl;"
      if
	indent.is_defined
	-> append(tabs_and_spaces(indent) str)
	-> str

$std_types::octet_string/to_uint8_array:
  #
    converts a string to an array of unsigned 8-bit integers

    Topic: Strings

    See also: to_string

    Example:

      $str "Hello World"
      $arr to_uint8_array(str)
      dump! 2 `arr
  (
    self
  )
  $arr uint8_array(length_of(self))
  for_each self
    : (idx chr)
      !arr(idx) chr.to_integer
      next
    -> arr

$std::indented:
  #
    increases the indent of the specified (multi-line) string

    The text is indented via tabs and spaces. Existing indents are treated
    correctly.

    The line feed character after the last line is optional.

    Topic: Strings

    See also: wrap_words

    Example:

      $str "
	a
	  b
	    c
	d
      $indented_str indented(5 str)
      print! indented_str

    Output:

	   a
	     b
	       c
	   d
  (
    indent
    text
  )
  $indented_text ""
  $new_indent undefined
  $i 1
  $n length_of(text)
  loop:
    !new_indent indent
    skip_indent !i !new_indent
    if
      i <= n:
	if
	  text(i) == '@nl;':
	    push &indented_text '@nl;'
	    !i i+1
	    next
	  :
	    append &indented_text tabs_and_spaces(new_indent)
	    $s i
	    loop
	      :
		if
		  text(i) == '@nl;':
		    append &indented_text range(text s i)
		    !i i+1
		    break
		  :
		    if
		      i < n:
			!i i+1
			next
		      :
			append indented_text range(text s -1)
	      next

      -> indented_text

  $skip_indent:
    if
      i <= n:
	if
	  text(i) == '@ht;':
	    !i i+1
	    !new_indent new_indent+8
	    skip_indent
	  skip_spaces
      -> i new_indent

  $skip_spaces:
    if
      i <= n && text(i) == ' ':
	!i i+1
	!new_indent new_indent+1
	skip_spaces
      -> i new_indent

$LEFT .
$RIGHT .
$CENTER .
$ZEROS .

$std::format:
  #
    formats its arguments using the specified template string

    The *template* contains a format specifier for each argument.

    Each format specifier start with a '%'-character and is folled by a length
    and (optionally) by a '.'-character and a second length specifying the
    number of decimal places.

    E.g. "%3.1" is a format specifier to print a real number with 3 digits,
    followed by a decimal point and 1 decimal place.

    If the size of the number exceeds the specified number of digits then the
    number is displayed anyways (ignoring the format specification).

    If the '%'-character is immediately followed by an 'l' or an 'r' it ist
    left- respectively righ-justified. The default is right justification.

    To print a character that might me misinterpreted as a part of a format
    specifier ('%', '.' or a digit) precede it with a backslash character ('\').
    This is also the way to print a backslash itself.

    The function returns the constructed string or <undefined> if the template
    string contains invalid format specifiers.

    Topic: Strings
  (
    template # the template string
    arguments* # the embedded arguments
  )
  $output ""
  $arg_idx 1
  $i 1
  $n length_of(template)
  loop:
    if
      i > n
      -> output
      :
	$chr template(i)
	!i i+1
	case chr
	  '%':
	    if
	      i > n
	      -> undefined
	      :
		case template(i) $alignment !i
		  '0' -> ZEROS i+1
		  'l' -> LEFT i+1
		  'r' -> RIGHT i+1
		  'c' -> CENTER i+1
		  -> RIGHT i
		$len_chr template(i)
		if
		  len_chr < '0' || len_chr > '9'
		  -> undefined
		  :
		    $width len_chr-'0'
		    loop
		      :
			!i i+1
			if
			  i > n
			  break
			  :
			    $fmt_chr template(i)
			    if
			      fmt_chr < '0' || fmt_chr > '9'
			      break
			      :
				!width 10*width+(fmt_chr-'0')
				next
		      :
			if
			  i > n:
			    add_argument alignment width
			  :
			    if
			      template(i) == '.':
				!i i+1
				if
				  i > n
				  -> undefined
				  :
				    $dw_chr template(i)
				    if
				      dw_chr < '0' || dw_chr > '9'
				      -> undefined
				      :
					$dw dw_chr-'0'
					loop
					  :
					    !i i+1
					    if
					      i > n
					      break
					      :
						$fmt_chr template(i)
						if
						  fmt_chr < '0' || fmt_chr > '9'
						  break
						  :
						    !dw 10*dw+(fmt_chr-'0')
						    next
					  :
					    add_argument alignment width dw
			      :
				add_argument alignment width
	  '\':
	    if
	      i > n
	      -> undefined
	      :
		push &output template(i)
		!i i+1
		next
	  :
	    push &output chr
	    next

  #$add_argument:
    (
      alignment
      width
      decimal_width = undefined
    )
    $argument arguments(arg_idx)
    !arg_idx arg_idx+1
    append &output
      if
	decimal_width.is_defined:
	  real_to_string &argument
	  $value argument .truncate_from. '.'
	  $decimals argument .behind. '.'
	  if
	    decimal_width > 0:
	      append
		pad_left(value width)
		"."
		truncate(pad_right(decimals decimal_width "0") decimal_width)
	    -> pad_left(value width)
	:
	  case alignment
	    RIGHT -> pad_left(argument width)
	    ZEROS -> pad_left(argument width "0")
	    -> pad_right(argument width)
    next

  $add_argument:
    (
      alignment
      width
      decimal_width = undefined
    )
    $argument arguments(arg_idx)
    !arg_idx arg_idx+1
    if
      decimal_width.is_defined:
	real_to_string &argument
	$value argument .truncate_from. '.'
	if
	  decimal_width > 0:
	    $decimals argument .behind. '.'
	    pad_right &decimals decimal_width "0"
	    range &decimals 1 decimal_width
	    if
	      alignment == ZEROS:
		append &output pad_left(value width "0") "." decimals
		next
	      :
		append &output pad_left(value width) "." decimals
		next
	  :
	    append &output
	      case
		alignment
		LEFT -> pad_right(value width)
		ZEROS -> pad_left(value width "0")
		-> pad_left(argument value)
	    next
      :
	append &output
	  case
	    alignment
	    LEFT -> pad_right(argument width)
	    ZEROS -> pad_left(argument width "0")
	    -> pad_left(argument width)
	next

$real_to_string: (num)
  $str num.to_string
  $n length_of(str)
  $i n
  loop:
    if
      i == 0
      -> str
      :
	if
	  str(i) == 'e'
	  handle_exponent
	  :
	    !i i-1
	    next

  $handle_exponent:
    if
      i >= n || str(2) != '.'
      -> undefined
      :
	$exp range(str i+2 n).to_integer
	$man put(range(str 3 i-1) str(1))
	if
	  exp.is_undefined
	  -> undefined
	  :
	    $zeros dup("0" exp-1)
	    case str(i+1)
	      '+':
		-> append(man zeros)
	      '-':
		-> append("0." append(zeros man))
	      -> undefined


$std_types::string.empty_collection_of ""
