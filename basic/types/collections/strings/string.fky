#
  Copyright (C) 2023 by
  Dipl.-Ing. Michael Niederle

  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU Library General Public License, version 2, or
  (at your option) under the terms of the GNU Lesser General Public License,
  version 3.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  GNU Lesser (Library) General Public License for more details.

  For details of the GNU General Public License see the accompanying
  files LGPLv2.txt and LGLPv3.txt or
  http://www.gnu.org/licenses/lgpl-2.0.html
  http://www.gnu.org/licenses/lgpl-3.0.html
  or write to the
  Free Software Foundation, Inc.,
  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

$std::to_sentence_case ()

$std::is_a_string ()
  #
    obvious

    Topic: Strings

$std_types::object.is_a_string false
  #
    obvious

    Topic: Objects

$std_types::string.is_a_string true
  #
    obvious

    Topic: Strings

$std::is_an_octet_string ()
  #
    obvious

    Topic: Strings

$std_types::object.is_an_octet_string false
  #
    obvious

    Topic: Objects

$std_types::octet_string.is_an_octet_string true
  #
    obvious

    Topic: Strings

$std_types::string/to_string:
  #
    returns its argument unaltered

    Topic: Strings

    See also: string
  (
    self
  )
  -> self

$std::create_string:
  #
    returns the concatenation of all of the list's items converted to strings

    Topic: Strings

    See also: string

    Example:

    $arguments list(7 " x " 7 " = " 7*7 '@nl;')
    print! create_string(arguments)

    Output:

    7 x 7 = 49
  (
    arguments # a list of printable items
  )
  if
    arguments.is_empty
    -> ""
    : map_reduce arguments to_string append

$std::string:
  #
    returns the concatenation of all its arguments converted to strings

    Topic: Strings

    See also: create_string, to_string

    Example:

    $str string(7 " x " 7 " = " 7*7 '@nl;')
  (
    args*
  )
  create_string args

$std_types::string/put:
  #
    adds a character at the front of the string

    Topic: Strings

    See also: std_types::string/push, std_types::string/append

    Example:

    $str " big surprise"
    put &str 'a'
  (
    self # the string
    chr # the character to add
  )
  -> append(chr.to_string self)

$std_types::string/dup:
  #
    creates a string containing n copies of the specified string

    The function aims to duplicate the specified string in a smart way.

    Topic: Strings

    See also: spaces, tabs_and_spaces

    Example:

    $str "abc"
    $str_x_3 dup(str 3)
    println! str_x_3

    Output:

    abcabcabc
  (
    self # the string to duplicate
    n # the duplication count
  )
  case n
    0 -> ""
    1 -> self
    :
      $h n >> 1 # fails if <n> is not a positive integer
      $str dup(self h)
      if
	2*h == n:
	  string str str
	:
	  string str str self

$std::pad_left:
  #
    extends a string to the specified width

    This function creates a string representation of *expr* which is at least
    *n* characters long. If it would be shorter than it is padded to the left
    with the string pattern stored in *pad*.

    The default value for *pad* is a single space.

    Topic: Strings

    See also: pad_right

    Example:

    $str "123"
    $padded_str pad_left(str 5 "0")
    println! padded_str

    Output:

    00123
  (
    expr # the expression that is converted into a string
    n # the length of the resulting string
    pad = " " # the pattern used to fill up the string
  )
  $text expr.to_string
  $len length_of(text)
  if
    len < n:
      $pad_len length_of(pad)
      string range(dup(pad (n-len)+(pad_len-1) .div. pad_len) 1 n-len) text
    -> text

$std::pad_right:
  #
    extends a string to the specified width

    This function creates a string representation of *expr* which is at least
    *n* characters long. If it would be shorter than it is padded to the right
    with the string pattern stored in *pad*.

    The default value for *pad* is a single space.

    Topic: Strings

    See also: pad_left

    Example:

    $str "computer"
    $padded_str pad_right(str 10 '_')
    println! padded_str

    Output:

    computer__
  (
    expr # the expression that is converted into a string
    n # the length of the resulting string
    pad = " " # the pattern used to fill up the string
  )
  $text expr.to_string
  $len length_of(text)
  if
    len < n:
      $pad_len length_of(pad)
      string text range(dup(pad (n-len)+(pad_len-1) .div. pad_len) 1 n-len)
    -> text

$eighty_spaces "
  @;                                        @
  @;                                        @

$std::spaces:
  #
    returns the specified number of spaces

    Topic: Strings

    See also: tabs_and_spaces
  (
    n # the desired number of spaces
  )
  if
    n <= 80
    -> range(eighty_spaces 1 n)
    -> dup(" " n)

$nine_tabs_and_seven_spaces "@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;       "

$std::tabs_and_spaces:
  #
    returns a sequence of tabulator- and space-characters

    Topic: Strings

    See also: spaces
  (
    n # the desired display width
  )
  if
    n < 80
    -> range(nine_tabs_and_seven_spaces 10-(n >> 3) 9+(n & 7))
    -> string(dup("@ht;" n >> 3) spaces(n & 7))

$tabs "@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;@ht;"

$std::with_tabs:
  #
    replaces leading spaces with tab-characters

    Replaces sequences of 8 or more leading spaces with the apprpriate number
    of tabulator-characters and the remaining spaces.

    Topic: Strings

    See also: tabs_and_spaces
  (
    text # the text to be processed
  )
  $s 1
  $n length_of(text)
  $i 1
  $output ""
  $count 0
  loop:
    if
      i <= n:
	if
	  text(i) == ' ':
	    !i i+1
	    !count count+1
	    next
	  :
	    if
	      count >= 8:
		$tab_count count >> 3
		if
		  tab_count >= 1:
		    append &output range(text s i-(count+1))
		    append &output
		      if
			tab_count < 10
			-> range(tabs 1 tab_count)
			-> dup("@ht;" tab_count)
		    !s (i-count)+(tab_count << 3)
		    skip_line
		  skip_line
	      skip_line
      :
	if
	  s == 1
	  -> text
	  -> append(output range(text s -1))

  $skip_line:
    loop
      :
	if
	  i <= n && text(i) != '@nl;':
	    !i i+1
	    next
	  break
      :
	!i i+1
	!count 0
	next


$std_types::string/match:
  #
    matches the start of the stream with the string

    Attempts to match the start of the stream with the specified string.
    If the match is successful the stream the length of the string is returned.
    Otherwise <undefined> is returned.

    Topic: Strings

    See also: std_types::string/search
  (
    self # the string to match
    stream # the stream to match against
  )
  $len length_of(self)
  if
    length_of(stream) >= len
    :
      if
	range(stream 1 len) == self
	-> len
	-> undefined
    -> undefined

$std_types::string/search:
  #
    searches for the start of the string within the stream

    Attempts to find the start of the string within the stream. If the match
    is successful the found position (one based) and the length of the string
    is returned. Otherwise the returned values for the position and the length
    are <undefined>.

    If *nth* is specified then the nth occurence of the string is looked for.
    If there are not at least *n* matches for *expr* within *str* then the
    returned values for the position and the length are <undefined>.

    Topic: Strings

    See also: std_types::string/match
  (
    self
    stream
    nth = 1 # search for the nth occurrence of *self* instead for the first one
  )
  $i undefined
  $length length_of(self)
  $offset length-1
  $n length_of(stream)-offset
  if
    nth < 0:
      !i n
      search_backwards
    :
      !i 1
      search_forwards

  $search_forwards:
    if
      i <= n
      :
	if
	  range(stream i i+offset) == self:
	    if
	      nth > 1:
		dec &nth
		plus &i length
		search_forwards
	      -> i length
	  :
	    inc &i
	    search_forwards
      -> undefined undefined

  $search_backwards:
    if
      i >= 1
      :
	if
	  range(stream i i+offset) == self:
	    if
	      nth < -1:
		inc &nth
		minus &i length
		search_backwards
	      -> i length
	  :
	    dec &i
	    search_backwards
      -> undefined undefined

$std_types::string/before:
  #
    returns the substring before the specified expression

    If the specified expression is found within the string the substring
    before the expression is returned. Otherwise the empty string is returned.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_from>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_from, string/behind, string/between, string/until

    Example:

    $identifier "std::before"
    $namespace identifier .before. "::"
    println! namespace

    Output:

    std

    Example:

    $identifier "std::before"
    $first_part identifier .before. '.'
    println! '[' first_part ']'

    Output:

    []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos-1)
    -> ""


$std_types::string/truncate_from:
  #
    returns the substring before the specified expression

    If the specified expression is found within the string the substring
    before the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/before>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/before, string/behind, string/between, string/until

    Example:

    $identifier "std::truncate_from"
    $namespace identifier .truncate_from. "::"
    println! namespace

    Output:

    std

    Example:

    $identifier "std::truncate_from"
    $first_part identifier .truncate_from. '.'
    println! '[' first_part ']'

    Output:

    [std::truncate_from]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos-1)
    -> str

$std_types::string/behind:
  #
    returns the substring after the specified expression

    If the specified expression is found within the string the substring
    after the expression is returned. Otherwise the empty string is returned.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_until>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_until, string/before, string/between, string/until

    Example:

    $identifier "std::behind"
    $name identifier .behind. "::"
    println! name

    Output:

    behind

    Example:

    $identifier "std::behind"
    $last_part identifier .behind. '.'
    println! '[' last_part ']'

    Output:

    []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str pos+len -1)
    -> ""

$std_types::string/truncate_until:
  #
    returns the substring behind the specified expression

    If the specified expression is found within the string the substring
    behind the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/behind>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/behind, string/before, string/between, string/until

    Example:

    $identifier "std::truncate_until"
    $name identifier .truncate_until. "::"
    println! name

    Output:

    truncate_until

    Example:

    $identifier "std::truncate_until"
    $last_part identifier .truncate_until. '.'
    println! '[' last_part ']'

    Output:

    [std::truncate_until]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str pos+len -1)
    -> str

$std_types::string/from:
  #
    returns the substring starting with the specified expression

    If the specified expression is found within the string the substring
    starting with the expression is returned. Otherwise the empty string is
    returned.

    If *nth* is specified then the nth occurence of the expression *expr* is
    looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_before>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_before, string/between, string/until, string/until

    Example:

    $identifier "std::from"
    $last_part identifier .from. "::"
    println! last_part

    Output:

    ::from

    Example:

    $identifier "std::from"
    $first_part identifier .from. '.'
    println! '[' first_part ']'

    Output:

    []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str pos -1)
    -> ""

$std_types::string/truncate_before:
  #
    returns the substring starting with the specified expression

    If the specified expression is found within the string the substring
    starting with the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr* is
    looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/from>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/from, string/between, string/until, string/until

    Example:

    $identifier "std::truncate_before"
    $last_part identifier .truncate_before. "::"
    println! last_part

    Output:

    ::truncate_before

    Example:

    $identifier "std::truncate_before"
    $first_part identifier .truncate_before. '.'
    println! '[' first_part ']'

    Output:

    [std::truncate_before]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $_len expr str nth
  if
    pos.is_defined
    -> range(str pos -1)
    -> str

$std_types::string/until:
  #
    returns the substring until (including) the specified expression

    If the specified expression is found within the string the substring
    until the expression is returned. Otherwise the empty string is returned.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the empty string is returned.

    A very similar function is <string/truncate_behind>. It behaves differently
    only when the expression is *not* found.

    Topic: Strings

    See also: string/truncate_behind, string/before, string/behind, string/from

    Example:

    $identifier "std::until"
    $first_part identifier .until. "::"
    println! first_part

    Output:

    std::

    Example:

    $identifier "std::until"
    $first_part identifier .until. '.'
    println! '<' first_part '>'

    Output:

    []
  (
    str # the input string
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos+len-1)
    -> ""

$std_types::string/truncate_behind:
  #
    returns the substring until (including) the specified expression

    If the specified expression is found within the string the substring
    until the expression is returned. Otherwise the string is returned
    unaltered.

    If *nth* is specified then the nth occurence of the expression *expr*
    is looked for. If there are not at least *n* matches for *expr* within *str*
    then the string is returned unaltered.

    A very similar function is <string/until>. It behaves differently only when
    the expression is *not* found.

    Topic: Strings

    See also: string/until, string/before, string/behind, string/from

    Example:

    $identifier "std::truncate_behind"
    $first_part identifier .truncate_behind. "::"
    println! first_part

    Output:

    std::

    Example:

    $identifier "std::truncate_behind"
    $first_part identifier .truncate_behind. '.'
    println! '[' first_part ']'

    Output:

    [std::truncate_behind]
  (
    str # the string to truncate
    expr # the expression to look for
    nth = 1 # look for the nth occurrence of *expr* instead for the first one
  )
  search $pos $len expr str nth
  if
    pos.is_defined
    -> range(str 1 pos+len-1)
    -> str

$std_types::string/between:
  #
    returns the substring between two expressions

    If the specified expressions are found within the string the substring
    between the expressions is returned. Otherwise the empty string is
    returned.

    If *nth* is specified then the nth occurence of the first expression
    *expr_1* is looked for. If there are not at least *n* matches for
    *expr_1* within *str* then the empty string is returned.

    Topic: Strings

    See also: string/before, string/behind, string/until, string/from

    Example:

    $path "/home/user/"
    $user_name between(path "/" "/" 2)
    println! user_name

    Output:

    user
  (
    str # the input string
    expr_1 # the expression on the left hand side
    expr_2 # the expression on the right hand side
    nth = 1 # look for the nth occurrence of *expr_1* instead for the first one
  )
  -> behind(str expr_1 nth) .before. expr_2

$std_types::string/has_prefix:
  #
    checks whether the string has the specified prefix

    Topic: Strings

    See also: string/has_suffix, string/without_prefix, string/contains

    Example:

    $path "/home/user/"
    if
      path .has_prefix. "/home/":
	println! "path starts with /home/"
      :
	println! "path does not start with /home/"
  (
    self
    prefix # the prefix to check for
  )
  -> match(prefix self).is_defined

$std_types::string/has_suffix:
  #
    checks whether the string has the specified suffix

    Topic: Strings

    See also: string/has_prefix, string/without_suffix, string/contains

    Example:

    $path "/home/user/"
    if
      path .has_suffix. '/':
	println! "path ends with a slash"
      :
	println! "path does not end with a slash"
  (
    self
    suffix # the suffix to check for
  )
  if
    suffix.is_a_character
    -> length_of(self) >= 1 && self(-1) == suffix
    :
      $len length_of(suffix)
      -> length_of(self) >= len && range(self -len -1) == suffix

$std_types::string/without_prefix:
  #
    returns the string without the specified prefix

    Checks whether the string has the specified prefix and if so returns
    the string without it. Otherwise the string is returned unaltered.

    Topic: Strings

    See also: string/without_suffix, string/has_prefix

    Example:

    $path "/home/user"
    $user_name path .without_prefix. "/home/"
    println! user_name

    Output:

    user
  (
    self
    prefix
  )
  $n match(prefix self)
  if
    n.is_defined
    -> range(self n+1 -1)
    -> self

$std_types::string/without_suffix:
  #
    returns the string without the specified suffix

    Checks whether the string has the specified suffix and if so returns
    the string without it. Otherwise the string is returned unaltered.

    Topic: Strings

    See also: string/without_prefix, string/has_suffix

    Example:

    $path "/home/user"
    $base_dir path .without_suffix. "/user"
    println! base_dir

    Output:

    /home
  (
    self
    suffix
  )
  $len length_of(self)
  if
    suffix.is_a_character:
      if
	len >= 1 && self(-1) == suffix
	-> range(self 1 -2)
	-> self
    : # assume the suffix is a string
      $slen length_of(suffix)
      if
	len >= slen && range(self -slen -1) == suffix
	-> range(self 1 -slen-1)
	-> self

$std_types::string/contains:
  #
    succeeds if the specified expression occurrs at least once within the string

    Returns <true> if the specified expression occurs at least once within the
    string.

    Returns <false> if the specified expression does not occur within the
    string.

    Topic: Strings

    See also: string/has_prefix, string/has_suffix

    Example:

    $path "/home/user/.bashrc"
    if
      path .contains. "/user/":
	println! "path contains /user/"
      :
	println! "path does not contain /user/"
  (
    self
    expr
  )
  search $pos $_len expr self
  -> pos.is_defined

$std::split:
  #
    splits a string into several parts and returns a list of these parts

    The separators are removed.

    Topic: Strings

    See also: string/join

    Example:

    $items split("a;b;c" ";")
    dump! 2 `items

    Output:

    items:
      list
	"a"
	"b"
	"c"
  (
    self
    separator = ' '
  )
  if
    self.is_empty
    -> empty_list
    :
      $items empty_list
      loop:
	search $pos $len separator self
	if
	  pos.is_defined:
	    push &items range(self 1 pos-1)
	    range &self pos+len -1
	    next
	  :
	    if
	      self.is_empty
	      -> items
	      -> push(items self)

$std::join:
  #
    concatenates the list items using the specified separator

    Returns a string which is the concatenation of all the list items
    separated by the specified separator.

    If the list is empty then the empty string is returned.

    Topic: Strings

    See also: string/split

    Example:

    $items list("a" "b" "c")
    $str join(items ";")
    println! str

    Output:

    a;b;c
  (
    items
    separator = " "
  )
  to_string &separator
  map_reduce
    items to_string
    : (left right) append left separator right
    ""

$std::trim:
  #
    removes leading and trailing whitespace

    Returns a string which is the specified string without any leading or
    trailing whitespace.

    Topic: Strings

    See also: string/trim_left, string/trim_right, string/normalize

    Example:

    $str "   text   "
    $trimmed_str trim(str)
    println! '*' trimmed_str '*'

    Output:

    *text*
  (
    self
    test = is_a_whitespace_character
  )
  $s 1
  $e length_of(self)
  loop:
    if
      s <= e && test(self(s)):
	inc &s
	next
      :
	loop:
	  if
	    e >= s && test(self(e)):
	      dec &e
	      next
	    :
	      range self s e

$std::trim_left:
  #
    removes leading whitespace

    Returns a string which is the specified string without any leading
    whitespace.

    Topic: Strings

    See also: string/trim, string/trim_right

    Example:

    $str "   text   "
    $trimmed_str trim_left(str)
    println! '*' trimmed_str '*'

    Output:

    *text   *
  (
    self
    test = is_a_whitespace_character
  )
  $s 1
  $e length_of(self)
  loop:
    if
      s <= e && test(self(s)):
	inc &s
	next
      :
	range self s e

$std::trim_right:
  #
    removes trailing whitespace

    Returns a string which is the specified string without any trailing
    whitespace.

    Topic: Strings

    See also: string/trim, string/trim_left

    Example:

    $str "   text   "
    $trimmed_str trim_right(str)
    println! '*' trimmed_str '*'

    Output:

    *   text*
  (
    self
    test = is_a_whitespace_character
  )
  $e length_of(self)
  loop:
    if
      e >= 1 && test(self(e)):
	dec &e
	next
      :
	range self 1 e

$std::normalize:
  #
    trims the string and replaces whitespace by a single space

    Returns a string which is the specified string without any leading or
    trailing whitespace and where all sequences of whitespace are replaced by
    a single space.

    Topic: Strings

    See also: string/trim

    Example:

    $str "   This    is    a     strange    text!   "
    $normalized_str normalize(str)
    println! '*' normalized_str '*'

    Output:

    *This is a strange text!*
  (
    self
  )
  $buf ""
  $e length_of(self)
  $i 0
  loop:
    loop
      :
	inc &i
	if
	  i > e
	  -> buf
	  :
	    if
	      self(i).is_a_whitespace_character
	      next
	      break
      :
	update_if buf.is_not_empty &buf -> push(buf ' ')
	$s i
	loop
	  :
	    inc &i
	    if
	      i > e
	      -> append(buf range(self s e))
	      :
		if
		  self(i).is_a_whitespace_character
		  break
		  next
	  :
	    append &buf range(self s i-1)
	    next

$std::parse_integer:
  #
    extracts an integer value from the start of the string

    Returns the unused part of the string as well as the extracted integer
    value.

    The function succeeds if the string starts with an integer literal in
    decimal, octal, hexadecimal or binary notation.

    If the function fails then the unaltered string and <undefined> are
    returned.

    Topic: Strings

    See also: string/parse_number, string/to_integer

    Example:

    $str "123abc"
    parse_integer &str $value
    println! "value: " value ", rest: " str

    Output:

    value: 123, rest: abc
  (
    self # the string to parse
  )
  $maybe_negated:
    if
      negate
      -> -value
      -> value

  $partial_match: (idx)
    if
      idx > 1
      -> range(self idx -1) maybe_negated()
      -> orig undefined

  $exhausted:
    if
      self.is_empty
      -> orig undefined
      -> "" maybe_negated()

  $orig self
  $negate self .has_prefix. '-'
  !self
    if
      negate
      -> range(self 2 -1)
      -> self
  $value 0
  cond
    -> self .has_prefix. "0b":
      range &self 3 -1
      for_each self
	: (idx chr)
	  case
	    chr
	    '0'..'1':
	      !value (value << 1)+(chr-'0')
	      next
	    :
	      partial_match idx
	exhausted
    -> self .has_prefix. "0o":
      range &self 3 -1
      for_each self
	: (idx chr)
	  case chr
	    '0'..'7':
	      !value (value << 3)+(chr-'0')
	      next
	    :
	      partial_match idx
	exhausted
    -> self .has_prefix. "0x":
      range &self 3 -1
      for_each self
	: (idx chr)
	  case chr
	    '0'..'9':
	      !value (value << 4)+(chr-'0')
	      next
	    'a'..'f':
	      !value (value << 4)+(chr-'a')+10
	      next
	    'A'..'F':
	      !value (value << 4)+(chr-'A')+10
	      next
	    :
	      partial_match idx
	exhausted
    -> true:
      for_each self
	: (idx chr)
	  case chr
	    '0'..'9':
	      !value 10*value+(chr-'0')
	      next
	    :
	      partial_match idx
	exhausted

$std::parse_number:
  #
    extracts a numeric value from the start of the string

    Returns the unused part of the string as well as the extracted numeric
    value (real or integer).

    The function succeeds if the string starts with a numeric literal in
    decimal, octal, hexadecimal or binary notation (integers only).

    If the function fails then the unaltered string and <undefined> are
    returned.

    Topic: Strings

    See also: string/parse_integer

    Example:

    $str "123.456abc"
    parse_number &str $value
    println! "value: " value ", rest: " str

    Output:

    value: 123.456, rest: abc
  (
    self # the string to parse
  )
  $i 1
  $n length_of(self)
  if
    i > n
    -> self undefined
    :
      $sign_chr self(1)
      update_if sign_chr == '-' || sign_chr == '+' &i -> i+1
      if
	self(i) == '0' && i+1 < n:
	  case self(i+1)
	    'b': parse_binary self i+2
	    'o': parse_octal self i+2
	    'x': parse_hex self i+2
	    parse
	parse

  $parse:
    skip_one_ore_more_digits:
      if
	i > n return_integer
	:
	  case self(i)
	    '.':
	      !i i+1
	      skip_one_ore_more_digits:
		if
		  i > n
		  return_real
		  :
		    case self(i)
		      'e', 'E' handle_exponent
		      return_real
	    'e', 'E' handle_exponent
	    return_integer

    $skip_one_ore_more_digits: (cont)
      if
	i > n
	-> self undefined
	:
	  $digit self(i)
	  if
	    digit < '0' || digit > '9'
	    -> self undefined
	    :
	      loop:
		!i i+1
		if
		  i > n
		  cont
		  :
		    $next_digit self(i)
		    if
		      next_digit >= '0' && next_digit <= '9'
		      next
		      cont

    $handle_exponent:
      !i i+1
      if
	i > n
	-> self undefined
	:
	  $exp_sign_chr self(i)
	  update_if exp_sign_chr == '-' || exp_sign_chr == '+' &i -> i+1
	  skip_one_ore_more_digits return_real

    $return_integer -> range(self i -1) integer(range(self 1 i-1))

    $return_real -> range(self i -1) real(range(self 1 i-1))

$parse_binary: (str i)
  $n length_of(str)
  if
    i > n -> str undefined
    :
      $digit str(i)
      if
	digit < '0' || digit > '1'
	-> str undefined
	:
	  $value digit-'0'
	  loop:
	    !i i+1
	    if
	      i > n
	      -> "" value
	      :
		$next_digit str(i)
		if
		  next_digit >= '0' && next_digit <= '1':
		    !value (value << 1)+(next_digit-'0')
		    next
		  -> range(str i -1) value

$parse_octal: (str i)
  $n length_of(str)
  if
    i > n -> str undefined
    :
      $digit str(i)
      if
	digit < '0' || digit > '7'
	-> str undefined
	:
	  $value digit-'0'
	  loop:
	    !i i+1
	    if
	      i > n
	      -> "" value
	      :
		$next_digit str(i)
		if
		  next_digit >= '0' && next_digit <= '7':
		    !value (value << 3)+(next_digit-'0')
		    next
		  -> range(str i -1) value

$std::parse_hex:
  #
    extracts a hexadecimal value from the start of the string

    Returns the unused part of the string as well as the extracted numeric
    value.

    The function succeeds if the string starts with a hexadecimal literal.

    If the function fails then the unaltered string and <undefined> are
    returned.

    Optionally a start index (*i*) can be specified.

    Topic: Strings

    See also: string/parse_integer

    Example:

    $str "123abc---"
    parse_hex &str $value
    println! "value: " value ", rest: " str

    Output:

    value: 1194684, rest: ---
  (
    str # the string to parse
    i = 1 # the start index
  )
  $n length_of(str)
  if
    i > n -> str undefined
    :
      $digit str(i)
      cond
	-> digit >= '0' && digit <= '9':
	  handle_more_digits digit-'0'
	-> digit >= 'a' && digit <= 'f':
	  handle_more_digits (digit-'a')+10
	-> digit >= 'A' && digit <= 'F':
	  handle_more_digits (digit-'A')+10
	-> true -> str undefined

      $handle_more_digits: (value)
	loop:
	  !i i+1
	  if
	    i > n
	    -> "" value
	    :
	      $next_digit str(i)
	      cond
		-> next_digit >= '0' && next_digit <= '9':
		  !value (value << 4)+(next_digit-'0')
		  next
		-> next_digit >= 'a' && next_digit <= 'f':
		  !value (value << 4)+(next_digit-'a')+10
		  next
		-> next_digit >= 'A' && next_digit <= 'F':
		  !value (value << 4)+(next_digit-'A')+10
		  next
		-> true -> range(str i -1) value

$std_types::string/to_integer:
  #
    converts the whole string into an integer value

    If the complete string can be converted into an integer then the
    resulting integer is returned.

    If the conversion fails or does not consume the complete string then
    <undefined> is returned.

    Topic: Strings

    See also: string/parse_integer

    Example:

    $str "123"
    $value str.to_integer
    println! "value: " value

    Output:

    value: 123

    Example:

    $str "123, 456"
    $value str.to_integer
    dump! `value

    Output:

    value: <undefined>
  (
    self # the string to convert
  )
  parse_integer &self $value
  if
    self == ""
    -> value
    -> undefined

$std_types::string/to_number:
  #
    converts the whole string into a number value

    If the complete string can be converted into a number then the
    resulting number (integer or real) is returned.

    If the conversion fails or does not consume the complete string then
    <undefined> is returned.

    Topic: Strings

    See also: string/to_integer, strint/parse_number

    Example:

    $str "123.456"
    $value str.to_number
    println! "value: " value

    Output:

    value: 123.456

    Example:

    $str "123.456, 789"
    $value str.to_number
    dump! `value

    Output:

    value: <undefined>
  (
    self # the string to convert
  )
  parse_number &self $value
  if
    self == ""
    -> value
    -> undefined

$std::map_characters:
  #
    applies a function to each character of the string

    The function returns a string that is the result of applying the
    specified function to each character of the string.

    Topic: Strings

    See also: to_upper_case, to_lower_case, to_title_case, map, map_reduce

    Example:

    $str "abc"
    $upper_case_str map_characters(str to_upper_case)
    println! upper_case_str

    Output:

    ABC
  (
    self # the string which characters will be mapped
    function # the function to apply to each character of the string
  )
  $map
    if
      parameter_count_of(function) == 2
      ->
	: (s e)
	  if
	    s < e:
	      $m (s+e) >> 1
	      append
		map(s m)
		map(m+1 e)
	    :
	      if
		s > e
		-> ""
		-> string(function(s self(s)))
      ->
	: (s e)
	  if
	    s < e:
	      $m (s+e) >> 1
	      append
		map(s m)
		map(m+1 e)
	    :
	      if
		s > e
		-> ""
		-> string(function(self(s)))

  map 1 length_of(self)

$std_types::string/to_upper_case:
  #
    returns the string converted to UPPER CASE

    Topic: Strings

    See also: to_lower_case, to_title_case, map_characters

    Example:

    $str "abc"
    $upper_case_str str.to_upper_case
    println! upper_case_str

    Output:

    ABC
  (
    self # the string to convert
  )
  map_characters self to_upper_case

$std_types::string/to_lower_case:
  #
    returns the string converted to lower case

    Topic: Strings

    See also: to_upper_case, to_title_case, map_characters

    Example:

    $str "ABC"
    $lower_case_str str.to_lower_case
    println! lower_case_str

    Output:

    abc
  (
    self # the string to convert
  )
  map_characters self to_lower_case

$std_types::string/to_title_case:
  #
    returns the string converted to "Title Case"

    Topic: Strings

    See also: to_sentence_case, to_upper_case, to_lower_case, map_characters

    Example:

    $str "this is a test"
    $title_case_str str.to_title_case
    println! title_case_str

    Output:

    This Is A Test
  (
    self # the string to convert
  )
  map_characters self: (idx chr)
    if
      idx > 1 && self(idx-1).is_a_letter_character
      -> chr.to_lower_case
      -> chr.to_title_case

$std_types::string/to_sentence_case:
  #
    converts the spefied string to "Sentence case"

    Topic: Strings

    See also: to_title_case

    Example:

    $str "this is a test."
    $sentence_case_str str.to_sentence_case
    println! sentence_case_str

    Output:

    This is s test.
  (
    self
  )
  map_characters self: (idx chr)
    if
      idx == 1 && self(idx).is_a_letter_character
      -> chr.to_title_case
      -> chr.to_lower_case

$std::delete_all:
  #
    deletes all occurences of the specfified expressions

    This function deletes all occurences of the specified expressions from
    the string.

    Topic: Strings

    See also: replace_all

    Example:

    $str "abcabc"
    $str_without_b delete_all(str 'b')
    println! str_without_b

    Output:

    acac
  (
    text # the string to process
    expressions* # the expressions to delete
  )
  $delete_all: (txt)
    if
      txt.is_empty
      -> new_text
      :
	for_each expressions
	  : (expression)
	    $len match(expression txt)
	    if_not len.is_defined next:
	      delete_all range(txt len+1 -1)
	  :
	    push &new_text txt(1)
	    delete_all range(txt 2 -1)

  $new_text ""
  delete_all text

$std::replace_all:
  #
    replaces all occurences of the specified expressions

    This function replaces all occurences of the specified expressions with
    their corresponding replacement texts.

    Topic: Strings

    See also: replace_first, delete_all

    Example:

    $str "abcabc"
    $str_with_x replace_all(str 'b' = 'x')
    println! str_with_x

    Output:

    axcaxc
  (
    text # the string to process
    args* # the expressions and their replacements
  )
  $replace_all: (txt)
    if
      txt.is_empty
      -> new_text
      :
	for_each args
	  : (arg)
	    arg $expression $replacement
	    $len match(expression txt)
	    if_not len.is_defined next:
	      if
		replacement.is_a_string:
		  append &new_text replacement
		  replace_all range(txt len+1 -1)
		:
		  append &new_text replacement(range(txt 1 len))
		  replace_all range(txt len+1 -1)
	  :
	    push &new_text txt(1)
	    replace_all range(txt 2 -1)

  $new_text ""
  replace_all text

$std::replace_first:
  #
    replaces the first occurence of the specified expressions

    This function replaces the first occurence of the specified expressions
    with their corresponding replacement texts.

    Topic: Strings

    See also: replace_all

    Example:

    $str "abcabc"
    $str_with_x replace_first(str 'b' = 'x')
    println! str_with_x

    Output:

    axcabc
  (
    text # the string to process
    args* # the expressions and their replacements
  )
  $replace_first: (txt)
    if
      txt.is_empty
      -> new_text
      :
	for_each args
	  : (arg)
	    arg $expression $replacement
	    $len match(expression txt)
	    if_not
	      len.is_defined
	      next
	      :
		update_if_not replacement.is_a_string &replacement
		  -> replacement(range(txt 1 len))
		-> append(new_text replacement range(txt len+1 -1))
	  :
	    push &new_text txt(1)
	    replace_first range(txt 2 -1)

  $new_text ""
  replace_first text

$std::count_occurrences:
  #
    returns the number of occurences of the specified expression

    This function returns the number of occurences of the specified
    expression in the string.

    Topic: Strings

    Example:

    $str "abcabc"
    $occurrences count_occurrences(str 'b')
    println! occurrences

    Output:

    2
  (
    text # the string to process
    expr # the expression to count
  )
  $search_next: (txt count)
    if
      txt == ""
      -> count
      :
	$n match(expr txt)
	if
	  n.is_defined:
	    search_next range(txt n+1 -1) count+1
	  :
	    search_next range(txt 2 -1) count

  search_next text 0

$FORK_TEXT_THRESHOLD 300

$std::partition:
  #
    partitions a string into several parts and returns a list of these parts

    This function partitions the specified string into several parts.
    The separators are not removed but start each part.

    The function returns a list of the parts.

    Topic: Strings

    See also: split, split_into_lines, join

    Example:

    $str "a:b;c"
    $parts partition(str ';', ':')
    dump! parts

    Output:

    list("a" ":b" ";c")
  (
    text # the string to process
    separators* # the separators
  )
  $n length_of(text)
  partition 1 n

  $partition: (s e)
    if
      e+1-s > FORK_TEXT_THRESHOLD: # recurse to exploit parallel execution
	$m (s+e) .div. 2
	append partition(s m) partition(m+1 e)
      :
	$parts empty_list
	$ls undefined
	from_to s e
	  : (i)
	    if_not any_of(separators equal text(i)) next:
	      if
		ls.is_defined:
		  push &parts range(text ls i-1)
		  !ls i
		  next
		:
		  !ls i
		  next
	  :
	    if
	      ls.is_defined && ls <= e:
		if
		  e == n:
		    -> push(parts range(text ls e))
		  :
		    loop: # the last part extends into the next block
		      !e e+1
		      if
			any_of(separators equal text(e))
			-> push(parts range(text ls e-1))
			next
	      -> parts

# parallel version
  $std::split_into_lines: (text)
    $n length_of(text)
    split 1 n

    $split: (s e)
      if
	e+1-s > FORK_TEXT_THRESHOLD: # recurse to exploit parallel execution
	  $m (s+e) .div. 2
	  append split(s m) split(m+1 e)
	:
	  $lines empty_list
	  $ls
	    if
	      s == 1 || text(s-1) == '@nl;'
	      -> s # the current block starts at a line start
	      -> undefined # just skip the characters until the next line start
	  from_to s e
	    : (i)
	      if_not text(i) == '@nl;' next:
		if
		  ls.is_defined:
		    push &lines range(text ls i)
		    !ls i+1
		    next
		  :
		    !ls i+1
		    next
	    :
	      if
		ls.is_defined && ls <= e:
		  loop: # the last line extends into the next block
		    !e e+1
		    if
		      text(e) == '@nl;'
		      -> push(lines range(text ls e))
		      next
		-> lines

#serial version
$std::split_into_lines: (text)
  $lines empty_list
  $i 1
  $n length_of(text)
  $s i
  loop:
    if
      i > n
      ->
	if
	  s <= n
	  -> push(lines range(text s n))
	  -> lines
      :
	if
	  text(i) == '@nl;':
	    push &lines range(text s i)
	    !i i+1
	    !s i
	    next
	  :
	    !i i+1
	    next

$std::split_into_indented_lines:
  #
    splits a text into indented lines

    The result is a list of tuples with two fields:

    * indent

    * text_line

    The *text_line* still contains the trailing line feed but leading whitespace
    is removed.

    If a line does not contain any text (whitespace does not count as text) then
    the whole tuple is replaced with the special value <undefined>.

    Topic: Strings

    See also: split_into_lines, split_into_groups

    Example:

    $text "
      a
	1
	2
	3
      b
	4
	5
    $lines split_into_indented_lines(text)
    dump! 3 lines

    Output:

    lines:
      list
	tuple
	  0
	  "a@0xa;"
	tuple
	  2
	  "1@0xa;"
	tuple
	  2
	  "2@0xa;"
	tuple
	  2
	  "3@0xa;"
	tuple
	  0
	  "b@0xa;"
	tuple
	  2
	  "4@0xa;"
	tuple
	  2
	  "5@0xa;"
  (
    text # the string to process
  )
  $n length_of(text)
  split 1 n

  $split: (s e)
    if
      e+1-s > FORK_TEXT_THRESHOLD: # recurse to exploit parallel execution
	$m (s+e) .div. 2
	append split(s m) split(m+1 e)
      :
	$lines empty_list
	$ls
	  if
	    s == 1 || text(s-1) == '@nl;'
	    -> s # the current block starts at a line start
	    -> undefined # just skip the characters until the next line start
	from_to s e
	  : (i)
	    if_not text(i) == '@nl;' next:
	      if
		ls.is_defined:
		  push &lines create_line(ls i)
		  !ls i+1
		  next
		:
		  !ls i+1
		  next
	  :
	    if
	      ls.is_defined && ls <= e:
		loop: # the last line extends into the next block
		  !e e+1
		  if
		    text(e) == '@nl;'
		    -> push(lines create_line(ls e))
		    next
	      -> lines

  $create_line: (s e)
    $indent 0
    loop:
      if
	text(s) == '@ht;':
	  !indent indent+8
	  !s s+1
	  next
	:
	  if
	    text(s) == ' ':
	      !indent indent+1
	      !s s+1
	      next
	    :
	      $line_text range(text s e)
	      if
		line_text == "@nl;"
		-> undefined
		-> tuple(indent line_text)

$FORK_LINES_THRESHOLD 20
$VERY_LARGE_INDENT 9999

$std::subgroups_of (!)

$indent_of: (line)
  if
    line.is_defined
    -> first(line)
    -> undefined

$std::split_into_groups:
  #
    splits already indented lines into groups

    Returns a list of indented lines where each line has a *subgroups*-attribute
    which is itself a list of "indented lines".

    The division into subgroups is only done on the top-level! The subgroups
    do not contain any further subgroups.

    Topic: Strings

    See also: split_into_indented_lines

    Example:

    $text "
      a
	1
	2
	3
      b
	4
	5
    $lines split_into_indented_lines(text)
    $groups split_into_groups(lines)
    dump! 3 `groups
    dump! 3 `subgroups_of(groups(1))

    Output:

    groups:
      list
	tuple
	  0
	  "a@0xa;"
	tuple
	  0
	  "b@0xa;"
    subgroups_of(groups(1)):
      list
	tuple
	  2
	  "1@0xa;"
	tuple
	  2
	  "2@0xa;"
	tuple
	  2
	  "3@0xa;"
  (
    lines # the indented lines
  )
  $n length_of(lines)
  $fv 1 # first valid line
  loop:
    if
      fv <= n:
	$indent indent_of(lines(fv))
	if
	  indent.is_defined:
	    split fv n indent undefined
	  :
	    !fv fv+1
	    next
      -> empty_list

  $split: (s e indent gs)
    if
      e+1-s > FORK_LINES_THRESHOLD: # recurse to exploit parallel execution
	$m (s+e) .div. 2
	append split(s m indent gs) split(m+1 e indent undefined)
      :
	$groups empty_list
	$minimum_indent VERY_LARGE_INDENT
	$ge gs
	from_to s e
	  : (i)
	    $current_indent indent_of(lines(i))
	    if
	      current_indent == indent:
		if
		  gs.is_defined && gs < i:
		    add_groups !groups ge
		    start_new_fragment_and_next i
		  :
		    start_new_fragment_and_next i
	      :
		!ge
		  if
		    current_indent.is_defined
		    -> i
		    -> ge
		reduce_minimum_indent_and_next current_indent
	  :
	    if
	      gs.is_defined:
		loop: # the last group extends into the next block
		  !e e+1
		  if
		    e > n
		    -> add_groups(ge)
		    :
		      $current_indent indent_of(lines(e))
		      if
			current_indent.is_defined && current_indent <= indent
			-> add_groups(ge)
			:
			  !ge
			    if
			      current_indent.is_defined
			      -> e
			      -> ge
			  reduce_minimum_indent_and_next current_indent
	      -> groups

	$add_groups: (l)
	  if
	    gs == l
	    -> push(groups lines(gs))
	    :
	      if
		minimum_indent == VERY_LARGE_INDENT
		-> append(groups range(lines gs l))
		:
		  $headline lines(gs)
		  push groups headline(.subgroups_of range(lines gs+1 l))

	$reduce_minimum_indent_and_next: (current_indent)
	  if
	    current_indent.is_defined && current_indent < minimum_indent:
	      !minimum_indent current_indent
	      next
	    next

	$start_new_fragment_and_next: (i)
	  !minimum_indent VERY_LARGE_INDENT
	  !gs i
	  !ge i
	  next

$std::wrap_words:
  #
    wraps a string consisting of words onto multiple lines

    The string is split into multiple lines according to the specified line
    width.

    The result is a list of lines.

    Topic: Strings

    See also: indented

    Example:

    $str "This is a very long string that should be wrapped onto multiple lines"
    $lines wrap_words(str 30)
    dump! 2 `lines

    Output:

    lines:
      list
	"This is a very long string"
	"that should be wrapped"
	"onto multiple lines"
  (
    text # the string to wrap
    width # the desired line width
  )
  $wrapped_text ""
  $n length_of(text)
  $s 1 # start of not yet copied text
  $l s # line start position
  $b undefined # possible break position
  $i 1
  loop:
    if
      i > n
      -> append(wrapped_text range(text s n))
      :
	$chr text(i)
	if
	  chr == '@nl;':
	    !i i+1
	    !l i
	    !b undefined
	    next
	  :
	    if
	      chr == ' ':
		if
		  i-l == width: # break
		    append &wrapped_text range(text s i-1)
		    push &wrapped_text '@nl;'
		    !i i+1
		    !s i
		    !l s
		    !b undefined
		    next
		  :
		    !b i
		    !i i+1
		    next
	      :
		!i i+1
		if
		  i-l <= width
		  next
		  :
		    if
		      b.is_defined: # wrap
			append &wrapped_text range(text s b-1)
			push &wrapped_text '@nl;'
			!s b+1
			!l s
			!b undefined
			next
		      : # hard break
			append &wrapped_text range(text s i-2)
			push &wrapped_text '@nl;'
			!s i-1
			!l s
			next

$std_types::string/serialize:
  #
    returns a string representation of the string

    Topic: Strings

    See also: deserialize

    Example:

    $str "Hello World"
    $serialized_str serialize(str)
    dump! `serialized_str

    Output:

    serialized_str: "@quot;Hello World@quot;@0xa;"
  (
    self
    indent = undefined
  )
  $str "@quot;"
  $s 1
  for_each self
    : (idx chr)
      if
	chr < '@0x20;' || chr > '@0x7e;' || chr == '"' || chr == '@@':
	  append &str range(self s idx-1)
	  append &str "@@@(chr.to_integer);"
	  !s idx+1
	  next
	next
    :
      append &str range(self s -1)
      append &str "@quot;@nl;"
      if
	indent.is_defined
	-> append(tabs_and_spaces(indent) str)
	-> str

$std::indented:
  #
    increases the indent of the specified (multi-line) string

    The text is indented via tabs and spaces. Existing indents are treated
    correctly.

    The line feed character after the last line is optional.

    Topic: Strings

    See also: wrap_words

    Example:

    $str "
      a
	b
	  c
      d
    $indented_str indented(5 str)
    print! indented_str

    Output:

	 a
	   b
	     c
	 d
  (
    indent
    text
  )
  $indented_text ""
  $new_indent undefined
  $i 1
  $n length_of(text)
  loop:
    !new_indent indent
    skip_indent !i !new_indent
    if
      i <= n:
	if
	  text(i) == '@nl;':
	    push &indented_text '@nl;'
	    !i i+1
	    next
	  :
	    append &indented_text tabs_and_spaces(new_indent)
	    $s i
	    loop
	      :
		if
		  text(i) == '@nl;':
		    append &indented_text range(text s i)
		    !i i+1
		    break
		  :
		    if
		      i < n:
			!i i+1
			next
		      :
			append indented_text range(text s -1)
	      next

      -> indented_text

  $skip_indent:
    if
      i <= n:
	if
	  text(i) == '@ht;':
	    !i i+1
	    !new_indent new_indent+8
	    skip_indent
	  skip_spaces
      -> i new_indent

  $skip_spaces:
    if
      i <= n && text(i) == ' ':
	!i i+1
	!new_indent new_indent+1
	skip_spaces
      -> i new_indent

$LEFT .
$RIGHT .
$CENTER .

$std::format:
  #
    formats its arguments using the specified template string

    The *template* contains a format specifier for each argument.

    Each format specifier start with a '%'-character and is folled by a length
    and (optionally) by a '.'-character and a second length specifying the
    number of decimal places.

    E.g. "%3.1" is a format specifier to print a real number with 3 digits,
    followed by a decimal point and 1 decimal place.

    If the size of the number exceeds the specified number of digits then the
    number is displayed anyways (ignoring the format specification).

    If the '%'-character is immediately followed by an 'l' or an 'r' it ist
    left- respectively righ-justified. The default is right justification.

    To print a character that might me misinterpreted as a part of a format
    specifier ('%', '.' or a digit) precede it with a backslash character ('\').
    This is also the way to print a backslash itself.

    The function returns the constructed string or <undefined> if the template
    string contains invalid format specifiers.

    Topic: Strings
  (
    template # the template string
    arguments* # the embedded arguments
  )
  $output ""
  $arg_idx 1
  $i 1
  $n length_of(template)
  loop:
    if
      i > n
      -> output
      :
	$chr template(i)
	!i i+1
	case chr
	  '%':
	    if
	      i > n
	      -> undefined
	      :
		case template(i) $alignment !i
		  'l' -> LEFT i+1
		  'r' -> RIGHT i+1
		  'c' -> CENTER i+1
		  -> RIGHT i
		$len_chr template(i)
		if
		  len_chr < '0' || len_chr > '9'
		  -> undefined
		  :
		    $width len_chr-'0'
		    loop
		      :
			!i i+1
			if
			  i > n
			  break
			  :
			    $fmt_chr template(i)
			    if
			      fmt_chr < '0' || fmt_chr > '9'
			      break
			      :
				!width 10*width+(fmt_chr-'0')
				next
		      :
			if
			  i > n:
			    add_argument width
			  :
			    if
			      template(i) == '.':
				!i i+1
				if
				  i > n
				  -> undefined
				  :
				    $dw_chr template(i)
				    if
				      dw_chr < '0' || dw_chr > '9'
				      -> undefined
				      :
					$dw dw_chr-'0'
					loop
					  :
					    !i i+1
					    if
					      i > n
					      break
					      :
						$fmt_chr template(i)
						if
						  fmt_chr < '0' || fmt_chr > '9'
						  break
						  :
						    !dw 10*dw+(fmt_chr-'0')
						    next
					  :
					    add_argument alignment width dw
			      :
				add_argument alignment width
	  '\':
	    if
	      i > n
	      -> undefined
	      :
		push &output template(i)
		!i i+1
		next
	  :
	    push &output chr
	    next

  $add_argument:
    (
      alignment
      width
      decimal_width = undefined
    )
    $argument arguments(arg_idx)
    !arg_idx arg_idx+1
    append &output
      if
	decimal_width.is_defined:
	  real_to_string &argument
	  if
	    argument.is_undefined
	    -> undefined
	    :
	      $value argument .truncate_from. '.'
	      $decimals argument .behind. '.'
	      string
		pad_left(value width)
		"."
		truncate(pad_right(decimals decimal_width "0") decimal_width)
	:
	  case alignment
	    LEFT -> pad_right(argument width)
	    RIGHT -> pad_left(argument width)
    next

$real_to_string: (num)
  $str num.to_string
  $n length_of(str)
  $i n
  loop:
    if
      i == 0
      -> str
      :
	if
	  str(i) == 'e'
	  handle_exponent
	  :
	    !i i-1
	    next

  $handle_exponent:
    if
      i >= n || str(2) != '.'
      -> undefined
      :
	$exp range(str i+2 n).to_integer
	$man put(range(str 3 i-1) str(1))
	if
	  exp.is_undefined
	  -> undefined
	  :
	    $zeros dup("0" exp-1)
	    case str(i+1)
	      '+':
		-> append(man zeros)
	      '-':
		-> append("0." append(zeros man))
	      -> undefined

$std_types::string.empty_collection_of ""
